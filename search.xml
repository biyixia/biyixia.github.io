<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP面向切面编程</title>
    <url>/post/AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在编写业务层代码时，除了实现业务接口中的方法外（主业务逻辑），可能还需要一些非业务方法，也称为交叉业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doOther&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>在业务实现类添加交叉业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doSome&quot;</span>);</span><br><span class="line">        doTrans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">        doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doOther&quot;</span>);</span><br><span class="line">        doTrans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法开始执行时输出日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTrans</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法执行后加入事务日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在工具类中定义交叉业务逻辑，供主业务逻辑调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceTools</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法开始执行时输出日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doTrans</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法执行后加入事务日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceTools.doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doSome&quot;</span>);</span><br><span class="line">        ServiceTools.doTrans();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceTools.doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doOther&quot;</span>);</span><br><span class="line">        ServiceTools.doTrans();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码中交叉业务与主业务深度耦合在一起</p>
<ul>
<li>当交叉业务逻辑较多时，业务实现类中会出现大量的交叉业务逻辑代码调用语句，使业务逻辑混杂不清，代码可读性差</li>
<li>当交叉业务逻辑需求复杂时，对于不同的需求分别设计交叉业务逻辑，代码的扩展性差</li>
</ul>
<p>所以，可以采用动态代理方式。在不修改主业务逻辑的前提下，扩展和增强其功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        ServiceTools.toLog();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        ServiceTools.toTrans();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:/application.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SomeService target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line">        <span class="type">SomeService</span> <span class="variable">someService</span> <span class="operator">=</span> (SomeService) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">        someService.doSome();</span><br><span class="line">        someService.doOther();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/post/Docker%E8%AE%B2%E4%B9%89/</url>
    <content><![CDATA[<ul>
<li>
<p>掌握Docker基础知识，能够理解Docker镜像与容器的概念</p>
</li>
<li>
<p>完成Docker安装与启动</p>
</li>
<li>
<p>掌握Docker镜像与容器相关命令</p>
</li>
<li>
<p>掌握Tomcat Nginx 等软件的常用应用的安装</p>
</li>
<li>
<p>掌握docker迁移与备份相关命令</p>
</li>
<li>
<p>能够运用Dockerfile编写创建容器的脚本</p>
</li>
<li>
<p>能够搭建与使用docker私有仓库</p>
</li>
</ul>
<h1><span id="docker简介">Docker简介</span></h1>
<h2><span id="什么是虚拟化">什么是虚拟化</span></h2>
<blockquote>
<p>将一台物理的计算机，拆分成多个虚拟的计算机</p>
</blockquote>
<p>​	在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p>
<p>​	在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件   对资源充分利用</p>
<p>​	虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p>
<h2><span id="什么是docker">什么是Docker</span></h2>
<p>​	Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker">GitHub</a> 上进行维护。</p>
<p>​	<img src="/post/Docker%E8%AE%B2%E4%B9%89/1-3.png" alt></p>
<p>​	Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p>
<p>​	Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p>
<p>​	在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>
<p>为什么选择Docker?</p>
<p>（1）上手快。</p>
<p>​	用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。</p>
<p>随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p>
<p>（2）职责的逻辑分类</p>
<p>​	使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p>
<p>（3）快速高效的开发生命周期</p>
<p>​	Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p>
<p>（4）鼓励使用面向服务的架构</p>
<p>​	Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p>
<h2><span id="容器与虚拟机比较">容器与虚拟机比较</span></h2>
<p>​	下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/post/Docker%E8%AE%B2%E4%B9%89/1-1.png" alt></p>
<p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p>
<h2><span id="docker-组件">Docker 组件</span></h2>
<h3><span id="docker服务器与客户端">Docker服务器与客户端</span></h3>
<p>​	Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p>
<p><img src="/post/Docker%E8%AE%B2%E4%B9%89/1-2.png" alt></p>
<h3><span id="docker镜像与容器">Docker镜像与容器</span></h3>
<p>​	镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p>
<p>添加一个文件；</p>
<p>执行一个命令；</p>
<p>打开一个窗口。</p>
<p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p>
<p>​	Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。  容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p>
<p>所以Docker容器就是：</p>
<p>​	一个镜像格式；</p>
<p>​	一些列标准操作；</p>
<p>​	一个执行环境。</p>
<p>​	Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p>
<p>和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。</p>
<p>Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</p>
<h3><span id="registry注册中心">Registry（注册中心）</span></h3>
<p>​	Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p>
<p>​	<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h1><span id="docker安装与启动">Docker安装与启动</span></h1>
<h2><span id="安装docker">安装Docker</span></h2>
<p>​	Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p>
<p>​	由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p>
<p>​	请直接挂载课程配套的Centos7.x镜像</p>
<p>（1）yum 包更新到最新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>
<p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>（3）设置yum源为阿里云</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>（4）安装docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
<p>（5）安装后查看docker版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>
<h2><span id="设置ustc的镜像">设置ustc的镜像</span></h2>
<p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p>
<p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p>
<p>编辑该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json  </span><br></pre></td></tr></table></figure>
<p>在该文件中输入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="docker的启动与停止">Docker的启动与停止</span></h2>
<p><strong>systemctl</strong>命令是系统服务管理器指令</p>
<p>启动docker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>停止docker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<p>重启docker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>查看docker状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<p>开机启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>查看docker概要信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p>查看docker帮助文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h1><span id="常用命令">常用命令</span></h1>
<h2><span id="镜像相关命令">镜像相关命令</span></h2>
<h3><span id="查看镜像">查看镜像</span></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64b733a61ddac507cc18f52c.jpg" alt></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>REPOSITORY</td>
<td>镜像名称</td>
</tr>
<tr>
<td>TAG</td>
<td>镜像标签</td>
</tr>
<tr>
<td>IMAGE ID</td>
<td>镜像ID</td>
</tr>
<tr>
<td>CREATED</td>
<td>镜像的创建日期（不是获取该镜像的日期）</td>
</tr>
<tr>
<td>SIZE</td>
<td>镜像大小</td>
</tr>
</tbody>
</table>
<p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p>
<h3><span id="搜索镜像">搜索镜像</span></h3>
<p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64b734231ddac507cc19fa9b.jpg" alt></p>
<table>
<thead>
<tr>
<th>列明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>仓库名称</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>镜像描述</td>
</tr>
<tr>
<td>STARS</td>
<td>用户评价，反应一个镜像的受欢迎程度</td>
</tr>
<tr>
<td>OFFICIAL</td>
<td>是否官方</td>
</tr>
<tr>
<td>AUTOMATED</td>
<td>自动构建，表示该镜像由Docker Hub自动构建流程创建的</td>
</tr>
</tbody>
</table>
<h3><span id="拉取镜像">拉取镜像</span></h3>
<p>拉取镜像就是从中央仓库中下载镜像到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure>
<p>例如，我要下载centos7镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure>
<h3><span id="删除镜像">删除镜像</span></h3>
<p>按镜像ID删除镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure>
<p>删除所有镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure>
<h2><span id="容器相关命令">容器相关命令</span></h2>
<h3><span id="查看容器">查看容器</span></h3>
<p>查看正在运行的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>查看所有容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure>
<p>查看最后一次运行的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure>
<p>查看停止的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -f status=exited</span><br></pre></td></tr></table></figure>
<h3><span id="创建与启动容器">创建与启动容器</span></h3>
<p>创建容器命令：docker run</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>表示运行容器</td>
</tr>
<tr>
<td>-t</td>
<td>表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端</td>
</tr>
<tr>
<td>–name</td>
<td>为创建的容器命名</td>
</tr>
<tr>
<td>-v</td>
<td>表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上</td>
</tr>
<tr>
<td>-d</td>
<td>在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）</td>
</tr>
<tr>
<td>-p</td>
<td>表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</td>
</tr>
<tr>
<td>-P</td>
<td>表示端口映射，随机端口映射，宿主机的端口是随机的，映射容器的固定端口号</td>
</tr>
</tbody>
</table>
<p>交互式方式创建容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定端口映射</span><br><span class="line">docker run -it --name=容器名称 -p 宿主机端口：容器端口 镜像名称:标签 /bin/bash</span><br><span class="line"></span><br><span class="line"># 随机端口映射</span><br><span class="line">docker run -it --name=容器名称 -P 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure>
<p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态</p>
<p>退出当前容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>守护式方式创建容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -di --name=容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure>
<p>登录守护式容器方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 (或者容器ID)  /bin/bash</span><br></pre></td></tr></table></figure>
<h3><span id="停止与启动容器">停止与启动容器</span></h3>
<p>停止容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>
<p>启动容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure>
<h3><span id="文件拷贝">文件拷贝</span></h3>
<p>如果我们需要将文件拷贝到容器内可以使用cp命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure>
<p>也可以将文件从容器内拷贝出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure>
<h3><span id="目录挂载">目录挂载</span></h3>
<p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>
创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</span><br></pre></td></tr></table></figure>
<p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p>
<p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  --privileged=true  来解决挂载的目录没有权限的问题</p>
<h3><span id="查看容器ip地址">查看容器IP地址</span></h3>
<p>我们可以通过以下命令查看容器运行的各种数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID） </span><br></pre></td></tr></table></figure>
<p>也可以直接执行下面的命令直接输出IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; 容器名称（容器ID）</span><br></pre></td></tr></table></figure>
<h3><span id="删除容器">删除容器</span></h3>
<p>删除指定的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure>
<h1><span id="应用部署">应用部署</span></h1>
<h2><span id="mysql部署">MySQL部署</span></h2>
<p>（1）拉取mysql镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7.34</span><br></pre></td></tr></table></figure>
<p>（2）创建容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br><span class="line"></span><br><span class="line"># 创建mysql容器、端口映射、挂载目录</span><br><span class="line">docker run -id --name=mysql -p 1111:3306 -v D:\BaiduNetdiskWorkspace\教学资料\sz2304\stage4\data\mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.34</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>代表端口映射，格式为  宿主机映射端口:容器运行端口</td>
</tr>
<tr>
<td>-e</td>
<td>代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</td>
</tr>
</tbody>
</table>
<p>（3）远程登录mysql</p>
<p>连接宿主机的IP  ,指定端口为33306</p>
<h2><span id="tomcat部署">tomcat部署</span></h2>
<p>（1）拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure>
<p>（2）创建容器</p>
<p>创建容器  -p表示地址映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 </span><br><span class="line">-v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</span><br><span class="line"></span><br><span class="line">docker run -id --name=tomcat -p 8080:8080 tomcat:7-jre7</span><br></pre></td></tr></table></figure>
<h2><span id="redis部署">Redis部署</span></h2>
<p>（1）拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
<p>（2）创建容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>
<h1><span id="迁移与备份">迁移与备份</span></h1>
<h2><span id="容器保存为镜像">容器保存为镜像</span></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit 【容器名】【镜像名】</span><br></pre></td></tr></table></figure>
<h2><span id="镜像备份">镜像备份</span></h2>
<p>将镜像保存为tar文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o 【XXX.tar】 【镜像名】</span><br></pre></td></tr></table></figure>
<h2><span id="镜像恢复与迁移">镜像恢复与迁移</span></h2>
<p>先删除掉原镜像  然后执行此命令进行恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load -i 【XXX.tar】</span><br></pre></td></tr></table></figure>
<p>-i 输入的文件</p>
<p>执行后再次查看镜像，可以看到镜像已经恢复</p>
<h1><span id="dockerfile">Dockerfile</span></h1>
<p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p>
<p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境<br>
2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了<br>
3、对于运维人员：在部署时，可以实现应用的无缝移植</p>
<h2><span id="常用命令">常用命令</span></h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM image_name:tag</td>
<td>定义了使用哪个基础镜像启动构建流程</td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的创建者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量 (可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>是Dockerfile的核心部分(可以写多条)</td>
</tr>
<tr>
<td>ADD source_dir/file dest_dir/file</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir/file dest_dir/file</td>
<td>和ADD相似，但是如果有压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
</tbody>
</table>
<h2><span id="使用脚本创建镜像">使用脚本创建镜像</span></h2>
<p>创建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir –p /usr/local/dockerjdk8</span><br></pre></td></tr></table></figure>
<p>下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p>
<p>创建文件Dockerfile  <code>vi Dockerfile</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#依赖镜像名称和ID</span><br><span class="line">FROM centos:7</span><br><span class="line">#指定镜像创建者信息</span><br><span class="line">MAINTAINER bjpowernode</span><br><span class="line">#切换工作目录</span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir -p /usr/local/java</span><br><span class="line">#ADD 是相对路径jar,把java添加到容器中</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/</span><br><span class="line"></span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行命令构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t=&#x27;jdk1.8&#x27; .</span><br></pre></td></tr></table></figure>
<p>注意后边的空格和点，不要省略</p>
<p>查看镜像是否建立完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java加载及执行原理</title>
    <url>/post/Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2><span id="类加载的过程">类加载的过程</span></h2>
<p><img src="https://pic.imgdb.cn/item/63d672baface21e9ef12a400.jpg" alt></p>
<p>加载、验证、准备、解析和初始化5个阶段</p>
<h3><span id="加载">加载</span></h3>
<ol>
<li>通过类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3><span id="验证">验证</span></h3>
<p>目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</p>
<h3><span id="准备">准备</span></h3>
<p>正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值</p>
<ul>
<li>
<p>从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但方法区本身是一个逻辑上的区域（在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了）</p>
</li>
<li>
<p>内存分配只包括类变量，而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li>
<p>初始值通常指数据类型的零值。赋值指令是程序被编译后，存放于类构造器()方法之中，所以赋值动作要到类的初始化阶段才会被执行。</p>
</li>
</ul>
<h3><span id="解析">解析</span></h3>
<p>所有目标方法都是通过符号引用（在Class文件的常量池中）来调用。在类加载的解析阶段，会将部分<strong>符号引用</strong>转化为<strong>直接引用</strong>。这些符号引用所属的方法在程序运行前就有一个可确定的调用版本，且在运行期不可改变（编译期可知，运行期不可变）。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。</p>
<p>主要指静态方法和私有方法，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</p>
<blockquote>
<p>符号引用：以一组符号来描述所引用的目标。符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</p>
<p>直接引用：直接引用是可以直接指向目标的指针。相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
</blockquote>
<ul>
<li>
<p>虚拟机实现时可以自行判断，是在类被加载器加载时，还是等到符号引用将被使用时，对常量池中的符号引用进行解析</p>
</li>
<li>
<p>解析阶段中对它们的可访问性（public、protected、 private、）进行检查</p>
</li>
</ul>
<h3><span id="初始化">初始化</span></h3>
<p>Java虚拟机真正开始执行类中编写的Java程序代码</p>
<ul>
<li>
<p>准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序代码来初始化类变量和其他资源</p>
</li>
<li>
<p>初始化阶段是执行类构造器&lt;clint&gt;()方法的过程。</p>
</li>
</ul>
<h3><span id="ltclintgt方法">&lt;clint&gt;()方法</span></h3>
<ol>
<li>
<p>&lt;clint&gt;()不是代码中程序员直接编写的方法，它是Javac编译器的自动生成物</p>
</li>
<li>
<p>&lt;clint&gt;()方法由编译器自动收集并合并类中的所有类变量的赋值动作和静态代码块中的语句，收集的顺序与语句在源文件中出现的顺序一致</p>
</li>
<li>
<p>JVM会保证在子类的&lt;clint&gt;()方法执行前，父类的&lt;clint&gt;()方法已经执行完毕。&lt;clint&gt;()方法与类的实例构造函数不同，它不需要显式地调用父类构造器，父类的&lt;clint&gt;()方法会优先先执行，也就意味着父类的静态语句块要优先于子类的变量赋值操作，具体查看<a href="../%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">类加载的初始化顺序</a></p>
</li>
<li>
<p>如果类中没有静态语句块、对变量的赋值操作，编译器可以不为这个类生成&lt;clint&gt;()方法</p>
</li>
<li>
<p>即使接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clint&gt;()方法。但接口与类不同的是，父接口的&lt;clint&gt;()方法不需要先于子接口的&lt;clint&gt;()方法执行，接口的实现类在初始化时也不会先执行接口的&lt;clint&gt;()方法。因为只有当父接口中定义的变量被使用时，父接口才会被初始化。</p>
</li>
</ol>
<h3><span id="源文件-类-字节码文件">源文件、类、字节码文件</span></h3>
<ul>
<li>源文件中可包含一个或多个类</li>
<li>源文件中至多有一个类被public修饰，当源文件中有public修饰类，原文件名必须与public修饰类名一致，当源文件中没有public修饰类，则源文件名与类名没有关系</li>
<li>在编译的过程中，对应每个类会生成相应的.class字节码文件，也就是说，当源文件中存在多个类时，编译完成后，会生成多个与类名一致的.class字节码文件</li>
<li>执行过程中，只需要指定字节码文件运行</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>linux</title>
    <url>/post/Linux/</url>
    <content><![CDATA[<h1><span id="linux命令">Linux命令</span></h1>
<p>服务器版的Linux是没有图形化界面的，只能通过在控制台输入Linux命令来操作系统，类似在windows下使用DOS命令。学习Linux，主要是学习Linux的各种命令。</p>
<p>在学习命令之前，让我们先来了解一下Linux命令的格式，包含3个部分（[]表示可选）：</p>
<p>Linux命令格式：<strong>command</strong> <strong>[options]</strong> <strong>[arguments]</strong></p>
<p><strong>command：命令名称，必需的</strong></p>
<p><strong>options：选项，可选的</strong></p>
<p><strong>arguments：参数，可选的</strong></p>
<p>命令名称、选项以及参数之间使用空格分隔，不同的命令完成不同的操作，关键是选项和参数（比较容易混淆）：</p>
<p><strong>选项</strong><em><strong>options：*<strong>选项是调整命令行为的因素，选项不同决定了命令的结果不同。选项又分为</strong>长选项和短选项</strong>。<strong>短选项（<strong><strong>short options</strong></strong>）</strong>：1. 格式多为中划线+选项，选项多为单个字母或数字，当有多个短选项时，各选项之间使用空格隔开，例如-a，-b，-2，-c  -d等。2. 大多短选项可以组合，例如-a -b，可以简写为-ab3. 大多短选项都有与之对应的长选项，但如果有短选项，一般不使用长选项 短选项：-h  与之对应的长选项： --help <strong>长选项（long</strong> <strong>options</strong>**）</em><em>：1. 格式为两个中划线+选项，选项多为一个单词，例如–help，–list等2. 都是完整的单词，通常不能组合  <strong>参数</strong></em>**arguments：***参数表示命令的操作对象，例如，在Linux中，查看目录使用ls，不加参数时显示的是当前目录，也可以加参数，例如：ls /dev，则查看 /dev 目录</p>
<p>简单总结：命令操作的对象叫参数，选项用来指定操作的方式。比如说杀猪，杀是命令，猪就是参数，而选项是杀猪的方式，可以是残忍的杀：一刀捅死，不死再来一刀；也可以是温柔的杀：让它吃到撑死，幸福的死去。。。</p>
<p>Linux的命令成千上万，课程中不能一一涉及，也没有必要一一涉及，根据程序员在日常工作中的需求，总结出如下几种供学习使用。</p>
<p>提示：Linux中很多（不是所有）命令对选项和参数的顺序没有要求，但通常选项在前，参数在后</p>
<h2><span id="目录切换命令">目录切换命令</span></h2>
<p>在windows中通过图形化界面和鼠标可以任意切换需要进入的目录，而Linux必须通过cd命令切换目录。</p>
<p>目录结构</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml5020\wps1.jpg)</p>
<p><strong>命令</strong>：cd 目录</p>
<p><strong>说明</strong>：从当前目录，切换到其它目录</p>
<p><strong>选项</strong>：无</p>
<p><strong>参数</strong>：目标目录</p>
<p><strong>示例</strong>：</p>
<p>cd					切换到当前用户的主目录</p>
<p>cd  /				切换到系统根目录</p>
<p>cd  /usr			切换到根目录下的usr目录</p>
<p>cd  demo		切换到当前目录下的demo目录</p>
<p>cd  …			切换到当前目录的上一层目录</p>
<p>cd ~				切换到用户主目录</p>
<p>cd -				切换到上一个所在目录（上一个是指你上一个访问的路径，相当于http协议的来路）</p>
<p><strong>小提示：输入<strong><strong>clear</strong></strong>命令清屏，或者是****Ctrl</strong> <strong>+ L</strong></p>
<h2><span id="目录操作命令">目录操作命令</span></h2>
<h3><span id="查看目录">查看目录★★★★★</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>选项</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>ls</td>
<td>-a   -l</td>
<td>目录路径，默认为当前目录</td>
</tr>
</tbody>
</table>
<p><strong>说明</strong>：ls(list)，该命令用于查看指定目录中的文件和文件夹</p>
<p><strong>选项</strong>：</p>
<p>-a(all)	表示所有，包括隐藏的文件和文件夹，在Linux中，以点开头的文件都是隐藏文件</p>
<p>-l(list)	使用详细格式列表</p>
<p><strong>示例</strong>：</p>
<p>ls			查看当前目录中的文件，不包含隐藏文件</p>
<p>ls -a		查看当前目录下的所有文件，包括隐藏的</p>
<p>ls -a -l	使用详细格式列表查看当前目录下的所有文件，选项还可以连着写：ls -al</p>
<p>ls /			查看根目录/中的文件，不包含隐藏文件</p>
<p>ls -al  /		使用详细格式列表查看根目录下的所有文件，选项和参数的顺序不影响结果，还可以这样写：ls / -al</p>
<p>小提示：ls -l 可以缩写成ll</p>
<h3><span id="创建目录">创建目录</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>mkdir</td>
<td>(make directory)</td>
</tr>
<tr>
<td>选项</td>
<td>[-p]</td>
<td>(parents) 用于一次创建多级目录，避免上级目录不存在或已存在报错</td>
</tr>
<tr>
<td>选项</td>
<td>[-v]</td>
<td>(verbose) 显示创建信息</td>
</tr>
<tr>
<td>参数</td>
<td>目录1 目录2 …</td>
<td>创建目录，可以一次创建多个目录，多个目录之间使用空格</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir demo</td>
<td>在根目录下创建demo目录</td>
</tr>
<tr>
<td>mkdir a b</td>
<td>在当前目录下创建a和b两个目录</td>
</tr>
<tr>
<td>mkdir -v /demo/c</td>
<td>创建/demo/c目录，并显示创建信息</td>
</tr>
<tr>
<td>mkdir -p /demo/d/a</td>
<td>创建/demo/d/a，如果不加p选项，则a的上级目录不存在会报错</td>
</tr>
</tbody>
</table>
<p>在创建目录时，建议都加上选项-p，即使创建的目录已经存在，也不会发生错误</p>
<h3><span id="改名和剪切移动">改名和剪切（移动）</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>mv</td>
<td>(move)</td>
</tr>
<tr>
<td>参数</td>
<td>原名 新名</td>
<td>将源文件重命名</td>
</tr>
<tr>
<td>参数</td>
<td>文件1 文件2… 目标目录</td>
<td>将源文件移动到指定的目录</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mv a b</td>
<td>如果b不存在，表示将a改名为b，如果b（目录）存在，表示将a移动到b</td>
</tr>
<tr>
<td>mv a b c</td>
<td>将a和b移动到c</td>
</tr>
</tbody>
</table>
<h3><span id="复制目录">复制目录</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>cp</td>
<td>(copy)</td>
</tr>
<tr>
<td>选项</td>
<td>[-v]</td>
<td>(verbose) 显示复制进度及详细信息</td>
</tr>
<tr>
<td>选项</td>
<td>[-r]</td>
<td>(recursive) 如果复制的是目录，则递归复制目录及其子目录内的所有内容</td>
</tr>
<tr>
<td>参数</td>
<td>文件1  文件2 …  目标目录</td>
<td>将多个指定的文件复制到目标目录</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp -r a b c</td>
<td>将a和b复制到c目录</td>
</tr>
<tr>
<td>cp -vr /demo/c  b</td>
<td>将/demo/c复制到b目录，并显示相关信息</td>
</tr>
<tr>
<td>cp  1.txt  a</td>
<td>复制1.txt到a目录下</td>
</tr>
<tr>
<td>cp  1.txt  a/11.txt</td>
<td>复制1.txt到a目录下，并改名为11.txt</td>
</tr>
</tbody>
</table>
<p>./  当前目录</p>
<p>…/	上级目录</p>
<h3><span id="删除目录">删除目录</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>rm</td>
<td>(remove)</td>
</tr>
<tr>
<td>选项</td>
<td>[-r]</td>
<td>(recursive) 如果删除的是目录，则递归删除目录及其子目录内的所有内容</td>
</tr>
<tr>
<td>选项</td>
<td>[-f]</td>
<td>(force) 强制删除。忽略不存在的文件，并且在删除时不给出确认的提示信息</td>
</tr>
<tr>
<td>选项</td>
<td>[-v]</td>
<td>(verbose) 显示删除进度及详细信息</td>
</tr>
<tr>
<td>参数</td>
<td>文件1 文件2 …</td>
<td>将多个指定的文件复制到目标目录</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>rm -r /demo/c</td>
<td>删除/demo/c目录，删除过程中需要输入y以确认删除</td>
</tr>
<tr>
<td>rm -rf /demo/b</td>
<td>不要询问，强制删除demo/b目录</td>
</tr>
<tr>
<td>rm -rf a b</td>
<td>不要询问，强制删除a和b两个文件</td>
</tr>
<tr>
<td>rm -rfv /demo/*</td>
<td>删除/demo目录下的所有文件，并显示相关信息</td>
</tr>
</tbody>
</table>
<p>提示：为了方便记忆，无论删除任何目录或文件，都直接使用rm -rf 文件…</p>
<h2><span id="文件操作命令">文件操作命令</span></h2>
<h3><span id="创建文件">创建文件</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>touch</td>
<td>/</td>
</tr>
<tr>
<td>参数</td>
<td>文件1 文件2 …</td>
<td>创建多个空文本文件</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>touch /demo/test</td>
<td>在/demo目录下创建文件&quot;test&quot;，该文件是文本文件，只是没有后缀名</td>
</tr>
</tbody>
</table>
<h3><span id="修改文件">修改文件★★★★★</span></h3>
<ol>
<li><code>vim 文件名</code>：进入“命令模式”，此时还不能编辑</li>
<li>按下 <code>i</code>：从命令模式，进入“编辑模式”，对文件进行编辑</li>
<li>编辑完成，按下<code>esc</code>从“编辑模式”回到“命令模式”</li>
<li>输入<code>:wq</code>，从命令模式进入底行模式，保存并退出</li>
</ol>
<h4><span id="命令模式">命令模式</span></h4>
<p>进入插入模式：</p>
<table>
<thead>
<tr>
<th>按键操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i(insert)</td>
<td>在光标前插入</td>
</tr>
<tr>
<td>shift + i</td>
<td>在光标当前行开始插入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入</td>
</tr>
<tr>
<td>shift + a</td>
<td>在光标当前行末尾插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标当前行的下一行插入新行</td>
</tr>
<tr>
<td>shift + o</td>
<td>在光标当前行的上一行插入新行</td>
</tr>
</tbody>
</table>
<p>进入底行模式：</p>
<p>“:”或 “/”或 “?”</p>
<p>其他操作：</p>
<table>
<thead>
<tr>
<th>按键操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>单行复制，复制光标所在的行</td>
</tr>
<tr>
<td>nyy</td>
<td>多行复制，将光标移动到将要复制的首行处，复制n行，n是一个数字</td>
</tr>
<tr>
<td>p</td>
<td>粘贴，将光标移动到将要粘贴的行处</td>
</tr>
<tr>
<td>gg</td>
<td>定位到文本的第一行</td>
</tr>
<tr>
<td>shift + g</td>
<td>到文本的最后一行</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除从光标开始的n行</td>
</tr>
</tbody>
</table>
<h4><span id="插入模式">插入模式</span></h4>
<p>只有在该模式下，才可以做文字输入</p>
<p>按「ESC」可以回到命令行模式。</p>
<h4><span id="底行模式">底行模式</span></h4>
<table>
<thead>
<tr>
<th>按键操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:q</td>
<td>quit，退出vim（没有做任何修改时）</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出不保存</td>
</tr>
<tr>
<td>:w</td>
<td>write，保存不退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存后退出</td>
</tr>
<tr>
<td>/字符串</td>
<td>从光标位置往后查找指定的字符串  按n查找下一个匹配的结果  Shift+n上一个匹配结果</td>
</tr>
<tr>
<td>?字符串</td>
<td>从光标位置往前查找指定的字符串</td>
</tr>
</tbody>
</table>
<h3><span id="查看文件">查看文件</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>cat</td>
<td>/</td>
</tr>
<tr>
<td>命令名称</td>
<td>tac</td>
<td></td>
</tr>
<tr>
<td>命令名称</td>
<td>less</td>
<td></td>
</tr>
<tr>
<td>命令名称</td>
<td>more</td>
<td></td>
</tr>
<tr>
<td>命令名称</td>
<td>head</td>
<td></td>
</tr>
<tr>
<td>命令名称</td>
<td>tail</td>
<td></td>
</tr>
<tr>
<td>参数</td>
<td>文件</td>
<td>每种方式都可以查看文件，但是查看的方式不同</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>head /etc/sudo.conf -n 10</code></td>
<td>查看最前面10行(默认)，Ctrl+C结束</td>
</tr>
<tr>
<td><code>tail /etc/sudo.conf -n 10</code></td>
<td>查看最后面10行(默认)，Ctrl+C结束</td>
</tr>
<tr>
<td><code>cat -n /etc/sudo.conf</code></td>
<td>只能显示最后一屏内容，-n表示显示行号</td>
</tr>
<tr>
<td><code>tac /etc/sudo.conf</code></td>
<td>只能显示最前一屏内容，并且是倒着的</td>
</tr>
</tbody>
</table>
<p><code>less /etc/sudo.conf</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>按键</th>
</tr>
</thead>
<tbody>
<tr>
<td>向下一行</td>
<td>回车或向下键</td>
</tr>
<tr>
<td>向上一行</td>
<td>向上键</td>
</tr>
<tr>
<td>上下翻页</td>
<td>PgUp和PgDn，或者ctrl+f(forward)向下翻页，ctrl+b(back)向上翻</td>
</tr>
<tr>
<td>上下翻半页</td>
<td>u (up)  d (down)</td>
</tr>
<tr>
<td>进入编辑模式</td>
<td>按 v (vim)</td>
</tr>
<tr>
<td>退出</td>
<td>按q (quit)</td>
</tr>
<tr>
<td>搜索</td>
<td>/ + 【搜索关键字】+回车</td>
</tr>
</tbody>
</table>
<p><code>more  /etc/sudo.conf</code></p>
<p>查看内容，并显示已查看内容的百分比</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>按键</th>
</tr>
</thead>
<tbody>
<tr>
<td>向下一行</td>
<td>回车</td>
</tr>
<tr>
<td>向上一行</td>
<td>无</td>
</tr>
<tr>
<td>上下翻页</td>
<td>ctrl+f(forward)向下翻页，ctrl+b(back)向上翻</td>
</tr>
<tr>
<td>进入编辑模式</td>
<td>按 v (vim)</td>
</tr>
<tr>
<td>退出</td>
<td>按q (quit) 或看完自动退出</td>
</tr>
</tbody>
</table>
<h3><span id="删除文件-复制-改名-剪切">删除文件、复制、改名、剪切</span></h3>
<p>见目录相关的操作</p>
<h3><span id="压缩文件">压缩文件</span></h3>
<p>windows的压缩文件的扩展名  .zip/.rar</p>
<p>linux中的打包文件：.tar  把多个文件打包，体积不变</p>
<p>linux中的压缩文件：.gz	 把多个文件压缩成一个文件，体积变小</p>
<p>linux中打包并压缩的文件：.tar.gz</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>tar</td>
<td>(make directory)</td>
</tr>
<tr>
<td>选项</td>
<td>[-z]</td>
<td>调用gzip压缩命令进行压缩</td>
</tr>
<tr>
<td>选项</td>
<td>[-c]</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>选项</td>
<td>[-v]</td>
<td>显示过程</td>
</tr>
<tr>
<td>选项</td>
<td>[-f]</td>
<td>指定压缩后的文件名</td>
</tr>
<tr>
<td>参数</td>
<td>处理后的文件名 被处理的文件路径</td>
<td>创建目录，可以一次创建多个目录，多个目录之间使用空格</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tar  -zcvf  xxx.tar.gz  /demo/*</td>
<td>打包并压缩/demo下的所有文件，压缩后的压缩包指定名称为xxx.tar.gz</td>
</tr>
</tbody>
</table>
<h3><span id="解压文件">解压文件</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>tar</td>
<td>(make directory)</td>
</tr>
<tr>
<td>选项</td>
<td>[-x]</td>
<td>解压</td>
</tr>
<tr>
<td>选项</td>
<td>[-v]</td>
<td>显示过程</td>
</tr>
<tr>
<td>选项</td>
<td>[-f]</td>
<td>指定解压后的文件名</td>
</tr>
<tr>
<td>参数</td>
<td>压缩文件 [-C 目录]</td>
<td>C表示解压到哪个目录</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tar -xvf xxx.tar.gz</td>
<td>将xxx.tar.gz解压到当前目录下</td>
</tr>
</tbody>
</table>
<h2><span id="其他命令">其他命令</span></h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看帮助</td>
<td>(命令名称) --help</td>
<td>mkdir --help</td>
</tr>
<tr>
<td>显示当前位置</td>
<td>pwd</td>
<td></td>
</tr>
<tr>
<td>显示所有的进程</td>
<td>ps -ef</td>
<td></td>
</tr>
<tr>
<td>结束进程</td>
<td>kill [-9] pid （9表示强制，pid是进程的id）</td>
<td>kill -9 123，强制结束进程id为123的进程</td>
</tr>
</tbody>
</table>
<h3><span id="关键字搜索">关键字搜索</span></h3>
<p><code>grep -i (--color)</code>：  要搜索的字符串或文件，-i表示忽略大小写 --color表示高亮显示</p>
<p>如搜索/etc/sudu.conf文件中包含字符串to的行：<code>grep -i  to /etc/sudo.conf (--color)</code></p>
<h3><span id="管道命令">管道命令</span></h3>
<p><code>命令1 | 命令2</code>：将前一个命令的输出作为后一个命令的输入（参数）</p>
<p>如查看当前系统中所有的进程中包括Administ字符串的进程：<code>ps -ef | grep -i Administ</code></p>
<p><img src="https://pic.imgdb.cn/item/64b1f22f1ddac507cce0b2f6.jpg" alt></p>
<h3><span id="网络通信命令">网络通信命令</span></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ifconfig</td>
<td>查看当前系统的网卡信息</td>
</tr>
<tr>
<td>ping 192.168.1.123</td>
<td>查看与某台机器的连接情况</td>
</tr>
<tr>
<td>netstat -nao</td>
<td>查看当前系统的端口使用</td>
</tr>
<tr>
<td>reboot</td>
<td>重启命令</td>
</tr>
<tr>
<td>halt</td>
<td>立即关机</td>
</tr>
</tbody>
</table>
<h1><span id="文件上传-下载">文件上传、下载</span></h1>
<h2><span id="sftp了解">sftp（了解）</span></h2>
<ol>
<li>
<p>按Alt + p打开sftp窗口，在sftp窗口中，一样可以使用命令来操作Linux中的文件，例如：</p>
</li>
<li>
<p>切换到根目录：cd /</p>
<p>在根目录下创建abc目录：mkdir /abc</p>
<p>查看当前所在的目录：pwd</p>
<p>但是有些命令无法使用，例如软件安装命令rpm等，因此一般只使用sftp上传文件</p>
</li>
<li>
<p>还可以像操作Linux那样来作本地文件，例如：</p>
<p>切换到本地d盘：lcd d:/</p>
<p>在d盘下创建abc目录：lmkdir d:/abc</p>
<p>查看在本地的当前位置：lpwd</p>
<p>规律就是在命令前加小写的l（唉偶。。。）</p>
</li>
<li>
<p>新建目录/usr/soft，一般软件包都放在这，并进入该目录</p>
</li>
<li>
<p>mkdir /usr/soft</p>
<p>cd /usr/soft</p>
</li>
<li>
<p>上传本地文件</p>
</li>
<li>
<p>上传本地文件到Linux：put -r 文件…</p>
<p>下载Linux文件到本地：get -r 文件…</p>
</li>
</ol>
<p>可以先使用lcd命令进入要上传的文件所在的目录（过程中多使用Tab键提示，多使用lpwd查看本地当前所在的位置）</p>
<p>然后输入命令：put -r 文件… 或者 put -r 文件全路径</p>
<p>​	注意：如果上传或下载的文件中有文件夹，必须使用-r(递归)，如果只是文件，可以不加</p>
<p>其它技巧：Ctrl+U  可以快速删除已输入的命令</p>
<h2><span id="rzsz重点">rzsz（重点）</span></h2>
<p>使用rz命令完成文件上传，默认没有rz命令，需要安装才能使用</p>
<h3><span id="安装rzsz">安装rzsz</span></h3>
<p>网络安装</p>
<ol>
<li>使用图形化界面工具将资料中的 “软件仓库文件/CentOS-Base.repo”上传到Linux的 /etc/yum.repos.d/ 目录下</li>
<li>执行安装命令 yum install lrzsz</li>
</ol>
<p>文件上传：输入命令rz，回车，会弹出选择文件的窗口，双击要上传的文件，添加到上传列表，可以一次上传多个文件，点击OK开始上传</p>
<p>文件下载：输入命令sz 文件…  回车即可</p>
<p>文件上传和下载的默认位置（可选设置）</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps1.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps2.jpg)</p>
<h1><span id="软件安装命令">软件安装命令</span></h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>创建目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名称</td>
<td>rpm</td>
<td>/</td>
</tr>
<tr>
<td>选项</td>
<td>[-i]</td>
<td>安装指定的软件</td>
</tr>
<tr>
<td>选项</td>
<td>[-e]</td>
<td>删除指定的软件</td>
</tr>
<tr>
<td>选项</td>
<td>[-U]</td>
<td>升级指定的软件</td>
</tr>
<tr>
<td>选项</td>
<td>[-q] 软件包</td>
<td>查询指定软件包</td>
</tr>
<tr>
<td>选项</td>
<td>[-a]</td>
<td>查询所有软件包，需要配合选项q一起使用</td>
</tr>
<tr>
<td>选项</td>
<td>[-h]</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>选项</td>
<td>[-v]</td>
<td>显示安装进度</td>
</tr>
<tr>
<td>选项</td>
<td>[–nodeps]</td>
<td>不验证软件包之间的依赖  a依赖b软件  直接安装a，不让安装</td>
</tr>
<tr>
<td>选项</td>
<td>[–nosignature]</td>
<td>安装时，不进行签名验证</td>
</tr>
<tr>
<td>选项</td>
<td>[–replacepkgs]</td>
<td>如果已经安装，则重新安装</td>
</tr>
<tr>
<td>参数</td>
<td>软件包</td>
<td>创建多个空文本文件</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>rpm  -ivh  rpm文件</td>
<td>安装</td>
</tr>
<tr>
<td>rpm  -e  --nodeps  软件名</td>
<td>删除</td>
</tr>
<tr>
<td>rpm  -Uvh  rpm文件</td>
<td>升级</td>
</tr>
<tr>
<td>rpm -qa | grep -i mysql</td>
<td>查看</td>
</tr>
</tbody>
</table>
<h1><span id="安装jre">安装JRE</span></h1>
<table>
<thead>
<tr>
<th>jdk</th>
<th>jre</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发工具和jre</td>
<td>java软件的运行环境</td>
</tr>
</tbody>
</table>
<p>查看当前Linux系统是否已经安装java</p>
<p><code>rpm -qa | grep -i java</code></p>
<p>卸载查找到的openJDK</p>
<p>rpm -e --nodeps java-XXX</p>
<p>使用rz命令上传jre到linux，或者使用图形化界面，解压jdk到/usr/soft</p>
<p>​	cd /usr/soft</p>
<p>​	tar -xvf  jre-8u211-linux-x64.tar.gz</p>
<ol start="5">
<li>配置jdk环境变量</li>
</ol>
<p>​	编辑配置文件/etc/profile：vim /etc/profile</p>
<p>​	Shift+g快速定位到该文件的最下方，然后按o，在当前行的下一行插入如下内容：jre1.8.0_211</p>
<p>​	#set java environment</p>
<p>​	JAVA_HOME=/usr/soft/jre1.8.0_211</p>
<p>​	PATH=$JAVA_HOME/bin:$PATH</p>
<p>​	CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</p>
<p>​	export JAVA_HOME PATH CLASSPATH</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps5.jpg)</p>
<ol start="6">
<li>重新加载/etc/profile配置文件</li>
</ol>
<p>命令：. /etc/profile <strong>或</strong> source /etc/profile</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps6.jpg)</p>
<p>\7. 测试安装： 输入 java</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps7.jpg)</p>
<h1><span id="安装mysql">安装MySQL</span></h1>
<p>步骤：</p>
<p>\1. 查看CentOS自带的mysql</p>
<p>命令：rpm -qa | grep -i mysql</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps8.jpg)</p>
<p>\2. 将自带的mysql卸载</p>
<p>命令：rpm -e --nodeps mysql-libs-5.1.73-8.el6_8.x86_64</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps9.jpg)</p>
<p>\3. 使用rz命令上传MySQL到linux</p>
<p>\4. 解压MySQL到/usr/soft/下的mysql目录</p>
<p>cd /usr/soft</p>
<p>mkdir mysql</p>
<p>tar -xvf MySQL-5.6.36-1.el6.x86_64.rpm-bundle.tar -C mysql</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps10.jpg)</p>
<p>\5. 在/usr/soft/mysql下安装mysql</p>
<p>切换到mysql：cd /usr/soft/mysql</p>
<p>安装服务器端：rpm -ivh MySQL-server-5.6.36-1.el6.x86_64.rpm --nosignature</p>
<p>安装客户端：rpm -ivh MySQL-client-5.6.36-1.el6.x86_64.rpm --nosignature</p>
<p>\6. 启动mysql</p>
<p>service mysql start</p>
<p>\7. 将mysql加到系统服务中并设置开机启动</p>
<p>加入到系统服务：chkconfig --add mysql</p>
<p>自动启动：chkconfig mysql on</p>
<p>\8. 登录mysql</p>
<p>mysql安装好后会生成一个临时随机密码，存储位置在，查看密码：head /root/.mysql_secret</p>
<p>mysql -uroot -p密码 回车</p>
<p>\9. 修改mysql的密码</p>
<p>set password = password(‘123456’);</p>
<p>\10. 开启mysql的远程登录权限</p>
<p>默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启	远程登录mysql的权限</p>
<p>登录mysql后输入如下命令：</p>
<p>grant all privileges on <em>.</em> to ‘root’ @‘%’ identified by ‘123456’;</p>
<p>flush privileges;</p>
<p>此处的密码必须和步骤9中的一致！</p>
<p>\11. 开放Linux的对外访问的端口3306</p>
<p>/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</p>
<p>/etc/rc.d/init.d/iptables save —将修改永久保存到防火墙中</p>
<p>\12. 修改mysql的编码方式为utf8</p>
<p>mysql默认使用的编码方式是：latin1，需要修改为utf8，当前编码方式可以执行如下<strong>SQL</strong>进行查看</p>
<p>show variables like ‘character%’;</p>
<p>show variables like ‘coll%’;</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps11.jpg)</p>
<p>mysql的配置信息在/usr/my.cnf中，编辑该文件，添加如下配置：</p>
<p>vim /usr/my.cnf</p>
<p>[mysqld]</p>
<p>…</p>
<p>character_set_server=utf8</p>
<p>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</p>
<p>[client]</p>
<p>default-character-set=utf8</p>
<p>如下图所示：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps12.jpg)</p>
<p>编辑完成之后，按ESC，输入&quot;:wq&quot;保存并退出</p>
<p>重启mysql服务器，service mysql restart</p>
<p>再次执行<strong>SQL</strong>查看编码方式：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml1840\wps13.jpg)</p>
<h1><span id="安装tomcat">安装Tomcat</span></h1>
<ol>
<li>
<p>上传Tomcat到linux上</p>
</li>
<li>
<p>解压Tomcat到/usr/soft下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/soft</span><br><span class="line">tar -xvf  apache-tomcat-9.0.65.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开放Linux的对外访问的端口8080</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport <span class="number">8080</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">/etc/rc.d/init.d/iptables save </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动tomcat，进入bin目录下 <code>./startup.sh</code></p>
</li>
<li>
<p>关闭tomcat，进入bin目录下<code>./shutdown.sh</code></p>
</li>
</ol>
<p>注意：在linux中执行某个文件时，一定要加&quot;./&quot;，不能直接文件名，否则会当做命令来执行</p>
<h1><span id="项目部署">项目部署</span></h1>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/post/MySQL/</url>
    <content><![CDATA[<h1><span id="mysql面试题">MySQL面试题</span></h1>
<hr>
<h2><span id="mysql支持的存储引擎">MySQL支持的存储引擎?</span></h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6645c490d9c307b7e97d32d5.png" alt></p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>MySQL支持</th>
<th>Transactions（是否支持事务）</th>
<th>XA（是否通过XA协议实现分布式事务）（分为本地资源管理器，事务管理器）</th>
<th>Savepoint（是否用来实现子事务）（嵌套事务）。创建了一个Savepoints之后，事务就可以回滚到这个点，不会影响到创建Savepoints之前的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>FEDERATED</td>
<td>×</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MRG_MYISAM</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>MyISAM</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>BLACKHOLE</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>CSV</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>MEMORY</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>ARCHIVE</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>InnoDB</td>
<td>默认</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>PERFORMANCE_SCHEMA</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="如何查看mysql存储引擎">如何查看MySQL存储引擎？</span></h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> `数据库名`; </span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6645ee07d9c307b7e9b884d5.png" alt></p>
<hr>
<h2><span id="myisam和innodb的区别">MyISAM和InnoDB的区别？</span></h2>
<p>MyISAM（3 个文件）</p>
<ul>
<li>特点：只读之类的数据分析的项目</li>
<li>支持表级别的锁（插入和更新会锁表）。不支持事务</li>
<li>拥有较高的插入（insert）和查询（select）速度</li>
<li>MyISAM 用一个变量保存了整个表的行数，执行select count(*) from table语句时只需要读出该变量即可，速度很快；</li>
</ul>
<p>InnoDB（2 个文件）</p>
<ul>
<li>
<p>经常更新的表，存在并发读写或者有事务处理的业务系统。</p>
</li>
<li>
<p>支持事务，支持外键，因此数据的完整性、一致性更高</p>
</li>
<li>
<p>支持行级别的锁和表级别的锁</p>
</li>
<li>
<p>支持读写并发，写不阻塞读（MVCC）</p>
</li>
<li>
<p>特殊的索引存放方式，可以减少IO，提升查询效率</p>
</li>
<li>
<p>在 MySQL 5.5 版本之前，默认的存储引擎是MyISAM；5.5版本之后默认的存储引擎改成了InnoDB</p>
</li>
<li>
<p>因为InnoDB 支持事务，支持外键，支持行级别的锁，对于业务一致性要求高的场景来说更适合</p>
</li>
</ul>
<hr>
<h2><span id="如何选择存储引擎">如何选择存储引擎？</span></h2>
<ul>
<li>InnoDB：适用对数据一致性要求比较高，需要事务支持</li>
<li>MyISAM：适用数据查询多更新少，对查询性能要求比较高</li>
<li>Memory：适用一个用于查询的临时表</li>
</ul>
<hr>
<h2><span id="innodb是如何实现事务的">Innodb是如何实现事务的？</span></h2>
<ul>
<li>在MySQL中事务是在存储引擎层实现的</li>
<li>对于InnoDB而言，原子性代表着可回滚，这一特性主要有undo log实现</li>
<li>隔离性需要在效率上作出平衡，在不同的隔离级别下主要由MVCC和锁实现；</li>
<li>持久性主要由redo log和double write实现，redo log是一种Write Ahead Log（WAL）策略，用于对数据页进行重做；double write则用于防止脏页刷盘时部分写失效导致的数据丢失。</li>
</ul>
<hr>
<h2><span id="myql中的事务回滚机制概述">Myql中的事务回滚机制概述 ？</span></h2>
<p>事务</p>
<ul>
<li>用户定义的一个数据库操作序列</li>
<li>这些操作要么全做要么全不做，是一个不可分割的工作单位</li>
</ul>
<p>事务回滚</p>
<ul>
<li>将该事务已经完成的对数据库的更新操作撤销</li>
<li>修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕</li>
<li>当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚</li>
</ul>
<hr>
<h2><span id="什么是索引">什么是索引？</span></h2>
<ul>
<li>在关系型数据库中，索引是一种对数据库表中的一列或多列的值进行排序的存储结构，是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的逻辑指针清单</li>
<li>相当于图书中的目录，可以根据目录中的页码快速找到所需的内容</li>
<li>能实现快速定位的一种存储结构，其设计思想是空间换时间</li>
</ul>
<hr>
<h2><span id="索引的分类">索引的分类</span></h2>
<ul>
<li>
<p>按照数据结构分类：B+ tree 索引、Hash索引、Full-text索引</p>
<ul>
<li>哈希索引基于哈希表实现，通过哈希算法将数据库的索引列数据转换成定长的哈希码作为key，将这条记录的行地址作为value存入哈希表响应位置</li>
<li>在MySQL中只有Memory引擎显示支持哈希索引（Memory引擎默认索引结构为哈希索引），同时Memory引擎也支持B-tree索引；Memory并非支持唯一哈希索引，若多个列的哈希值相同（哈希碰撞），索引会在对应的哈希键下以链表的形式存储多个地址</li>
<li>哈希索引不支持部分索引列的匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希值（在数据列【a，b】上建立索引，查询只有数据列a，则无法使用哈希索引）</li>
<li>哈希索引的数据存储是无序的，因此无法用于排序，且只适用于精确匹配所有列的查询（=,&lt;&gt;），无法使用任何范围查询</li>
<li>精确查询的哈希索引效率高，时间复杂度为O(1)；但是若发生哈希冲突（不同的索引拥有相同的哈希值），存储引擎必须遍历链表中所有数据指针，逐行比较直至找到所有符合条件的行。因此哈希冲突越多，时间复杂度越大</li>
</ul>
</li>
<li>
<p>按照物理存储分类：聚簇索引（主键索引）、非聚簇索引（辅助索引或二级索引）</p>
<ul>
<li>聚簇索引将数据存储到索引树的叶子节点上；非聚簇索引则将数据存储在数据页中</li>
<li>聚簇索引查询索引树的同时能获取到数据，因此可以减少一次查询；非聚簇索引需要先查询一次索引树获取数据页的地址，在通过数据页的地址查询数据，因此需要查询两次查询（特殊情况：索引覆盖不用回表）</li>
<li>聚簇索引对数据进行修改和删除操作时需要更新索引树，会增加系统的开销；非聚簇索引则不用更新索引树</li>
<li>聚簇索引主要用于提升查询效率；非聚簇索引主要用于提高数据更新和删除的效率</li>
</ul>
</li>
<li>
<p>按照字段特性分类：主键索引、唯一索引、普通索引、前缀索引</p>
<ul>
<li>
<table>
<thead>
<tr>
<th>索引分类</th>
<th>是否允许为空</th>
<th>索引列是否唯一</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引</td>
<td>不允许为空</td>
<td>必须唯一</td>
</tr>
<tr>
<td>唯一索引</td>
<td>允许为空</td>
<td>必须唯一</td>
</tr>
<tr>
<td>普通索引</td>
<td>允许为空</td>
<td>不一定唯一</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>唯一索引使用场景：业务无法确保数据唯一性，因此可以使用唯一索引；</p>
</li>
</ul>
</li>
<li>
<p>按照字段个数分类：单列索引、联合索引</p>
</li>
</ul>
<hr>
<h2><span id="innodb是否支持哈希索引">InnoDB是否支持哈希索引？</span></h2>
<ul>
<li>InnoDB用户无法手动创建哈希索引</li>
<li>但是InnoDB会自调优（self-turning），如果判定建立自适应哈希索引，能够提升效率，InnoDB则会自己建立相关哈希索引</li>
</ul>
<p>自适应哈希索引（Adaptive Hash Index，AHI）</p>
<p><img src="https://pic.imgdb.cn/item/664da169d9c307b7e9bfd316.png" alt></p>
<ul>
<li>当InnoDB存储引擎根据查询统计发现某一查询条件满足哈希索引的数据结构特点，就会建立哈希索引</li>
<li>哈希索引底层的数据结构为散列表，适合在内存中使用，自适应Hash索引存在与InnoDB的缓存中（不在磁盘架构中）</li>
</ul>
<hr>
<h2><span id="mysql如何实现索引">MySQL如何实现索引</span></h2>
<ul>
<li>顺序查找：O(N)</li>
<li>二分查找：O(log(N))，必须顺序存储结构，必须按照关键字进行有序排序</li>
<li>哈希查找：直接定位，效率无限接近O(1)，取决于冲突的数量。但散列表是无序存储的，需要排序。并且散列表扩容耗时长，遇到散列冲突性能不稳定</li>
<li>B树、B+树：O(log2(N))</li>
</ul>
<hr>
<h2><span id="索引的应用场景">索引的应用场景？</span></h2>
<p>需要建索引的情况</p>
<ul>
<li>主键自动创建唯一索引</li>
<li>较频繁的作为查询条件的字段</li>
<li>查询中排序的字段，查询中统计或者分组的字段</li>
</ul>
<p>不需要建索引的情况</p>
<ul>
<li>表记录太少的字段</li>
<li>经常增删改的字段</li>
<li>唯一性太差的字段，不适合单独创建索引。比如性别，民族，政治面貌</li>
</ul>
<hr>
<h2><span id="索引的数据结构">索引的数据结构？</span></h2>
<p>索引的数据结构是B+树（加强版多路平衡查找树）</p>
<p>原理：如下图，是一颗B+树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220822/1661135892@a76e3b01eecba05f65b44ac1a753b550.png" alt="img"></p>
<p>查找过程：</p>
<ul>
<li>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计</li>
<li>通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针</li>
<li>通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO</li>
</ul>
<p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的</p>
<p>如果没有索引，操作系统将加载所有的数据项到内存，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高</p>
<p>优点：保证等值和范围查询的快速查找</p>
<hr>
<h2><span id="索引的优缺点">索引的优缺点？</span></h2>
<p>优点</p>
<ul>
<li>提高数据检索的效率，降低数据库IO成本</li>
<li>通过索引对数据进行排序，降低数据的排序成本，降低CPU的消耗</li>
</ul>
<p>缺点</p>
<ul>
<li>建立索引需要占用物理空间，建立索引越多需要的空间越大</li>
<li>创建索引和维护索引要耗费时间，数据量越多耗费的时间越长</li>
<li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引，导致增删改时间变长</li>
</ul>
<hr>
<h2><span id="索引数据结构为什么是b树">索引数据结构为什么是B+树？</span></h2>
<p>先来说说二叉查找树（BST Binary Search Tree）</p>
<ul>
<li>左子树所有的节点都小于父节点</li>
<li>右子树所有的节点都大于父节点</li>
<li>投影到平面以后，就是一个有序的线性表</li>
</ul>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220822/1661136347@23fc08e195ef78f74671c0a3b8731c9b.png" alt="img"><br>
比如我们插入的数据是有序的[2、6、11、13、17、22] ，那么这个时候我们的二叉查找树变成了什么样了呢？如下图：</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220822/1661136386@889ba0bb8507666c164152e861873eed.png" alt="img"><br>
很明显，树变成链表了，因为左右子树深度差太大，这棵树的左子树根本没有节点——也就是它不够平衡。<br>
优点：能够实现快速查找和插入。<br>
缺点：树的深度会影响查找效率。<br>
\1. 平衡二叉树（Balanced binary search trees）<br>
平衡二叉树又称红黑树，除了具备二叉树的特点，最主要的特征是左右子树深度差绝对值不能超过1。例如我们按顺序插入1、2、3、4、5、6，就会变成如下图：</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220822/1661136418@c6d9e97b3100bb57f38d93c3734d46be.png" alt="img"><br>
优点：在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。<br>
缺点：<br>
● 时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。在表数据量大时，查询性能就会很差。<br>
● 平衡二叉树不支持快速的范围查找，范围查找时需要从根节点多次遍历，查询效率不高。</p>
<hr>
<h2><span id="索引类型有哪些">索引类型有哪些？</span></h2>
<p><strong>单列索引</strong></p>
<ul>
<li>
<p>只包含单个列的索引，但一个表中可以有多个单列索引</p>
</li>
<li>
<p>单列索引又分为主键索引、唯一索引</p>
<ul>
<li>
<p>主键索引：主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键</p>
</li>
<li>
<p>唯一索引：索引列的所有值都只能出现一次，即必须唯一，值可以为空</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX account_UNIQUE_Index <span class="keyword">ON</span> `award`(`account`);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>普通索引：基本的索可以为空，没有唯一性的限制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX account_Index <span class="keyword">ON</span> `award`(`account`);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>复合索引</strong></p>
<p>包含两个或两个以上字段的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index a_b_c_index on table1(a,b,c)</span><br></pre></td></tr></table></figure>
<p>创建的联合索引a_b_c_index，实际上相当于建立了三个索引（a）、（a_b）、（a_b_c）</p>
<p>遵循最左匹配原则，举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220822/1661136772@232e50cb374053c6243d941c6ac5d0a1.png" alt="img"><br>
可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序</p>
<p>注意：<br>
● 查询必须从索引的最左边的列开始，否则无法使用索引。比如直接使用b或着c，此时索引会失效。<br>
● 查询不能跳过某一个索引。比如使用了a索引，但是跳过了b，使用了c，此时只有a索引有用，而c索引失效。<br>
● 查询中如果使用了范围查询，那么其右侧的索引列会失效。比如a=1 and b&gt;2 and c=3.此时b使用了范围查询，&gt;、like等。c索引列不会起作用。</p>
<p><strong>全文索引</strong></p>
<ul>
<li>常在MyISAM引擎上使用</li>
<li>只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引</li>
<li>在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有&quot;我爱学编程尤其是java …&quot; 通过java，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思</li>
<li>一般开发中，不会用到全文索引，因为其占用很大的物理空间和降低了记录修改性，故较为少用</li>
</ul>
<hr>
<h2><span id="怎么查询sql语句是否使用了索引查询">怎么查询SQL语句是否使用了索引查询？</span></h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在查询<span class="keyword">sql</span>前加explain</span><br><span class="line">explain <span class="keyword">select</span> ..........</span><br></pre></td></tr></table></figure>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220822/1661136932@84c5c7800158ef9acc8d30e08e964ea9.png" alt="img"></p>
<p>我们只需要注意一个最重要的type 的信息很明显的提现是否用到索引，type结果值从好到坏依次是：<br>
system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL<br>
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。其中possible_keys：sql所用到的索引</p>
<hr>
<h2><span id="什么是聚簇索引">什么是聚簇索引？</span></h2>
<ul>
<li>将数据(一行一行的数据)跟索引结构放到一块</li>
<li>innodb存储引擎使用的就是聚簇索引</li>
<li>聚集索引中表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放</li>
<li>聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序</li>
<li>而非聚集索引：制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排</li>
</ul>
<hr>
<h2><span id="使用聚簇索引的优缺点">使用聚簇索引的优缺点？</span></h2>
<ul>
<li>由于行数据和聚簇索引的叶子节点存储在一起，同一页（16k）中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中(读取数据是按页读取的)，再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快</li>
<li>辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小</li>
<li>因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的</li>
</ul>
<hr>
<h2><span id="为什么推荐使用自增主键作为索引">为什么推荐使用自增主键作为索引？</span></h2>
<p>主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出现新增加记录的uuid，会插入在索引树中间的位置，出现页分裂（比如之前的索引已经紧凑的排列在一起了，你此时需要在已经紧凑排列好的数据中插入数据就会导致前面已经排好序的索引出现松动和重构排序，但是使用自增id就不会出现这种情况了），导致索引树调整复杂度变大，消耗更多的时间和资源。但是使用自增主键就可以避免出现页分裂，因为自增主键后面的主键值是要比前面的大， 那后来的数据直接放在后面就行；<br>
聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，它会不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但如果是自增的id，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<hr>
<h2><span id="什么叫回表">什么叫回表？</span></h2>
<p>如果一个查询是先走辅助索引（聚簇索引外的索引都叫辅助索引）的，那么通过这个辅助索引（innodb中的辅助索引的data存储的是主键）没有获取到我们想要的全部数据，那么MySQL就会拿着辅助索引查询出来的主键去聚簇索引中进行查询，这个过程就是叫回表；</p>
<hr>
<h2><span id="什么是索引覆盖">什么是索引覆盖？</span></h2>
<p>所谓的索引覆盖是索引高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</p>
<p>注意：id 字段是聚簇索引，age 字段是普通索引（二级索引）<br>
select id,age from user where age = 30;<br>
上面的这个sql是不用回表查询的，因为在非聚簇索引的叶子节点上已经有id和age的值。所以根本不需要拿着id的值再去聚簇索引定位行记录数据了。也就是在这一颗索引树上就可以完成对数据的检索，这样就实现了覆盖索引。<br>
select id,age,name from user where age = 30;<br>
而上面的这个sql不能实现索引覆盖了，因为name的值在age索引树上是没有的，还是需要拿着id的值再去聚簇索引定位行记录数据。但是如果我们对age和name做一个组合索引idx_age_name(age,name),那就又可以实现索引覆盖了。</p>
<hr>
<h2><span id="mysql索引失效的几种情况">MySQL索引失效的几种情况？</span></h2>
<p>1）like查询以%开头，因为会导致查询出来的结果无序；如：应尽量避免使用模糊查询， like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。否则将导致引擎将放弃使用索引而进行全表扫描。<br>
2）类型转换，列计算也会可能会让索引失效，因为结果可能是无序的，也可能是有序的；如：应尽量避免在where子句中的“=”左边进行函数、算术运算或其他表达式运算，否则将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为：select id from t where num=100*2<br>
3）在一些查询的语句中，MySQL认为走全表扫描也会导致索引失效；如：应尽量避免使用is null 和is not null 、in和not in，否则将导致引擎将放弃使用索引而进行全表扫描。<br>
对于连续的数值用between就不要用in，如：select id from t where num in(1,2,3) 替换成：select id from t where num between 1 and 3<br>
用exists代替in，如：select num from a where num in(select num from b) 替换成：select num from a where exists(select 1 from b where num=a.num)<br>
4）如果条件中有or并且or连接的字段中有列没有索引，那么即使其中有条件带索引也不会使用索引 (这是因为MySQL判断即便你开始走了索引查询，但是它发现查询中有or ，也就是说or 后面的还是需要走全表扫描（因为or会导致后面的数据是无序的），所以MySQL还不如一开始就直接走全表扫描，这也是为什么尽量少用or的原因)要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引，当检索条件有or但是所有的条件都有索引时，索引不失效，可以走【两个索引】，这叫索引合并（取二者的并集）;<br>
5)复合索引不满足最左原则就不能使用全部索引，如：注意最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)。</p>
<hr>
<h2><span id="谈一下你对mysql索引的理解">谈一下你对MySQL索引的理解？</span></h2>
<p>索引的b+树结构,为什么使用b+树说一下,然后再说一下聚簇索引，回表和索引覆盖；<br>
然后再谈一下索引失效；</p>
<hr>
<h2><span id="mysql中聚合函数有哪些">MySQL中聚合函数有哪些？</span></h2>
<p>如sum. avg, count, max, min等</p>
<hr>
<h2><span id="mysql的函数中有关string的操作">MySQL的函数中有关String的操作？</span></h2>
<p>1、LOCATE(substr , str )：返回子串 substr 在字符串 str 中第一次出现的位置，如果字符substr在字符串str中不存在，则返回0；<br>
2、POSITION(substr IN str )：返回子串 substr 在字符串 str 中第一次出现的位置，如果字符substr在字符串str中不存在，与LOCATE函数作用相同；<br>
3、LEFT(str, length)：从左边开始截取str，length是截取的长度；<br>
4、RIGHT(str, length)：从右边开始截取str，length是截取的长度；<br>
5、SUBSTRING_INDEX(str ,substr ,n)：返回字符substr在str中第n次出现位置之前的字符串;<br>
6、SUBSTRING(str ,n ,m)：返回字符串str从第n个字符截取到第m个字符；<br>
7、REPLACE(str, n, m)：将字符串str中的n字符替换成m字符；<br>
8、LENGTH(str)：计算字符串str的长度。</p>
<hr>
<h2><span id="count1-count-与-count列名-的区别">count(1)、count(*) 与 count(列名) 的区别？</span></h2>
<p>1）从含义上讲，count(1) 与 count(<em>) 都表示对全部数据行的查询。count(</em>) 包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL ；count(1) 用1代表代码行，在统计结果的时候不会忽略列值为NULL 。<br>
2）执行效率上：<br>
count(<em>)对行的数目进行计算，包含NULL，count(1)这个用法和count(</em>)的结果是一样的。如果表没有主键，那么count(1)比count(<em>)快。表有主键，count(</em>)会自动优化到主键列上。如果表只有一个字段，count(<em>)最快。<br>
count(1)跟count(主键)一样，只扫描主键。count(</em>)跟count(非主键)一样，扫描整个表。明显前者更快一些。<br>
count(1)和count(*)基本没有差别，但在优化的时候尽量使用count(1)。</p>
<hr>
<h2><span id="mysql的时间函数有哪些">MySQL的时间函数有哪些？</span></h2>
<p>1） DATE_FORMAT(time, ‘%Y-%m-%d’) 或者 “%H:%i:%S”<br>
2） extract(year from “2019-12-25 22:47:37”) 从时间提前年/月/日<br>
3） datediff(end_date,start_date) 时间做差，得到日期day<br>
4） timestampdiff( day, end_date,start_date) 时间做差，可选择返回的时间类型</p>
<hr>
<h2><span id="mysql中int20和char20以及varchar20的区别">MySQL中int(20)和char(20)以及varchar(20)的区别?</span></h2>
<p>1、 int(20) 表示字段是int类型，显示长度是 20<br>
2、 char(20)表示字段是固定长度字符串，长度为 20<br>
3、 varchar(20) 表示字段是可变长度字符串，长度为 20</p>
<hr>
<h2><span id="sql语句中关键字的执行顺序">SQL语句中关键字的执行顺序？</span></h2>
<p>SQL的执行顺序：from—where–group by—having—select—order by</p>
<hr>
<h2><span id="sql的生命周期">SQL的生命周期？</span></h2>
<p>第一步：客户端请求<br>
第二步：连接器（负责跟客户端建立连接、获取权限、维持和管理连接）<br>
第三步：查询缓存（存在缓存则直接返回，不存在则执行后续操作）<br>
第四步：分析器（对SQL进行词法分析和语法分析操作）<br>
第五步：优化器（主要对执行的sql优化选择最优的执行方案方法）<br>
第六步：执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）<br>
第七步：去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<hr>
<h2><span id="drop-delete与truncate的区别">drop、delete与truncate的区别？</span></h2>
<p>delete和truncate只删除表的数据不删除表的结构<br>
速度,一般来说: drop&gt; truncate &gt;delete<br>
delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效，如果有相应的trigger,执行的时候将被触发.<br>
truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p>
<hr>
<h2><span id="union与union-all的区别">UNION与UNION ALL的区别？</span></h2>
<p>● Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；<br>
● Union All：对两个结果集进行并集操作，包括重复行，不进行排序；<br>
● UNION ALL的效率高于 UNION</p>
<hr>
<h2><span id="什么是数据库锁">什么是数据库锁？</span></h2>
<p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。<br>
加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
<hr>
<h2><span id="mysql锁分类">MySQL锁分类?</span></h2>
<p>1.从对数据操作的类型分类<br>
读锁（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响<br>
写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁<br>
2.从对数据操作的范围分类<br>
为了尽可能提高数据库的并发度，理论上每次只锁定当前操作的数据，即每次锁定的数据范围越小就会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。<br>
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；<br>
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）； 适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。<br>
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
<hr>
<h2><span id="悲观锁和乐观锁的区别">悲观锁和乐观锁的区别？</span></h2>
<p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据都会block直到它拿到锁。因此，悲观锁需要耗时比较的多，跟乐观锁比较，悲观锁是有数据库自己实现的，用的时候我们直接调用数据的相关语句就可以。<br>
乐观锁：用数据版本记录机制实现，这是乐观锁最常用的方式，所谓的数据版本，为数据增加一个版本号的字段，一般是通过为数据表增加一个数据类型的version字段实现，当读取数据时，将把二十年字段的值一同读取出来，数据每次更新都需要对version值加一，在我们提交更新的时候，判断数据表对应记录的当前版本信息与第一次取出来的version值进行对比，如果数据库的表当前版本号鱼取出来的version值相等，则给与更新否则认为过期数据不给与更新。</p>
<hr>
<h2><span id="什么是数据库死锁">什么是数据库死锁？</span></h2>
<p>是指二个或者二个以上的进程在执行时候，因为争夺资源造成相互等待的现象，进程一直处于等待中，无法得到释放，这种状态就叫做死锁。如批量入库时，存在则更新，不存在则插入，insert into tab(xx,xx) on duplicate key update xx=‘xx’。</p>
<hr>
<h2><span id="如何查看死锁">如何查看死锁？</span></h2>
<p>1）使用命令 show engine innodb status 查看最近的一次死锁。<br>
2）InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。</p>
<hr>
<h2><span id="数据库死锁如何处理">数据库死锁如何处理？</span></h2>
<p>1：通过innodblockwait_timeout来设置超时时间，一直等待直到超时。其中innodb默认是使用设置死锁时间来让死锁超时的策略，默认innodblockwait_timeout设置的时长是50s。<br>
2：发起死锁检测，发现死锁之后，主动回滚死锁中的事务，不需要其他事务继续。</p>
<hr>
<h2><span id="如何避免数据库死锁">如何避免数据库死锁？</span></h2>
<p>1）为了在单个innodb表上执行多个并发写入操作时避免死锁，可以在事务开始时，通过为预期要修改行，使用select …for update语句来获取必要的锁，即使这些行的更改语句是在之后才执行的<br>
2）在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时在申请排他锁。因为这时候当用户在申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，<br>
3）如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发获取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。<br>
4）通过 select …lock in share mode获取行的读锁后，如果当前事务在需要对该记录进行更新操作，则很有可能造成死锁；<br>
5）改变事务隔离级别.</p>
<hr>
<h2><span id="什么是主从复制">什么是主从复制?</span></h2>
<p>主从复制就是用来建立一个或多个和主库一样的数据库,称为从库,然后可以在这两者之上进行一个读写分离,主库少写,从库多读的操作,这样就能大大缓解数据库的并发压力。</p>
<hr>
<h2><span id="主从复制作用">主从复制作用 ？</span></h2>
<p>1）做数据的热备份，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>
2）架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>
3）读写分离，使数据库能支持更大的并发。在线上环境中,一般都是读多写少,那么我们可以在主库中实现写操作,然后在从库实现读操作,这样就能很好的分担压力.</p>
<hr>
<h2><span id="mysql的主从复制如何做的">MySQL的主从复制如何做的？</span></h2>
<p>\1. 首先从库创建I/O线程去请求主库 的binlog<br>
\2. 然后主库创建一个binlog dump线程将数据同步到binlog文件中.<br>
\3. 然后从库I/O线程将binlog文件数据同步到自身的redo log文件中.<br>
\4. 然后从库创建一个sql线程将redo log文件里的数据同步到数据库里.</p>
<hr>
<h2><span id="主从复制可能会遇到的问题">主从复制可能会遇到的问题？</span></h2>
<p>1.因为从库复制binlog文件的这个IO线程是单线程,所以如果出现网络阻塞等情况,那么主库的写操作肯定要比复制数据要快,这个时候就会导致从库复制延迟,数据不一致.<br>
2.在从库用sql线程将redo log文件里的数据复制到数据库里的时候,可能会被对该表的操作阻塞,比如有另外的线程进行锁表的操作,那么该导入数据的sql线程就会被阻塞.此时也会导致复制延迟.<br>
3.如果中间过程出现了宕机,可能会产生数据丢失的问题.</p>
<hr>
<h2><span id="主从复制的问题如何解决">主从复制的问题如何解决？</span></h2>
<p>1.解决数据丢失,很简单,可以采用半同步复制策略.即在进行同步复制的时候,主库要求必须要有一个从库进行回应后才能确定复制成功,确保数据至少复制到了一台从机了.<br>
2.解决复制延迟问题可以采用并行复制,这是自5.6后提出的,到5.7后得以升级传播,此后多个数据库版本出现就有多个版本的并行复制,这里截取网上一种通用说法,跟面试官说说就可以了,毕竟我们是刚出去工作的小白:<br>
MySQL为了解决这个问题，将sql_thread演化了多个worker的形式，在slave端并行应用relay log中的事务，从而提高relay log的应用速度，减少复制延迟。</p>
<hr>
<h2><span id="分库分表的概念">分库分表的概念？</span></h2>
<p>水平分库<br>
概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。<br>
结果：每个库的结构都一样，拥有相同的表数量；每个库的数据都不一样，没有交集，所有库的并集是全量数据；</p>
<p>垂直分库<br>
概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。拆分对象是表<br>
结果：每个库的结构都不一样，比如abcd四张表，ab表放x库，cd表放y库；每个库的数据也不一样，没有交集，所有库的并集是全量数据；</p>
<p>水平分表<br>
概念：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。<br>
结果：每个表的结构都一样；每个表的数据都不一样，没有交集；所有表的并集是全量数据；</p>
<p>垂直分表<br>
概念：以字段为依据，按照字段的活跃性，将热点字段放在一张表，非热点字段放一张表。<br>
结果：每个表的结构都不一样，idabcd五个字段，idab字段放x表，idcd字段放y表；都存有主键，通过主键来关联</p>
<hr>
<h2><span id="如何设置自增的主键">如何设置自增的主键？</span></h2>
<p>很简单，只需要在主键后面添加AUTO_INCREMENT关键字就行了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    `password` <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="插入数据时指定主键了怎么办">插入数据时指定主键了怎么办？</span></h2>
<p>刚才，我们在user表中已经把主键id设置为自增的了，但是又在表中插入了一条设置了id值的数据<br>
insert into <code>user</code> values(1, “张三”, “zs666”)<br>
那么MySQL会直接忽略掉我们自己设置的id，继续通过自增来设置插入数据的id</p>
<hr>
<h2><span id="主键不连续是什么情况">主键不连续是什么情况？</span></h2>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220826/1661498667@be84a965e6f5c112f9bdc50b005b36c8.png" alt="img"></p>
<p>例如id从5直接跳到了8，这是因为我们之前在尝试进行插入操作时，虽然事务没有提交，但是id已经自增了</p>
<hr>
<h2><span id="主键是用自增还是随机uuid">主键是用自增还是随机（UUID）？</span></h2>
<p>主键建议是自增的好。因为InnoDB中的主键是聚簇索引，如果主键是自增的话，每次插入新的记录就会顺序添加到当前索引节点的后续位置，当一页写满就会自动开辟新的页。如果不是自增主键，可能就会在中间插入，引发页的分裂导致产生很多表空间的碎片。可以理解为当主键是UUID的时候，插入表记录的时间会更长，占用空间也会更大。</p>
<hr>
<h2><span id="主键为什么不推荐有业务含义">主键为什么不推荐有业务含义？</span></h2>
<p>1.任何有业务含义的列都有改变的可能性，主键一旦带上了业务含义，那么主键就有可能发生变更。而主键一旦发生变更，该记录数据在磁盘上的存储位置就会发生改变，甚至有可能会引发页分裂导致产生空间碎片。<br>
2.带有业务含义的主键就不一定是顺序自增的了，这样就会导致数据的插入顺序不到有序的，也不能保证后面插入数据的主键一定比前面的数据大。如果出现了后面插入数据的主键比前面的小的情况，就有可能引发页分裂导致产生空间碎片。</p>
<hr>
<h2><span id="表示枚举的字段为什么不用enum类型">表示枚举的字段为什么不用enum类型？</span></h2>
<p>表示枚举的字段一般选用tinyint类型。不选用enum类型主要有两个原因：<br>
1.enum类型的order by的操作效率低，需要额外的操作。<br>
2.如果枚举值是数值类型的，会很容易出现语法陷阱，枚举的下标和数值很容易会被弄混淆。</p>
<hr>
<h2><span id="货币字段用什么类型">货币字段用什么类型？</span></h2>
<p>如果货币单位是分，可以是int类型；如果坚持用元，则要用decimal类型。<br>
但是是不能用float和double类型的，因为这两个类型是以二进制存储的，会有一定的误差。比如float类型如果你insert一个1234567.23，查询出来的结果可能是1234567.25。</p>
<hr>
<h2><span id="时间字段用什么类型">时间字段用什么类型？</span></h2>
<p>时间字段的话需要结合项目背景，varchar、timestamp、datetime或bigint类型都可以。<br>
1.varchar类型。如果用varchar类型来存时间，优点在于显示直观，存取都方便。但是缺点也是挺多的，比如插入的数据没有校验，某一天你可能会发现数据库中存了一个2019-06-31的数据。其次，做时间比较运算时需要用str_to_date()等函数将其转化为时间类型，除非建立基于函数的索引，否则这么写是无法命中索引的，数据量一大，查询效率就会很低。<br>
2.timestamp类型。这个类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07，而2038年以后的时间，是无法用timestamp类型存储的。但是它有一个优势是它带有时区信息的，一旦系统中的时区发生改变，项目中的该字段的值也会自己发生改变。<br>
3.datetime类型。datetime类型的储存占用8个字节，存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大，但是它存储的是时间绝对值，不带有时区信息。如果改变了数据库的时区，该项的值不会自己发生变更。<br>
4.bigint类型。这个类型也是8个字节，自己维护一个时间戳，表示范围比timestamp类型大多了。缺点就是要自己维护，不大方便。</p>
<hr>
<h2><span id="为什么不直接存储图片-音频和视频等大容量内容">为什么不直接存储图片、音频和视频等大容量内容？</span></h2>
<p>在实际应用中，一般都是用HDFS来存储文件的，在MySQL中只会存文件的存放路径。但是实际上MySQL是有提供两个字段类型被涉及用来存放大容量文件的，一个是text类型，一个是blob类型。然而在生产中基本不会使用这两个类型，主要原因如下：<br>
1.MySQL内存临时表不支持text和blob这样的大数据类型。如果查询中包含这样的数据，那么在排序等操作的时候就不能够使用内存临时表，只能使用磁盘临时表，会导致查询效率低下。<br>
2.这两种类型会造成binlog的内容太多。因为数据的内容比较大，也就会造成binlog的内容比较多。我们知道，主从同步是通过binlog来进行的，如果binlog过大，就会导致主从同步的效率问题。</p>
<hr>
<h2><span id="为什么字段要被定义为not-null">为什么字段要被定义为NOT NULL？</span></h2>
<p>1.索引的性能不好。MySQL难以优化引用可空列查询，它会使得索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要MySQL内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节。<br>
2.查询可能会出现一些不可预料的结果。比如说使用count()聚合函数去统计一个可为空的字段，那么最后统计出来的记录数可能会和实际的记录数不同。</p>
<hr>
<h2><span id="varchar50中50的含义">varchar(50)中50的含义？</span></h2>
<p>1）字段最多存放 50 个字符<br>
2）如 varchar(50) 和 varchar(200) 存储 “jay” 字符串所占空间是一样的，后者在排序时会消耗更多内存</p>
<hr>
<h2><span id="mysql性能如何分析">MySql性能如何分析？</span></h2>
<p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有慢查询日志，EXPLAIN 分析查询，profiling分析以及show命令查询系统状态及系统变量，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>
1 慢查询日志<br>
MySQL 的慢查询日志用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的 SQL，则会被记录到慢查询日志中<br>
● long_query_time的默认值为10，意思是运行10秒以上的语句。<br>
● 默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启<br>
------------------------------------------------<br>
修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数<br>
[mysqld]<br>
slow_query_log = ON<br>
slow_query_log_file = /var/lib/mysql/hostname-slow.log<br>
long_query_time = 3<br>
在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具mysqldumpslow。<br>
2 Explain(执行计划)<br>
使用 Explain 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈<br>
3 Show Profile 分析查询<br>
Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。默认情况下，参数处于关闭状态，并保存最近15次的运行结果 .</p>
<hr>
<h2><span id="慢查询优化的基本步骤">慢查询优化的基本步骤？</span></h2>
<ul>
<li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li>
<li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li>
<li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li>
<li>order by limit 形式的sql语句让排序的表优先查</li>
<li>了解业务方使用场景</li>
<li>加索引时参照建索引的几大原则</li>
<li>观察结果，不符合预期继续从0分析</li>
</ul>
<hr>
<h2><span id="mysql索引优化">MySQL索引优化？</span></h2>
<ul>
<li>使用复合索引而不是索引的组合</li>
<li>创建索引尽量让辅助索引进行索引覆盖 而不是回表</li>
<li>在可以使用主键id的表中，尽量使用自增主键id，这样可以避免页分裂</li>
<li>查询的时候尽量不要使用select * ，这样可以避免大量的回表</li>
<li>尽量少使用子查询，能使用外连接就使用外连接，这样可以避免产生笛卡尔集</li>
<li>能使用短索引就是用短索引，这样可以在非叶子节点存储更多的索引列降低树的层高，并且减少空间的开销</li>
</ul>
<hr>
<h2><span id="说说对sql语句优化有哪些方法">说说对SQL语句优化有哪些方法？</span></h2>
<ul>
<li>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后</li>
<li>用EXISTS替代IN、用NOT EXISTS替代NOT IN</li>
<li>避免在索引列上使用计算</li>
<li>避免在索引列上使用IS NULL和IS NOT NULL</li>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li>
</ul>
<hr>
<h2><span id="百万级别或以上的数据如何删除">百万级别或以上的数据如何删除?</span></h2>
<p>首先对于索引的维护来说是需要成本的，我们对数据的增/删/修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，删除数据的速度和创建的索引数量是成正比的,如果直接删除很可能会产生中断情况，所以我们想要删除百万数据的时候可以做如下操作：<br>
\1. 先删除索引（此时大概耗时三分多钟）<br>
\2. 然后删除其中无用数据（此过程需要不到两分钟）<br>
\3. 删除完成后重新创建索引(此时数据较少了创建索引也非常快，约十分钟左右)</p>
<hr>
<h2><span id="什么是当前读和快照读吗">什么是当前读和快照读吗？</span></h2>
<p>简单来说在高并发情况下当前读是获取最新的记录并且其他事务不能修改这个记录、快照读获取的有可能是老的数据。当前读是加了锁的，并且加的是悲观锁。而快照读是没加锁的。</p>
<hr>
<h2><span id="什么是mvcc">什么是MVCC？</span></h2>
<p>MVCC（Multi-Version Concurrency Control）</p>
<ul>
<li>高并发版本控制器，用于数据库中对数据的并发访问</li>
<li>通过保存数据的历史版本，根据比较版本号来处理数据是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果</li>
<li>是一种非堵塞、同时还可以解决脏读，不可重复读，幻读等事务隔离问题，但不能解决更新丢失问题</li>
<li>InnoDB存储引擎使用MVCC用于提高读写的并发性能</li>
<li>在很多情况下避免了加锁操作。MVCC通过undo log来构建数据的历史版本，通过视图来定义数据版本的可见性。并由此构建数据库在某一个时间点的全库快照（一致性视图），来实现一致性非锁定读，保障事务的隔离性和一致性。</li>
</ul>
<hr>
<h2><span id="mvcc-实现的原理">MVCC 实现的原理？</span></h2>
<ul>
<li>依靠记录中的3个隐含字段、undo log日志（回滚日志 ）、Read View来实现的</li>
</ul>
<p>隐含字段</p>
<ul>
<li>DB_TRX_ID:记录操作该数据事务的事务id</li>
<li>DB_ROLL_PTR：指向上一个版本数据在undo log里的位置指针</li>
<li>DB_ROW_ID：隐藏ID，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引</li>
</ul>
<p>undo log日志</p>
<p>insert undo log：在进行插入操作事务时产生、在事务回滚时需要、在提交事务后可以被立即丢掉<br>
update undo log：进行update、delete时产生的undo log、不仅在回滚事务时需要、在快照读时也需要。所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除（purge类似jvm中的gc垃圾回收器）</p>
<p>Read View(读视图)</p>
<p>Read View读视图就是用来记录发生快照读那一刻所有的记录，当你下次就算有执行新的事务记录改变了，read view没变，读出来的数据依然是不变的。<br>
而隔离级别中的RR（可重复读）、和RC（提交读）不同就是差在快照读时。前者创建一个快照和Read View，并且下次快照读时使用的还是同一个Read View，所以其他事务修改数据对他是不可见的、解决了不可重复读问题。后者则是每次快照读时都会产生新的快照和Read View所以就会产生不可重复读问题</p>
<hr>
<h2><span id="mysql中都有哪些触发器">MySQL中都有哪些触发器？</span></h2>
<ul>
<li>Before Insert、After Insert</li>
<li>Before Update、After Update</li>
<li>Before Delete、After Delete</li>
</ul>
<hr>
<h2><span id="什么是mysql数据库缓存">什么是MySQL数据库缓存？</span></h2>
<ul>
<li>开启Mysql的查询缓存后，当执行之前执行过的SQL语句时，服务器会直接从缓存中读取结果</li>
<li>缓存中的数据被修改后将会失效，因此频繁修改不使用开启查询缓存</li>
</ul>
<hr>
<h2><span id="如何查询缓存相关的配置">如何查询缓存相关的配置？</span></h2>
<p>查看当前数据库是否支持查询缓存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;have_query_cache&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看当前MySQL是否开启查询缓存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_type&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看查询缓存的占用大小</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_size&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看查询缓存的状态变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="缓存数据失效时机">缓存数据失效时机？</span></h2>
<p>1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须完全一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item; SQL2 : <span class="keyword">Select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item;</span><br></pre></td></tr></table></figure>
<p>2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() ,uuid() , user() , database() 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> updatetime <span class="operator">&lt;</span> now() limit <span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>(); </span><br><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
<p>3） 不使用任何表查询语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>4） 查询 mysql， information_schema或 performance_schema 数据库中的表时，不会走查询缓存。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.engines;</span><br></pre></td></tr></table></figure>
<p>5） 在存储的函数，触发器或事件的主体内执行的查询。<br>
6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用 MERGE 映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE，TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。</p>
<hr>
<h2><span id="mysql数据类型优化">MySQL数据类型优化?</span></h2>
<ul>
<li>尽量用小范围的数据类型（能存储且范围最小）</li>
<li>尽量用整型（简单的数据类型需要更少的CPU周期，相比于整形字符操作需考虑校对规则）</li>
<li>尽量避免NULL（指定列为NOT NULL）</li>
</ul>
<hr>
<h2><span id="实践中如何优化mysql">实践中如何优化MySQL？</span></h2>
<ul>
<li>优化SQL语句及索引</li>
<li>优化数据库表结构</li>
<li>优化系统配置</li>
<li>优化硬件</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/post/SQL%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<hr>
<h2><span id>{}</span></h2>
<h2><span id="特殊窗口函数">特殊窗口函数</span></h2>
<p><strong>用户在某天刷题后第二天还会再来刷题的平均概率</strong></p>
<p>示例：question_practice_detail</p>
<table>
<thead>
<tr>
<th>id</th>
<th>device_id</th>
<th>date</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2138</td>
<td>2021-05-03</td>
</tr>
<tr>
<td>2</td>
<td>3214</td>
<td>2021-05-09</td>
</tr>
<tr>
<td>3</td>
<td>3214</td>
<td>2021-06-15</td>
</tr>
<tr>
<td>4</td>
<td>6543</td>
<td>2021-08-13</td>
</tr>
<tr>
<td>5</td>
<td>2315</td>
<td>2021-08-13</td>
</tr>
<tr>
<td>6</td>
<td>2315</td>
<td>2021-08-14</td>
</tr>
<tr>
<td>7</td>
<td>2315</td>
<td>2021-08-15</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用外连接（笛卡尔积）查询添加列时，会重复添加不需要的数据，连接后还要去重</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> a.device_id,a.date,b.date)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> a.device_id,a.date) avg_ret</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	question_practice_detail a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">	question_practice_detail b </span><br><span class="line">	<span class="keyword">ON</span> DATE_ADD(a.date,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>) <span class="operator">=</span> b.date</span><br><span class="line">	<span class="keyword">AND</span> a.device_id <span class="operator">=</span> b.device_id</span><br><span class="line">	</span><br><span class="line"><span class="comment">-- lead函数添加列不会重复添加不需要的数据，可以在使用前去重</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">AVG</span>(IF(DATE_ADD(<span class="type">date</span>,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>) <span class="operator">=</span> ranking,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> device_id,<span class="type">date</span>,</span><br><span class="line">		<span class="built_in">LEAD</span>(<span class="type">date</span>,<span class="number">1</span>) <span class="keyword">OVER</span>(					<span class="comment">-- 将第一天后的刷题日期加到新列上</span></span><br><span class="line">			<span class="keyword">PARTITION</span> <span class="keyword">BY</span> device_id</span><br><span class="line">			<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span></span><br><span class="line">		)ranking</span><br><span class="line">	<span class="keyword">FROM</span>(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> device_id,<span class="type">date</span>		<span class="comment">-- 每个用户id的第一天刷题日期</span></span><br><span class="line">		<span class="keyword">FROM</span> question_practice_detail)b</span><br><span class="line">)a</span><br></pre></td></tr></table></figure>
<h2><span id="聚合函数作为窗口函数">聚合函数作为窗口函数</span></h2>
<p><strong>请输出自从有用户作答记录以来，每月的试卷作答记录中月活用户数、新增用户数、截止当月的单月最大新增用户数、截止当月的累积用户数。结果按月份升序输出。</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-20 10:01:01</td>
<td>2020-01-20 10:10:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2020-02-01 12:11:01</td>
<td>2020-02-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 19:01:01</td>
<td>2020-03-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:31:01</td>
<td>68</td>
</tr>
<tr>
<td>11</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1001</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody>
</table>
<ul>
<li>每个用户的首次登录日期</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MIN</span>(start_time)<span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid) <span class="keyword">AS</span> new_user_day <span class="comment">-- 第一天登录		不改变列长，为每个用户找到最早刷题日期</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标记新用户登录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">	IF(<span class="built_in">MIN</span>(start_time) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid)<span class="operator">=</span> start_time,<span class="number">1</span>,<span class="number">0</span>) add_uv</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	DATE_FORMAT(start_time,<span class="string">&#x27;%Y%m&#x27;</span>) start_month,</span><br><span class="line">	<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> uid),</span><br><span class="line">	<span class="built_in">SUM</span>(add_uv) month_add_uv,						<span class="comment">-- 每月新增用户</span></span><br><span class="line">	<span class="built_in">MAX</span>(<span class="built_in">SUM</span>(add_uv)) <span class="keyword">OVER</span>(							<span class="comment">-- 截止当月的单月最大新增用户数</span></span><br><span class="line">		<span class="keyword">ORDER</span> <span class="keyword">BY</span> DATE_FORMAT(start_time,<span class="string">&#x27;%Y%m&#x27;</span>)</span><br><span class="line">	)max_month_add_uv,</span><br><span class="line">	<span class="built_in">SUM</span>(<span class="built_in">SUM</span>(add_uv)) <span class="keyword">OVER</span>(							<span class="comment">-- 截止当月的累积用户数</span></span><br><span class="line">		<span class="keyword">ORDER</span> <span class="keyword">BY</span> DATE_FORMAT(start_time,<span class="string">&#x27;%Y%m&#x27;</span>)</span><br><span class="line">	)</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">        IF(<span class="built_in">MIN</span>(start_time) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid)<span class="operator">=</span> start_time,<span class="number">1</span>,<span class="number">0</span>) add_uv</span><br><span class="line">    <span class="keyword">FROM</span> exam_record</span><br><span class="line">)a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> start_month</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">By</span> start_month</span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/fe24c93008b84e9592b35faa15755e48?tpId=268&amp;tqId=2285342&amp;ru=%2Fpractice%2F0226c7b2541c41e59c3b8aec588b09ff&amp;qru=%2Fta%2Fsql-factory-interview%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">每篇文章同一时刻最大在看人数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><a href="https://www.nowcoder.com/practice/aef5adcef574468c82659e8911bb297f?tpId=268&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">连续签到领金币_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span>,</span><br><span class="line">	IF(DATEDIFF(<span class="type">DATE</span>(<span class="built_in">LEAD</span>(in_time,<span class="number">1</span>,<span class="keyword">NULL</span>) <span class="keyword">OVER</span>(</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid</span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> in_time</span><br><span class="line">       )),<span class="type">DATE</span>(in_time))<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> sign_in <span class="operator">=</span> <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)b</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	tb_user_log</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	DATE_FORMAT(in_time,<span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;202107&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;202110&#x27;</span></span><br><span class="line">	<span class="keyword">AND</span> artical_id <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">AND</span> sign_in</span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">		<span class="operator">*</span>,</span><br><span class="line">		<span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(</span><br><span class="line">               <span class="keyword">PARTITION</span> <span class="keyword">BY</span> dt_tmp,uid  <span class="comment">-- 没写uid</span></span><br><span class="line">               <span class="keyword">ORDER</span> <span class="keyword">BY</span> dt</span><br><span class="line">           )ranking</span><br><span class="line">	<span class="keyword">FROM</span>(</span><br><span class="line">           <span class="keyword">SELECT</span></span><br><span class="line">           <span class="keyword">DISTINCT</span> </span><br><span class="line">           uid,</span><br><span class="line">           <span class="type">DATE</span>(in_time)dt,</span><br><span class="line">           <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(</span><br><span class="line">               <span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid</span><br><span class="line">               <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">DATE</span>(in_time)</span><br><span class="line">           )rn,</span><br><span class="line">           <span class="type">DATE</span>(in_time)<span class="operator">-</span>(	<span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">DATE</span>(in_time))) dt_tmp</span><br><span class="line">           <span class="keyword">FROM</span></span><br><span class="line">           tb_user_log</span><br><span class="line">           <span class="keyword">WHERE</span></span><br><span class="line">           <span class="type">DATE</span>(in_time) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-07-07&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-10-31&#x27;</span></span><br><span class="line">           <span class="keyword">AND</span> artical_id <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">           <span class="keyword">AND</span> sign_in <span class="operator">=</span><span class="number">1</span></span><br><span class="line">       )a</span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/65de67f666414c0e8f9a34c08d4a8ba6?tpId=268&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">某店铺的各商品毛利率及店铺整体毛利率_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	product_id1 product_id,</span><br><span class="line">	CONCAT(profit_rate,<span class="string">&#x27;%&#x27;</span>)profit_rate</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		<span class="built_in">COALESCE</span>(product_id,<span class="string">&#x27;店铺汇总&#x27;</span>) product_id1,</span><br><span class="line">		ROUND((<span class="number">1</span><span class="operator">-</span><span class="built_in">SUM</span>(in_price<span class="operator">*</span>cnt)<span class="operator">/</span><span class="built_in">SUM</span>(price<span class="operator">*</span>cnt))<span class="operator">*</span><span class="number">100</span>,<span class="number">1</span>)profit_rate</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		tb_order_detail <span class="keyword">JOIN</span> tb_product_info <span class="keyword">USING</span>(product_id)</span><br><span class="line">		<span class="keyword">JOIN</span> tb_order_overall <span class="keyword">USING</span>(order_id)</span><br><span class="line">	<span class="keyword">WHERE</span> shop_id <span class="operator">=</span> <span class="number">901</span></span><br><span class="line">		<span class="keyword">AND</span> DATE_FORMAT(event_time,<span class="string">&#x27;%Y%m&#x27;</span>) <span class="operator">&gt;=</span> <span class="string">&#x27;202110&#x27;</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span></span><br><span class="line">	<span class="keyword">HAVING</span> profit_rate <span class="operator">&gt;</span> <span class="number">24.9</span> <span class="keyword">OR</span> product_id <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="comment">-- 百分比不能直接字符判断，还要判断产品ID空值</span></span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> product_id</span><br><span class="line">)a</span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/9c175775e7ad4d9da41602d588c5caf3?tpId=268&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">零食类商品中复购率top3高的商品_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	product_id,</span><br><span class="line">	ROUND(<span class="built_in">SUM</span>(repurchase)<span class="operator">/</span><span class="built_in">COUNT</span>(uid),<span class="number">3</span>)repurchase_rate</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		product_id,</span><br><span class="line">		uid,</span><br><span class="line">		IF(<span class="built_in">COUNT</span>(event_time)<span class="operator">&gt;=</span><span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)repurchase     <span class="comment">--没有分组</span></span><br><span class="line">	<span class="keyword">FROM</span>(</span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			product_id,uid,event_time,</span><br><span class="line">			DATEDIFF(<span class="built_in">MAX</span>(event_time) <span class="keyword">OVER</span>(			<span class="comment">-- 当天为最大日期</span></span><br><span class="line">			),event_time) recently</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			tb_order_detail <span class="keyword">JOIN</span> tb_order_overall <span class="keyword">USING</span>(order_id)</span><br><span class="line">			<span class="keyword">JOIN</span> tb_product_info <span class="keyword">USING</span>(product_id)</span><br><span class="line">		<span class="keyword">WHERE</span> </span><br><span class="line">			tag <span class="operator">=</span> <span class="string">&#x27;零食&#x27;</span></span><br><span class="line">	)a</span><br><span class="line">	<span class="keyword">WHERE</span> recently <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">89</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> uid,product_id</span><br><span class="line">)b</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> repurchase_rate <span class="keyword">DESC</span>,product_id</span><br><span class="line">LIMIT <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/d15ee0798e884f829ae8bd27e10f0d64?tpId=268&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">10月的新户客单价和获客成本_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    ROUND(<span class="built_in">AVG</span>(total_amount), <span class="number">1</span>) avg_amount,</span><br><span class="line">    ROUND(<span class="built_in">AVG</span>(raw_amount <span class="operator">-</span> total_amount), <span class="number">1</span>) avg_cost</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        uid,total_amount,raw_amount</span><br><span class="line">    <span class="keyword">FROM</span>(</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            <span class="operator">*</span>,</span><br><span class="line">            IF(event_time <span class="operator">=</span> <span class="built_in">MIN</span>(event_time) <span class="keyword">OVER</span>(</span><br><span class="line">                    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid</span><br><span class="line">            ),<span class="number">1</span>,<span class="number">0</span>)new_user</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            tb_order_overall <span class="keyword">JOIN</span>(</span><br><span class="line">                    <span class="keyword">SELECT</span> order_id,<span class="built_in">SUM</span>(price<span class="operator">*</span>cnt) raw_amount</span><br><span class="line">                    <span class="keyword">FROM</span> tb_order_detail</span><br><span class="line">                    <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_id</span><br><span class="line">            )a <span class="keyword">USING</span>(order_id)</span><br><span class="line">    )b</span><br><span class="line">    <span class="keyword">WHERE</span> new_user <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> DATE_FORMAT(event_time,<span class="string">&#x27;%Y%m&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;202110&#x27;</span>   </span><br><span class="line">) c</span><br><span class="line"><span class="comment">-- 新用户首单可能不在10月份，因此要先选出新用户首单，再选出10月的订单</span></span><br><span class="line"><span class="comment">-- 否则会过滤掉不在10月份的信用户首单，所有新用户首单都在10月，不符合实践情况</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/e7837f66e8fb4b45b694d24ea61f0dc9?tpId=268&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">店铺901国庆期间的7日动销率和滞销率_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	dt,ROUND(<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> a.product_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> b.product_id),<span class="number">3</span>)sale_rate,</span><br><span class="line">	<span class="number">1</span><span class="operator">-</span>(ROUND(<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> a.product_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> b.product_id),<span class="number">3</span>))unsale_rate</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		dt,product_id</span><br><span class="line">	<span class="keyword">FROM</span>(</span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			<span class="keyword">DISTINCT</span> <span class="type">DATE</span>(event_time) dt</span><br><span class="line">		<span class="keyword">FROM</span> tb_order_overall</span><br><span class="line">		<span class="keyword">WHERE</span> <span class="type">DATE</span>(event_time) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-10-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-10-03&#x27;</span></span><br><span class="line">	)t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tb_order_overall t2 <span class="keyword">ON</span> DATEDIFF(t1.dt,t2.event_time) <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">6</span></span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">			<span class="keyword">SELECT</span> product_id,order_id</span><br><span class="line">			<span class="keyword">FROM</span> tb_product_info <span class="keyword">JOIN</span> tb_order_detail <span class="keyword">USING</span>(product_id) <span class="keyword">WHERE</span> shop_id <span class="operator">=</span> <span class="number">901</span></span><br><span class="line">		)b <span class="keyword">USING</span>(order_id)	</span><br><span class="line">)a	<span class="keyword">JOIN</span> tb_product_info b <span class="keyword">ON</span> <span class="type">DATE</span>(release_time) <span class="operator">&lt;=</span> dt <span class="keyword">AND</span> shop_id <span class="operator">=</span> <span class="number">901</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dt</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> dt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/63ac3be0e4b44cce8dd2619d2236c3bf?tpId=268&amp;tqId=2285906&amp;ru=%2Fpractice%2F715dd44c994f45cb871afa98f1b77538&amp;qru=%2Fta%2Fsql-factory-interview%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">某宝店铺连续2天及以上购物的用户及其对应的天数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id,<span class="built_in">MAX</span>(ranking)days_count</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> user_id,sales_date,<span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sales_date)ranking</span><br><span class="line">	<span class="keyword">FROM</span> sales_tb</span><br><span class="line">)a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(ranking) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/practice/d69677e41f9a4bf3b3ed7a42573e9490?tpId=268&amp;tqId=2286245&amp;ru=%2Fpractice%2F0cab547df4f0430b93042128f445d899&amp;qru=%2Fta%2Fsql-factory-interview%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%E7%AF%87%26topicId%3D268">牛客直播各科目同时在线人数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	course_id,</span><br><span class="line">	course_name,</span><br><span class="line">	<span class="built_in">MAX</span>(sum_diff)max_num</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		<span class="operator">*</span>,</span><br><span class="line">		<span class="built_in">SUM</span>(diff) <span class="keyword">OVER</span>(</span><br><span class="line">			<span class="keyword">PARTITION</span> <span class="keyword">BY</span> course_id</span><br><span class="line">			<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span>,user_id </span><br><span class="line">		)sum_diff</span><br><span class="line">	<span class="keyword">FROM</span>(</span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			course_id,user_id,in_datetime <span class="type">time</span>,<span class="string">&#x27;1&#x27;</span>diff</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			attend_tb</span><br><span class="line">		<span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			course_id,user_id,out_datetime <span class="type">time</span>,<span class="string">&#x27;-1&#x27;</span>diff</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			attend_tb</span><br><span class="line">	)a</span><br><span class="line">)b <span class="keyword">JOIN</span> course_tb <span class="keyword">USING</span>(course_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> course_id,course_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> course_id</span><br></pre></td></tr></table></figure>
<p>168 169</p>
]]></content>
  </entry>
  <entry>
    <title>Markdown 入门使用</title>
    <url>/post/Markdown%20%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2><span id="介绍">介绍</span></h2>
<p>Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。</p>
<span id="more"></span>
<h2><span id="标题">标题</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h1><span id="标题1">标题1</span></h1>
<h2><span id="标题2">标题2</span></h2>
<h3><span id="标题3">标题3</span></h3>
<h4><span id="标题4">标题4</span></h4>
<h5><span id="标题5">标题5</span></h5>
<h6><span id="标题6">标题6</span></h6>
</blockquote>
<h2><span id="列表">列表</span></h2>
<h3><span id="有序列表">有序列表</span></h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">把大象放进冰箱：</span><br><span class="line"><span class="bullet">1.</span> 打开冰箱</span><br><span class="line"><span class="bullet">2.</span> 把大象放进冰箱</span><br><span class="line"><span class="bullet">3.</span> 关上冰箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把大象放进冰箱:</p>
<ol>
<li>打开冰箱</li>
<li>把大象放进冰箱</li>
<li>关上冰箱</li>
</ol>
</blockquote>
<h3><span id="无序列表">无序列表</span></h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">无序列表：</span><br><span class="line"><span class="bullet">-</span> 所爱扥就</span><br><span class="line"><span class="bullet">-</span> 撒欧丹发腮</span><br><span class="line"><span class="bullet">-</span> 哦啊赛季反扒</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无序列表：</p>
<ul>
<li>所爱扥就</li>
<li>撒欧丹发腮</li>
<li>哦啊赛季反扒</li>
</ul>
</blockquote>
<h2><span id="任务列表">任务列表</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">明天要做的事：	</span><br><span class="line"><span class="bullet">-</span> [ ] 吃饭	//每个字符之间由空格隔开	</span><br><span class="line"><span class="bullet">-</span> [ ] 睡觉</span><br><span class="line"><span class="bullet">-</span> [ ] 打豆豆</span><br></pre></td></tr></table></figure>
<blockquote>
<p>明天要做的事：</p>
<ul>
<li>[x] 吃饭</li>
<li>[x] 睡觉</li>
<li>[ ] 打豆豆</li>
</ul>
</blockquote>
<h2><span id="代码块">代码块</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">``` c      //选择语言</span></span><br><span class="line"><span class="code">int main()&#123;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">&gt;&#125;</span><br><span class="line">```markdown</span><br><span class="line"></span><br><span class="line">## 数学公式：</span><br><span class="line"></span><br><span class="line">``` markdown</span><br><span class="line">$$</span><br><span class="line">\frac&#123;\partial f&#125;&#123;\partial x&#125; = <span class="number">2</span>\<span class="built_in">sqrt</span>&#123;a&#125;x</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>$$<br>
\frac{\partial f}{\partial x} = 2\sqrt{a}x<br>
$$</p>
</blockquote>
<h2><span id="表格">表格</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|姓名|年龄|成绩|</span><br><span class="line">|:--|--:|:-----:| </span><br><span class="line"><span class="code">			//冒号靠左为左对齐，靠右为右对齐，两边都有冒号为居中对齐</span></span><br><span class="line"><span class="code">|张三|18|90|</span></span><br><span class="line"><span class="code">|李四|20|89|</span></span><br></pre></td></tr></table></figure>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:right">年龄</th>
<th style="text-align:center">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">张三</td>
<td style="text-align:right">18</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:left">李四</td>
<td style="text-align:right">20</td>
<td style="text-align:center">89</td>
</tr>
</tbody>
</table>
</blockquote>
<h2><span id="脚注">脚注</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一条注释[^注释]</span><br><span class="line">[<span class="symbol">^注释</span>]:<span class="link">这是注释的注释。</span></span><br><span class="line"> ---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一条注释<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<hr>
</blockquote>
<h2><span id="超链接">超链接</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span>)</span><br><span class="line">[<span class="string">百度</span>][<span class="symbol">id</span>]</span><br><span class="line">[<span class="symbol">id</span>]:<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span></span><br><span class="line"></span><br><span class="line">请参考[<span class="string">标题1</span>](<span class="link">#标题</span>)</span><br><span class="line"></span><br><span class="line">URL：</span><br><span class="line">http://www.baidu.com</span><br><span class="line"></span><br><span class="line">![<span class="string">百度</span>](<span class="link">https://imgse.com/i/z2p2JH&quot;百度搜索&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.baidu.com" title="一个搜索引擎">百度</a><br>
<a href="http://www.baidu.com" title="一个搜索引擎">百度</a></p>
<p>请参考<a href="#%E6%A0%87%E9%A2%98">标题1</a></p>
<p>URL：<br>
<a href="http://www.baidu.com">http://www.baidu.com</a></p>
<p><img src="https://pic.imgdb.cn/item/63914551b1fccdcd36559921.png%22%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%22" alt="百度"></p>
</blockquote>
<h2><span id="字体变化">字体变化</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="code">`行内代码printf()`</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">:smile:</span><br><span class="line">$\theta=x^2$</span><br><span class="line">H~2~O,x^2^</span><br><span class="line">==这是一段高亮文字==</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>斜体</em><br>
<strong>加粗</strong><br>
<code>行内代码printf()</code><br>
<u>下划线</u><br>
😄<br>
$\theta=x^2$<br>
H<sub>2</sub>O,x<sup>2</sup><br>
==这是一段高亮文字==</p>
</blockquote>
<h2><span id="参考视频">参考视频</span></h2>
<iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这是注释的注释。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>SSM</title>
    <url>/post/SSM/</url>
    <content><![CDATA[<h2><span id="环境搭建">环境搭建</span></h2>
<h3><span id="导入依赖">导入依赖</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以统一的定义依赖的版本号，方便修改，避免版本号不一致;子标签名称自定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-version</span>&gt;</span>5.3.20<span class="tag">&lt;/<span class="name">spring-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">mybatis-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="springmvc">SpringMVC</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="servlet">Servlet</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--servlet原生技术的相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="spring">Spring</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring框架基础环境依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="comment">&lt;!--与spring-webmvc重复--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aop程序所需的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring框架和junit结合使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--junit单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="mybatis-数据库">Mybatis、数据库</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--spring和mybatis结合使用的依赖包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis框架的环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- DBUtils工具类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql数据库的驱动包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数据库连接池，阿里巴巴的德鲁伊连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 分页插件jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="其他">其他</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- lombok，省略实体类中的相关的方法定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志相关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboss-vfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.16.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--json数据转换包，将其他数据类型，转换为String字符串(json字符串)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      src/main/java目录下默认情况下只对.java文件进行编译。</span></span><br><span class="line"><span class="comment">      该配置可以添加其它类型的文件也进行编译。</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="配置文件">配置文件</span></h3>
<h4><span id="springapplicationxml">SpringApplication.xml</span></h4>
<ol>
<li>IOC注解扫描</li>
<li>AOP注解驱动</li>
<li>mybatis.xml
<ol>
<li>导入外部资源文件</li>
<li>数据库连接池及连接配置</li>
<li>日志配置</li>
<li>SqlSessionFactory</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--IOC和DI的注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.service&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--AOP的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--从mybatis中转移过来的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入外部的资源文件  classpath: 表示路径，加入一个文件名即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提供一个数据源,连接池负责处理登录数据库的信息，可以把连接池对象交给具体操作数据库的那个工具类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configuration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.ibatis.session.Configuration&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--依然需要mybatis的SqlSessionFactory工厂的。负责获取连接对象,</span></span><br><span class="line"><span class="comment">    需要被MapperScannerConfigurer加载</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用一个数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置mybatis运行的日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configuration&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;configuration&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实体类类名简化,如果是多个包可以使用数组类型，如果是一个包可以使用字符串类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.pojo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--若mapper.xml配置在mapper文件夹的xml文件夹下，则需要声明以下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/bjpowernode/mapper/xml/*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取mybatis框架的配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--统一配置mapper文件所在的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--读取上方配置好的工程对象,引用的是一个对象但是使用的是value,左边的变量是String类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--=======================使用AOP完成事务管理控制=========================--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用spring框架提供好类完成事务管理，此种写法称之为声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--针对事务管理的类DataSourceTransactionManager进行进一步的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--针对service中的方法进行细节化的事务管理配置</span></span><br><span class="line"><span class="comment">                区分CRUD</span></span><br><span class="line"><span class="comment">                写法支持通配模式；可以自己定义service中的方法哪些要添加事务管理，哪些不需要添加</span></span><br><span class="line"><span class="comment">                name:service中的方法名，add*表示以add开头的任意名称</span></span><br><span class="line"><span class="comment">                rollback-for:表示name中的方法要添加事务管理，如果发生异常需要回滚，爆出一个异常Exception</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;edit*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;del*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;abc*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transFer&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果是查询的方法，是不需要事务管理的</span></span><br><span class="line"><span class="comment">            read-only:表示事务只读，不添加事务管理</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通过AOP的方式完成最终的绑定，最终的效果--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--service方法的位置,使用切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="springmvc-configxml">SpringMVC-config.xml</span></h4>
<ol>
<li>注解扫描</li>
<li>注解驱动</li>
<li>请求静态资源</li>
<li>视图解析器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.web&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注解驱动:框架提供的一系列的简化写法,推荐不论用或不用，都添加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之前的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之后的扩展名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="webxml">web.xml</span></h4>
<ol>
<li>servlet添加SpringMVC配置</li>
<li>listener添加Spring配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置springMVC的核心控制器，可以让框架能够接收请求--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--读取springMVC的核心配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--添加一个监听器，目的是为了读取spring配置文件(spring中自动读取mybatis配置文件)--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--加载spring配置文件，自动的被上面的监听器读取--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springApplication.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--字符编码过滤器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="crud">CRUD</span></h2>
<p><a href="https://github.com/biyixia/java-code.git">https://github.com/biyixia/java-code.git</a></p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/post/Spring%20Boot/</url>
    <content><![CDATA[<h2><span id="说明">说明</span></h2>
<p>​	springboot作为引擎启动程序，不是一个新的框架，可以将ssm以更简洁的方式完成应用；<br>
​	之前的ssm程序需要模块化，一堆配置，服务器等等，现在只需要使用springboot简化配置。<br>
​</p>
<p>使用springboot的前提:<br>
1.需要搞定Spring Framework<br>
2.更多的是处理web应用，需要搞定springMVC<br>
3.程序可能需要数据库的支持，需要搞定JDBC体系(mybatis)<br>
4.web应用需要服务器的支持，需要搞定服务器软件(tomcat)<br>
springboot的特点:<br>
1.可以快速的创建spring应用，快速启动(启动器)<br>
2.可以快速加载第三方配置，简化程序的配置，以最少的内容快速启动</p>
<p>注意：之前的配置现在依然是需要的，只不过之前是需要程序员自己定义，现在是将这些配置<br>
全部交给springboot内部完成。</p>
<h2><span id="创建springboot工程">创建springboot工程</span></h2>
<ol>
<li>Spring官方：<a href="https://start.spring.io">https://start.spring.io</a></li>
<li>阿里云：<a href="https://start.aliyun.com">https://start.aliyun.com</a></li>
<li>Spring Boot：<a href="https://start.springboot.io">https://start.springboot.io</a></li>
</ol>
<p>注意:程序需要编译，打包等操作，可能会出现打包时有异常（跳过测试检查）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="工程结构">工程结构</span></h2>
<p>​	static:springboot中专门存放页面的路径(webapp目录),名称是不能改变的。<br>
​	application.properties：名称固定的配置文件,键值对模式的配置文件，<br>
​						    之前的所有配置都可以在这个文件中，<br>
​							使用的全部都是默认值。<br>
​							还有一种配置文件是.yml文件。<br>
​	注解扫描问题:<br>
​		1.在启动器的类之上添加注解扫描(不推荐使用)<br>
​				@ComponentScan(basePackages = {“com.bjpowernode.controller”,“com.bjpowernode.service”})<br>
​		2.启动器所在的包，所有的注解都可以被自动识别，可以将所有的程序放在此位置，<br>
​				注解就会被自动的识别。<br>
​	注意：手动将程序中的所有内容打包时，可能会提示有问题:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="视图层使用jsp">视图层使用jsp</span></h2>
<p>官方不推荐</p>
<p><strong>视图模块添加处理jsp页面的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>配置jsp文件编译输出的路径</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jsp<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建webapp文件夹为页面的根目录(可以放入jsp了),允许添加视图解析器</strong></p>
<pre><code>    静态资源(图片,js,css.....)放在/resources/static
</code></pre>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/post/SpringMVC/</url>
    <content><![CDATA[<h2><span id="导入依赖">导入依赖</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="配置文件">配置文件</span></h2>
<h3><span id="springmvc-configxml">SpringMVC-config.xml</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.web&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之前的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之后的扩展名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注解驱动:框架提供的一系列的简化写法,推荐不论用或不用，都添加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="webxml">web.xml</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置springMVC的核心控制器，可以让框架能够接收请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--讀取SpringMVC核心配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:SpringMVC-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--控制Servlet实例化時間--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="匹配优先级">匹配优先级</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/helloWorld&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestServlet运行了................&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/helloWorld&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorldController运行了................&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述Servlet与Controller对应的请求都是“/helloWorld”，但是由于@WebServlet注解相当于直接在web.xml中配置</p>
<p>当有一个“/helloWorld”请求时，先访问web.xml，其中的@WebServlet(“/helloWorld”)优先级高于 “/”，因此不会向下执行Controller中的hello01，而执行TestServlet中的doGet方法。</p>
<h2><span id="web-inf">WEB-INF</span></h2>
<ol>
<li>WEB-INF目录可以称之为是安全文件夹，此目录可以保护和限制前端页面；</li>
<li>此目录下的所有子目录以及所有的资源，不允许通过路径拼接访问，也不允许响应重定向跳转(限制)，只允许请求转发的方式跳转此页面(保护)。</li>
<li>推荐：后面可以将前端页面(不包含静态资源)，放入此文件夹。</li>
</ol>
<h2><span id="常用注解">常用注解</span></h2>
<h3><span id="controller">@Controller</span></h3>
<ol>
<li>@Component注解的别名</li>
<li>在类（控制器）上使用，将此类的实例交给spring容器管理</li>
</ol>
<h3><span id="requestmapping">@RequestMapping</span></h3>
<ol>
<li>在类和方法使用，确定访问路径和类及类中方法的映射关系</li>
<li>在类上使用时，value值作为一级路径(模块)存在，方便团队分模块开发</li>
<li>在方法上使用时，value值作为二级路径，表示模块中的不同功能</li>
<li>路径可以是uri变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址</li>
</ol>
<p><strong>常用属性</strong></p>
<ol>
<li>value***：一级或二级路径</li>
<li>method : 限定请求方式，只能使用指定的请求方式，没有该属性则表示不限制请求方式</li>
<li>params 指定请求的时候必须携带指定的参数(或者参数及其对应值)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello.html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能使用post方式来访问</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;hello2.html&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;hello2.html&quot;)</span> <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>;</span><br><span class="line">        <span class="comment">//使用视图解析器后可简写成 return &quot;success.jsp&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;hello3.html&quot;, params = &#123;</span></span><br><span class="line"><span class="meta">            &quot;username&quot;, // 必须携带username参数，不限制值</span></span><br><span class="line"><span class="meta">            &quot;type=1&quot;    // 必须携带type参数，值必须是1</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="requestparam">@RequestParam</span></h3>
<ol>
<li>@RequestParam:框架帮助程序接收请求参数（将参数封装成map集合）</li>
<li>属性“defaultValue”设置默认值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello06</span><span class="params">(<span class="meta">@RequestParam(defaultValue =&quot;女1&quot;)</span> String sex)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(sex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="cookievalue了解">@CookieValue(了解)</span></h3>
<p>获取指定cookie的值</p>
<h2><span id="springmvc的请求传统请求">SpringMVC的请求（传统请求）</span></h2>
<h3><span id="接收请求参数重点掌握">接收请求参数(重点掌握)</span></h3>
<h4><span id="简单类型">简单类型</span></h4>
<ol>
<li>8种基本数据类型(包括包装类型)和String类型</li>
<li>方法中的参数名和请求参数的名称保持一致</li>
<li>如果使用的是基本数据类型，必须有数据，否则因为默认值的原因，程序会出现500的异常</li>
<li>如果是String对象字符串，可以不赋值，使用null来表示</li>
<li>推荐写法: 将基本数据类型改为包装类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello02</span><span class="params">(Integer id,String name,Double score)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line">	<span class="comment">//http://localhost:8080/request02?id=123&amp;&amp;name=biyixia&amp;&amp;score=100</span></span><br><span class="line">    System.out.println(id);<span class="comment">//123</span></span><br><span class="line">    System.out.println(name);<span class="comment">//biyixia</span></span><br><span class="line">    System.out.println(score);<span class="comment">//100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="对象类型pojo">对象类型pojo</span></h4>
<p>对象类型数据(自定义类型数据)， 直接在方法中声明需要封装的pojo，请求参数名称需要和类中的属性名一致！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello03</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(account);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="数组类型">数组类型</span></h4>
<ol>
<li>
<p>请求参数名和数组的名称一致</p>
</li>
<li>
<p>请求参数的格式：</p>
<ol>
<li>
<p>常规写法： <code>http://127.0.0.1/request04?ids=1&amp;ids=2&amp;ids=234</code></p>
</li>
<li>
<p>简化写法(如需使用，需要添加框架的注解驱动)：<code>http://127.0.0.1/request04?ids=1,2,3,4,5,100,50,20</code></p>
<blockquote>
<p>注解驱动：框架提供的一系列的简化写法</p>
<p><code>&lt;mvc:annotation-driven/&gt;</code></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello04</span><span class="params">(Integer[] ids)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(ids));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="集合类型">集合类型</span></h4>
<ol>
<li>请求任意数量任意类型任意名称的参数，需要添加@RequestParam注解帮助程序接收请求参数</li>
<li>太灵活了，使用频率不高</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello05</span><span class="params">(<span class="meta">@RequestParam</span> Map map)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="时间类型">时间类型</span></h4>
<ol>
<li>
<p>默认格式：2023/06/13 16:19:50</p>
</li>
<li>
<p>其他方式：需要添加注解，单独定义时间格式模板(如果使用了注解定义了时间格式模板，默认的/不让使用)</p>
<blockquote>
<p>2023-06-13 16:19:50、2023年06月13日 16:19:50</p>
</blockquote>
</li>
<li>
<p>说明:在今后的程序中，针对时间格式一个项目只会存在一种规则，一种时间格式就够了。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello07</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:ss:mm&quot;)</span> Date date)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="post请求中文过滤器会使用">post请求中文过滤器（会使用）</span></h3>
<ol>
<li>POST方式请求中文参数时会出现乱码的情况（由于进行了数据处理），因此需要使用过滤器统一字符编码</li>
<li>spring已经提供了一个过滤器CharacterEncodingFilter,我们只需要去web.xml中配置即可</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置字符编码过滤器--&gt;</span></span><br><span class="line">&lt;**filter**&gt;</span><br><span class="line">  &lt;**filter-name**&gt;CharacterEncodingFilter&lt;/**filter-name**&gt;</span><br><span class="line">  &lt;**filter-class**&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/**filter-class**&gt;</span><br><span class="line">  &lt;**init-param**&gt;</span><br><span class="line">    <span class="comment">&lt;!--指定post请求的编码--&gt;</span></span><br><span class="line">    &lt;**param-name**&gt;encoding&lt;/**param-name**&gt;</span><br><span class="line">    &lt;**param-value**&gt;utf-8&lt;/**param-value**&gt;</span><br><span class="line">  &lt;/**init-param**&gt;</span><br><span class="line">&lt;/**filter**&gt;</span><br><span class="line">&lt;**filter-mapping**&gt;</span><br><span class="line">  &lt;**filter-name**&gt;CharacterEncodingFilter&lt;/**filter-name**&gt;</span><br><span class="line">  &lt;**url-pattern**&gt;/*&lt;/**url-pattern**&gt;</span><br><span class="line">&lt;/**filter-mapping**&gt;  </span><br></pre></td></tr></table></figure>
<h3><span id="获得原生servletapi重要">获得原生ServletAPI(重要)</span></h3>
<h4><span id="在目标方法中添加参数">在目标方法中添加参数</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello09</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response,</span></span><br><span class="line"><span class="params">        HttpSession session</span></span><br><span class="line"><span class="params">                      )</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="通过注入的方式">通过注入的方式</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*<span class="comment">// 一般web的组件在进行注入时，required改为false，防止注入不成功时报错！*</span></span><br><span class="line">  <span class="meta">@Autowired(required = **false**)</span></span><br><span class="line">  **<span class="keyword">private</span>** HttpServletRequest request;</span><br><span class="line">  <span class="meta">@Autowired(required = **false**)</span></span><br><span class="line">  **<span class="keyword">private</span>** HttpServletResponse response;</span><br><span class="line">  <span class="meta">@Autowired(required = **false**)</span></span><br><span class="line">  **<span class="keyword">private</span>** HttpSession session;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;request10&quot;)</span></span><br><span class="line">  **<span class="keyword">public</span>** String <span class="title function_">hello10</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    **<span class="keyword">return</span>** <span class="string">&quot;success&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="请求静态资源处理会用">请求静态资源处理(会用)</span></h3>
<p>每个web服务器都实现了servlet-api和jsp-api,提供了两个servlet(DefaultServlet和JspServlet)</p>
<ol>
<li>
<p>修改dispatcherservlet的匹配规则（web.xml）</p>
<blockquote>
<p>将 / 修改为 *.do,这样的话,页面中所有的连接都需要改成 xx.do.这样的话我们的前端控制器就只处理以&quot;.do&quot;结尾的请求了.其他的请求交给服务器来处理</p>
</blockquote>
</li>
<li>
<p>通过springMVC框架自定义映射关系（spring-mvc.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--建立静态资源映射关系</span></span><br><span class="line"><span class="comment">  mapping:虚拟路径，可以自己定义，用于页面中的编写路径(推荐使用真实路径)</span></span><br><span class="line"><span class="comment">  location:项目中资源的路径，真实路径，必须是静态资源的真实路径</span></span><br><span class="line"><span class="comment">  cache-period：在客户端（浏览器）缓存的时间</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/static/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;#&#123;3600*24*10&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开启静态资源servlet支持(spring-mvc.xml)</p>
<p>任意的目录，任意的静态资源都可以任意使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明:在服务器接收请求时，优先使用框架处理请求,如果遇到静态资源参与时，框架无法处理，服务器就会将请求交给tomcat的DefaultServlet来处理。</p>
</li>
</ol>
<h3><span id="与">/* 与 /**</span></h3>
<table>
<thead>
<tr>
<th></th>
<th>/*</th>
<th>/**</th>
</tr>
</thead>
<tbody>
<tr>
<td>web.xml(url-pattern)</td>
<td>所有的子目录以及所有子目录中的所有资源</td>
<td>无意义</td>
</tr>
<tr>
<td>SpringMVC-config.xml</td>
<td>目录中的所有资源,不包含子目录</td>
<td>表示所有的资源(所有的子目录以及所有子目录中的所有资源)</td>
</tr>
</tbody>
</table>
<h2><span id="springmvc的响应">SpringMVC的响应</span></h2>
<p>分为全局刷新与局部刷新两种情况</p>
<h3><span id="全局刷新拼接路径">全局刷新（拼接路径）</span></h3>
<ol>
<li>请求：超链接，表单，地址栏</li>
<li>响应：请求转发，响应重定向</li>
<li>整个浏览器被新的数据覆盖,浏览器需要加载，渲染页面</li>
</ol>
<p>全局刷新情况下，可使用3种不同的返回值，分别为String、ModelAndView和void</p>
<h4><span id="string类型">String类型</span></h4>
<ol>
<li>
<p>默认使用请求转发跳转到一个页面，可以结合试图解析器</p>
<p><code>return &quot;success&quot;;</code></p>
</li>
<li>
<p>使用请求转发跳转到一个页面，不能结合视图解析器；固定单词forward:</p>
<p><code>return &quot;forward:/WEB-INF/jsp/success.jsp&quot;;</code></p>
</li>
<li>
<p>使用响应重定向的方式跳转到一个页面，不能结合视图解析器；固定单词redirect:</p>
<p><code>return &quot;redirect:/WEB-INF/jsp/success.jsp&quot;;</code></p>
</li>
</ol>
<h4><span id="modelandview类型">ModelAndView类型</span></h4>
<ol>
<li>
<p>自动生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">hello02</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放键值对护具,实际上就是request对象作用域</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>);</span><br><span class="line">    <span class="comment">//存放一个页面名称(结合视图解析器)</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自己创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">hello04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放键值对护具,实际上就是request对象作用域</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>);</span><br><span class="line">    <span class="comment">//存放一个页面名称(结合视图解析器)</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4><span id="void类型">void类型</span></h4>
<p>使用servlet原生对象处理响应，没有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello02</span><span class="params">(HttpServletRequest request，HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line">    <span class="comment">//请求转发</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    <span class="comment">//响应重定向</span></span><br><span class="line">    <span class="comment">//response.sendRedirect(&quot;&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="model和modelmap不推荐">Model和ModelMap（不推荐）</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello05</span><span class="params">(Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>);</span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;request06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello06</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>);</span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="局部刷新ajax请求">局部刷新（Ajax请求）</span></h3>
<ol>
<li>请求:jquery中的ajax函数发送任意的请求</li>
<li>响应:底层使用的是打印流返回结果，目前使用的是注解完成</li>
<li>在浏览器的内部，发起请求，获取数据，改变页面的部分内容。其余的页面无需加载和渲染，网络中的数据传输量少，给用户感觉好，通过Ajax实现</li>
</ol>
<p>可以使用任意类型的返回值，通过SpringMVC框架实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入jQuery--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/static/jquery-1.12.4.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 页面加载完成事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#sendBtn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&quot;/request_ajax_01&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#sendBtn2&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&quot;/request_ajax_02&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#sendBtn3&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&quot;request_ajax_03&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 发送json字符串时，必须使用post请求</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 内容的编码类型</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">contentType</span>:<span class="string">&quot;application/json;charset=utf-8&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// json字符串，键值必须使用双引号</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">data</span>:<span class="string">&#x27;&#123;&quot;aid&quot;:1001,&quot;name&quot;:&quot;admin&quot;,&quot;balance&quot;:500.0&#125;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// JSON.stringify可以将js对象转换为json字符串</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//data: JSON.stringify(&#123; aid: 1001, name: &quot;tom&quot;, balance: 500.0 &#125;),</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * jQuery会根据dataType对结果进行处理，</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * 如果后台设置了content-type为application/json，则此处可以不指定</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * 但最好是明确指定为json，这样即便后台不设置content-type，jQuery也会处理</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     */</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 打印对象，不能看出对象中包含哪些属性</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data);</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// JSON.stringify可以将js对象转换为json字符串，方便查看对象结构</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data) );</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data.<span class="property">success</span>);</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;原生的方式发送ajax请求&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;框架的方式发送ajax请求_@ResponseBody&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;框架的方式发送ajax请求_@RequestBody&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request_ajax_01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getRequestAjax01</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到了请求！！！！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回浏览器一个结果</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">    <span class="comment">//out.write(&quot;getRequestAjax01方法返回的结果&quot;);//返回一个字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="number">1000.5</span>);</span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(account);</span><br><span class="line">    out.write(json);<span class="comment">//返回的是一个对象(集合)</span></span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前提：若要使用RequestBody和ResponseBody必须导入jackson依赖</p>
<h4><span id="responsebody">@ResponseBody</span></h4>
<p>表示方法的返回值直接以Json格式写入Http response body中，而不是解析为跳转路径。</p>
<p>只处理局部刷新(完成打印流的输出，json数据的类型转换)</p>
<p>返回值类型没有任何限制了，可以是任意的返回值类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request_ajax_02&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">getRequestAjax02</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到了请求！！！！！！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1002</span>,<span class="string">&quot;abcd&quot;</span>,<span class="number">2000.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="requestbody了解">@RequestBody(了解)</span></h4>
<ol>
<li>用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；</li>
<li>必须用POST方式进行提交</li>
<li>在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;request_ajax_03&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Map <span class="title function_">getRequestAjax03</span><span class="params">(<span class="meta">@RequestBody</span> Account account)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到了请求！！！！！！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;请求参数:&quot;</span>+account);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>()&#123;&#123;</span><br><span class="line">        put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;新增成功!!!!!!!!&quot;</span>);</span><br><span class="line">        put(<span class="string">&quot;flag&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="restful风格请求">RestFul风格请求</span></h2>
<p>所有的rest风格请求必须建立在局部刷新的基础上</p>
<p>传统请求与RestFul请求中都含有请求名称、请求方式、请求参数，但两者唯一区分请求的标准不同</p>
<table>
<thead>
<tr>
<th>传统请求</th>
<th>RestFul请求</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以出现&quot;?&quot; “&amp;” 键值对 “/”</td>
<td>仅 “/”</td>
</tr>
<tr>
<td>主要通过请求名称唯一区分不同请求(请求方式辅助)</td>
<td>主要通过请求方式唯一区分不同请求(请求参数辅助)</td>
</tr>
</tbody>
</table>
<h3><span id="pathvariable">@PathVariable</span></h3>
<p>映射 URL 绑定的占位符，将 URL中{xxx}占位符参数绑定到控制器处理方法的入参中</p>
<p>一般与@RequestMapping(method = RequestMethod.GET)一起使用</p>
<p>1、若方法参数名称和需要绑定的url中变量名称一致时,可以简写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUser/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.selectUser(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、若方法参数名称和需要绑定的url中变量名称不一致时，写成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUserById/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String userName)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.selectUser(userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="restcontroller">@RestController</span></h3>
<ol>
<li>等同于@Controller + @ResponseBody</li>
<li>若控制器中的所有方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。</li>
</ol>
<h3><span id="put请求无法获取数据">put请求无法获取数据</span></h3>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.FormContentFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="文件上传">文件上传</span></h2>
<h3><span id="导入依赖">导入依赖</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="配置springmvc">配置SpringMVC</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传配置：id必须为multiPartResolver--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multiPartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置单次上传文件总大小最大值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;50*1024*1024&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置单次上传每个文件大小的最大值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;1*1024*1024&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="前端请求">前端请求</span></h3>
<p>表单处理，必须为post请求</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;upload.do&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    导入：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;files&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span> &gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="后端接收">后端接收</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;upload.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile[] files)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile file : files) &#123;</span><br><span class="line">        <span class="comment">//获取上传文件名</span></span><br><span class="line">        System.out.println(file.getOriginalFilename());</span><br><span class="line">        <span class="comment">//为了避免上传文件名一致导致的已上传的文件被覆盖，需处理文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + file.getOriginalFilename();</span><br><span class="line">        System.out.println(fileName);</span><br><span class="line">        <span class="comment">//创建保存上传文件的目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\upload&quot;</span>+getPath(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">File</span>(path).mkdirs();</span><br><span class="line">        <span class="comment">//保存上传文件</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(path+<span class="string">&quot;\\&quot;</span>+fileName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;upload&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理目录的分离：</span></span><br><span class="line"><span class="comment"> *   level 目录深度:表示有几层</span></span><br><span class="line"><span class="comment"> *   count 目录数量:每一层的目录个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回生成的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPath</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        result.append(<span class="string">&quot;\\&quot;</span>);</span><br><span class="line">        result.append((random.nextInt(count) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>避免文件名重复：UUID随机数作为名称</li>
<li>避免文件夹文件过多：尽可能存放在不同的目录中(自己定义)</li>
</ol>
<h2><span id="统一异常处理与信息返回">统一异常处理与信息返回</span></h2>
<h3><span id="统一错误友好页面webxml">统一错误友好页面（web.xml）</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--友好错误页面配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="异常处理">异常处理</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//专门用于异常处理的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理空指针异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(NullPointerException.class)</span><span class="comment">//传入什么类型，处理什么类型的异常</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">NullPointException</span><span class="params">(Exception e,HttpServletRequest request)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springMVC_error&quot;</span>;<span class="comment">//跳转一个异常处理页面，结合视图解析器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理所有的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span><span class="comment">//传入什么类型，处理什么类型的异常</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">myException</span><span class="params">(Exception e,HttpServletRequest request)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springMVC_error02&quot;</span>;<span class="comment">//跳转一个异常处理页面，结合视图解析器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="拦截器interceptor">拦截器Interceptor</span></h2>
<p>类似于Filter过滤器，对处理器(方法)进行前置拦截 和 后置 拦截操作。</p>
<h3><span id="实现handlerinterceptor接口prehandle方法">实现HandlerInterceptor接口preHandle方法</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intercepter1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">// 拦截处理程序（Controller）的调用，返回false表示处理程序不会被调用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截到了请求：&quot;</span> + request.getRequestURI());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="配置拦截器springmvcxml">配置拦截器（springmvc.xml）</span></h3>
<ol>
<li>指定拦截哪些资源</li>
<li>放行拦截中的哪些资源</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  拦截器配置，当配置多个拦截器时</span></span><br><span class="line"><span class="comment">    1. 拦截顺序根据配置的顺序进行拦截</span></span><br><span class="line"><span class="comment">    2. 如果第一个拦截器中return false，则之后与请求路径匹配的拦截器不会执行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      /test/\  拦截/test目录下的资源</span></span><br><span class="line"><span class="comment">      /test/  拦截/test目录及其子目录下的资源</span></span><br><span class="line"><span class="comment">    --&gt;</span>*</span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/test/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.web.intercepter.Intercepter1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/test/test1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.web.intercepter.Intercepter2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h3><span id="过滤器和拦截器面试题">过滤器和拦截器(面试题)</span></h3>
<p>过滤器能够实现的功能，使用拦截器也可以实现</p>
<p><strong>关系（Filter、Servlet、Interceptor、Controller）图：</strong></p>
<p>web服务器组件：Filter、Servlet</p>
<p>SpringMVC的组件：Interceptor、Controller</p>
<p><img src="https://pic.imgdb.cn/item/6490f5fe1ddac507cc5b916d.jpg" alt></p>
<table>
<thead>
<tr>
<th></th>
<th>过滤器</th>
<th>拦截器</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行顺序</td>
<td>先执行过滤器Filter</td>
<td>再执行拦截器Intercepter</td>
</tr>
<tr>
<td>组件</td>
<td>web服务器的组件</td>
<td>SpringMVC的组件</td>
</tr>
<tr>
<td>处理请求</td>
<td>可以拦截所有请求</td>
<td>只能拦截SpringMVC核心处理器（DispatcherServlet）处理范围内的资源</td>
</tr>
<tr>
<td>使用场景</td>
<td>处理和数据相关的需求，字符集过滤器CharacterEncodingFilter（解决中文乱码）、FormContentFilter（解决put请求获取不到表单数据的问题）</td>
<td>用于权限的控制，例如某些功能需要登录才能访问！又如某些功能需要会员才能使用。</td>
</tr>
</tbody>
</table>
<h3><span id="登录权限拦截器案例">登录权限拦截器案例</span></h3>
<p>用户没有登录的情况下，除了登录页面和静态资源以外，不给访问！强制跳转到登录界面！</p>
<h2><span id="springmvc的执行流程面试题">SpringMVC的执行流程(面试题)</span></h2>
<p><img src="https://pic.imgdb.cn/item/6490f61d1ddac507cc5bb2b6.jpg" alt></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心控制器</td>
<td>整个流程控制的核心，调用其他组件处理用户的请求，简化Servlet共有行为的处理。</td>
</tr>
<tr>
<td>处理器映射器</td>
<td>根据请求对象(中的url)获取到对应的处理程序执行链对象，该对象中包括处理程序 Handler（Controller） 和拦截器 Interceptor</td>
</tr>
<tr>
<td>处理器适配器</td>
<td>执行处理程序 Handler 的对象，处理器映射器负责查找处理程序，而处理程序中的参数的封装，都是处理器适配器完成的，例如通过参数的声明直接获取参数</td>
</tr>
<tr>
<td>视图解析器</td>
<td>将逻辑视图解析为View对象（真实资源文件对象），对处理程序（Controller中的每个方法都是一个处理程序）的返回值（视图）进行解析！例如：方法返回String类型时，返回redirect:/路径表示重定向，这都是视图解析器在完成</td>
</tr>
<tr>
<td>处理程序</td>
<td>处理业务逻辑（特有行为），Controller中的每个方法都是一个处理程序</td>
</tr>
<tr>
<td>拦截器</td>
<td>类似过滤器，权限控制，例如登录权限</td>
</tr>
<tr>
<td>Model</td>
<td>存放渲染视图所需的数据</td>
</tr>
<tr>
<td>View</td>
<td>JSP、HTML，渲染 View</td>
</tr>
</tbody>
</table>
<h3><span id="执行流程">执行流程</span></h3>
<ol>
<li>用户发起请求到核心控制器 DispatcherServlet</li>
<li>处理器映射器 HandlerMapping 根据请求对象获取处理器执行链 HandlerExecutionChain。包括处理程序Handler和拦截器Interceptor数组</li>
<li>为处理程序查找合适的处理器适配器 HandlerAdapter，该对象用于真正的调用处理程序Handler</li>
<li>处理器适配器 HandlerAdapter 调用处理程序 Handler，返回模型和视图对象 ModelAndView</li>
<li>核心控制器请求视图解析器去进行视图解析（将逻辑视图转化成完整的视图地址）</li>
<li>核心控制器将Model交给View进行视图渲染</li>
<li>View将结果响应给浏览器</li>
</ol>
<p>我们需要做的事情:</p>
<ol>
<li>在web.xml中配置核心控制器DispatcherServlet</li>
<li>编写处理器（controller）和 视图（jsp）</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC拦截器</title>
    <url>/post/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h2><span id="什么是拦截器">什么是拦截器</span></h2>
<p>SpringMVC中的interceptor拦截器</p>
<p>依赖于web框架，基于Java的反射机制实现，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个 controller生命周期之内可以多次调用。</p>
<p>它主要的作用是拦截指定的用户请求，并进行相应的预处理与后处理。</p>
<p>使用的aop的思想，多个Controller中集中到拦截器统一处理</p>
<p><strong>应用场景</strong></p>
<ul>
<li>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。</li>
<li>权限检查：如登录检测，进入处理器检测是否登录，如果没有直接返回到登录页面；</li>
<li>性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）；</li>
<li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个Controller中的处理方法都需要的，我们就可以使用拦截器实现。</li>
</ul>
<h2><span id="拦截器执行时机">拦截器执行时机</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>preHandle</td>
<td>请求前（即控制类方法执行前）执行，通过返回true，拦截返回false</td>
</tr>
<tr>
<td>postHandle</td>
<td>请求结束（即控制类方法执行后），且此时仍未相应到界面时执行，可以改变响应结果</td>
</tr>
<tr>
<td>afterCompletion</td>
<td>请求结束（即控制类方法执行后），同时已经响应界面执行，可以用于清理对象、关闭资源</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/64141a80a682492fcc3f3a71.jpg" alt></p>
<h2><span id="拦截器实现">拦截器实现</span></h2>
<ol>
<li>实现HandlerInterceptor拦截器接口</li>
<li>在spring-mvc.xml配置文件注册</li>
</ol>
<h3><span id="注册拦截器">注册拦截器</span></h3>
<p><strong>拦截器支持的通配符</strong></p>
<ol>
<li>*	:包括当前路径所有   /admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截</li>
<li>/**  :包括路径及其子路径</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射要拦截的请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**/*.action&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置放行的请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/login.action&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/loginErr.action&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置拦截器的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.interceptor.MyInterceptor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="实现handlerinterceptor拦截器接口">实现HandlerInterceptor拦截器接口</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throw</span> Exception&#123;</span><br><span class="line">        <span class="comment">//准备请求地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle准备请求地址:&quot;</span>+request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截请求地址，检测是否登录</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();        <span class="comment">//可以从request对象获取HttpSession对象</span></span><br><span class="line">        <span class="keyword">if</span>(session!=<span class="literal">null</span> &amp;&amp; session.getAttribute(<span class="string">&quot;user&quot;</span>)!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//response.sendRedirect(&quot;/login.html&quot;);ajax则会请求失败，要使用其他的控制器周转</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/user/loginErr.action&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle请求结束准备响应界面：....................&quot;</span>+request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion请求响应结束：....................&quot;</span>+request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="拦截器链多拦截器">拦截器链（多拦截器）</span></h2>
<p>如果多个拦截器能够对相同的请求进行拦截，则多个拦截器会形成一个拦截器链，主要理解拦截器链中各个拦截器的执行顺序。拦截器链中多个拦截器的执行顺序，与拦截器的配置顺序有关，先配置的先执行。也可以通过@Order指定顺序。</p>
<h2><span id="拦截器与过滤器">拦截器与过滤器</span></h2>
<h3><span id="过滤器">过滤器</span></h3>
<p>依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例，只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作，比如：在过滤器中修改字符编码； 在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。</p>
<h3><span id="拦截器">拦截器</span></h3>
<p>在AOP（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。</p>
<blockquote>
<p>在 Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>拦截器</th>
<th>过滤器</th>
</tr>
</thead>
<tbody>
<tr>
<td>SpringMVC提供，SpringMVC容器中创建</td>
<td>servlet中的对象，tomcat服务器创建</td>
</tr>
<tr>
<td>实现HandlerInterceptor</td>
<td>继承HttpFilter</td>
</tr>
<tr>
<td>验证请求，拦截请求</td>
<td>设置request，response的参数，属性的，侧重对数据过滤的</td>
</tr>
<tr>
<td>三个执行时间点</td>
<td>一个执行时间点</td>
</tr>
<tr>
<td>侧重拦截对Controller方法，不会拦截jsp/html/css/image/js</td>
<td>可以处理jsp，js，html等等</td>
</tr>
<tr>
<td>通常对处理器Controller进行拦截，只能拦截dispatcherServlet处理的请求</td>
<td>几乎对所有请求过滤</td>
</tr>
<tr>
<td></td>
<td>过滤器是在拦截器之前先执行的</td>
</tr>
</tbody>
</table>
<p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity与oauth2</title>
    <url>/post/SpringSecurity%E4%B8%8Eoauth2/</url>
    <content><![CDATA[<h1><span id="springsecurity">SpringSecurity</span></h1>
<h2><span id="简介">简介</span></h2>
<p><code>Spring Security</code>是一个能够为基于Spring的企业应用系统提供<strong>声明式</strong>（注解）的安全访问控制解决方案的安全框架</p>
<p>它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能</p>
<p>为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作</p>
<hr>
<h2><span id="基础概念">基础概念</span></h2>
<h3><span id="认证登录">认证（登录）</span></h3>
<p>认证能够保护系统的隐私数据与资源，让用户以合法的身份访问系统的资源</p>
<p>认证是判断一个用户的身份是否合法的过程</p>
<p><strong>认证的场景</strong></p>
<ol>
<li>登录请求：在初次使用注册后，输入账号和密码登录微信的过程</li>
<li>非登录请求：用户去访问要求验证用户的身份信息的系统资源（url接口）时，身份合法方可继续访问，不合法则拒绝访问</li>
</ol>
<p><strong>常用认证方式</strong></p>
<p>用户名密码登录，二维码登录，手机短信登录，指纹认证等方式</p>
<p><strong>保持登录状态</strong></p>
<p>为了避免用户通过认证后访问系统资源仍需重复认证，系统需要将用户的信息保存，从而保持用户的登录状态，常见的保持登录状态的方式有：session会话、token令牌，其中session常应用与java web项目中</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>服务端</th>
<th>客户端</th>
</tr>
</thead>
<tbody>
<tr>
<td>session认证成功后</td>
<td>在session中保存用户信息</td>
<td>在cookie中保存sesssion_id</td>
</tr>
<tr>
<td>token认证成功后</td>
<td>服务端生成token并在Redis中保存</td>
<td>在cookie或localStorage中保存token</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方式</th>
<th>客户端请求</th>
<th>服务端</th>
</tr>
</thead>
<tbody>
<tr>
<td>session校验</td>
<td>携带 session_id和cookie中的用户信息</td>
<td>验证sesion中是否存在该用户信息</td>
</tr>
<tr>
<td>token校验</td>
<td>携带 token</td>
<td>验证Redis中该token是否有效</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>对比</th>
<th>基于session的认证方式（Servlet规范定制）</th>
<th>基于token的认证方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务端存储位置</td>
<td>存储session，占用内存资源</td>
<td>不需要存储token</td>
</tr>
<tr>
<td>客户端存储方式</td>
<td>需要支持cookie</td>
<td>不限制存储方式</td>
</tr>
</tbody>
</table>
<p><strong>token令牌</strong></p>
<img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml3808\wps1.jpg" alt="img" style="zoom:67%;"> 
<p>鉴权  判断用户是否有访问某个资源的权限</p>
<p>根据用户的权限控制用户使用资源的过程</p>
<h3><span id="授权">授权</span></h3>
<p>为认证通过的用户授予访问指定资源的权限，从而对用户的隐私数据进行更详细的划分</p>
<p>授权是用户认证通过后根据用户的权限来控制用户访问资源的过程（有则访问，无则拒绝）</p>
<p><strong>授权的数据模型（RBAC）</strong></p>
<p>用户 角色 权限</p>
<p>Who对What(which)进行How操作</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>主体（Subject）</td>
<td>用户或程序，需要访问系统资源</td>
</tr>
<tr>
<td>资源（Resource）</td>
<td>功能资源（菜单、页面、按钮，每个功能对应一个url）、实体资源（资源类型和资源实例）</td>
</tr>
<tr>
<td>权限（Permission）</td>
<td>规定用户能否操作指定资源，如用户查询权限、用户添加权限</td>
</tr>
</tbody>
</table>
<img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml3808\wps2.png" alt="img" style="zoom:50%;"> 
<table>
<thead>
<tr>
<th>主体</th>
<th>主体和角色</th>
<th>角色</th>
<th>角色和权限</th>
<th>权限（包括资源）</th>
<th>资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户id、账号、密码、…</td>
<td>用户id、角色id、…</td>
<td>角色id、角色名称、…</td>
<td>角色 id、权限id、…</td>
<td>权限id、权限标识、权限名称、资源名称、资源访问地址、…</td>
<td>资源id、资源名称、访问地址、…</td>
</tr>
</tbody>
</table>
<img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml3808\wps4.png" alt="img" style="zoom:50%;"> 
<h3><span id="rbac">RBAC</span></h3>
<p>把<strong>权限</strong>打包给角色，分配给<strong>用户</strong></p>
<p>一般指基于角色的访问控制，至少需要五张表实现，是实施面向企业安全策略的一种有效的访问控制方式</p>
<table>
<thead>
<tr>
<th>基于角色的访问控制（Role-Based Access Control）</th>
<th>基于资源的访问控制（Resource-Based Access Control）</th>
</tr>
</thead>
<tbody>
<tr>
<td>按角色进行授权</td>
<td>按资源（或权限）进行授权</td>
</tr>
<tr>
<td>当角色与权限关系变化时，要修改相关授权代码，系统可扩展性差</td>
<td>定义权限标识无需修改授权代码系统可扩展性强</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="快速开始">快速开始</span></h2>
<h3><span id="导入springsecurity依赖">导入SpringSecurity依赖</span></h3>
<p>在pom.xml文件中添加如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以及Spring Boot、Nacos注册、配置、mybatisPlus、dataSource</p>
<h3><span id="添加注解enablewebsecurity">添加注解<code>@EnableWebSecurity</code></span></h3>
<p>在引导类中添加注解：<code>@EnableWebSecurity</code>开启SpringSecurity认证操作（5.X版本后默认就是开启）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LoginApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="添加控制器">添加控制器</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloSecurity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot Security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//根据Security上下文获取认证的用户信息</span></span><br><span class="line">        <span class="keyword">return</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="启动服务并请求资源">启动服务并请求资源</span></h3>
<p>SpringSecurity默认拦截所有请求，转发至/login</p>
<p><img src="https://pic.imgdb.cn/item/64cb7e851ddac507ccf1cfb9.jpg" alt></p>
<ol>
<li>若没有配置任何用户信息：可通过用户名：<code>user</code>、密码：服务启动日志中显示的密码进行登录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using generated security password: 0b509b4e-7f8e-4d18-97f0-348ff455489e</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>可以在<code>application.cml</code>中配置用户信息进行登录，基于配置文件管理security用户，配置后第一种方法失效</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>可以在[配置文件中配置用户信息进行登录](# 基于内存的认证及授权方式)，配置后前两种方法失效</li>
</ol>
<p>登录（认证）过后即可正常访问资源</p>
<hr>
<p>如何为不同的用户分配角色或权限呢？</p>
<h2><span id="授权操作">授权操作</span></h2>
<h3><span id="基于内存的认证及授权方式">基于内存的认证及授权方式</span></h3>
<p>添加自定义配置类<code>WebSecurityConfigServer</code>，配置用户信息以及用户登录成功后拥有的权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfigServer</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//SpringSecurity 5起强制要求密码要加密，声明密码加密器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//基于内存配置用户信息及授权信息</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">            <span class="comment">//用户名</span></span><br><span class="line">            .withUser(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">            <span class="comment">//密码，必须根据BCrypt加密器对密码加密</span></span><br><span class="line">            .password(passwordEncoder().encode(<span class="string">&quot;123&quot;</span>))</span><br><span class="line">            <span class="comment">//权限信息，授权操作</span></span><br><span class="line">            .authorities(</span><br><span class="line">                <span class="string">&quot;m:save&quot;</span>,</span><br><span class="line">                <span class="string">&quot;m:query&quot;</span>,</span><br><span class="line">                <span class="string">&quot;m:update&quot;</span>,</span><br><span class="line">                <span class="string">&quot;m:delete&quot;</span>,</span><br><span class="line">                <span class="string">&quot;user:save&quot;</span>,</span><br><span class="line">                <span class="string">&quot;user:query&quot;</span>,</span><br><span class="line">                <span class="string">&quot;user:update&quot;</span>,</span><br><span class="line">                <span class="string">&quot;user:delete&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="comment">//角色信息，授权操作，若同时配置角色和权限，则角色失效</span></span><br><span class="line">            <span class="comment">//.roles()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//默认拦截所有请求，将所有请求转发至/login，SpringSecurity自带的表单登录</span></span><br><span class="line">        <span class="built_in">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时仅为指定用户添加了权限，但权限并没有映射到响应的资源，因此需要鉴权后才能测试授权的效果</p>
<h4><span id="获取当前登录用户信息">获取当前登录用户信息</span></h4>
<ol>
<li><strong>直接在参数中注入Principal对象</strong></li>
</ol>
<p>此对象是登录后自动写入UsernamePasswordAuthenticationToken类中，未认证则返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;userInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Principal <span class="title function_">getUserInfo</span><span class="params">(Principal principal)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> principal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong><code>SecurityContextHolder.getContext()</code>获取安全上下文对象</strong></li>
</ol>
<p>保存在 ThreadLocal，未认证则创建一个authentication属性为null的empty安全上下文对象</p>
<h3><span id="基于数据库的认证及授权方式">基于数据库的认证及授权方式</span></h3>
<p>配置类中设置基于数据库的认证及授权方式：<code>auth.userDetailsService(userService);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfigServer</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserServiceImpl userService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//基于数据库配置用户信息及授权信息</span></span><br><span class="line">        auth.userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//使用默认表单进行登录操作</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">                <span class="comment">//.and();</span></span><br><span class="line">                <span class="comment">//鉴权方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>登录时将调用传入参数<code>userService</code>中重写的<code>loadUserByUsername(String name)</code>方法，根据用户名查询用户及其拥有的权限</li>
<li>该方法返回User对象也需要分别实现7个方法</li>
</ol>
<h4><span id="userserviceimpl实现userdetailsservice接口"><code>userServiceImpl</code>实现<code>UserDetailsService</code>接口</span></h4>
<p>重写<code>UserDetailsService</code>接口的<code>loadUserByUsername(String username)</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">UserService</span>, UserDetailsService &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;().eq(User::getLoginAct, username)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//若存在当前用户，则查询该用户拥有的权限</span></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(user)) &#123;</span><br><span class="line">            List&lt;String&gt; authorities = userMapper.getPerCodeList(user.getId());</span><br><span class="line">            user.setAuthorities(authorities);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="user实现userdetails接口"><code>User</code>实现<code>UserDetails</code>接口</span></h4>
<p>重写<code>UserDetails</code>以下7个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(value =&quot;tbl_user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, UserDetails &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;loginAct&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loginAct;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;loginPwd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loginPwd;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;lockState&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String lockState;</span><br><span class="line">    ...</span><br><span class="line">        <span class="meta">@TableField(exist = false)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; authorities;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities.stream()</span><br><span class="line">            .map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//是以下代码的简写</span></span><br><span class="line">        <span class="comment">//List&lt;SimpleGrantedAuthority&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//for (String authority : authorities) &#123;</span></span><br><span class="line">        <span class="comment">//    list.add(new SimpleGrantedAuthority(authority));</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return list;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getLoginPwd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.loginAct;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前用户是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getLockState().equals(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前用户账号是否被锁定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getLockState().equals(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前用户凭证是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getLockState().equals(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前用户是否可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getLockState().equals(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="鉴权操作">鉴权操作</span></h2>
<p>将根据如下不同的资源请求（控制器）匹配权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloSecurity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot Security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//根据Security上下文获取认证的用户信息</span></span><br><span class="line">        <span class="keyword">return</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">query</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;查询管理员&quot;</span>;&#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;新增管理员&quot;</span>;&#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;修改管理员&quot;</span>;&#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;删除管理员&quot;</span>;&#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">queryUser</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;查询用户&quot;</span>;&#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;新增用户&quot;</span>;&#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;修改用户&quot;</span>;&#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="string">&quot;删除用户&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="配置权限">配置权限</span></h3>
<p>本示例是基于内存配置用户信息及授权信息的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfigServer</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//SpringSecurity 5起强制要求密码要加密，声明密码加密器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//基于内存配置用户信息及授权信息</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">            <span class="comment">//用户名</span></span><br><span class="line">            .withUser(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">            <span class="comment">//密码，必须根据BCrypt加密器对密码加密</span></span><br><span class="line">            .password(passwordEncoder().encode(<span class="string">&quot;123&quot;</span>))</span><br><span class="line">            <span class="comment">//权限信息，授权操作</span></span><br><span class="line">            .authorities(</span><br><span class="line">                <span class="comment">//&quot;m:save&quot;,</span></span><br><span class="line">                <span class="comment">//&quot;m:query&quot;,</span></span><br><span class="line">                <span class="comment">//&quot;m:update&quot;,</span></span><br><span class="line">                <span class="comment">//&quot;m:delete&quot;,</span></span><br><span class="line">                <span class="string">&quot;user:save&quot;</span>,</span><br><span class="line">                <span class="string">&quot;user:query&quot;</span>,</span><br><span class="line">                <span class="string">&quot;user:update&quot;</span>,</span><br><span class="line">                <span class="string">&quot;user:delete&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="comment">//角色信息，授权操作，若同时配置角色和权限，则角色失效</span></span><br><span class="line">            <span class="comment">//.roles()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//以Post方式请求，登录成功或失败的重定向请求</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">            .successForwardUrl(<span class="string">&quot;/welcome&quot;</span>)</span><br><span class="line">            .failureForwardUrl(<span class="string">&quot;/fail&quot;</span>);</span><br><span class="line">        <span class="comment">//使用默认表单进行登录操作</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            <span class="comment">//鉴权方法</span></span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/m/sava&quot;</span>).hasAuthority(<span class="string">&quot;m:save&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/m/update&quot;</span>).hasAuthority(<span class="string">&quot;m:update&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/m/delete&quot;</span>).hasAuthority(<span class="string">&quot;m:delete&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/m/query&quot;</span>).hasAuthority(<span class="string">&quot;m:query&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/user/sava&quot;</span>).hasAuthority(<span class="string">&quot;user:save&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/user/update&quot;</span>).hasAuthority(<span class="string">&quot;user:update&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/user/delete&quot;</span>).hasAuthority(<span class="string">&quot;user:delete&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/user/query&quot;</span>).hasAuthority(<span class="string">&quot;user:query&quot;</span>)</span><br><span class="line">            .mvcMatchers(<span class="string">&quot;/info&quot;</span>).authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求没有权限的资源时，会发生浏览器状态码为403的异常</p>
<p>可以添加<code>403.html</code>设置没有权限的跳转页面</p>
<h3><span id="方法级别的url配权限">方法级别的url配权限</span></h3>
<p>在引导类中添加注解<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启SpringSecurity认证操作</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LoginApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在控制器上添加注解<code>@PreAuthorize(&quot;hasAuthority('【权限名】')&quot;)</code>，为url匹配对应的权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloSecurity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot Security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;isAuthenticated()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//根据Security上下文获取认证的用户信息</span></span><br><span class="line">        <span class="keyword">return</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/query&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;m:query&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询管理员&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/save&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;m:save&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;新增管理员&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/update&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;m:update&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;修改管理员&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;m/delete&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;m:delete&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除管理员&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/query&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user:query&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">queryUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/save&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user:save&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;新增用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/update&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user:update&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;修改用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user/delete&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user:delete&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当同时配置了方法级别的鉴权、配置类的鉴权，配置类的鉴权优先级更高</p>
<p>测试为方法级别为指定请求分配已有权限，配置类为该请求分配无权限，结果展示403无权限页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何读取数据库的用户名和密码</span><br><span class="line">如何对密码加密</span><br><span class="line">如何使用数据的角色和权限</span><br><span class="line">如何配置方法级别的权限访问</span><br><span class="line">如何自定义登陆页面</span><br><span class="line">如何集成redis把登陆信息放到Redis</span><br></pre></td></tr></table></figure>
<hr>
<h1><span id="oauth2">Oauth2</span></h1>
<h2><span id="配置">配置</span></h2>
<h3><span id="导入依赖">导入依赖</span></h3>
<p>在pom.xml文件中导入如下依赖，oauth2中包含了SpringSecurity依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>redis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="添加注解">添加注解</span></h3>
<p>在引导类中添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启资源服务器，当前必须传递token才能够访问资源</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="comment">//开启授权服务器</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LoginApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>服务器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>认证服务器</td>
<td>登录，以内存、数据库的方式进行登录及授权操作</td>
</tr>
<tr>
<td>授权服务器</td>
<td>登录成功后，根据指定的第三方**(Oauth2)**账号及密码，颁发token</td>
</tr>
<tr>
<td>资源服务器</td>
<td>解析token**，**验证token合法性</td>
</tr>
</tbody>
</table>
<p>所有的请求除了登录以外，都必须带token，否则未授权</p>
<h2><span id="授权服务器生成token">授权服务器生成token</span></h2>
<p><strong>添加授权服务器配置类，并配置redis保存生成的token</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//注入Redis连接工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    <span class="comment">//创建redis的tokenStore保存办法的token</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisTokenStore</span>(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(clients);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//使用Redis保存token</span></span><br><span class="line">        endpoints.tokenStore(tokenStore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>授权方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>验证码授权</td>
<td>通过认证后获取验证码，再通过验证码获取token</td>
</tr>
<tr>
<td>静默授权</td>
<td></td>
</tr>
<tr>
<td>密码授权</td>
<td></td>
</tr>
<tr>
<td>客户端授权</td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="验证码授权">验证码授权</span></h3>
<p><strong>配置第三方账号信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients</span><br><span class="line">                <span class="comment">//基于内存配置第三方的账号信息</span></span><br><span class="line">                .inMemory()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;power&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;power-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，验证码授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;power&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(endpoints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>授权并获取验证码</strong></p>
<p>登录完成后，在浏览器输入地址，进行授权操作，获取code码</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET http://localhost:2222/oauth/authorize?response_type=code&amp;client_id=power&amp;redirect_uri=http://www.bjpowernode.com</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>response_type=code</td>
<td>获取验证码</td>
</tr>
<tr>
<td>client_id</td>
<td>第三方账号</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>重定向的地址，必须和当前账号配置的地址一致，获取code码及token时都需要通过重定向的方式来获取</td>
</tr>
</tbody>
</table>
<p>授权后重定向至 <code>http://www.bjpowernode.com/?code=yNDFUC</code></p>
<p><strong>根据授权码获取token</strong></p>
<p>在浏览器输入地址，进行获取token操作，根据code码来换取token</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://localhost:2222/oauth/token?grant_type=authorization_code&amp;code=yNDFUC&amp;redirect_uri=http://www.bjpowernode.com</span><br></pre></td></tr></table></figure>
<p>请求头信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Authorization</span>=<span class="string">Basic cG93ZXI6cG93ZXItc2VjcmV0 (power:power-secret)</span></span><br></pre></td></tr></table></figure>
<p>响应体数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7d501648-d6c8-4068-880e-948baf0bfdcd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7199</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;power&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3><span id="静默授权">静默授权</span></h3>
<p><strong>配置第三方账号信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients</span><br><span class="line">                <span class="comment">//基于内存配置第三方的账号信息</span></span><br><span class="line">                .inMemory()</span><br><span class="line">                ...【此处省略了验证码第三方账号信息】</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;node&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;node-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，静默授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;implicit&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;node&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(endpoints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>登录并授权</strong></p>
<p>登录完成后，根据浏览器请求地址，完成授权操作</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET http://localhost:2222/oauth/authorize?response_type=token&amp;client_id=node&amp;redirect_uri=http://www.bjpowernode.com</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>response_type=token</td>
<td>获取token令牌</td>
</tr>
</tbody>
</table>
<p><strong>获取token令牌</strong></p>
<p>通过重定向地址获取token令牌</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://www.bjpowernode.com/#access_token=bd82dd11-8938-42fd-9d4c-b9d0e5f3f499&amp;token_type=bearer&amp;expires_in=7199&amp;scope=node</span><br></pre></td></tr></table></figure>
<h3><span id="密码授权">密码授权</span></h3>
<p><strong>配置第三方账号信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients</span><br><span class="line">                <span class="comment">//基于内存配置第三方的账号信息</span></span><br><span class="line">                .inMemory()</span><br><span class="line">                ...【此处省略了验证码授权的第三方账号信息】</span><br><span class="line">            	...【此处省略了静默授权的第三方账号信息】</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;pw&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;pw-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，密码授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;pw&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(endpoints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Spring管理认证管理器</strong></p>
<p>需要在认证服务器中，将认证管理器交给Spring容器进行管理，然后将认证管理器对象交给endpoints进行声明</p>
<p>否则产生异常：不支持的授权类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unsupported_grant_type&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error_description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unsupported grant type: password&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在<code>WebSecurityConfigServer</code>配置类中重写<code>authenticationManagerBean()</code>方法并交给Spring容器管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置密码授权时使用的认证管理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//密码授权时需要使用认证管理器对象</span></span><br><span class="line">        endpoints.authenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>发送请求获取token令牌</strong></p>
<p>无需登录，直接根据请求中的用户名密码(第三方)，来获取令牌</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://localhost:2222/oauth/token?username=kunkun&amp;password=123&amp;grant_type=password</span><br></pre></td></tr></table></figure>
<p>username和password是数据库中的用户名密码（数据库中的密码必须经过加密），认证的用户名密码</p>
<p>请求头</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Authorization</span>=<span class="string">Basic Ympwb3dlcm5vZGU6Ympwb3dlcm5vZGUtc2VjcmV0 (bjpowernode:bjpowernode-secret)</span></span><br></pre></td></tr></table></figure>
<p>响应体token数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;074ae2ba-8b5f-4c3f-9ac2-909ecefae9ac&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7199</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bjpowernode&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3><span id="客户端授权">客户端授权</span></h3>
<p><strong>配置第三方登录信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients</span><br><span class="line">                <span class="comment">//基于内存配置第三方的账号信息</span></span><br><span class="line">                .inMemory()</span><br><span class="line">                ...【此处省略了验证码授权的第三方账号信息】</span><br><span class="line">            	...【此处省略了静默授权的第三方账号信息】</span><br><span class="line">            	...【此处省略了密码授权的第三方账号信息】</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;client&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;client-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，客户端授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;client_credentials&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;client&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送请求获取token令牌</strong></p>
<p>无需登录，直接获取令牌（用于整个应用的授权）</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://localhost:2222/oauth/token?grant_type=client_credentials</span><br></pre></td></tr></table></figure>
<p>请求头</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Authorization</span>=<span class="string">Basic Y2xpZW50OmNsaWVudC1zZWNyZXQ= (client:client-secret)</span></span><br></pre></td></tr></table></figure>
<p>响应体token数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60fa5091-1f8a-4841-8ef5-6897ea8e7c3c&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7199</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;client&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2><span id="jwtjson-web-token">JWT（<code>Json Web Token</code>）</span></h2>
<p>可以按照指定方式生成的令牌，可以在互联网中进行传递，生成令牌具有一定规则</p>
<p>由三部分组成（头部，载荷，签名）</p>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>头部</td>
<td>指定jwt的算法、编码方式，由于是jwt的标准，我们无法修改</td>
</tr>
<tr>
<td>载荷</td>
<td>指定加密的数据，即用户自定义的数据</td>
</tr>
<tr>
<td>签名</td>
<td>指定对称、非对称加密的密匙，可以保护当前的token</td>
</tr>
</tbody>
</table>
<h2><span id="生成jwt格式令牌">生成JWT格式令牌</span></h2>
<p>生成的令牌可以<a href="https://jwt.io">JWT官网</a>中进行查看和校验</p>
<h3><span id="对称加密生成">对称加密生成</span></h3>
<p>指定生成JWT格式的token令牌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients</span><br><span class="line">                <span class="comment">//基于内存配置第三方的账号信息</span></span><br><span class="line">                .inMemory()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;power&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;power-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，验证码授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;power&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;node&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;node-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，验证码授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;implicit&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;node&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">jwtAccessTokenConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//默认生成token方式为UUID</span></span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">jwtAccessTokenConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        <span class="comment">//指定通过对称加密生成令牌,通过固定的秘钥对数据进行加密</span></span><br><span class="line">        jwtAccessTokenConverter.setSigningKey(SECRET);</span><br><span class="line">        <span class="keyword">return</span> jwtAccessTokenConverter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//密码授权时需要使用认证管理器对象</span></span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .tokenStore(tokenStore())</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="非对称加密生成">非对称加密生成</span></h3>
<table>
<thead>
<tr>
<th>对称加密</th>
<th>非对称加密</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过签名加密解密</td>
<td>通过公钥和私钥进行加密和解密</td>
</tr>
<tr>
<td>签名泄露则别人也能颁发token</td>
<td>私钥（授权服务器）产生token，公钥（资源服务器）验证该token，因此公钥泄露没有影响</td>
</tr>
</tbody>
</table>
<p><strong>在java中生成公钥和秘钥</strong></p>
<p><a href="https://oomake.com/download/openssl">安装ssl软件</a></p>
<p><strong>配置环境变量</strong></p>
<p>为了使用keytool命令</p>
<p>在系统环境变量Path中新建变量：<code>【ssl安装路径】\bin</code></p>
<p><strong>生成一个私钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -genkeypair -<span class="built_in">alias</span> 【别名】 -validity 3650 -keyalg RSA -dname <span class="string">&quot;CN=jwt,OU=jtw,O=jwt,L=zurich,S=zurich,C=CH&quot;</span> -keypass 【key密码】 -keystore 【生成文件名.jks】 -storepass 【store密码】</span><br></pre></td></tr></table></figure>
<p><strong>获取一个公钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -list -rfc --keystore 【私钥文件名.jks】 | openssl x509 -inform pem -pubkey</span><br></pre></td></tr></table></figure>
<p><strong>复制公钥</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnnVsCdyEXAUpTXIe9vNx</span><br><span class="line">y74JZ3/r5mAqk71DX4vSXkSauxzY3gdgxz6JSGGv8rNX1/Rdr8i661rvJTcUXp+c</span><br><span class="line">Me8H4IqhTGjefQ+0bMaLSGFFRkpa22sc+dfs0dgimx4WaPIrC0EpVk9/Jj/Rvwtd</span><br><span class="line">j8NUCVTR5/RfSDGf10eUlEy7TvPW+gXzNcKyQ1OwjFa6/+Pof3xe7fsYrjrN2s6h</span><br><span class="line">IfvwAQLI+rsxugNEsR8H28B7vkog27Eh9VTcMDxU1gWOEXag62dBhrHol3UehLJ2</span><br><span class="line">KzK5aFzetAGzd3/yZo6THZ+US9XtYPGRnOAcruAtD3Q0Ar7WNfYJldDXVTeBUPd2</span><br><span class="line">rQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
<p>将私钥复制到Resource文件夹下，并reload maven</p>
<p>修改授权配置类AuthorizationConfig，指定非加密方式生成JWT格式的token令牌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationConfigServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(security);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients</span><br><span class="line">                <span class="comment">//基于内存配置第三方的账号信息</span></span><br><span class="line">                .inMemory()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;power&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;power-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，验证码授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;power&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//用户名</span></span><br><span class="line">                .withClient(<span class="string">&quot;node&quot;</span>)</span><br><span class="line">                <span class="comment">//密码</span></span><br><span class="line">                .secret(bCryptPasswordEncoder.encode(<span class="string">&quot;node-secret&quot;</span>))</span><br><span class="line">                <span class="comment">//令牌生命周期，以秒为单位</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">7200</span>)</span><br><span class="line">                <span class="comment">//令牌的授权规则，验证码授权</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;implicit&quot;</span>)</span><br><span class="line">                <span class="comment">//作用域</span></span><br><span class="line">                .scopes(<span class="string">&quot;node&quot;</span>)</span><br><span class="line">                <span class="comment">//重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.bjpowernode.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">jwtAccessTokenConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">jwtAccessTokenConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        <span class="comment">//指定通过非对称加密生成令牌</span></span><br><span class="line">        <span class="comment">//1. 加载私钥文件</span></span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;rsa/sz2304.jks&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建秘钥工厂对象</span></span><br><span class="line">        <span class="type">KeyStoreKeyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KeyStoreKeyFactory</span>(resource,<span class="string">&quot;sz2304&quot;</span>.toCharArray());</span><br><span class="line">        <span class="comment">//3. 获取秘钥对象，参数为alias别名</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> factory.getKeyPair(<span class="string">&quot;sz2304&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 通过私钥生成token令牌</span></span><br><span class="line">        jwtAccessTokenConverter.setKeyPair(keyPair);</span><br><span class="line">        <span class="keyword">return</span> jwtAccessTokenConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//密码授权时需要使用认证管理器对象</span></span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .tokenStore(tokenStore())</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="资源服务器验证token">资源服务器验证token</span></h2>
<h3><span id="验证非对称加密生成">验证非对称加密生成</span></h3>
<p>添加ResourceConfigServer.java 配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceConfigServer</span> <span class="keyword">extends</span> <span class="title class_">ResourceServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">resourceJwtAccessTokenConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">jwtAccessTokenConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenCo</span>	nverter();</span><br><span class="line">        jwtAccessTokenConverter.setSigningKey(SECRET);</span><br><span class="line">        <span class="keyword">return</span> jwtAccessTokenConverter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">resourceTokenStore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(</span><br><span class="line">                resourceJwtAccessTokenConverter()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        指定对令牌进行校验解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        resources.tokenStore(resourceTokenStore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="验证对称加密生成">验证对称加密生成</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceConfigServer</span> <span class="keyword">extends</span> <span class="title class_">ResourceServerConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">resourceJwtAccessTokenConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">jwtAccessTokenConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        <span class="comment">//1. 加载公钥资源</span></span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;rsa/sz2304.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 将公钥读取为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            publicKey = FileUtils.readFileToString(resource.getFile(), Charset.defaultCharset());</span><br><span class="line">            jwtAccessTokenConverter.setVerifierKey(publicKey);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 通过公钥验证token合法性</span></span><br><span class="line">        <span class="keyword">return</span> jwtAccessTokenConverter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">resourceTokenStore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(</span><br><span class="line">                resourceJwtAccessTokenConverter()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        指定对令牌进行校验解析</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        resources.tokenStore(resourceTokenStore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat安装与配置</title>
    <url>/post/Tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2><span id="下载与安装">下载与安装</span></h2>
<p><a href="https://tomcat.apache.org/download-90.cgi">Tomcat官网</a></p>
<p><img src="https://pic.imgdb.cn/item/64959f7a1ddac507cc218315.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/64959fd01ddac507cc222a69.jpg" alt></p>
<h2><span id="配置">配置</span></h2>
<p>JAVA_HOME</p>
<p>计算机右键 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量</p>
<ol>
<li>在系统环境变量中新建 <code>CATALINA_HOME</code> 环境变量，值为<code>D:\java\apache-tomcat-9.0.76</code>（安装目录）</li>
<li>修改 Path ，在 Path 后添加： <code>%CATALINA_HOME%\lib</code>、<code>%CATALINA_HOME%\bin</code>、<code>%CATALINA_HOME%\lib\servlet-api.jar</code></li>
</ol>
<p>注意：</p>
<ol>
<li>环境变量中变量名对大小写不敏感，可将CATALINA_HOME小写，但需要保持一致</li>
<li>在环境变量中，如果新建有两个相同仅大小写不同的的变量名，会覆盖设置。如：path和PATH</li>
</ol>
<h2><span id="tomcat文件目录">Tomcat文件目录</span></h2>
<ol>
<li>bin：可执行文件（启动文件startup.bat、关闭文件shutdown.bat）</li>
<li>conf：配置文件（修改端口号：server.xml，建议将server.xml备份）</li>
<li>lib：依赖的jar包</li>
<li>log：日志文件（记录出错等信息）</li>
<li>temp：临时文件</li>
<li>webapps：可执行的项目。默认作为存放开发项目的目录</li>
<li>work：存放由jsp翻译成的.java源文件,以及编译的.class字节码文件(jsp -&gt;java -&gt;class)<br>
其他文件</li>
</ol>
<h2><span id="启动tomcat">启动Tomcat</span></h2>
<ol>
<li>
<p>在.<code>D:\java\apache-tomcat-9.0.76\bin</code>目录下，双击<code>startup.bat</code>打开窗口，双击<code>shutdown.bat</code>关闭窗口。</p>
<p>如果点startup.bat窗口的×直接关闭，可能会造成关闭异常</p>
<p><img src="https://pic.imgdb.cn/item/6495aa681ddac507cc34bebf.jpg" alt></p>
</li>
<li>
<p>通过命令行窗口打开。<code>D:\java\apache-tomcat-9.0.76\bin</code>路径下打开命令行窗口，输入命令：<code>startup</code>，出现如下对话框，表明服务启动成功。<code>shutdown</code>关闭</p>
<p><img src="https://pic.imgdb.cn/item/6495ab3a1ddac507cc35f912.jpg" alt></p>
</li>
</ol>
<h2><span id="常见问题">常见问题</span></h2>
<h3><span id="闪退">闪退</span></h3>
<p>环境变量配置不正确</p>
<ol>
<li>JAVA_HOME中的路径不能用分号结尾，如C:\Program Files\Java\jdk1.8.0_121</li>
<li>JAVA_HOME的路径是JDK路径，而不是JRE的路径。</li>
<li>CATALINA_HOME中的路径不能以\结尾。</li>
<li>在环境变量中修改添加变量时，一定要注意分号、空格，是否有多余的字母。</li>
</ol>
<h3><span id="乱码">乱码</span></h3>
<p>打开startup.bat后汉字乱码</p>
<ol>
<li>在D:\java\apache-tomcat-9.0.76\conf下打开logging.properties文件</li>
<li>将java.util.logging.ConsoleHandler.encoding = UTF-8 替换为java.util.logging.ConsoleHandler.encoding = GBK</li>
<li>idea的输出窗口中不会产生乱码，如果输出乱码，参考文章：IDEA 控制台Tomcat Catalina Log 和 Tomcat Localhost Log乱码？</li>
</ol>
<h3><span id="与其他服务的端口号冲突">与其他服务的端口号冲突</span></h3>
<p>tomcat端口号默认8080，如果和其他服务的端口号冲突，则可对端口号进行修改</p>
<ol>
<li>
<p>在<code>D:\java\apache-tomcat-9.0.76\conf</code>下打开server.xml文件，在文件的69行左右，将port=&quot;8080&quot;修改为指定的某一端口号，重新启动。端口号：网络编程-传输层</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="访问tomcat">访问Tomcat</span></h2>
<p>先打开startup.bat，再打开浏览器，在地址栏中输入http://localhost:8080或localhost:8080回车，如果看到Tomcat自带的一个JSP页面，说明JDK和Tomcat已搭建成功。</p>
<h2><span id="常见状态码">常见状态码</span></h2>
<p>200：一切正常<br>
300/301：页面重定向 （跳转）<br>
404：资源不存在<br>
403：权限不足 （如果访问a目录，但是a目录设置 不可见）<br>
500：服务器内部错误（代码有误）<br>
其他编码：积累</p>
<h2><span id="卸载tomcat">卸载Tomcat</span></h2>
<p>直接删除Tomcat目录，并删除已配置的环境变量</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>ajax请求</title>
    <url>/post/ajax%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2><span id="导入jqueryminjs">导入jquery.min.js</span></h2>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;static/js/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="jquery的ajax函数">jQuery的ajax函数</span></h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;路径&quot;</span>,</span><br><span class="line">	<span class="attr">type</span>: <span class="string">&quot;请求方式&quot;</span>, <span class="comment">//默认是get</span></span><br><span class="line">	<span class="attr">data</span>: <span class="string">&quot;name1=value1&amp;name2=value2&quot;</span> 或者 js对象&#123;<span class="attr">name1</span>: value1, <span class="attr">name2</span>: value2&#125;,</span><br><span class="line">  	<span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>, <span class="comment">// 可以省略不写！默认根据响应头&quot;content-type&quot;来动态决定</span></span><br><span class="line">	<span class="comment">// 成功，data就是返回来的数据</span></span><br><span class="line">    <span class="attr">beforeSend</span>: <span class="keyword">function</span>(<span class="params">XHR</span>) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data, textStatus, jqXHR</span>) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">XHR, textStatus, errorThrown</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求发送失败！&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="keyword">function</span> (<span class="params">XHR, TS</span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求发送结束！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="ajax的语法糖">ajax的语法糖</span></h2>
<p>语法不同，代码简化，效果相同，底层还是$.ajax，只能指定4个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">post</span>(url, [data], [fn], [dataType]);</span><br><span class="line">$.<span class="title function_">get</span>(url, [data], [fn], [dataType]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Web后端</title>
    <url>/post/Web%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<h1><span id="web后端面试题">Web后端面试题</span></h1>
<hr>
<h2><span id="servlet的生命周期">Servlet的生命周期？</span></h2>
<ul>
<li>web Client 向servlet服务器发出Http请求</li>
<li>servlet接受web Client的请求</li>
<li>servlet容器创建一个HttpRequest 对象，将Web Client请求的信息封装到这个对象中</li>
<li>servlet容器创建一个HttpResponset对象</li>
<li>servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet对象</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息</li>
<li>HttpServlet调用HttpResponst 对象的有关方法，生成响应数据</li>
<li>Servlet容器把 HttpServlet的响应结果给Web Client</li>
<li>简单的说:init   service  destroy</li>
</ul>
<hr>
<h2><span id="servlet是线程安全的吗">Servlet是线程安全的吗？</span></h2>
<ul>
<li>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题</li>
<li>解决的办法是尽量不要在实现servlet接口的类中定义实例变量，而是要把变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法</li>
<li>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的</li>
</ul>
<hr>
<h2><span id="如何实现servlet的单线程模式">如何实现servlet的单线程模式？</span></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page isThreadSafe=”false”%&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="get和post请求的区别">get和post请求的区别？</span></h2>
<ul>
<li>get请求用来从服务器上获得资源；而post是用来向服务器提交数据；</li>
<li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用&quot;?“连接，而各个变量之间使用”&amp;&quot;连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL</li>
<li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式</li>
<li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post</li>
<li>get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是&quot;%20&quot;</li>
</ul>
<hr>
<h2><span id="转发和重定向的区别">转发和重定向的区别？</span></h2>
<ul>
<li>重定向访问服务器两次，转发只访问服务器一次。</li>
<li>转发页面的URL不会改变，而重定向地址会改变</li>
<li>转发只能转发到自己的web应用内，重定向可以重定义到任意资源路径。</li>
<li>转发相当于服务器跳转，相当于方法调用，在执行当前文件的过程中转向执行目标文件，两个文件(当前文件和目标文件)属于同一次请求，前后页 共用一个request，可以通过此来传递一些数据或者session信息，request.setAttribute()和 request.getAttribute()。而重定向会产生一个新的request，不能共享request域信息与请求参数。</li>
<li>由于转发相当于服务器内部方法调用，所以转发后面的代码仍然会执行(转发之后记得return)；重定向代码执行之后是方法执行完成之后进行重定向操作，也就是访问第二个请求，如果是方法的最后一行进行重定向那就会马上进行重定向(重定向也需要return)。</li>
<li>无论是RequestDispatcher.forward方法，还是HttpServletResponse.sendRedirect方法，在调用它们之前，都不能有内容已经被实际输出到了客户端。如果缓冲区中已经有了一些内容，这些内容将被从缓冲区中移除。<br>
可以这么理解：转发相当于，张三向你借钱，但是你兜里没钱，所以你去找李四借到钱之后借给张三。对于张三而言并不知道你的钱是和李四借的；重定向相当于，张三向你借钱，你兜里没钱，你告诉他李四有钱，所以张三再次去找李四借钱。</li>
</ul>
<hr>
<h2><span id="jsp九大内置对象">jsp九大内置对象?</span></h2>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<hr>
<h2><span id="jsp的四大域对象">jsp的四大域对象？</span></h2>
<ul>
<li>page代表与一个页面相关的对象和属性。</li>
<li>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<hr>
<h2><span id="jsp中的静态包含和动态包含有什么区别">JSP中的静态包含和动态包含有什么区别？</span></h2>
<ul>
<li>静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作<a href="jsp:forward">jsp:forward</a>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的&quot;contentType&quot;属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新</li>
<li>动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。</li>
</ul>
<hr>
<h2><span id="jsp请求是如何被处理的">JSP请求是如何被处理的？</span></h2>
<p>浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。</p>
<hr>
<h2><span id="jsp和servlet的区别">jsp和Servlet的区别？</span></h2>
<ul>
<li>jsp的本质是Servlet ，jvm只能识别java的类，不能识别jsp的代码；</li>
<li>jsp更擅长表现与页面显示，Servlet更擅长与逻辑控制；</li>
<li>servlet中没有内置对象，jsp中有九大内置对象;</li>
</ul>
<hr>
<h2><span id="过滤器filter的作用及配置">过滤器Filter的作用及配置？</span></h2>
<p>过滤器是一个对象，可以传输请求或修改响应。它可以在请求到达Servlet/JSP之前对其进行预处理，而且能够在响应离开Servlet/JSP之后对其进行后处理。所以如果你有几个Servlet/JSP需要执行同样的数据转换或页面处理的话，你就可以写一个过滤器类，然后在部署描述文件（web.xml）中把该过滤器与对应的Servlet/JSP联系起来。你可以一个过滤器以作用于一个或一组servlet，零个或多个过滤器能过滤一个或多个servlet。一个过滤器实现java.servlet.Filter接口并定义它的三个方法：<br>
1.void init(FilterConfig config) throws ServletException:在过滤器执行service前被调用，以设置过滤器的配置对象。<br>
2.void destroy();在过滤器执行service后被调用。<br>
3.void doFilter(ServletRequest req，ServletResponse res，FilterChain chain) throws IOException，ServletException;</p>
<hr>
<h2><span id="五个常用的jstl常用标签">五个常用的JSTL常用标签？</span></h2>
<p>&lt;c:if&gt;、&lt;c:item&gt;、&lt;c:foreach&gt;、&lt;c:out&gt;、&lt;c:set&gt;</p>
<hr>
<h2><span id="xml是什么">XML是什么？</span></h2>
<p>XML 即可扩展标记语言（Extensible Markup language），你可以根据自己的需要扩展 XML。XML 中可以轻松定义<books>, <orders>等自定义标签，而在 HTML 等其他标记语言中必须使用预定义的标签，比如<p>，而不能使用用户定义的标签。使用 DTD 和 XML Schema 标准化XML 结构。XML 主要用于从一个系统到另一系统的数据传输，比如企级应用的客户端与服务端。</p>
<hr>
<h2><span id="xpath是什么">XPath是什么？</span></h2>
<p>XPath 是用于从 XML 文档检索元素的 XML 技术。XML 文档是结构化的，因此 XPath 可以从 XML 文件定位和检索元素、属性或值。从数据检索方面来说，XPath与 SQL 很相似，但是它有自己的语法和规则。了解更多查看怎样使用 XPath 从XML文档中检索数据。</p>
<hr>
<h2><span id="xml命名空间是什么它为什么很重要">XML命名空间是什么？它为什么很重要？</span></h2>
<p>XML 命名空间与 Java 的 package 类似，用来避免不同来源名称相同的标签发生冲突。XML 命名空间在 XML 文档顶部使用 xmlns 属性定义，语法为 xmlns:prefix=’URI’。prefix 与XML 文档中实际标签一起使用。下面例子为 XML 命名空间的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;root xmlns:inst=&quot;http://instruments.com/inst&quot;</span><br><span class="line">    &lt;inst:phone&gt;</span><br><span class="line">    &lt;inst:number&gt;837363223&lt;/inst:number&gt;</span><br><span class="line">    &lt;/inst:phone&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="解析-xml-文档有哪几种方式">解析 XML 文档有哪几种方式？</span></h2>
<ul>
<li>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这种结构占用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML 的随机访问；</li>
<li>SAX:不同于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML 的顺序访问；</li>
<li>STAX:Streaming API for XML (StAX)。</li>
</ul>
<hr>
<h2><span id="项目中的哪些地方用到xml">项目中的哪些地方用到xml?</span></h2>
<ul>
<li>在做数据交换平台时，将不能数据源的数据组装成 XML 文件，然后将 XML 文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同 XML 文件中还原相关信息进行处理。</li>
<li>在做软件配置时，利用 XML 可以很方便的进行，软件的各种配置参数都存贮在 XML 文件中。</li>
</ul>
<hr>
<h2><span id="什么是json">什么是JSON?</span></h2>
<p>JSON是一种取代XML的数据结构，和xml相比，它更小巧但描述能力不差，网络传输数据将减少更多的流量从而加快速度，是一种轻量级的数据交换格式。</p>
<hr>
<h2><span id="json和xml之间的区别">JSON和XML之间的区别？</span></h2>
<ul>
<li>JSON是JavaScript Object Notation；XML是可扩展标记语言。</li>
<li>JSON是基于JavaScript语言；XML源自SGML。</li>
<li>JSON是一种表示对象的方式；XML是一种标记语言，使用标记结构来表示数据项。</li>
<li>JSON不提供对命名空间的任何支持；XML支持名称空间。</li>
<li>JSON支持数组；XML不支持数组。</li>
<li>XML的文件相对难以阅读和解释；与XML相比，JSON的文件非常易于阅读。</li>
<li>JSON不使用结束标记；XML有开始和结束标签。</li>
<li>JSON的安全性较低；XML比JSON更安全。</li>
<li>JSON不支持注释；XML支持注释。</li>
<li>JSON仅支持UTF-8编码；XML支持各种编码。</li>
</ul>
<hr>
<h2><span id="http协议是什么">HTTP协议是什么？</span></h2>
<p><strong>HTTP（超文本传输协议，Hypertext Transfer Protocol）</strong></p>
<ul>
<li>是一种用于从网络传输超文本到本地浏览器的传输协议</li>
<li>它定义了客户端与服务器之间请求和响应的格式</li>
<li>基于TCP/IP通信协议</li>
</ul>
<hr>
<h2><span id="http和https有什么区别">http和https有什么区别？</span></h2>
<ul>
<li>https有ca证书，http一般没有</li>
<li>http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输</li>
<li>http默认80端口，https默认443端口</li>
</ul>
<hr>
<h2><span id="http协议有什么特点">http协议有什么特点？</span></h2>
<ul>
<li>http无连接：限制每次连接只处理一个请求，服务端完成客户端的请求后，即断开连接。(传输速度快，减少不必要的连接，但也意味着每一次访问都要建立一次连接，效率降低);</li>
<li>http无状态：对于事务处理没有记忆能力。每一次请求都是独立的，不记录客户端任何行为；</li>
<li>客户端/服务端模型：客户端支持web浏览器或其他任何客户端；</li>
<li>简单快速\灵活：可以传输任何类型的数据。</li>
</ul>
<hr>
<h2><span id="什么是http协议无状态协议怎么解决http协议无状态协议">什么是http协议无状态协议？怎么解决http协议无状态协议？</span></h2>
<p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。<br>
状态协议解决办法：1、cookie 2、通过session会话保存。</p>
<hr>
<h2><span id="说一下http协议中302状态">说一下http协议中302状态？</span></h2>
<p>http协议中，返回状态码302表示重定向。这种情况下，服务器返回的头部信息中会包含一个Location字段，内容是重定向到的url</p>
<hr>
<h2><span id="http协议什么组成">http协议什么组成？</span></h2>
<p>请求报文</p>
<ul>
<li>请求行：包含请求方法、URI、HTTP版本信息</li>
<li>请求首部字段</li>
<li>请求内容实体</li>
</ul>
<p>响应报文</p>
<ul>
<li>状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>响应首部字段</li>
<li>响应内容实体</li>
</ul>
<hr>
<h2><span id="http协议中有那些请求方式">http协议中有那些请求方式？</span></h2>
<ul>
<li>GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效</li>
<li>OPTIONS：查询相应URI支持的HTTP方法</li>
</ul>
<hr>
<h2><span id="tcp和udp的区别">TCP和UDP的区别？</span></h2>
<p>TCP（Transmission Control Protocol，传输控制协议）</p>
<ul>
<li>是基于连接的协议</li>
<li>在正式收发数据前，必须和对方建立可靠的连接</li>
<li>一个TCP连接必须要经过三次“对话”才能建立起来</li>
</ul>
<p>UDP（User Data Protocol，用户数据报协议）</p>
<ul>
<li>是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去</li>
<li>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境</li>
</ul>
<hr>
<h2><span id="http的长连接和短连接区别">http的长连接和短连接区别？</span></h2>
<p>HTTP协议有HTTP/1.0版本和HTTP/1.1版本</p>
<p>HTTP1.1默认保持长连接（HTTP persistent connection，也翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据</p>
<p>在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</p>
<p>从HTTP/1.1起，默认使用的是长连接，用以保持连接特性。</p>
<hr>
<h2><span id="什么是-csrf-攻击如何避免">什么是 CSRF 攻击，如何避免？</span></h2>
<p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造</p>
<p>攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令</p>
<p>常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为</p>
<hr>
<h2><span id="什么是-xss-攻击如何避免">什么是 XSS 攻击，如何避免？</span></h2>
<p>XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击）</p>
<p>其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的</p>
<p>XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的</p>
<p>而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息</p>
<p>XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式</p>
<p>XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</p>
<hr>
<h2><span id="说一说osi网络模型">说一说OSI网络模型</span></h2>
<p>网络的七层架构从下到上主要包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</p>
<p>物理层</p>
<ul>
<li>主要定义物理设备标准</li>
<li>传输比特流，具体做法是在发送端将1、0转化为电流强弱来进行传输，在到达目的地之后再将电流强弱转化为1、0</li>
<li>也就是模数转换与数模转换，这一层的数据叫做比特</li>
</ul>
<p>数据链路层</p>
<ul>
<li>主要用于对数据包中的MAC地址进行解析和封装</li>
<li>这一层的数据叫做帧，在这一层工作的设备是网卡、网桥、交换机</li>
</ul>
<p>网络层</p>
<ul>
<li>主要用于对数据包中的IP地址进行封装和解析</li>
<li>这一层的数据叫做数据包。在这一层工作的设备有路由器、交换机、防火墙等</li>
</ul>
<p>传输层</p>
<ul>
<li>定义了传输数据的协议和端口号</li>
<li>主要用于数据的分段、传输和重组</li>
<li>在这一层工作的协议有TCP和UDP等</li>
<li>TCP是传输控制协议，传输效率低，可靠性强，用于传输对可靠性要求高，数据量大的数据，比如支付宝转账业务</li>
<li>UDP是用户数据报协议，用于传输可靠性要求不高，数据量小的数据，例如抖音等视频服务</li>
</ul>
<p>会话层</p>
<ul>
<li>传输层的基础上建立连接和管理会话，具体包括登陆验证、断点续传、数据粘包与分包等</li>
<li>在设备之间需要互相识别的可以是IP，也可以是MAC或者主机名</li>
</ul>
<p>表示层</p>
<ul>
<li>表示层主要对接收的数据进行解释、加密、解密、压缩、解压缩等</li>
<li>即把计算机能够识别的内容转换成人能够识别的内容（图片、声音、文字等）</li>
</ul>
<p>应用层</p>
<ul>
<li>基于网络构建具体应用</li>
<li>例如FTP上传文件下载服务、Telnet服务、HTTP服务、DNS服务、SNMP邮件服务等</li>
</ul>
<hr>
<h2><span id="说一说tcpip的网络模型">说一说TCP/IP的网络模型。</span></h2>
<p>TCP/IP不是指TCP和IP这两个协议的合称，而是指因特网的整个TCP/IP协议簇。从协议分层模型方面来讲，TCP/IP由4个层次组成：网络接口层、网络层、传输层和应用层。<br>
①网络接口层：定义了主机间网络连通的协议，具体包括Echernet、FDDI、ATM等通信协议。<br>
②网络层：主要用于数据的传输、路由及地址的解析，以保障主机可以把数据发送给任何网络上的目标。数据经过网络传输，发送的顺序和到达的顺序可能发生变化。在网络层使用IP协议和ARP地址解析协议。<br>
③传输层：使源端和目的端的机器上的对等实体可以基于会话相互通信。在这一层定义了两个端到端的协议TCP和UDP。TCP是面向连接的协议，提供可靠的报文传输和对上层应用的连接服务，除了基本的数据传输，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP是面向无连接的不可靠传输的协议，主要用于不需要TCP的排序和流量控制等功能的应用程序。<br>
④应用层：负责具体应用层协议的定义，包括Telnet虚拟终端协议、FTP文件传输协议、SMTP简单电子邮件传输协议、DNS域名解析服务、NNTP网上新闻传输协议和HTTP超文本传输协议等。</p>
<hr>
<h2><span id="简述tcp的三次握手过程为什么不是两次或四次">简述TCP的三次握手过程，为什么不是两次或四次？</span></h2>
<p>①服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。<br>
②服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。<br>
③客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。<br>
④不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。<br>
⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。</p>
<hr>
<h2><span id="简述tcp的四次握手过程为什么不是三次">简述TCP的四次握手过程，为什么不是三次？</span></h2>
<p>①当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。<br>
②服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。<br>
③当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。<br>
④客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。<br>
⑤不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。</p>
<hr>
<h2><span id="会话是什么">会话是什么？</span></h2>
<p>会话：客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。<br>
http协议是“无状态”协议，不能保存用户信息，需要判断是否是同一个用户，需要会话跟踪。cookies和session都是用来跟踪浏览器用户身份的会话方式，但两者应用场景不一样。</p>
<hr>
<h2><span id="session和cookie的概念">Session和Cookie的概念？</span></h2>
<p>Cookie 是Web 服务器发送给客户端（浏览器）的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。<br>
Session 代表着服务器和客户端一次会话的过程。每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。</p>
<hr>
<h2><span id="cookie的工作原理">Cookie的工作原理？</span></h2>
<p>(1)浏览器端第一次发送请求到服务器端<br>
(2)服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端<br>
(3)浏览器端再次访问服务器端时会携带服务器端创建的Cookie<br>
(4)服务器端通过Cookie中携带的数据区分不同的用户</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20221011/1665470640@00feaa79335586b0530fd04a40ecc872.png" alt="img"></p>
<hr>
<h2><span id="session的工作原理">Session的工作原理？</span></h2>
<p>(1)浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端<br>
(2)浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象<br>
(3)服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20221011/1665470853@c176e8f01ce5c6c500929a18ba7112a8.png" alt="img"></p>
<hr>
<h2><span id="cookie禁止掉session还能用吗">Cookie禁止掉，Session还能用吗？</span></h2>
<p>第一种，在每次请求中都携带一个 SessionID 的参数放入URL<br>
第二种，Token 机制。Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。随机且无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</p>
<hr>
<h2><span id="cookie的生存周期">Cookie的生存周期？</span></h2>
<p>Cookie在生成时就会被指定一个Expire值，这就是Cookie的生存周期，在这个周期内Cookie有效，超出周期Cookie就会被清除。有些页面将Cookie的生存周期设置为“0”或负值，这样在关闭浏览器时，就马上清除Cookie，不会记录用户信息，更加安全。</p>
<hr>
<h2><span id="cookie和session的区别">Cookie和Session的区别?</span></h2>
<p>①存在的位置：<br>
Cookie存在于客户端，临时文件夹中；  Session存在于服务器的内存中，一个Session域对象为一个用户浏览器服务<br>
②安全性<br>
Cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；  Session存放于服务器的内存中，所以安全性好<br>
③网络传输量<br>
Cookie会传递消息给服务器；  Session本身存放于服务器，不会有传送流量<br>
④生命周期(以20分钟为例)<br>
Cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，Cookie生命周期结束；<br>
session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问Session，那么Session生命周期被销毁。但是，如果在20分钟内（如在第19分钟时）访问过Session，那么，将重新计算Session的生命周期。关机会造成Session生命周期的结束，但是对Cookie没有影响<br>
⑤访问范围<br>
Cookie为多个用户浏览器共享；  Session为一个用户浏览器独享</p>
</orders></books></p>]]></content>
  </entry>
  <entry>
    <title>axios</title>
    <url>/post/axios/</url>
    <content><![CDATA[<h1><span id="axios">Axios</span></h1>
<h2><span id="中文官网">中文官网</span></h2>
<p><a href="https://www.axios-http.cn/docs/intro">起步 | Axios 中文文档 | Axios 中文网 (axios-http.cn)</a></p>
<h2><span id="安装axios">安装Axios</span></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure>
<h2><span id="引入依赖并全局注册">引入依赖并全局注册</span></h2>
<p>在<code>main.js</code>中引入，将Axios封装到vue组件中，可通过<code>this.$axios</code>进行调用并发送请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> ‘axios’</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$axios</span> = axios</span><br></pre></td></tr></table></figure>
<h2><span id="配置config文件">配置config文件</span></h2>
<p>在<code>vue.config.js</code>中配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">		<span class="attr">proxy</span>: &#123;</span><br><span class="line">			<span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">				<span class="attr">target</span>: <span class="string">&#x27;http://localhost:1001&#x27;</span>,<span class="comment">//跳转的目标网址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">				<span class="comment">//请求时重写pathname:将api重写为&#x27;&#x27;</span></span><br><span class="line">				<span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">					<span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">				&#125;, </span><br><span class="line">				<span class="comment">//请求http://localhost/api/XXX =&gt; 代理请求 http://localhost:1001/XXX</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2><span id="使用axios">使用Axios</span></h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="attr">method</span>: method,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">params</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;&#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>elasticsearch</title>
    <url>/post/elasticsearch/</url>
    <content><![CDATA[<h1><span id="倒排索引重点">倒排索引【重点】</span></h1>
<h2><span id="正排索引">正排索引</span></h2>
<p>正排索引根据id 找到对应的一组数据  （B+tree 聚簇索引） <img src="https://pic.imgdb.cn/item/64c259fb1ddac507cc6a541c.jpg" style="zoom:50%;"></p>
<h2><span id="倒排索引">倒排索引</span></h2>
<p>非聚簇索引：给一个字段建立索引，查询的时候 根据这个字段查到这行数据对应的id</p>
<p>回表  再根据id 去查 聚簇索引 从而拿到一行数据</p>
<img src="https://pic.imgdb.cn/item/64c25a101ddac507cc6a77d8.jpg" style="zoom:50%;"> 
<p>一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的 Term 列表</p>
<h1><span id="分词">分词</span></h1>
<p>就是按照一定的规则，将一句话分成组合的单词</p>
<h1><span id="elasticsearch核心概念重点">Elasticsearch核心概念【重点】</span></h1>
<h2><span id="结构说明">结构说明</span></h2>
<table>
<thead>
<tr>
<th>Elasticsearch</th>
<th>Mysql</th>
</tr>
</thead>
<tbody>
<tr>
<td>Index(索引库)</td>
<td>Database(数据库)</td>
</tr>
<tr>
<td>Type（_doc）</td>
<td>Table(表)</td>
</tr>
<tr>
<td>Document(文档)</td>
<td>Row(行)</td>
</tr>
<tr>
<td>Field(字段)</td>
<td>Column(列)</td>
</tr>
<tr>
<td>mappings</td>
<td>列的类型约束(int,varchar…)</td>
</tr>
</tbody>
</table>
<p>这里的Type概念从ES6.x以后被弱化，官方将在ES8.0以后正式剔除他</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引库（indices）</td>
<td>把数据写入elasticsearch 时，会在里面建立索引，索引库里面存储索引，一个index 对应一个database</td>
</tr>
<tr>
<td>文档（document）</td>
<td>就是一条数据，一般使用json 表示，和数据库对比，就是一行数据，在java 里面就是一个一个对象</td>
</tr>
<tr>
<td>字段（field）</td>
<td>一个对象的属性，对应数据库就是一列</td>
</tr>
<tr>
<td>节点</td>
<td>一台运行elasticsearch的服务器，被称为一个节点</td>
</tr>
<tr>
<td>集群</td>
<td>多个节点组成一个集群</td>
</tr>
<tr>
<td>分片</td>
<td>一个索引可以存储在多个主分片上，有负载均衡的作用，还有从分片是主分片的一个副本</td>
</tr>
<tr>
<td>副本</td>
<td>一份数据可以有多个副本，做数据冗余（安全），一般放在从分片里面</td>
</tr>
</tbody>
</table>
<img src="https://pic.imgdb.cn/item/64c25e161ddac507cc73505e.jpg" style="zoom:50%;"> 
<h1><span id="elasticsearch安装">Elasticsearch安装</span></h1>
<h2><span id="拉取镜像">拉取镜像</span></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>
<h2><span id="运行镜像">运行镜像</span></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms256m -Xmx256m&quot;</span>  elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>
<h2><span id="测试访问-ip9200">测试访问 ip:9200</span></h2>
<p>异常：<code>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</code></p>
<p>运行<code>sysctl -w vm.max_map_count=262144</code> ，再重启容器</p>
<h1><span id="elasticsearch目录">Elasticsearch目录</span></h1>
<p><img src="https://pic.imgdb.cn/item/64c25a7d1ddac507cc6b37fc.jpg" alt></p>
<ol>
<li>bin：启动脚本</li>
<li>config:
<ol>
<li>elasticsearch.yml，ES的集群信息、对外端口、内存锁定、数据目录、跨域访问等属性的配置</li>
<li>jvm.options，ES使用Java写的，此文件用于设置JVM相关参数，如最大堆、最小堆</li>
<li>log4j2.properties，ES使用log4j作为其日志框架</li>
</ol>
</li>
<li>data：数据存放目录（索引数据）</li>
<li>plugins: ES的可扩展插件存放目录，如可以将ik中文分词插件放入此目录，ES启动时会自动加载</li>
</ol>
<h1><span id="ik分词的安装重点">IK分词的安装【重点】</span></h1>
<p>以插件的形式安装</p>
<h2><span id="官网下载">官网下载</span></h2>
<p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">IK分词下载</a>  （7.6.2版本）</p>
<h2><span id="拷贝至docker">拷贝至Docker</span></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> elasticsearch-analysis-ik-7.6.2.zip 【容器名称】:/usr/share/elasticsearch/plugins</span><br></pre></td></tr></table></figure>
<h2><span id="解压">解压</span></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip elasticsearch-analysis-ik-7.6.2.zip -d </span><br></pre></td></tr></table></figure>
<p>删除原zip文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf elasticsearch-analysis-ik-7.6.2.zip</span><br></pre></td></tr></table></figure>
<h2><span id="重启es测试">重启ES测试</span></h2>
<table>
<thead>
<tr>
<th>Ik分词方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ik_smart</td>
<td>分词的粒度较小，也叫智能分词</td>
</tr>
<tr>
<td>ik_max_word</td>
<td>分词的粒度较大，也叫最大力度分词</td>
</tr>
</tbody>
</table>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/_analyze</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我有个女朋友&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>ik_smart</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;有&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;个&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;女朋友&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>ik_max_word</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;有&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;个&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;女朋友&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;朋友&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure>
<h1><span id="elasticsearch基本使用重点">Elasticsearch基本使用【重点】</span></h1>
<p>Elasticsearch 是基于restful风格的http应用，即使用http动词形式对url资源进行操作（GET,POST,PUT,DELETE…）</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">ip:port/索引名/_doc/文档id</span><br><span class="line">&#123;请求体&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="操作索引-mappings">操作索引、mappings</span></h2>
<p>相当于MySQL建库建表约束</p>
<h3><span id="新增索引">新增索引</span></h3>
<p>新建一个student索引，给定几个字段约束</p>
<p>索引只能增删，不能修改</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PUT http://localhost:9200/student</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;birthDay&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3><span id="查询索引">查询索引</span></h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET http://localhost:9200/student</span><br></pre></td></tr></table></figure>
<h3><span id="查询索引mappings">查询索引mappings</span></h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET http://localhost:9200/student/_mappings </span><br></pre></td></tr></table></figure>
<h3><span id="删除索引">删除索引</span></h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">DELETE http://localhost:9200/student </span><br></pre></td></tr></table></figure>
<h2><span id="操作document">操作Document</span></h2>
<h3><span id="新增数据">新增数据</span></h3>
<p><strong>PUT方式（需指定id）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PUT http://localhost:9200/【索引名】/_doc/1</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;超人&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;birthDay&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64c262311ddac507cc7e0291.jpg" alt></p>
<p><strong>POST方式（自动生成id）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://localhost:9200/【索引名】/_doc</span><br></pre></td></tr></table></figure>
<h3><span id="查询数据">查询数据</span></h3>
<p>es中的查询叫 DSL查询语法 表现形式就是放在发送的请求体里面</p>
<p><strong>查询单个数据</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET http://localhost:9200/【索引名】/_doc/1 </span><br></pre></td></tr></table></figure>
<p><strong>查询全部数据</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET http://localhost:9200/【索引名】/_doc/_search </span><br></pre></td></tr></table></figure>
<h3><span id="修改数据">修改数据</span></h3>
<p><strong>PUT方式（覆盖）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PUT http://localhost:9200/【索引名】/_doc/1</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于没有赋值的字段会被空值覆盖（相当于清除），因此该修改方式不安全</p>
<p><strong>POST方式（保留）</strong></p>
 <figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://localhost:9200/【索引名】/_doc/1/_update </span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于没有赋值的字段会保留，因此该修改方式安全</p>
<h3><span id="删除数据">删除数据</span></h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">DELETE http://localhost:9200/【索引名】/_doc/1 </span><br></pre></td></tr></table></figure>
<h1><span id="spring-boot使用es重点">Spring Boot使用ES【重点】</span></h1>
<h2><span id="导入依赖">导入依赖</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以及Spring Boot、nacos注册中心、nacos配置中心依赖</p>
<h2><span id="添加配置">添加配置</span></h2>
<p>在 <code>application.yml</code>中添加如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">rest:</span></span><br><span class="line">      <span class="comment"># es的连接地址</span></span><br><span class="line">      <span class="attr">uris:</span> <span class="string">http://localhost:9200</span></span><br></pre></td></tr></table></figure>
<h2><span id="测试连接">测试连接</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchDemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchRestTemplate elasticsearchRestTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//测试连接</span></span><br><span class="line">        System.out.println(elasticsearchRestTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="操作实体类">操作实体类</span></h2>
<p>对索引的操作 ==&gt; 使用实体类操作</p>
<p><strong><code>@Document</code></strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>createIndex</td>
<td>启动时是否创建</td>
</tr>
<tr>
<td>indexName</td>
<td>索引名称</td>
</tr>
<tr>
<td>shards</td>
<td>分片个数</td>
</tr>
<tr>
<td>replicas</td>
<td>副本个数</td>
</tr>
<tr>
<td>refreshInterval</td>
<td>数据导入到索引里面，最多几秒搜索到</td>
</tr>
</tbody>
</table>
<p><strong><code>@Id</code></strong></p>
<p>默认使用keyword关键字模式，不进行分词</p>
<p><code> @Field</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>analyzer</td>
<td>导入时使用的分词</td>
</tr>
<tr>
<td>searchAnalyzer</td>
<td>搜索时使用的分词</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * es注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document(createIndex = true,indexName = &quot;clue&quot;,shards = 1,replicas = 2,refreshInterval = &quot;1s&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clue</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">//默认使用keyword关键字模式，不进行分词</span></span><br><span class="line">    <span class="meta">@Field</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * analyzer:导入时使用的分词</span></span><br><span class="line"><span class="comment">     * searchAnalyzer：搜索时使用的分词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text,searchAnalyzer = &quot;ik_max_word&quot;,analyzer = &quot;ik_smart&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text,searchAnalyzer = &quot;ik_max_word&quot;,analyzer = &quot;ik_smart&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fullname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String contactSummary;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String editTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String mphone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String appellation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String editBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String nextContactTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="创建索引和mappings约束">创建索引和mappings约束</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitDataConfig</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="comment">//注入es</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchRestTemplate elasticsearchRestTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//根据实体类的注解创建es索引</span></span><br><span class="line">        <span class="type">IndexOperations</span> <span class="variable">operations</span> <span class="operator">=</span> elasticsearchRestTemplate.indexOps(Clue.class);</span><br><span class="line">        <span class="comment">//根据实体类的注解创建映射关系</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">mapping</span> <span class="operator">=</span> operations.createMapping(Clue.class);</span><br><span class="line">        <span class="comment">//执行mapping</span></span><br><span class="line">        operations.putMapping(mapping);</span><br><span class="line">        <span class="comment">//从索引里面获取mappings</span></span><br><span class="line">        System.out.println(operations.getMapping());</span><br><span class="line">        <span class="comment">//初始化es数据并导入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="操作文档">操作文档</span></h2>
<h3><span id="创建cluerepository">创建ClueRepository</span></h3>
<p>类似通用Dao，封装了CRUD方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClueRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Goods, Integer&gt; &#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3><span id="新增数据">新增数据</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ClueRepository clueRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savaAllClue</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//新增商品数据100条</span></span><br><span class="line">    ArrayList&lt;Clue&gt; clues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        clues.add(</span><br><span class="line">            Clue.builder()</span><br><span class="line">            .id(i)</span><br><span class="line">            .fullname(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .appellation(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .owner(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .company(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .job(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .email(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .phone(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .website(<span class="string">&quot;XXX&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//批量新增</span></span><br><span class="line">    clueRepository.saveAll(clues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="根据id查询数据">根据id查询数据</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findClue</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(clueRepository.findById(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="查询所有数据">查询所有数据</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findAllClue</span><span class="params">()</span> &#123;</span><br><span class="line">    clueRepository.findAll().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="修改数据覆盖">修改数据(覆盖)</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UpdateClue</span><span class="params">()</span>&#123;</span><br><span class="line">    clueRepository.save(</span><br><span class="line">        Clue.builder().id(<span class="number">1000</span>).fullname(<span class="string">&quot;XXX&quot;</span>).build()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除数据">删除数据</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delClue</span><span class="params">()</span>&#123;</span><br><span class="line">    clueRepository.deleteById(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="复杂的查询操作重点">复杂的查询操作【重点】</span></h1>
<table>
<thead>
<tr>
<th>注意</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>match</td>
<td>会通过分词器去模糊匹配 例如：华为电脑，会把包含‘华为’，‘电脑’，都查出来</td>
</tr>
<tr>
<td>term</td>
<td>精确查找你的关键字,一般使用keywords的约束，使用term</td>
</tr>
<tr>
<td>matchPhrase</td>
<td>不分词查询，弥补了match和term</td>
</tr>
<tr>
<td>rang</td>
<td>范围查询</td>
</tr>
<tr>
<td>match、rang 同时出现</td>
<td>需要组合bool查询分页，排序是通用的查询，不需要通过bool组合使用，直接nativeSearchQueryBuilder使用</td>
</tr>
</tbody>
</table>
<h2><span id="查询常用类">查询常用类</span></h2>
<table>
<thead>
<tr>
<th>查询常用类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QueryBuilders</code></td>
<td>构造条件对象，例如matchQuery，rangeQuery，boolQuery等</td>
</tr>
<tr>
<td><code>NativeSearchQueryBuilder</code></td>
<td>组合条件对象，组合后使用build构建查询对象</td>
</tr>
<tr>
<td><code>HighlightBuilder</code></td>
<td>高亮的查询类，注意使用它的Field静态内部类</td>
</tr>
<tr>
<td><code>FunctionScoreQueryBuilder</code></td>
<td>权重类，注意它的FilterFunctionBuilder静态内部类</td>
</tr>
</tbody>
</table>
<h2><span id="关键字范围分页排序">关键字，范围，分页，排序</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFuZaSearch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//关键字，“华为” ，范围，分页，排序</span></span><br><span class="line">    <span class="type">MatchQueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;goodsName&quot;</span>, <span class="string">&quot;华为&quot;</span>);</span><br><span class="line">    <span class="type">RangeQueryBuilder</span> <span class="variable">rangeQueryBuilder</span> <span class="operator">=</span> QueryBuilders.rangeQuery(<span class="string">&quot;goodsStock&quot;</span>).from(<span class="number">700</span>).to(<span class="number">750</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用bool组合这两个查询</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().must(matchQueryBuilder).must(rangeQueryBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建组合器</span></span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    <span class="comment">//去build()构建查询对象</span></span><br><span class="line">    <span class="type">NativeSearchQuery</span> <span class="variable">nativeSearchQuery</span> <span class="operator">=</span> nativeSearchQueryBuilder</span><br><span class="line">            .withQuery(boolQueryBuilder)</span><br><span class="line">            .withPageable(PageRequest.of(<span class="number">0</span>, <span class="number">20</span>))    <span class="comment">//注意范围和分页有关系，可能查出来了，但是当前分页没有</span></span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;goodsPrice&quot;</span>).order(SortOrder.ASC))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用es查询 得到结果集</span></span><br><span class="line">    SearchHits&lt;Goods&gt; searchHits = elasticsearchRestTemplate.search(nativeSearchQuery, Goods.class);</span><br><span class="line">    searchHits.forEach(goodsSearchHit -&gt; &#123;</span><br><span class="line">        <span class="comment">//循环结果集，答应结果</span></span><br><span class="line">        System.out.println(goodsSearchHit.getContent());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="高亮查询">高亮查询</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//华为，模糊匹配</span></span><br><span class="line">    <span class="type">MatchQueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;goodsName&quot;</span>, <span class="string">&quot;华为&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HighlightBuilder.<span class="type">Field</span> <span class="variable">goodsName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>.Field(<span class="string">&quot;goodsName&quot;</span>).preTags(<span class="string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>).postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">NativeSearchQuery</span> <span class="variable">nativeSearchQuery</span> <span class="operator">=</span> nativeSearchQueryBuilder</span><br><span class="line">        .withQuery(matchQueryBuilder)</span><br><span class="line">        .withHighlightFields(goodsName)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//得到结果集 我们需要手动组装高亮字段</span></span><br><span class="line">    SearchHits&lt;Goods&gt; searchHits = elasticsearchRestTemplate.search(nativeSearchQuery, Goods.class);</span><br><span class="line"></span><br><span class="line">    List&lt;Goods&gt; goodsArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    searchHits.forEach(goodsSearchHit -&gt; &#123;</span><br><span class="line">        <span class="comment">//得到goods对象,但是这里面额goodsName属性不是高亮的，所以要改</span></span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> goodsSearchHit.getContent();</span><br><span class="line">        List&lt;String&gt; highlightField = goodsSearchHit.getHighlightField(<span class="string">&quot;goodsName&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">highlight</span> <span class="operator">=</span> highlightField.get(<span class="number">0</span>);</span><br><span class="line">        goods.setGoodsName(highlight);</span><br><span class="line">        goodsArrayList.add(goods);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(JSON.toJSONString(goodsArrayList));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="权重查询">权重查询</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWeight</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//手机名称 和卖点 都有的情况下，设置权重查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keyWords</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    <span class="comment">//创建权重数组</span></span><br><span class="line">    FunctionScoreQueryBuilder.FilterFunctionBuilder[] functionBuilders = <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置权重</span></span><br><span class="line">    functionBuilders[<span class="number">0</span>] = (<span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">        QueryBuilders.matchQuery(<span class="string">&quot;goodsName&quot;</span>, keyWords),</span><br><span class="line">        ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)<span class="comment">//给名称设置10的权重大小</span></span><br><span class="line">    ));</span><br><span class="line">    functionBuilders[<span class="number">1</span>] = (</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">            QueryBuilders.matchQuery(<span class="string">&quot;goodsBrief&quot;</span>, keyWords),</span><br><span class="line">            ScoreFunctionBuilders.weightFactorFunction(<span class="number">4</span>)<span class="comment">//给卖点设置4的权重</span></span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">    <span class="type">FunctionScoreQueryBuilder</span> <span class="variable">functionScoreQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>(functionBuilders);</span><br><span class="line"></span><br><span class="line">    functionScoreQueryBuilder.setMinScore(<span class="number">2</span>) <span class="comment">//设置最小分数</span></span><br><span class="line">        .scoreMode(FunctionScoreQuery.ScoreMode.FIRST);<span class="comment">//设置计分方式</span></span><br><span class="line"></span><br><span class="line">    <span class="type">NativeSearchQuery</span> <span class="variable">nativeSearchQuery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>().withQuery(functionScoreQueryBuilder).build();</span><br><span class="line">    SearchHits&lt;Goods&gt; searchHits = elasticsearchRestTemplate.search(nativeSearchQuery, Goods.class);</span><br><span class="line">    searchHits.forEach(goodsSearchHit -&gt; &#123;</span><br><span class="line">        <span class="comment">//循环结果集，答应结果</span></span><br><span class="line">        System.out.println(goodsSearchHit.getContent());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="es总结面试">Es总结面试</span></h1>
<h2><span id="为什么使用es结合项目业务来说">为什么使用es（结合项目业务来说）</span></h2>
<p>商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，（%name%）导致商品查询是全表扫描，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。 (数据量过大，而且用户经常使用查询的场景，对用户体验很好)</p>
<h2><span id="es用来做什么场景重点">es用来做什么（场景）重点</span></h2>
<p>\1. 商品存放 （业务数据的存放） 每个商品都是一个对象</p>
<p>\2. 日志统计 （整个应用的日志非常多，都要收集起来，方便后期做日志分析，数据回溯）</p>
<p>\3. 数据分析（大数据）（只要是电商，就要和tb，jd等对比价格，做数据分析等）</p>
<p>你做一个电商项目 你卖鞋子 衣服  你怎么 定价  鞋子 199 599 398</p>
<p>你写个爬虫（jsoup） 定期采集tb jd的数据库 做数据比对分析 做 竞品 分析</p>
<p>业务  商业</p>
<p>定期的做数据采集和分析 数据采集系统 定时任务去采集别的大型电商网站的数据，进行价格分析，从而定价，后期还要做竞品分析</p>
<h2><span id="什么是倒排索引">什么是倒排索引</span></h2>
<p>通常正排索引是通过id映射到对应的数据</p>
<p>倒排索引是将分词建立索引，通过分词映射到id，在通过id找到数据</p>
<p>详见文档4.2</p>
<h2><span id="es的存储数据的过程">es的存储数据的过程</span></h2>
<p>先写内存</p>
<p>当缓冲页满了或者时间到了就refresh操作将数据刷新到分片去 （这个操作使得搜索可见了）</p>
<p>分片有flush操作  将数据持久化到磁盘</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml9648\wps1.jpg)</p>
<p>1：写入请求，分发节点。</p>
<p>2：数据写入****同时写入内存和translog各一份****，tanslog为保证数据不丢失，每 5 秒，或每次请求操作结束前，会强制刷新 translog 日志到磁盘上</p>
<p>3：确定数据给那个分片，<em><strong>*refresh 刷新内存中数据到分片的segment*</strong></em>，默认1秒刷新一次，为了提高吞吐量可以增大60s。参数refresh_interval（<em><strong>*refresh操作使得写入文档搜索可见*</strong></em>）</p>
<p>4：<em><strong>*通过flush操作将segment刷新到磁盘中完成持久化，保存成功清除translog*</strong></em>，新版本es的 translog 不会在 segment 落盘就删，而是会保留，默认是512MB，保留12小时。每个分片。所以分片多的话 ，要考虑 translog 会带来的额外存储开销（<em><strong>*flush操作使得filesystem cache写入磁盘，以达到持久化的目的*</strong></em>） （<em><strong>*refresh之前搜索不可见*</strong></em>）</p>
<p>5：segment过多会进行合并merge为大的segment，消耗大量的磁盘io和网络io （方便数据整理和磁盘优化）</p>
<h2><span id="es的搜索过程">es的搜索过程</span></h2>
<p>1、搜索被执行成一个****两阶段过程****，我们称之为 <em><strong>*Query*</strong></em> Then <em><strong>*Fetch*</strong></em>；</p>
<p>2、在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分</p>
<p>片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的</p>
<p>优先队列。</p>
<p>注意：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory</p>
<p>Buffer，所以搜索是****接********近实时****的。</p>
<p>3、每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点（主节点），它合并</p>
<p>这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
<p>4、接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并****向相关的分片****</p>
<p><em><strong>*提交多个 GET 请求*</strong></em>。每个分片加载并 丰富 文档，如果有需要的话，接着返回</p>
<p>文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
<p><em><strong>*通俗的将就是：*</strong></em></p>
<p><em><strong>*每个分片先拿到id和排序值，然后整合成一个全局列表*</strong></em></p>
<p><em><strong>*然后通过判断找到相应的节点提交多个get请求，组装数据返回*</strong></em></p>
<p>5、补充：Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分</p>
<p>片的数据（score），这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增</p>
<p>加了一个****预查询****的处理，询问 Term 和 Document frequency，这个评分更准确，</p>
<p>但是性能会变差。</p>
<p><em><strong>*搜索因为有分片的存在 是有局限性的  每个分片都自己判断*</strong></em></p>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>gateway</title>
    <url>/post/gateway/</url>
    <content><![CDATA[<p><img src="https://pic.imgdb.cn/item/64be70e41ddac507ccce11f9.jpg" alt></p>
<h1><span id="使用gateway">使用gateway</span></h1>
<h2><span id="创建gateway模块">创建gateway模块</span></h2>
<p><img src="https://pic.imgdb.cn/item/64be71741ddac507cccfa816.jpg" alt></p>
<h2><span id="引入依赖">引入依赖</span></h2>
<p>在pom文件中引入如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-start-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加nacos依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="网关的配置方式">网关的配置方式</span></h2>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.5.RELEASE/reference/html/">Spring Cloud Gateway</a></p>
<h3><span id="配置文件">配置文件</span></h3>
<p>在application.yml文件中添加如下配置：（注意Path是以大写开头）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">toUser</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">          <span class="attr">uri:</span></span><br><span class="line">            <span class="string">http://localhost:2001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">toActivity</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/activity/**</span></span><br><span class="line">          <span class="attr">uri:</span></span><br><span class="line">            <span class="string">http://localhost:3001</span></span><br></pre></td></tr></table></figure>
<p>查看routes定义位置，可以看出routes为一个集合，集合中每个元素的类型为RouteDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoutes</span><span class="params">(List&lt;RouteDefinition&gt; routes)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.routes = routes;</span><br><span class="line">    <span class="keyword">if</span> (routes != <span class="literal">null</span> &amp;&amp; routes.size() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Routes supplied from Gateway Properties: &quot;</span> + routes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看RouteDefinition定义位置，可以看出有如下属性定义，其中非空的有<code>predicates</code>、<code>uri</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotEmpty</span> <span class="meta">@Valid</span> List&lt;PredicateDefinition&gt; predicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Valid</span> List&lt;FilterDefinition&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotNull</span> URI uri;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; metadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RouteDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="配置类">配置类</span></h3>
<p>在CustomRouteConfig.java类中进行如下配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRouteConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(</span><br><span class="line">                        <span class="string">&quot;toUser&quot;</span>,</span><br><span class="line">                        predicateSpec -&gt; predicateSpec</span><br><span class="line">                                .path(<span class="string">&quot;/user/**&quot;</span>)</span><br><span class="line">                                .uri(<span class="string">&quot;http://localhost:2001&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .route(</span><br><span class="line">                        <span class="string">&quot;toActivity&quot;</span>,</span><br><span class="line">                        predicateSpec -&gt; predicateSpec</span><br><span class="line">                                .path(<span class="string">&quot;/activity/**&quot;</span>)</span><br><span class="line">                                .uri(<span class="string">&quot;http://localhost:3001&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="动态路由">动态路由</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">crm-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="comment"># 开启动态路由</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 所有服务名称转为小写</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>http://localhost:1001/crm-user/user/list</code> <em>-&gt;</em> 负载均衡访问{<code>http://localhost:2001/user/list,http://localhost:2002/user/list</code>}<br>
<code>http://localhost:1001/crm-activity/activity/list</code> <em>-&gt;</em> 负载均衡访问{<code>http://localhost:3001/activity/list</code>}</p>
<h2><span id="负载均衡">负载均衡</span></h2>
<p>配置文件与配置类中设置负载均衡</p>
<p>只需将     <code>uri: http://localhost:3001</code> 改为   <code>uri: lb://crm-user</code> 即<code>http</code>改为<code>lb</code>，双斜杠后缀改为微服务模块名称(使用全局过滤器：ReactiveLoadBalancerClientFilter)</p>
<h2><span id="断言规则">断言规则</span></h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">toActivity</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Xxx=xxx</span></span><br><span class="line">          <span class="attr">uri:</span></span><br><span class="line">            <span class="string">http://localhost:3001</span></span><br></pre></td></tr></table></figure>
<p>断言规则实际上是<code>List*&lt;PredicateDefinition&gt;</code>集合，集合元素类型为<code>PredicateDefinition</code></p>
<p>在application.yml中的predicates进行配置</p>
<p>若请求满足指定的断言规则，则将请求转发至 <code>http://localhost:3001 </code></p>
<ol>
<li>对于多个断言规则，则满足逻辑与的关系</li>
<li>yaml形式配置中多以大写字母开头，java类形式配置中多以小写字母开头</li>
</ol>
<p>具体的断言规则如下：</p>
<h3><span id="path路由断言">Path路由断言</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/activity/**</span></span><br></pre></td></tr></table></figure>
<p>请求<strong>相对路径</strong>满足以 <code>/acitvity</code> 开头</p>
<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">predicateSpec -&gt; predicateSpec</span><br><span class="line">    .path(<span class="string">&quot;/activity/**&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="after-before-between-路由断言">After、Before、Between 路由断言</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">After=2023-07-25T15:49:25.851+08:00[Asia/Shanghai]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Before=2023-07-25T15:53:25.851+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="comment"># - Between=2023-07-25T15:49:25.851+08:00[Asia/Shanghai],2023-07-25T15:53:25.851+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在 2023-07-25 15:49:25 <strong>之后</strong>请求（上海时间）</li>
<li>且在 2023-07-25 15:53:25 <strong>之前</strong>请求（上海时间）</li>
</ol>
<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">predicateSpec -&gt; predicateSpec</span><br><span class="line">    .after(ZonedDateTime.now().plusMinutes(<span class="number">1</span>))</span><br><span class="line">    .and()</span><br><span class="line">    .before(ZonedDateTime.now().plusMinutes(<span class="number">5</span>))</span><br><span class="line">    <span class="comment">//.between(ZonedDateTime.now().plusMinutes(1),ZonedDateTime.now().plusMinutes(5))</span></span><br></pre></td></tr></table></figure>
<h3><span id="cookie-路由断言">Cookie 路由断言</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Cookie=aaa,bbb</span></span><br></pre></td></tr></table></figure>
<p>具有<strong>Cookie</strong>其中键为“aaa”，值为“bbb”</p>
<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">predicateSpec -&gt; predicateSpec</span><br><span class="line">    .cookie(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="header-路由断言">Header 路由断言</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Header=aaa,bbb</span></span><br></pre></td></tr></table></figure>
<p><strong>请求头</strong>必须有键为“aaa”、值为“bbb”的参数</p>
<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">predicateSpec -&gt; predicateSpec</span><br><span class="line">    .header(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="host-路由断言">Host 路由断言</span></h3>
<h3><span id="method-路由断言">Method 路由断言</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>
<p><strong>请求方式</strong>必须使用GET或Post</p>
<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">predicateSpec -&gt; predicateSpec</span><br><span class="line">    .method(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="query-路由断言">Query 路由断言</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Query=aaa,bbb</span></span><br></pre></td></tr></table></figure>
<p>具有<strong>请求参数</strong>键为“aaa”，值为“bbb”</p>
<p>配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">predicateSpec -&gt; predicateSpec</span><br><span class="line">    .query(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2><span id="过滤器">过滤器</span></h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">toActivity</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Xxx=xxx</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Xxx=xxx</span></span><br><span class="line">          <span class="attr">uri:</span></span><br><span class="line">            <span class="string">http://localhost:3001</span></span><br></pre></td></tr></table></figure>
<p>配置类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRouteConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(</span><br><span class="line">                        <span class="string">&quot;toActivity&quot;</span>,</span><br><span class="line">                        predicateSpec -&gt; predicateSpec</span><br><span class="line">                                .filters(</span><br><span class="line">                                        filter -&gt; filter</span><br><span class="line">                                                .addRequestHeader(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">                                                .addRequestParameter(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">                                                .addResponseHeader(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">                                )</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/64bf8c3b1ddac507ccf32903.jpg" style="zoom:50%;">
<h3><span id="请求头的添加与删除">请求头的添加与删除</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">AddRequestHeader=aaa,bbb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RemoveRequestHeader=aaa</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter -&gt; filter</span><br><span class="line">        .addRequestHeader(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">        .removeRequestHeader(<span class="string">&quot;aaa&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="请求参数的添加与删除">请求参数的添加与删除</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">AddRequestParameter=aaa,bbb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RemoveRequestParameter=aaa</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter -&gt; filter</span><br><span class="line">        .addRequestParameter(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">        .removeRequestParameter(<span class="string">&quot;aaa&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="响应头的添加与删除">响应头的添加与删除</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">AddResponseHeader=aaa,bbb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RemoveResponseHeader=aaa</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter -&gt; filter</span><br><span class="line">        .addResponseHeader(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">        .removeResponseHeader(<span class="string">&quot;aaa&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="重定向">重定向</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RedirectTo=300,https://www.baidu.com</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter -&gt; filter</span><br><span class="line">        .redirect(<span class="number">300</span>, <span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="路径重写">路径重写</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RewritePath=/red(?&lt;segment&gt;/?.*),</span> <span class="string">/activity/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter -&gt; filter</span><br><span class="line">        .rewritePath(<span class="string">&quot;/red(?&lt;segment&gt;/?.*)&quot;</span>,<span class="string">&quot;/activity/$\\&#123;segment&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>将以<code>red</code>开头的路径转换成以<code>/acitivity/</code>开头的路径</p>
<h3><span id="设置响应状态码">设置响应状态码</span></h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SetStatus=404</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter -&gt; filter</span><br><span class="line">        .setStatus(<span class="number">404</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="修改响应体">修改响应体</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter -&gt; filter</span><br><span class="line">    .modifyResponseBody(</span><br><span class="line">    <span class="comment">//要修改的数据类型</span></span><br><span class="line">    String.class,</span><br><span class="line">    <span class="comment">//修改后的数据类型</span></span><br><span class="line">    String.class,</span><br><span class="line">    <span class="comment">//修改后的响应类型</span></span><br><span class="line">    <span class="string">&quot;application/json;charset=utf-8&quot;</span>,</span><br><span class="line">    <span class="comment">//修改响应体的业务逻辑（参数serverWebExchange，可通过该对象获取请求或响应对象，参数responseBody，响应体数据）</span></span><br><span class="line">    (serverWebExchange, responseBody) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改前的响应体：&quot;</span> + responseBody);</span><br><span class="line">        HashMap&lt;Object, Object&gt; modifyResponseBody = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        modifyResponseBody.put(<span class="string">&quot;data&quot;</span>, responseBody);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(modifyResponseBody);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(s);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2><span id="自定义过滤器">自定义过滤器</span></h2>
<p>实现接口GlobalFilter、Ordered</p>
<p>GlobalFIlter重写FIlter方法，拦截器执行的业务逻辑</p>
<p>Ordered重写Ordered方法，拦截器的执行顺序</p>
<p>​	数字越小优先级越高，反之越低（HIGHEST_PRECEDENCE = 2147483647，LOWEST_PRECEDENCE = -2147483648）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">customFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//简单的权限校验：必须传递token令牌才能进行路由操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> exchange.getRequest().getHeaders().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//String token = exchange.getRequest().getQueryParams().getFirst(&quot;token&quot;);</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有权限则返回错误信息</span></span><br><span class="line">        Map&lt;String,Object&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        resultMap.put(<span class="string">&quot;code&quot;</span>, <span class="number">500</span>);</span><br><span class="line">        resultMap.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;您没有该权限&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytes = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsBytes(resultMap);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        exchange.getResponse().getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().writeWith(</span><br><span class="line">                Mono.just(exchange.getResponse().bufferFactory().wrap(bytes))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Git</title>
    <url>/post/git/</url>
    <content><![CDATA[<h2><span id="git">Git</span></h2>
<p>Git是分布式代码版本管理系统，其分为客户端和服务端两个部分</p>
<p>服务器端：大家共同存储的一个终端，可以自己搭建，也可以选择别的公司更好的的处理</p>
<p>本地机： 程序员自己的电脑，保存编写的代码</p>
<p>Git服务端的具体产品有GitHub（国外的喵咪）和Gitee（国内的码云）两款比较出名</p>
<h2><span id="常用术语">常用术语</span></h2>
<table>
<thead>
<tr>
<th>常用术语</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>本地仓库（Repository）</td>
<td>保存了工程开发中的每一个迭代版本</td>
</tr>
<tr>
<td>远程仓库</td>
<td>远程保存推送的版本，使用github、码云等网站可以进行远程版本库的创建</td>
</tr>
<tr>
<td>工作区（Working Directory)</td>
<td>本地电脑上的工作目录文件夹</td>
</tr>
<tr>
<td>暂存区（Staging area）</td>
<td>暂存对工作区中文件的操作</td>
</tr>
<tr>
<td>索引（Index）</td>
<td>暂存区的别名</td>
</tr>
<tr>
<td>签入（Check in）</td>
<td>将新版本复制回仓库</td>
</tr>
<tr>
<td>签出（Check out）</td>
<td>从仓库中将文件的最新修订版本复制到工作区</td>
</tr>
<tr>
<td>提交（Commit）</td>
<td>将暂存区的文件提交到本地仓库</td>
</tr>
<tr>
<td>冲突（Conflict）</td>
<td>多人对同一文件的同一部分进行了修改，导致了冲突的发生</td>
</tr>
<tr>
<td>分支（Branch）</td>
<td>两个子版本，当前版本出现了两个不同分支</td>
</tr>
<tr>
<td>合并（Merge）</td>
<td>将指定的不同的版本合并成当前版本，合并过程中对于冲突的文件需要手动选择保留哪个文件</td>
</tr>
<tr>
<td>头（HEAD）</td>
<td>指向当前选择的分支</td>
</tr>
<tr>
<td>修订（Revision）</td>
<td>表示代码的一个版本状态。Git通过用SHA1 hash算法表示的ID来标识不同的版本</td>
</tr>
<tr>
<td>标记（Tags）</td>
<td>标记某个分支的某一个版本，方便检索和查看</td>
</tr>
<tr>
<td>推送（Push）</td>
<td>将当前的版本推送到远程仓库</td>
</tr>
<tr>
<td>拉取（Pull）</td>
<td>从远程仓库拉取文件，并合并入当前分支</td>
</tr>
<tr>
<td>add</td>
<td>添加新的文件（文件夹）到Git项目中，如果添加文件夹，该文件夹下所有文件将被包含</td>
</tr>
<tr>
<td>reset</td>
<td>选择commit前面版本重新开始编辑，通常是选择恢复到上一个编辑点</td>
</tr>
<tr>
<td>diff</td>
<td>找出两个文档或目录的不同</td>
</tr>
<tr>
<td>revert</td>
<td>恢复版本到某个commit前（即使push也能恢复，相当于过去的版本重新覆盖当前版本）</td>
</tr>
<tr>
<td>undo commit</td>
<td>撤销某个commit（push后无法撤销）</td>
</tr>
<tr>
<td>clone</td>
<td>从目标服务器下载整个用Git管理项目的</td>
</tr>
<tr>
<td>issues</td>
<td>问题</td>
</tr>
<tr>
<td>fork</td>
<td>分叉</td>
</tr>
<tr>
<td>rebase</td>
<td>重定</td>
</tr>
<tr>
<td>star</td>
<td>星</td>
</tr>
</tbody>
</table>
<h2><span id="本地开发">本地开发</span></h2>
<h3><span id="文件状态">文件状态</span></h3>
<table>
<thead>
<tr>
<th>文件状态</th>
<th>说明</th>
<th>存储位置</th>
<th>去向</th>
</tr>
</thead>
<tbody>
<tr>
<td>Untracked</td>
<td>未跟踪</td>
<td>仅工作区，未进行版本控制</td>
<td>可通过git add 将其加入暂存区</td>
</tr>
<tr>
<td>Staged</td>
<td>已暂存</td>
<td>工作区-&gt;暂存区</td>
<td>commit 加入本地仓库则变为Unmodified，修改则变为Modified</td>
</tr>
<tr>
<td>Modified</td>
<td>已修改</td>
<td>工作区、暂存区（内容不同）</td>
<td>commit 将修改文件加入暂存区并上传至本地仓库，或checkout 丢弃修改, 返回unmodify状态（用暂存区的文件覆盖工作区文件）</td>
</tr>
<tr>
<td>Unmodified</td>
<td>未修改</td>
<td>工作区、本地仓库（内容相同）</td>
<td>修改则变为Modified，移出本地仓库则变为Untracked</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/649d4b211ddac507cc5e3677.jpg" alt></p>
<ol>
<li>在工作区新建一个文件 a.txt 。 此时文件状态为 Untracked</li>
<li>执行 git add a.txt 。 此时文件状态为 Staged</li>
<li>修改 a.txt 文件并保存，此时文件状态为 Modified，此时可进行两种操作：
<ol>
<li>执行 git add a.txt 。 此时文件状态又为 Staged</li>
<li>执行 git commit -m ‘提交a文件’ ，此时文件状态变为 Unmodified，此时可进行：
<ol>
<li>执行 git rm --cached a.txt 。此时工作区的a.txt变为Untracked状态</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3><span id="数据结构">数据结构</span></h3>
<p>某个结点表示该版本中的所有文件。箭头表示HEAD指针。</p>
<p><img src="https://pic.imgdb.cn/item/649e74731ddac507cc1ea93a.jpg" alt></p>
<h3><span id="常用命令">常用命令</span></h3>
<table>
<thead>
<tr>
<th>常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td>在当前目录下生成一个名为.git的文件夹，该文件夹即为版本库</td>
</tr>
<tr>
<td>git config</td>
<td>在将版本提交到版本库之前需要使用git config <a href="http://user.name">user.name</a> xxx和git config user.email xxx设置好个人身份签名</td>
</tr>
<tr>
<td>git add xxx</td>
<td>将处理后的文件xxx的最新状态同步至暂存区中</td>
</tr>
<tr>
<td>git commit -m “XXX”</td>
<td>将暂存区中暂存的所有改动写进版本库中，形成一个新的版本。commit log表示对该版本的一个说明</td>
</tr>
<tr>
<td>git status</td>
<td>查看工作区（在工作区中进行了改动还未同步到暂存区的文件）、暂存区（在暂存区中还未写入版本库的文件）的状态</td>
</tr>
<tr>
<td>git log</td>
<td>显示版本库中，HEAD指针之前的所有版本的详细信息（space向下翻页、b向上翻页、q退出）</td>
</tr>
<tr>
<td>git log --oneline</td>
<td>显示版本库中，HEAD指针之前的所有版本的简略信息</td>
</tr>
<tr>
<td>git reflog</td>
<td>显示版本库中，HEAD指针之前及之后的所有版本的简略信息</td>
</tr>
<tr>
<td>git reset --hard xxx</td>
<td>将HEAD指针移动到版本哈希为xxx的版本处，并使工作区重置为该版本下的状态</td>
</tr>
<tr>
<td>git revert versionX…versionY</td>
<td>执行版本X到版本Y之间（不含X含Y）所有版本的逆向操作，使得这些版本的提交所造成的影响被撤销。对指定的每个版本进行撤销都会产生一次新的提交记录。（可添加–no-commit参数使得对所有版本的撤销操作全都保存在暂存区中，再通过commit命令一次性提交）</td>
</tr>
<tr>
<td>git diff 文件名</td>
<td>查看这个文件和之前文件的对比</td>
</tr>
</tbody>
</table>
<h2><span id="远程多人协作">远程多人协作</span></h2>
<p>远程仓库地址：用于定位远程仓库。以github为例，其为每个仓库提供HTTPS协议和SSH协议的两种地址</p>
<h3><span id="常用命令">常用命令</span></h3>
<table>
<thead>
<tr>
<th>常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>git remote add 【别名】【 远程仓库地址】</td>
<td>为远程仓库地址取别名</td>
</tr>
<tr>
<td>git remote -v</td>
<td>查看当前所有的远程仓库别名</td>
</tr>
<tr>
<td>git clone【 远程仓库地址】</td>
<td>将远程仓库完整下载下来成为本地仓库</td>
</tr>
<tr>
<td>git pull 【远程仓库地址别名】【 远程分支名】</td>
<td>将远程仓库中的指定分支拉取到本地，pull操作等同于fetch操作+merge操作</td>
</tr>
<tr>
<td>git fetch【远程仓库地址别名】/【 远程分支名】</td>
<td>获取远程仓库中的指定分支到本地</td>
</tr>
<tr>
<td>git push【远程仓库别名】【 本地分支名】</td>
<td>将本地仓库指定分支中HEAD指针所指的版本推送到远程仓库中，作为远程仓库的一次版本更新</td>
</tr>
</tbody>
</table>
<ol>
<li>推送到远程仓库的版本必须是基于远程仓库中最新版本所做的修改。否则，需要先	pull拉取最新的内容后再push推送</li>
<li>只有远程仓库所属团队的团队成员才能够执行push操作对该远程仓库进行更新</li>
</ol>
<h3><span id="pull-request">pull request</span></h3>
<p>非远程仓库所属团队的团队成员需通过pull request的方式贡献代码</p>
<ol>
<li>对他人的远程仓库进行fork。该操作将会得到一个他人远程仓库的完整副本，并且该远程仓库副本是属于自己的</li>
<li>将贡献的代码更新到fork出来的自己的远程仓库中</li>
<li>在fork出来的自己的远程仓库中执行pull request操作，请求原远程仓库所属团队成员进行代码审核，来将自己改动的内容合并进他们的远程仓库中</li>
</ol>
<h2><span id="分支管理">分支管理</span></h2>
<ol>
<li>git支持分布式开发，集中式开发，分支式处理</li>
<li>以主分支为核心，创建子分支，利用子分支扩张内容，最后与主分支合并</li>
<li>从数据上来说呢，每个分支相当于独立的，我们可以在当前分支中进行回溯和查看版本（如:git reflog）</li>
<li>分支可以任意的切换</li>
<li>主分支master一般不处理具体的内容，主要负责调配调用子分支，子分支负责处理具体的内容</li>
</ol>
<h3><span id="数据结构">数据结构</span></h3>
<p>（在分支X下仅能操作分支X自身的HEAD指针）</p>
<p><img src="https://pic.imgdb.cn/item/649e74b41ddac507cc1f0eac.jpg" alt></p>
<h3><span id="合并">合并</span></h3>
<p><strong>fast forward</strong></p>
<p><img src="https://pic.imgdb.cn/item/649e74cf1ddac507cc1f3c19.jpg" alt></p>
<ol>
<li>原分支（Master）的HEAD指针移动至其他分支（Branch）的HEAD指针处。</li>
<li>分支后，原分支未进行过提交。</li>
</ol>
<p><strong>three way merge</strong></p>
<p><img src="https://pic.imgdb.cn/item/649e74f31ddac507cc1f6f68.jpg" alt></p>
<p>处于该种情况时，在原分支（Master）下对其他分支（Branch）进行的合并操作会使得原分支产生一次新的提交</p>
<p>合并时，git会比对版本F和版本G相对于它们的公共祖先版本C所做的改动：</p>
<ol>
<li>版本F和版本G相对于版本C新增的文件，在版本H中都会存在（新增文件名相同文件某行内容不同也会发生冲突）</li>
<li>版本F和版本G相对于版本C减少的文件，在版本H中都不会存在</li>
<li>若两个分支都对同一个文件中的同一行进行了修改，则会发生冲突</li>
<li>若一个分支删除了另一个分支进行了修改的文件，则会发生冲突</li>
</ol>
<h3><span id="变基">变基</span></h3>
<p><img src="https://pic.imgdb.cn/item/64a528f01ddac507cc587076.jpg" alt>主分支发生了变化，主分支由其他的子分支合并了新的内容，另一个子分支也需要新增的这些内容，就可以让子分支变基(让主分支的新的内容重新分配给子分支)</p>
<p>先选择要变基的子分支，选中主分支右键选择Rebase即可，主分支中的内容就会重新分配给当前子分支。</p>
<p>情况一:主分支新建了一个子分支，都有内容的改变，推荐先让子分支合并到主分支中，子分支在变基，最后子分支在合并到主分支中。</p>
<p>情况二:分支不是由master创建的，而是由其他的子分支创建的，可以正常使用，分支结构线会有点乱</p>
<p>使用多条分支来并发地推进多个任务</p>
<h3><span id="冲突">冲突</span></h3>
<p><img src="https://pic.imgdb.cn/item/649e75081ddac507cc1f8e4c.jpg" alt></p>
<p>冲突的解决：编辑修改好发生冲突的文件x后，执行git add x和git commit -m “message”</p>
<h3><span id="常用命令">常用命令</span></h3>
<table>
<thead>
<tr>
<th>常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>git branch【分支名】</td>
<td>创建名【分支名】的分支。（在当前HEAD指针所指版本上创建了一个新的HEAD指针）</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看本地仓库中的所有分支，* 开头的分支为当前分支</td>
</tr>
<tr>
<td>git checkout【分支名】</td>
<td>切换到名为【分支名】的分支下，并使工作区重置为该分支的HEAD指针所指版本下的状态</td>
</tr>
<tr>
<td>git merge【分支名】</td>
<td>将该分支的内容合并进当前分支</td>
</tr>
</tbody>
</table>
<h2><span id="gitflow工作流">GitFlow工作流</span></h2>
<table>
<thead>
<tr>
<th>分支</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>主干分支master</td>
<td>仅负责更新正在运行的生产环境下的版本</td>
</tr>
<tr>
<td>Bug修理分支bugfix</td>
<td>负责更新master分支中出现紧急bug后，进行bug修复的版本。修复完毕后将并回master分支</td>
</tr>
<tr>
<td>预发布分支release</td>
<td>负责更新准备发布到主干分支的预发布版本，供一小部分发烧用户预先使用，来收集意见以及测试bug。若出现bug，一般直接在该分支下进行修复；若无问题，则并入主干分支</td>
</tr>
<tr>
<td>开发分支develop</td>
<td>负责更新开发过程中的版本，一般仅在该分支中更新短周期的开发。当开发完成到一定阶段后，将并入预发布分支，进行正式发布前的最后测试</td>
</tr>
<tr>
<td>功能分支feature</td>
<td>负责更新针对某一功能的需要进行长周期开发的版本，使得对不同功能的开发可以并行推进，并且不会影响到开发分支中短周期的开发工作。功能开发完成后，将并入开发分支</td>
</tr>
</tbody>
</table>
<h2><span id="安装git">安装git</span></h2>
<p><a href="https://git-scm.com/">Git官网</a>(注意安装路径不能有中文)</p>
<p><a href="https://gitee.com/">Gitee官网</a></p>
<h2><span id="使用git">使用Git</span></h2>
<p><strong>本地机设置提交码云的用户名和全局邮箱</strong></p>
<p>右键打开git-bash</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>
<h3><span id="idea配置git">idea配置Git</span></h3>
<p><img src="https://pic.imgdb.cn/item/649d42901ddac507cc4dfe2a.jpg" alt></p>
<h3><span id="idea配置gitee">idea配置Gitee</span></h3>
<p><img src="https://pic.imgdb.cn/item/649d433f1ddac507cc4f35b3.jpg" alt></p>
<h3><span id="ssh-配置">SSH 配置</span></h3>
<p>若远程仓库地址使用的是SSH协议，则需要生成公钥（id_rsa.pub文件）</p>
<ol>
<li>右键Git Bash Here打开终端窗口 <code>ssh-keygen -t rsa -C &quot;XXXXXXXXX@qq.com&quot;</code></li>
<li>按照提示完成三次回车生成 ssh key</li>
<li><code>cat ~/.ssh/id_rsa.pub</code>  查看生成的钥匙信息</li>
<li>复制ssh公钥添加到Gitee的SSH公钥管理</li>
<li>回到终端窗口 <code>ssh -T git@gitee.com</code>  <code>Hi XXX! You've successfully authenticated, but Gitee.com does not provide shell access.</code> 则添加成功</li>
</ol>
<h3><span id="上传gitee远程仓库">上传Gitee远程仓库</span></h3>
<img src="https://pic.imgdb.cn/item/649d4bad1ddac507cc5f4404.jpg" style="zoom:67%;">
<h3><span id="首次提交">首次提交</span></h3>
<p><img src="https://pic.imgdb.cn/item/64a3eab71ddac507cc353cfb.jpg" alt></p>
<h3><span id="新增文件交给git">新增文件交给Git</span></h3>
<p><img src="https://pic.imgdb.cn/item/64a3eb3c1ddac507cc365cee.jpg" alt></p>
<p>新建文件会提示add的操作，将新建文件加入到git的本地暂存区，让文件被git管理</p>
<h3><span id="提交新版本">提交新版本</span></h3>
<p><img src="https://pic.imgdb.cn/item/64a3ebd81ddac507cc37aa06.jpg" alt></p>
<p>选择需要提交到本地仓库的文件</p>
<p><img src="https://pic.imgdb.cn/item/64a3ec561ddac507cc38cec2.jpg" alt>commit 将处理好的代码文件提交到版本库中，形成一个新的版本</p>
<h3><span id="版本内容对比">版本内容对比</span></h3>
<ol>
<li>选择提交版本</li>
<li>右侧在选择的版本中指定要对比的文件</li>
<li>点击 Show Diff 展示版本文件对比</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/64a50da51ddac507cc1ae605.jpg" alt></p>
<h3><span id="推送至远程仓库">推送至远程仓库</span></h3>
<p><img src="https://pic.imgdb.cn/item/64a3ecb81ddac507cc39c937.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/64a3f4841ddac507cc4ac21c.jpg" alt>push 将git仓库中的内容推送到码云的远程服务器上</p>
<h3><span id="更新项目">更新项目</span></h3>
<p>若远程仓库与本地仓库版本不一致，需要先对本地仓库版本备份，拉取（更新）远程仓库的版本并合并（解决冲突）</p>
<p><img src="https://pic.imgdb.cn/item/64a3ff831ddac507cc602e12.jpg" alt></p>
<p><img src="/post/git/C:%5CUsers%5Cbiyixia%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230704184312999.png" alt="image-20230704184312999"></p>
<p><strong>冲突发生情况</strong></p>
<table>
<thead>
<tr>
<th>本地仓库版本</th>
<th>远程仓库版本</th>
<th>更新项目</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有改变</td>
<td>改变</td>
<td>直接更新到本地仓库</td>
</tr>
<tr>
<td>改变</td>
<td>改变</td>
<td>可能发生冲突</td>
</tr>
<tr>
<td>/</td>
<td>没有改变</td>
<td>无更新</td>
</tr>
</tbody>
</table>
<p><strong>如何避免冲突</strong></p>
<ol>
<li>错开推送代码到远程仓库的时间</li>
<li>在更新版本代码前，需先将远程仓库版本更新到本地仓库</li>
</ol>
<h3><span id="撤销提交">撤销提交</span></h3>
<p><strong>undo commit</strong></p>
<p>提交本地仓库版本后，<strong>若尚未推送至远程仓库</strong>，则可以撤销本次提交且删除记录</p>
<p><img src="https://pic.imgdb.cn/item/64a4caac1ddac507cc9969d0.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/64a4cb431ddac507cc9a89af.jpg" alt></p>
<p>撤销提交不会将暂存区的改动撤销，还需要手动回滚</p>
<p><img src="https://pic.imgdb.cn/item/64a4e5341ddac507ccce2a62.jpg" alt></p>
<h3><span id="恢复提交">恢复提交</span></h3>
<p><strong>revert commit</strong></p>
<p>提交本地仓库版本后，<strong>若已经推送至远程仓库</strong>，则只能恢复先前的版本（相当于重新提交先前做过的修改），留下操作记录</p>
<p>恢复提交会将暂存区的改动撤销</p>
<p><img src="https://pic.imgdb.cn/item/64a4e0a41ddac507ccc5781d.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/64a4e0c51ddac507ccc5bc38.jpg" alt></p>
<h3><span id="版本回溯">版本回溯</span></h3>
<p>将版本回溯至指定版本，版本回溯会将暂存区的改动撤销</p>
<p>版本回溯会清空 <strong>指定回溯版本后的</strong> 、<strong>未推送的</strong>版本记录</p>
<p><img src="https://pic.imgdb.cn/item/64a4e4261ddac507cccc246f.jpg" alt></p>
<p><img src="/post/git/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230705113217378.png" alt="image-20230705113217378"></p>
<h3><span id="创建分支">创建分支</span></h3>
<p>右键将在当前分支的头结点创建分支，创建后自动切换到新建的分支</p>
<p><img src="https://pic.imgdb.cn/item/64a4e7641ddac507ccd21c51.jpg" alt></p>
<h3><span id="合并主分支">合并主分支</span></h3>
<p>将子分支合并到主分支中，主分支就拥有了主分支的所有内容</p>
<p>右键主分支，切换至主分支</p>
<p><img src="https://pic.imgdb.cn/item/64a4e8581ddac507ccd3c92e.jpg" alt></p>
<p>右键新分支，将新分支提交版本合并到主分支</p>
<p><img src="https://pic.imgdb.cn/item/64a4e8961ddac507ccd43acc.jpg" alt></p>
<p>合并后会覆盖主分支中的内容</p>
<h2><span id="菜单图标">菜单图标</span></h2>
<p>​		 <!--mybatis框架的环境--> <dependency>     <groupid>org.mybatis</groupid>     <artifactid>mybatis</artifactid>     <version>${mybatis-version}</version> </dependency><!-- 分页插件jar --><dependency>    <groupid>com.github.pagehelper</groupid>    <artifactid>pagehelper</artifactid>    <version>5.2.0</version></dependency></p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>html学习</title>
    <url>/post/html%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTML">HTML</a>（HyperText Markup Language，超文本标记语言）是一种用来告知浏览器如何组织页面的<em>标记语言</em>。HTML 可复杂、可简单，一切取决于 web 开发者。</p>
<ul>
<li>语法不严谨</li>
<li>不区分大小写</li>
<li>自动填充没有编写的语法</li>
</ul>
<h2><span id="元素">元素</span></h2>
<ul>
<li><strong>开始标签</strong>（Opening tag）：包含元素的名称（本例为 <em>p</em>），被左、右角括号所包围。开头标签标志着元素开始或开始生效的地方。在这个示例中，它在段落文本的开始之前。</li>
<li><strong>内容</strong>（Content）：元素的内容，本例中就是段落的文本。</li>
<li><strong>结束标签</strong>（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这标志着该元素的结束。没有包含关闭标签是一个常见的初学者错误，它可能会产生奇特的结果。</li>
</ul>
<p>整个元素即指开始标签、内容、结束标签三部分组成的整体。</p>
<h3><span id="嵌套元素">嵌套元素</span></h3>
<p>My cat is <strong>very</strong> grumpy.</p>
<h3><span id="元素分类">元素分类</span></h3>
<ul>
<li>块级元素在页面中以块的形式展现。一个块级元素出现在它前面的内容之后的新行上。任何跟在块级元素后面的内容也会出现在新的行上。块级元素通常是页面上的结构元素。例如，一个块级元素可能代表标题、段落、列表、导航菜单或页脚。一个块级元素不会嵌套在一个内联元素里面，但它可能嵌套在另一个块级元素里面。</li>
<li>内联元素通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行。它通常与文本一起使用，例如，<a>元素创建一个超链接，<strong>等元素创建强调。</strong></a></li>
</ul>
<p><em>第一</em><em>第二</em><em>第三</em></p>
<p>第四</p><p>第五</p><p>第六</p>
<blockquote>
<p>在这篇文章中提到的“块”和“内联”，不应该与 CSS 盒子的类型中的同名术语相混淆。尽管它们默认是相关的，但改变 CSS 显示类型并不会改变元素的分类，也不会影响它可以包含和被包含于哪些元素。防止这种混淆也是 HTML5 摒弃这些术语的原因之一。</p>
</blockquote>
<h3><span id="空元素">空元素</span></h3>
<img src="https://roy-tian.github.io/learning-area/extras/getting-started-web/beginner-html-site/images/firefox-icon.png" alt="Firefox 图标">
<h2><span id="属性">属性</span></h2>
<p>属性包含元素的额外信息，这些信息不会出现在实际的内容中。</p>
<p>属性必须包含：</p>
<ul>
<li>一个空格，它在属性和元素名称之间。如果一个元素具有多个属性，则每个属性之间必须由空格分隔。</li>
<li>属性名称，后面跟着一个等于号。</li>
<li>一个属性值，由一对引号（“”）引起来。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mozilla.org/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;The Mozilla homepage&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>mozila<span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>href：声明超链接的 web 地址</li>
<li>title：超链接声明额外的信息，当鼠标悬停在超链接上面时，这部分信息将以工具提示的形式显示。</li>
<li>target：指定链接如何呈现出来。例如，<code>target=&quot;_blank&quot;</code> 将在新标签页中显示链接。如果你希望在当前标签页显示链接，忽略这个属性即可。</li>
</ul>
<h3><span id="布尔属性">布尔属性</span></h3>
<p>有时你会看到没有值的属性，这也是完全可以接受的。这些属性被称为布尔属性。布尔属性只能有一个值，这个值一般与属性名称相同。例如，考虑 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input#attr-disabled"><code>disabled</code></a> 属性，你可以将其分配给表单输入元素。用它来禁用表单输入元素，这样用户就不能输入了。被禁用的元素通常有一个灰色的外观。示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 disabled 属性来防止终端用户输入文本到输入框中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面这个输入框不包含 disabled 属性，所以用户可以向其中输入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="属性引号">属性引号</span></h3>
<ul>
<li>
<p>建议不省略包围属性的引号</p>
</li>
<li>
<p>可以使用单引号或双引号，但不能在一个属性值里混用</p>
</li>
<li>
<p>可以在一种引号中嵌套另一种引号，若想在引号中嵌套同种引号，必须使用 HTML 实体引用 ：' (&amp;apos;)</p>
</li>
<li>
<p>连续多个空格最多显示一个，也需要使用实体引用 </p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/XML%E4%B8%8EHTML%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8#HTML%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8">XML与HTML字符实体引用列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://www.example.com&#x27;</span> <span class="attr">title</span>=<span class="string">&#x27;Isn<span class="symbol">&amp;apos;</span>t this fun?&#x27;</span>&gt;</span>示例站点链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><span id="html文档">HTML文档</span></h2>
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <title>我的测试站点</title>
  </head>
  <body>
    <h1><span id="经典回忆">经典回忆</span></h1>
    <p>
     相思无用，惟别而已。别期若有定，千般煎熬又何如？莫道黯然销魂，何处<strong>柳暗花明</strong>？<br>
     ——《<a href="https://zh.wikipedia.org/zh-hans/神鵰俠侶">神雕侠侣</a>》
    </p>
    <img src="https://roy-tian.github.io/learning-area/extras/tools/playable-code/images/sdxl.jfif" alt="《神雕侠侣》作品图片">
    <div>
      <input type="text">
    </div>
	<div>
      <input type="text" disabled>
    </div>
  </body>
</html>
<ol>
<li><code>&lt;!DOCTYPE html&gt;</code>: 声明文档类型。早期的 HTML（大约 1991-1992 年）文档类型声明类似于链接，规定了 HTML 页面必须遵从的良好规则，能自动检测错误和其他有用的东西。文档类型是一个历史遗留问题，需要包含它才能使其他东西正常工作。现在，只需要知道 <code>&lt;!DOCTYPE html&gt;</code> 是html第五个版本的声明</li>
<li><code>&lt;html&gt;&lt;/html&gt;</code>: <html>元素。这个元素包裹了页面中所有的内容，有时被称为根元素。</html></li>
<li><code>&lt;head&gt;&lt;/head&gt;</code>: <head>元素。这个元素是一个容器，它包含了所有你想包含在 HTML 页面中但<strong>不在 HTML 页面中显示</strong>的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述、CSS 样式、字符集声明等等。以后的章节中会学到更多相关的内容。</head></li>
<li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>: <meta>元素。这个元素代表了不能由其他 HTML 元相关元素表示的元数据，比如<base><link><script><style><title>。charset属性将你的文档的字符集设置为 UTF-8，其中包括绝大多数人类书面语言的大多数字符。有了这个设置，页面现在可以处理它可能包含的任何文本内容。没有理由不对它进行设置，它可以帮助避免以后的一些问题。</li>
<li><code>&lt;title&gt;&lt;/title&gt;</code>: <title> 元素。这设置了页面的标题，也就是出现在该页面加载的浏览器标签中的内容。当页面被加入书签时，页面标题也被用来描述该页面。</li>
<li><code>&lt;body&gt;&lt;/body&gt;</code>: <body> 元素。包含了你访问页面时<em>所有</em>显示在页面上的内容，包含文本、图片、视频、游戏、可播放音频轨道等等。</li>
</ol>
<h2 id="格式">格式</h2>
<ul>
<li>无论你在 HTML 元素的内容中使用多少空格（包括一个或多个空白字符或换行），当渲染这些代码的时候，HTML 解释器会将连续出现的空白字符减少为一个单独的空格符。</li>
<li>在我们的HTML中，每个嵌套元素都比它所在的元素多缩进了两个空格。</li>
</ul>
<h2 id="注释">注释</h2>
<!--内容-->
<h2 id="HTML头部">HTML头部</h2>
<p>HTML 头部包含 HTML&lt;head&gt;元素的内容，与&lt;body&gt;元素内容不同，页面在浏览器加载后它的内容不会在浏览器中显示，它的作用是保存页面的一些元数据</p>
<h3 id="添加标题-title">添加标题 title</h3>
<ul>
<li>&lt;h1&gt; 元素在页面加载完毕时显示在页面中，通常只出现一次，为 body 添加顶级标题、用来标记页面内容的标题（故事名称、新闻摘要等等）。</li>
<li>&lt;title&gt;元素是一项元数据，用于表示整个 HTML 文档的标题（而不是文档内容）为head添加标题。</li>
</ul>
<h3 id="元数据-meta">元数据 meta</h3>
<ul>
<li>指定文档字符编码</li>
</ul>
<meta charset="utf-8" />
<ul>
<li>添加作者和描述</li>
</ul>
<p><meta
  name="description"
  content="The MDN Web Docs site
  provides information about Open Web technologies
  including HTML, CSS, and APIs for both Web sites and
  progressive web apps." /></p>
<p><img src="https://pic.imgdb.cn/item/63f6d267f144a01007a898af.jpg" alt=""></p>
<ul>
<li>其他类型</li>
</ul>
<h3 id="应用css和JavaScript">应用css和JavaScript</h3>
<ul>
<li>&lt;link&gt;元素经常位于文档的头部，它有 2 个属性，<code>rel=&quot;stylesheet&quot;</code> 表明这是文档的样式表，而 <code>href</code> 包含了样式表文件的路径：</li>
</ul>
<link rel="stylesheet" href="my-css-file.css" />
<ul>
<li>&lt;script&gt;元素也应当放在文档的头部，并包含 <code>src</code> 属性来指向需要加载的 JavaScript 文件路径，同时最好加上 <code>defer</code> 以告诉浏览器在解析完成 HTML 后再加载 JavaScript。这样可以确保在加载脚本之前浏览器已经解析了所有的 HTML 内容。这样你就不会因为 JavaScript 试图访问页面上不存在的 HTML 元素而产生错误。实际上有很多方法来处理在你的页面上加载 JavaScript，但对于现代浏览器来说，这是最可靠的方法</li>
</ul>
<script src="my-js-file.js" defer></script>
<h2><span id="html文本">HTML文本</span></h2>
<table>
<thead>
<tr>
<th>标签</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>双标签</td>
<td>段落</td>
</tr>
<tr>
<td>title</td>
<td>双标签</td>
<td>标题</td>
</tr>
<tr>
<td>ol（li）</td>
<td>双标签</td>
<td>有序列表</td>
</tr>
<tr>
<td>ul（li）</td>
<td>双标签</td>
<td>无序列表</td>
</tr>
<tr>
<td>strong</td>
<td>双标签</td>
<td>强调</td>
</tr>
<tr>
<td>em</td>
<td>双标签</td>
<td>斜体</td>
</tr>
<tr>
<td>br</td>
<td>单标签</td>
<td>强制换行</td>
</tr>
<tr>
<td>hr</td>
<td>单标签</td>
<td>水平线</td>
</tr>
<tr>
<td>blockquote</td>
<td>双标签</td>
<td>块引用</td>
</tr>
<tr>
<td>cite</td>
<td>双标签</td>
<td>行引用</td>
</tr>
</tbody>
</table>
<h3><span id="列表">列表</span></h3>
<ul>
<li>
<p>有序列表</p>
<ol>
  <li>沿着条路走到头</li>
  <li>右转</li>
  <li>直行穿过第一个十字路口</li>
  <li>在第三个十字路口处左转</li>
  <li>继续走 300 米，学校就在你的右手边</li>
</ol>
</li>
<li>
<p>无序列表</p>
<ul>
  <li>豆浆</li>
  <li>油条</li>
  <li>豆汁</li>
  <li>焦圈</li>
</ul>
</li>
<li>
<p>嵌套列表</p>
<ol>
  <li>先用蛋白一个、盐半茶匙及淀粉两大匙搅拌均匀，调成“腌料”，鸡胸肉切成约一厘米见方的碎丁并用“腌料”搅拌均匀，腌渍半小时。</li>
  <li>用酱油一大匙、淀粉水一大匙、糖半茶匙、盐四分之一茶匙、白醋一茶匙、蒜末半茶匙调拌均匀，调成“综合调味料”。</li>
  <li>鸡丁腌好以后，色拉油下锅烧热，先将鸡丁倒入锅内，用大火快炸半分钟，炸到变色之后，捞出来沥干油汁备用。</li>
  <li>在锅里留下约两大匙油，烧热后将切好的干辣椒下锅，用小火炒香后，再放入花椒粒和葱段一起爆香。随后鸡丁重新下锅，用大火快炒片刻后，再倒入“综合调味料”继续快炒。
    <ul>
      <li>如果你采用正宗川菜做法，最后只需加入花生米，炒拌几下就可以起锅了。</li>
      <li>如果你在北方，可加入黄瓜丁、胡萝卜丁和花生米，翻炒后起锅。</li>
    </ul>
  </li>
</ol>
</li>
</ul>
<h3><span id="强调">强调</span></h3>
<p>This liquid is <strong>highly toxic</strong> —
if you drink it, <b>you may <em>die</em></b>.</p>
<p>仅仅影响表象而且没有语义，被称为<strong>表象元素</strong>（presentational elements）并且不应该再被使用。因为正如我们在之前看到的，语义对无障碍、SEO（搜索引擎优化）等非常重要。</p>
<ul>
<li><code>&lt;b&gt;</code>、<code>&lt;i&gt;</code> 或 <code>&lt;u&gt;</code> 来表达传统上的粗体、斜体或下划线</li>
</ul>
<h3><span id="描述列表">描述列表</span></h3>
<p>目的是标记一组项目及其相关描述，例如术语和定义，或者是问题和答案等。让我们看一组术语和定义的示例：</p>
<p>描述列表使用与其他列表类型不同的闭合标签<dl>；此外，每一项都用 <dt>（description term）元素闭合。每个描述都用<dd>（description definition）元素闭合。</dd></dt></dl></p>
<dl>
  <dt>内心独白</dt>
    <dd>戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。</dd>
  <dt>语言独白</dt>
    <dd>戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。</dd>
  <dt>旁白</dt>
    <dd>戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。</dd>
</dl>
<p>一个术语可以同时有多个描述</p>
<h3><span id="引用">引用</span></h3>
<p><strong>块引用</strong></p>
<p>你应该把它用<blockquote>元素包裹起来表示，并且在cite属性里用 URL 来指向引用的资源。</blockquote></p>
<p>Here is a blockquote:</p>
<blockquote cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote">
  <p>
    The <strong>HTML <code>&lt;blockquote&gt;</code> Element</strong> (or
    <em>HTML Block Quotation Element</em>) indicates that the enclosed text is
    an extended quotation.
  </p>
</blockquote>
<p><strong>行内引用</strong></p>
<q>
<p>The quote element — <code>&lt;q&gt;</code> — is <q cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q">intended
for short quotations that don't require paragraph breaks.</q></p>
<p>
  According to the
  <a href="/en-US/docs/Web/HTML/Element/blockquote">
    <cite>MDN blockquote page</cite></a>:
</p>
<blockquote cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote">
  <p>The <strong>HTML <code>&lt;blockquote&gt;</code> Element</strong> (or <em>HTML Block
  Quotation Element</em>) indicates that the enclosed text is an extended quotation.</p>
</blockquote>
<h3><span id="引文cite">引文cite</span></h3>
<p>The quote element — <code>&lt;q&gt;</code> — is <q cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q">intended
for short quotations that don't require paragraph breaks.</q> — <a href="/en-US/docs/Web/HTML/Element/q">
<cite>MDN q page</cite></a>.</p>
<h3><span id="水平线">水平线</span></h3>
<hr color="red" size="100px" width="700px"> 
<h2><span id="html超链接ltagt">HTML超链接&lt;a&gt;</span></h2>
<h3><span id="属性">属性</span></h3>
<ul>
<li>href：指向链接</li>
<li>title：关于链接的补充信息</li>
</ul>
<h3><span id="url-path">URL、PATH</span></h3>
<ul>
<li>
<p>URL（统一资源定位符）是一个定义了在网络上的位置的一个文本字符串。例如https://www.mozilla.org/zh-CN/`.</p>
</li>
<li>
<p>指向当前： href=“contacts.html”</p>
</li>
<li>
<p>指向子目录：href=&quot;projects/index.html</p>
</li>
<li>
<p>指向上级目录：href=“…/pdfs/project-brief.pdf”</p>
</li>
</ul>
<h3><span id="链接文档特定部分">链接文档特定部分</span></h3>
<h2><span id="邮寄地址">邮寄地址</span></h2>
<p>要提供意见和建议，请将信件邮寄至<a href="contacts.html#Mailing_address">我们的地址</a>。</p>
<ul>
<li>组件设置id</li>
<li>通过href:&quot;URL#id&quot;链接到特定的id</li>
</ul>
<p><strong>绝对 URL</strong>：指向由其在 Web 上的绝对位置定义的位置，包括<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_name">域名</a>。像下面的例子，如果 <code>index.html</code> 页面上传到了 <code>projects</code> 这一个目录。并且 <code>projects</code> 目录位于 web 服务站点的根目录，web 站点的域名为 <code>http://www.example.com</code>，那么这个页面就可以通过 <code>http://www.example.com/projects/index.html</code> 访问（或者通过 <code>http://www.example.com/projects/</code> 来访问，因为在没有指定特定的 URL 的情况下，大多数 web 服务器会默认访问加载 <code>index.html</code> 这类页面）</p>
<p><strong>相对 URL</strong>：指向与你链接的文件相关的位置，更像我们在前面一节中所看到的位置。例如，如果我们想从示例文件链接 <code>http://www.example.com/projects/index.html</code> 转到相同目录下的一个 PDF 文件，URL 就是文件名（例如 <code>project-brief.pdf</code>），没有其他的信息要求。如果 PDF 文件能够在 <code>projects</code> 的子目录 <code>pdfs</code> 中访问到，相对路径就是 <code>pdfs/project-brief.pdf</code>（对应的绝对 URL 是 <code>http://www.example.com/projects/pdfs/project-brief.pdf</code>）</p>
<p>一个相对 URL 将指向不同的位置，这取决于它所在的文件所在的位置</p>
<p><a href="https://www.example.com/large-report.pdf">
  下载销售报告（PDF, 10MB）
</a></p>
<p><a href="https://www.example.com/video-stream/" target="_blank">
  观看视频（将在新标签页中播放，HD 画质）
</a></p>
<p><a href="https://www.example.com/car-game">
  进入汽车游戏（需要 Flash 插件）
</a></p>
<h3><span id="download属性">download属性</span></h3>
<p>当你链接到要下载的资源而不是在浏览器中打开时，你可以使用 download 属性来提供一个默认的保存文件名。下面是一个 Firefox 的 Windows 最新版本下载链接的示例：</p>
<p><a href="https://download.mozilla.org/?product=firefox-latest-ssl&os=win64&lang=zh-CN" download="firefox-latest-64bit-installer.exe"><br>
下载最新的 Firefox 中文版 - Windows（64 位）<br>
</a></p>
</q></li></ol>]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>mybatisPlus</title>
    <url>/post/mybatis%20plus/</url>
    <content><![CDATA[<p><a href="https://baomidou.com/">mybatis plus官方文档</a></p>
<h2><span id="springboot-引入">Springboot 引入</span></h2>
<h3><span id="导入依赖">导入依赖</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="配置">配置</span></h3>
<p>在 <code>application.yml</code> 配置文件中添加数据库的相关配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="comment"># Mybatis配置信息(MybatisPlus是对Mybatis的增强)</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># Sql日志的输出到控制台</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="comment"># 加载xml映射配置文件的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure>
<p>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.bjpowernode.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="实体类">实体类</span></h3>
<table>
<thead>
<tr>
<th>MybatisPlus注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@TableName</td>
<td>映射的数据库表</td>
</tr>
<tr>
<td>@TableId</td>
<td>映射表中主键字段</td>
</tr>
<tr>
<td>@TableField</td>
<td>映射表中非主键字段</td>
</tr>
</tbody>
</table>
<h3><span id="mapper接口">Mapper接口</span></h3>
<ol>
<li>继承<code>BaseMapper&lt;实体类&gt;</code></li>
<li>仅增删改查，根据ids批量删除、根据ids批量查询</li>
</ol>
<h3><span id="service接口">Service接口</span></h3>
<ol>
<li>Service接口继承<code>IService&lt;实体类&gt;</code>(MybatisPlus)接口</li>
<li>Service实现类继承<code>Service接口</code>及<code>ServiceImpl&lt;Mapper,实体类&gt;</code></li>
<li>可以批量新增或修改操作，根据ids批量删除，根据ids批量查询</li>
</ol>
<p>通用Service和通用Mapper的继承关系主要是为了使用api增删改查数据库操作**(**单表)，多表操作必须通过sql实现</p>
<h2><span id="crud">CRUD</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过通用service查询用户列表数据</span></span><br><span class="line">userService.list().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过通用mapper查询用户列表数据</span></span><br><span class="line">userMapper.selectList(<span class="literal">null</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量新增</span></span><br><span class="line">userService.saveBatch(</span><br><span class="line">    Arrays.asList(</span><br><span class="line">        User.builder()</span><br><span class="line">        .loginAct(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">        .loginPwd(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .name(<span class="string">&quot;张三&quot;</span>+<span class="number">1</span>)</span><br><span class="line">        .build(),</span><br><span class="line">        User.builder()</span><br><span class="line">        .loginAct(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">        .loginPwd(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .name(<span class="string">&quot;张三&quot;</span>+<span class="number">2</span>)</span><br><span class="line">        .build(),</span><br><span class="line">        User.builder()</span><br><span class="line">        .loginAct(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">        .loginPwd(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .name(<span class="string">&quot;张三&quot;</span>+<span class="number">3</span>)</span><br><span class="line">        .build(),</span><br><span class="line">        User.builder()</span><br><span class="line">        .loginAct(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">        .loginPwd(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .name(<span class="string">&quot;张三&quot;</span>+<span class="number">4</span>)</span><br><span class="line">        .build(),</span><br><span class="line">        User.builder()</span><br><span class="line">        .loginAct(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">        .loginPwd(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .name(<span class="string">&quot;张三&quot;</span>+<span class="number">5</span>)</span><br><span class="line">        .build()</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据id查询出用户信息</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="string">&quot;1682305372411715585&quot;</span>);</span><br><span class="line"><span class="comment">//修改用户操作</span></span><br><span class="line">user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">userService.updateById(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有逻辑删除，执行的是delete操作，有逻辑删除执行的update操作</span></span><br><span class="line">userService.removeById(<span class="string">&quot;1682316120911327236&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2><span id="条件构造器">条件构造器</span></h2>
<table>
<thead>
<tr>
<th>条件构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>QueryWrapper</td>
<td>条件只能根据字符串来封装</td>
</tr>
<tr>
<td>LambdaQueryWrapper</td>
<td>根据上下文推断（将被编译检查）</td>
</tr>
<tr>
<td>UpdateWrapper</td>
<td></td>
</tr>
<tr>
<td>LambdaUpdateWrapper</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;1682305372646596611&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印所有userId非空且id为userId的用户</span></span><br><span class="line">userService.list(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(StringUtils.isNotBlank(userId),<span class="string">&quot;id&quot;</span>,userId)).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">userService.list(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;().eq(StringUtils.isNotBlank(userId),User::getId,userId)).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据更新条件来修改数据</span></span><br><span class="line"><span class="comment">//        userService.update(</span></span><br><span class="line"><span class="comment">//                //更新的用户信息</span></span><br><span class="line"><span class="comment">//                User.builder()</span></span><br><span class="line"><span class="comment">//                        .loginAct(&quot;李四&quot;)</span></span><br><span class="line"><span class="comment">//                        .loginPwd(&quot;321&quot;)</span></span><br><span class="line"><span class="comment">//                        .name(&quot;李四&quot;)</span></span><br><span class="line"><span class="comment">//                        .build(),</span></span><br><span class="line"><span class="comment">//                //更新的条件</span></span><br><span class="line"><span class="comment">//                new LambdaUpdateWrapper&lt;User&gt;()</span></span><br><span class="line"><span class="comment">//                .like(</span></span><br><span class="line"><span class="comment">//                        User::getName,</span></span><br><span class="line"><span class="comment">//                        &quot;张三&quot;</span></span><br><span class="line"><span class="comment">//                )</span></span><br><span class="line"><span class="comment">//        );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先根据条件，将要更新的数据查询出来</span></span><br><span class="line">List&lt;User&gt; userList = userService.list(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;().like(User::getName, <span class="string">&quot;李四&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将李四更新为张三</span></span><br><span class="line">userList.forEach(user -&gt; user.setLoginAct(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量更新</span></span><br><span class="line">userService.updateBatchById(userList);</span><br></pre></td></tr></table></figure>
<h2><span id="分页与乐观锁">分页与乐观锁</span></h2>
<h3><span id="配置文件">配置文件</span></h3>
<p>在配置文件中配置分页拦截器与乐观锁拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">interceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">//乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="分页查询">分页查询</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">        Page&lt;User&gt; page = userService.page(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Page</span>&lt;User&gt;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//获取分页结果集</span></span><br><span class="line">        System.out.println(page);</span><br><span class="line">        <span class="comment">//获取当前页数</span></span><br><span class="line">        System.out.println(page.getCurrent());</span><br><span class="line">        <span class="comment">//获取每页数据量</span></span><br><span class="line">        System.out.println(page.getSize());</span><br><span class="line">        <span class="comment">//获取总页数</span></span><br><span class="line">        System.out.println(page.getPages());</span><br><span class="line">        <span class="comment">//获取总数据量</span></span><br><span class="line">        System.out.println(page.getTotal());</span><br><span class="line">        <span class="comment">//获取分页结果</span></span><br><span class="line">        System.out.println(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： 分页查询从1开始代表第一页（即使0也代表第一页）</p>
<h3><span id="乐观锁">乐观锁</span></h3>
<p>在批量更新时，防止数据超出更新的限制</p>
<h3><span id="实体类添加注解">实体类添加注解</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="meta">@TableField(value = &quot;version&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>
<p>使用MybatisPlus的updateById方法时，先对乐观锁进行更新（version+1），再查出符合乐观锁赋值后的数据并修改</p>
<h2><span id="逻辑删除">逻辑删除</span></h2>
<ol>
<li>在查询时自动拼接未删除的查询条件，查出未删除的数据</li>
<li>删除数据实际上执行修改操作，只是无法通过MybatisPlus查出，但仍存在在数据库中（可找回）</li>
</ol>
<h3><span id="配置">配置</span></h3>
<p>在 <code>application.yml</code> 配置文件中添加逻辑删除的相关配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment"># 配置逻辑删除操作</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 逻辑删除的字段是什么</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">is_delete</span></span><br><span class="line">      <span class="comment"># 删除的值为1</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 未删除的值为0</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3><span id="实体类添加注解">实体类添加注解</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="meta">@TableField(value = &quot;is_delete&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String isDelete;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/post/maven/</url>
    <content><![CDATA[<p><a href="http://maven.apache.org/">Maven官网</a></p>
<h2><span id="传统项目开发存在的问题">传统项目开发存在的问题</span></h2>
<p>一个项目做成一个工程，造成工程比较庞大，package划分模块已经不再满足需求，需要使用工程来划分模块；</p>
<p>数量众多的项目之间的依赖，需要手动打包并引入；</p>
<p>项目中需要的数量众多的jar包，需要手动下载并引入，并且多个项目需要的jar包存在重复的问题；</p>
<p>项目中需要的jar包有版本兼容的问题，需要手动解决；</p>
<p>项目中需要的jar包又依赖其它的jar包，需要手动解决。</p>
<h2><span id="maven功能">Maven功能</span></h2>
<h3><span id="管理依赖">管理依赖</span></h3>
<p>只需要声明就可以自动到仓库下载</p>
<h3><span id="构建项目">构建项目</span></h3>
<h3><span id="管理项目信息">管理项目信息</span></h3>
<p>生成一个站点文档，一个命令就可以解决，最后再说</p>
<h2><span id="pomproject-object-mode">POM(Project Object Mode)</span></h2>
<p>Maven基于项目中的POM配置文件来对当前项目进行构建</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>modelVersion</em></td>
<td>固定值4.0.0</td>
</tr>
<tr>
<td><em>groupId</em></td>
<td>公司或组织的 id，<code>项目用途(com/org).公司名.项目名</code></td>
</tr>
<tr>
<td><em>artifactId</em></td>
<td>项目或某个模块的名称，作为 Maven 工程的工程名</td>
</tr>
<tr>
<td><em>version</em></td>
<td>版本号,若项目还在开发中，通常在版本后带-SNAPSHOT</td>
</tr>
<tr>
<td>packaging</td>
<td>项目打包的类型，如ar、war、rar、ear、pom，默认是jar</td>
</tr>
<tr>
<td>dependencies</td>
<td>嵌套一个或多个dependency标签</td>
</tr>
<tr>
<td>dependency</td>
<td>Maven中用于项目构建、运行所依赖的jar包被称为依赖，该标签用于定位、配置要使用的依赖</td>
</tr>
<tr>
<td>dependencyManagement</td>
<td>主要用于继承；声明依赖，并不会实际引入依赖</td>
</tr>
<tr>
<td>properties</td>
<td>定义配置属性，如project.build.sourceEncoding（项目构建源码编码方式）设置为UTF-8防止中文乱码</td>
</tr>
<tr>
<td>build</td>
<td>配置构建相关的信息，比如build下有finalName，表示的就是最终构建之后的名称</td>
</tr>
<tr>
<td>parent</td>
<td>声明要继承的父工程的pom配置</td>
</tr>
<tr>
<td>modules</td>
<td>主要用于聚合其它模块</td>
</tr>
</tbody>
</table>
<ol>
<li>groupId，artifactId，version构成了该项目的坐标，其唯一确定了一个project</li>
<li>对应Maven本地仓库根目录\【groupId】\【artifactId】\【version】\【artifactId】-【version】.jar</li>
</ol>
<h2><span id="六大属性">六大属性</span></h2>
<h3><span id="内置属性">内置属性</span></h3>
<p>内置属性(Maven预定义,用户可以直接使用)</p>
<table>
<thead>
<tr>
<th>内置属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${basedir}</td>
<td>表示项目根目录,即包含pom.xml文件的目录</td>
</tr>
<tr>
<td>${version}</td>
<td>表示项目版本</td>
</tr>
<tr>
<td>${project.basedir}</td>
<td>同 ${basedir}</td>
</tr>
<tr>
<td>${project.baseUri}</td>
<td>表示项目文件地址</td>
</tr>
<tr>
<td>${maven.build.timestamp}</td>
<td>表示项目构件开始时间</td>
</tr>
<tr>
<td>${maven.build.timestamp.format}</td>
<td>表示属性 ${maven.build.timestamp}的展示格式,默认值为yyyyMMdd-HHmm</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">maven.build.timestamp.format</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="name">maven.build.timestamp.format</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="pom属性">POM属性</span></h3>
<p>POM属性(使用pom属性可以引用到pom.xml文件对应元素的值)</p>
<table>
<thead>
<tr>
<th>POM属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${project.build.directory}</td>
<td>表示主源码路径</td>
</tr>
<tr>
<td>${project.build.sourceEncoding}</td>
<td>表示主源码的编码格式</td>
</tr>
<tr>
<td>${project.build.sourceDirectory}</td>
<td>表示主源码路径</td>
</tr>
<tr>
<td>${project.build.finalName}</td>
<td>表示输出文件名称</td>
</tr>
<tr>
<td>${project.version}</td>
<td>表示项目版本,与 ${version}相同</td>
</tr>
</tbody>
</table>
<h3><span id="自定义属性">自定义属性</span></h3>
<p>自定义属性(在pom.xml文件的标签下定义的Maven属性)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-version</span>&gt;</span>5.3.20<span class="tag">&lt;/<span class="name">spring-version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis-version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">mybatis-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="settingsxml文件属性">settings.xml文件属性</span></h3>
<p>(与pom属性同理,用户使用以settings.开头的属性引用settings.xml文件中的XML元素值)</p>
<table>
<thead>
<tr>
<th>settings.xml属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${settings.localRepository}</td>
<td>表示本地仓库的地址</td>
</tr>
</tbody>
</table>
<h3><span id="java系统属性">Java系统属性</span></h3>
<p>(所有的Java系统属性都可以使用Maven属性引用)</p>
<ol>
<li>使用mvn help:system命令可查看所有的Java系统属性;</li>
<li>System.getProperties()可得到所有的Java属性;</li>
<li>${user.home}表示用户目录;</li>
</ol>
<h3><span id="环境变量属性">环境变量属性</span></h3>
<p>(所有的环境变量都可以用以env.开头的Maven属性引用)</p>
<ol>
<li>使用mvn help:system命令可查看所有环境变量;</li>
<li>${env.JAVA_HOME}表示JAVA_HOME环境变量的值;</li>
</ol>
<h2><span id="仓库">仓库</span></h2>
<p>为了提高构建的效率和依赖复用，maven把所有的依赖统一存储在某一个位置，这个位置就叫做仓库。</p>
<h3><span id="本地仓库">本地仓库</span></h3>
<p>默认存放路径为当前用户目录\.m2\repository为本机上所有的Maven工程服务</p>
<p>可在<code>【Maven_home】/conf/settings.xml</code>中通过<code>&lt;localRepository&gt;</code>标签来指定本地仓库路径</p>
<h3><span id="远程仓库">远程仓库</span></h3>
<p>构建项目时，若POM中所声明的依赖未能在本地仓库中找到，将触发Maven从远程仓库中进行下载，并保存在本地仓库中，供项目使用。</p>
<p>中央仓库是maven默认的远程仓库，其地址是:<a href="http://repo.maven.apache.org/maven2/">http://repo.maven.apache.org/maven2/</a></p>
<p>我们可以在<code>【Maven_home】/conf/settings.xml</code>或POM中通过如下配置来对远程仓库进行设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中id，name，url分别表示该远程仓库的唯一标识、名字、地址</p>
<p><strong>若配置了多个远程仓库，MAVEN寻找依赖的顺序</strong></p>
<ol>
<li>在<code>【Maven_home】/conf/settings.xml</code>文件中配置的远程仓库</li>
<li>当前项目POM文件中配置的远程仓库</li>
<li>父项目POM文件中配置的远程仓库</li>
<li>Super POM文件中配置的远程仓库（Maven的中心仓库）</li>
</ol>
<p><strong>在<code>【Maven_home】/conf/settings.xml</code>中通过如下配置来为每个远程仓库配置最多一个镜像</strong></p>
<p>当Maven需要访问某个远程仓库时，将会去访问该远程仓库的镜像，以下是阿里云maven镜像仓库配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中id，name，url，mirrorOf分别表示该镜像的唯一标识、名字、地址、所镜像的远程仓库id</p>
<h3><span id="内部仓库私服">内部仓库（私服）</span></h3>
<p>本质上就是内部使用的远程仓库，架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用</p>
<p>当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。公司中常常使用这种方式</p>
<p>当前主流的maven私服： Apache的Archiva、JFrog的Artifactory、Sonatype的Nexus</p>
<img src="https://pic.imgdb.cn/item/64a667b41ddac507ccabd228.jpg" style="zoom:50%;">
<h2><span id="依赖">依赖</span></h2>
<p>可通过如下POM配置来设置当前项目的直接依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中groupId，artifactId，version为依赖的坐标。type为依赖的类型，一般为依赖文件的后缀名，默认为jar</p>
<h2><span id="项目继承">项目继承</span></h2>
<p>当一个项目有足够多的文件时，可以将项目拆分多个模块，每个模块都需要配置自身的依赖信息</p>
<p>通过如下POM配置将当前项目设置为另一个项目的子项目</p>
<p>父模块POM文件里的<strong>变量、依赖、组织、版本</strong>配置都将合并到子项目中，成为子项目POM文件的默认值（插件配置无法继承）</p>
<ol>
<li>子模块继承了父模块的变量，父模块统一管理子模块的依赖版本</li>
<li>子模块选择性继承父模块的依赖，父模块维护整个项目的依赖信息</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中parent标签指定了父项目的坐标，以及父模块的POM文件的相对路径</p>
<p><strong>父模块打包方式必须为pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父模块POM中设置packaging，只有打包方式为pom的工程才能够管理其他工程，工程中不写业务代码，因此可将src目录删除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>父模块统一管理依赖版本</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父模块POM中设置property，并在其它标签中使用$&#123;propertyName&#125;来表示该property的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">propertyName</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">propertyName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>父模块统一管理依赖配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父模块POM中设置dependencyManagement（依赖管理器），子模块手动继承时才会引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若不使用依赖管理器，则强制使所有子模块继承一下依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子模块引用父工程管理的依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子模块POM中直接引用依赖，可省略版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子项目根据groupId（必填）, artifactId（必填）, type（默认为jar）, classifier（默认为null）四个值来定位到父项目dependencyManagement中的依赖，并完全沿用父项目dependencyManagement中对该依赖的配置</p>
<h2><span id="项目聚合">项目聚合</span></h2>
<p>在<strong>总工程</strong>中通过如下POM配置将各个<strong>模块工程</strong>汇集成起来，作为一个整体（完整的项目）</p>
<p>对当前项目进行编译时，也将同时为该项目所有的子模块进行编译，解决一次性编译的问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子模块项目的相对路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="依赖传递">依赖传递</span></h2>
<p>根据直接依赖，获取到其所有的间接依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">├── B</span><br><span class="line">│  	└── D</span><br><span class="line">└── C</span><br><span class="line">	└── E</span><br></pre></td></tr></table></figure>
<p>如当前项目A直接依赖于B和C，而B和C分别直接依赖于D和E。通过依赖传递机制，我们仅需在项目A中配置其直接依赖B和C，Maven会自动对间接依赖D和E进行获取</p>
<h2><span id="依赖冲突">依赖冲突</span></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">├── B</span><br><span class="line">│  	└── E 1.0</span><br><span class="line">└── C</span><br><span class="line">    └── D 2.0</span><br><span class="line">    	└── E 2.0</span><br></pre></td></tr></table></figure>
<p>在上例中，A的间接依赖E发生了冲突。由于E 1.0在依赖树中的层级更加接近项目A，因此E 1.0将会被采用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">├── B</span><br><span class="line">│  	└── D 1.0</span><br><span class="line">└── C</span><br><span class="line">	└── D 2.0</span><br></pre></td></tr></table></figure>
<p>在上例中，A的间接依赖D发生了冲突。由于D 1.0所属的直接依赖B在A中被首先声明，因此D 1.0将会被采用</p>
<h2><span id="依赖范围">依赖范围</span></h2>
<p>在<dependency>标签中，我们可通过设置<scope>标签来指定该依赖的范围。其可选值有：</scope></dependency></p>
<p>maven项目依赖生效分为三个时期，编译期、测试期、运行期</p>
<p>通过对<code>&lt;scope&gt;</code>合理的配置，可以控制当前依赖在不同时期编译期、测试期、运行期生效的关系，指定被依赖资源的依赖范围</p>
<p>可选配置有 compile、test、provided、runtime、system、import，若不指定则默认 compile</p>
<table>
<thead>
<tr>
<th><code>&lt;scope&gt;</code>依赖范围</th>
<th>编译期</th>
<th>测试期</th>
<th>运行期</th>
<th>打入jar包</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>默认</td>
</tr>
<tr>
<td>test</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>如JUnit依赖，只在编译测试代码（src/test）和运行测试的时候才需要</td>
</tr>
<tr>
<td>provided</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>当前依赖在运行时默认由某个子项目项目引用，运行期则不需要引用</td>
</tr>
<tr>
<td>runtime</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动</td>
</tr>
<tr>
<td>system</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>由systemPath标签指定依赖jar的路径，表示的是从本地磁盘上找依赖，而不是从 maven 仓库下载，不适用多人协作</td>
</tr>
<tr>
<td>import</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>将目标pom的dependencyManagement标签中的依赖，合并到当前pom的dependencyManagement标签内，供引用项目中使用</td>
</tr>
</tbody>
</table>
<p><strong>使用provided依赖范围</strong> <img src="https://pic.imgdb.cn/item/64a396961ddac507cc7a32b3.jpg" alt></p>
<p>上述工具项目中引用了spring-web依赖，但是当前项目同时引用了<code>spring-boot-starter-web</code>（包括<code>spring-web</code>）</p>
<p>既然运行时SpringBoot会提供spring-web，因此使用provided依赖范围在运行时不参与项目打包，避免重复引用依赖</p>
<p><strong>使用runtime依赖范围</strong><br>
专门用于编译时不需要，但是运行时需要的 jar 包。比如：编译时我们根据接口调用方法，但是实际运行时需要的是接口的实现类。典型案例是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用system依赖范围</strong><br>
以 Windows 系统环境下开发为例，假设现在 D:\product\maven-demo-parent\demo-module\target\demo-module-1.0-SNAPSHOT.jar 想要引入到我们的项目中，此时我们就可以将依赖配置为 system 范围：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target\demo-module-1.0-SNAPSHOT.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是很明显：这样引入依赖完全不具有可移植性，所以不要使用</p>
<p><strong>使用import 依赖范围</strong></p>
<p>由于Maven中只能使用单继承，springboot项目的父工程为spring-boot-starter-parent，无法直接配置springCloud的依赖</p>
<ol>
<li>打包类型必须是 pom</li>
<li>必须在 dependencyManagement 配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringCloud 微服务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringCloud Alibaba 微服务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="依赖范围传递">依赖范围传递</span></h2>
<img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml4668\wps2.jpg" alt="img" style="zoom:67%;"> 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">└── B</span><br><span class="line">	└── C</span><br></pre></td></tr></table></figure>
<p>A直接依赖于B，B直接依赖于C</p>
<ol>
<li>当B的POM文件将依赖C配置为test和provided范围时，B和C之间的依赖传递将被阻断。此时A不再间接依赖于C</li>
<li>当B的POM文件将依赖C配置为compile和runtime范围时，C将会成为A的间接依赖，其范围值将被设置为与依赖B的范围值一致</li>
<li>特殊：当B的POM文件将依赖C配置为runtime范围且A的POM文件将依赖B配置为compile范围时，C的范围值将被设置为runtime</li>
</ol>
<table>
<thead>
<tr>
<th>test</th>
<th>provided</th>
</tr>
</thead>
<tbody>
<tr>
<td>B中依赖C仅用于测试，因此A依赖B而无需间接依赖C</td>
<td>B在运行时外界将提供C，则A无需间接依赖C</td>
</tr>
</tbody>
</table>
<h2><span id="可选依赖">可选依赖</span></h2>
<p>可通过如下POM配置来将当前项目的某个直接依赖设置为可选依赖。该设置将会阻断当前项目与该依赖间的依赖传递，使得其它项目无法通过当前项目而间接依赖于该依赖，只能本项目使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> </span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="依赖排除">依赖排除</span></h2>
<p>可通过如下POM配置来删除当前项目的某个直接依赖中的间接依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span> </span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="依赖循环问题">依赖循环问题</span></h2>
<p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DANGER</span><br><span class="line"></span><br><span class="line">[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:</span><br></pre></td></tr></table></figure>
<h2><span id="生命周期">生命周期</span></h2>
<p>当我们对一个项目进行打包时，maven分别执行了</p>
<p>验证（validate） ==&gt; 编译源码（compile） ==&gt; 编译测试源码（test-compile） ==&gt; 单元测试（test）==&gt; 打包（package）</p>
<ol>
<li>这个过程就是生命周期(lifecycle)。在生命周期的过程中会有很多的阶段(phase)（如clean由pre-clean、clean、post-clean组成），这些阶段按照既定的顺序执行来完成一个项目的构建。</li>
</ol>
<p>Maven有三个内置的构建生命周期，分别是：clean、default、site，都对应成一个个的生命周期阶段，并对每一个阶段提供相应的命令</p>
<h3><span id="clean">Clean</span></h3>
<p>构建之前进行项目的清理（缓存，临时文件，编译文件等）</p>
<ol>
<li>pre-clean 执行一些需要在clean 之前完成的工作</li>
<li>clean 移除所有上一次构建生成的文件，即target目录，但是已经install到仓库里的包不会删除</li>
<li>post-clean 执行一些需要在clean 之后立即完成的工作</li>
</ol>
<h3><span id="default">Default</span></h3>
<p>负责项目的部署，构建的核心部分，编译，测试，打包，安装，部署等。</p>
<ol>
<li>compile 编译项目源码，会在当前目录下生成一个target,里边存放编译主程序之后生成的字节码文件</li>
<li>test-Compile 编译测试源代码，会在当前目录下生成一个target,里边存放编译测试程序之后生成的字节码文件</li>
<li>test 会生成一个目录surefire-reports，保存测试结果使用合适的单元测试框架运行测试，这些测试代码不会打包或者部署</li>
<li>package 编译、编译测试、测试；并把主程序按照pom.xml配置打包</li>
<li>install 打包，且按照本工程的坐标保存至本地仓库，以让其他项目依赖</li>
<li>deploy 打包、保存到本地仓库中，并将最终的包保存到私服仓库，以让其他开发人员项目共享或部署到服务器上运行</li>
</ol>
<h3><span id="site">Site</span></h3>
<p>负责项目文档的创建，生成项目报告，站点 ，发布站点</p>
<ol>
<li>pre-site 执行一些需要在生成站点文档之前完成的工作</li>
<li>site 生成项目的站点文档</li>
<li>site-deploy 将生成的站点文档部署到特定的服务器上</li>
</ol>
<p><strong>注意</strong></p>
<p>当执行某个生命周期的阶段时，该阶段及其所在生命周期中所有位于该阶段前的所有构建阶段都将被按序执行（运行任何一个阶段的时候，它前面的所有阶段都会被运行 ）</p>
<h2><span id="构建配置">构建配置</span></h2>
<p><code>&lt;build&gt;</code> 标签的子标签大致包含如下三个部分</p>
<h3><span id="定义约定的目录结构">定义约定的目录结构</span></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(根目录，也就是工程名)</span><br><span class="line">- src(源代码)</span><br><span class="line">  - main(主程序)</span><br><span class="line">    - java(主程序的java源码)</span><br><span class="line">    - resources(主程序的配置文件)</span><br><span class="line">  - test(测试程序)</span><br><span class="line">    - java(测试程序的java源码)</span><br><span class="line">    - resources(测试程序的配置文件)</span><br><span class="line">- pom.xml (Maven工程的核心配置文件)</span><br></pre></td></tr></table></figure>
<p>在项目根路径下查看pom.xml，右键点击Show Effective POM选项，在页面中可以查找到maven默认的目录结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>【module_path】\src\main\java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>【module_path】e\src\main\scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>【module_path】\src\test\java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>【module_path】\target\classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>【module_path】\target\test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>【module_path】\src\main\resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>【module_path】\src\test\resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>【module_path】\target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>demo-module-1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>标签</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sourceDirectory</td>
<td>主体源程序存放目录</td>
</tr>
<tr>
<td>scriptSourceDirectory</td>
<td>脚本源程序存放目录</td>
</tr>
<tr>
<td>testSourceDirectory</td>
<td>测试源程序存放目录</td>
</tr>
<tr>
<td>outputDirectory</td>
<td>主体源程序编译结果输出目录</td>
</tr>
<tr>
<td>testOutputDirectory</td>
<td>测试源程序编译结果输出目录</td>
</tr>
<tr>
<td>resources</td>
<td>主体资源文件存放目录</td>
</tr>
<tr>
<td>testResources</td>
<td>测试资源文件存放目录件，默认位于${basedir}/src/test/resources/目录下</td>
</tr>
<tr>
<td>directory</td>
<td>构建结果输出目录，默认为${basedir}/target目录</td>
</tr>
<tr>
<td>finalName</td>
<td>构建的最终结果的名字，该名字可能在其他plugin中被改变</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>resource标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>resources</td>
<td>build过程中涉及的资源文件</td>
</tr>
<tr>
<td>targetPath</td>
<td>资源文件的目标路径</td>
</tr>
<tr>
<td>filtering</td>
<td>构建过程中是否对资源进行过滤，默认false</td>
</tr>
<tr>
<td>directory</td>
<td>资源文件的路径，默认位于${basedir}/src/main/resources/目录下</td>
</tr>
<tr>
<td>includes</td>
<td>一组文件名的匹配模式，被匹配的资源文件将被构建过程处理</td>
</tr>
<tr>
<td>excludes</td>
<td>一组文件名的匹配模式，被匹配的资源文件将被构建过程忽略。同时被includes和excludes匹配的资源文件，将被忽略</td>
</tr>
<tr>
<td>filters</td>
<td>给出对资源文件进行过滤的属性文件的路径，默认位于${basedir}/src/main/filters/目录下。属性文件中定义若干键值对。在构建过程中，对于资源文件中出现的变量（键），将使用属性文件中该键对应的值替换</td>
</tr>
</tbody>
</table>
<h3><span id="自定义配置资源文件">自定义配置资源文件</span></h3>
<p>将java源代码路径下的资源文件也打包输出到指定路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当是web项目时，编译结果会在target下生成目录，【project_name】是项目名</p>
<ol>
<li><code>src/main/webapps</code> 下的文件输出到 <code>target/【project_name】</code></li>
<li><code>target/classes </code>下的文件输出到 <code>target/【project_name】/WEB-INF/classes</code></li>
<li>项目所有依赖输出到 <code>target/【project_name】/WEB-INF/lib </code></li>
</ol>
<h3><span id="备用插件管理">备用插件管理</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2-beta-5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-release-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>pluginManagement</strong></p>
<ol>
<li>在<code>&lt;build&gt;</code>中，<code>&lt;pluginManagement&gt;</code>与<code>&lt;plugins&gt;</code>并列 ,两者之间的关系类似于<code>&lt;dependencyManagement&gt;</code>与<code>&lt;dependencies&gt;</code>之间的关系</li>
<li><code>&lt;pluginManagement&gt;</code>中也配置<code>&lt;plugin&gt;</code>，其配置参数与<code>&lt;plugins&gt;</code>中的<code>&lt;plugin&gt;</code>完全一致</li>
<li><code>&lt;pluginManagement&gt;</code>往往出现在父项目中，其中配置的<code>&lt;plugin&gt;</code>往往通用于子项目。子项目中只要在<code>&lt;plugins&gt;</code>中以<code>&lt;plugin&gt;</code>声明该插件，该插件的具体配置参数则继承自父项目中<code>&lt;pluginManagement&gt;</code>对该插件的配置，从而避免在子项目中进行重复配置</li>
</ol>
<h3><span id="生命周期插件">生命周期插件</span></h3>
<ol>
<li>在生命周期中，各个阶段的工作由插件来完成(plugin)</li>
<li>一个插件通常可以完成一个或者多个阶段的工作。每个阶段的工作对应插件中的一个目标(goal)</li>
<li>不同的插件结合起来，就完成了项目的构建</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-clean<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>clean<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>clean<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-testResources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testResources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-jar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-compile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-testCompile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-install<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>install<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-deploy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>site<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>site<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>D:\1MyProject\gitee-test\target\site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportPlugins</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reportPlugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">reportPlugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportPlugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-deploy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>site-deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>D:\1MyProject\gitee-test\target\site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportPlugins</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reportPlugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">reportPlugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportPlugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>D:\1MyProject\gitee-test\target\site<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reportPlugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportPlugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportPlugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">reportPlugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>阶段</th>
<th>插件</th>
</tr>
</thead>
<tbody>
<tr>
<td>clean</td>
<td>maven-clean-plugin:2.5</td>
</tr>
<tr>
<td>resources、testResources</td>
<td>maven-resources-plugin:2.6</td>
</tr>
<tr>
<td>compile、testCompile</td>
<td>maven-compiler-plugin:3.1</td>
</tr>
<tr>
<td>test</td>
<td>maven-surefire-plugin:2.12.4</td>
</tr>
<tr>
<td>package</td>
<td>maven-jar-plugin:2.4</td>
</tr>
<tr>
<td>install</td>
<td>maven-install-plugin:2.4</td>
</tr>
<tr>
<td>site、deploy</td>
<td>maven-site-plugin:3.3</td>
</tr>
<tr>
<td>deploy</td>
<td>maven-deploy-plugin:2.7</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>plugin标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>extensions</td>
<td>是否加载该插件的扩展，默认false</td>
</tr>
<tr>
<td>configuration</td>
<td>该插件所需要的特殊配置，在父子项目之间可以覆盖或合并</td>
</tr>
<tr>
<td>inherited</td>
<td>该插件的configuration中的配置是否可以被（继承该POM的其他Maven项目）继承，默认true</td>
</tr>
<tr>
<td>dependencies</td>
<td>该插件所特有的依赖类库</td>
</tr>
<tr>
<td>executions</td>
<td>该插件的某个goal（一个插件中可能包含多个goal）的执行方式</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>execution标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>唯一标识</td>
</tr>
<tr>
<td>goals</td>
<td>要执行的插件的goal（可以有多个），如<code>&lt;goal&gt;run&lt;/goal&gt;</code></td>
</tr>
<tr>
<td>phase</td>
<td>插件的goal要嵌入到Maven的生命周期阶段（phase）中执行，如verify</td>
</tr>
<tr>
<td>inherited</td>
<td>该execution是否可被子项目继承</td>
</tr>
<tr>
<td>configuration</td>
<td>该execution的其他配置参数</td>
</tr>
</tbody>
</table>
<p><strong>绑定插件目标(goal)</strong></p>
<p>在构建阶段上可以绑定插件目标。若阶段上未绑定任何插件目标，则该阶段将不会产生任何影响。若阶段绑定了一个或多个插件目标，则所有绑定的插件目标都将被执行</p>
<p>为构建阶段绑定插件目标(goal)：若某个阶段绑定了多个插件目标，先执行packaging中绑定的goal，后按序执行POM中绑定的goal</p>
<p><strong>在POM中设置packaging标签</strong></p>
<p>其值可以被设为jar，war，ear，pom。这些packaging值将会为每个build lifecycle中对应的build phase绑定对应的plugin goal（未指定packaging标签时，其将被默认设置为jar）</p>
<p><strong>在POM中设置plugin标签</strong></p>
<p>为某个<code>&lt;phase&gt;</code>绑定上该plugin下的某个或某些<code>&lt;goal&gt;</code></p>
<h3><span id="自定义配置插件">自定义配置插件</span></h3>
<h4><span id="指定-jdk-版本">指定 JDK 版本</span></h4>
<p>在 settings.xml 中已经配置了 JDK 版本，若将 Maven 工程部署都服务器上，脱离了 settings.xml 配置覆盖范围，无法生效</p>
<p>当前Maven工程 pom.xml 中的 maven-compiler-plugin 插件配置JDK 版本，无论在哪个环境执行编译等构建操作都有效。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件的坐标。此处引用的 maven-compiler-plugin 插件不是第三方的，是一个 Maven 自带的插件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- configuration 标签：配置 maven-compiler-plugin 插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 具体配置信息会因为插件不同、需求不同而有所差异 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="springboot-定制化打包">SpringBoot 定制化打包</span></h4>
<p>默认情况下 Maven 使用 maven-jar-plugin 插件的 jar 目标，打包成普通的 jar 包（无法通过 java -jar xxx.jar 直接运行），而SpringBoot项目需要为每个『微服务』导出为一个可以直接启动运行的jar 包（ java -jar xxx.jar ），因此需要使用spring-boot-maven-plugin</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过如下POM配置，来使得所有其它配置文件的值都在POM中统一管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中directory标签中为其它配置文件所在的目录路径。添加该配置后，在该目录下的所有配置文件中，我们都可以使用${…}来引用POM中的property，从而使得这些配置的具体值都可以统一在POM文件中进行管理</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>resources</td>
<td>build过程中涉及的资源文件</td>
</tr>
<tr>
<td>targetPath</td>
<td>资源文件的目标路径</td>
</tr>
<tr>
<td>filtering</td>
<td>构建过程中是否对资源进行过滤，默认false</td>
</tr>
<tr>
<td>directory</td>
<td>资源文件的路径，默认位于${basedir}/src/main/resources/目录下</td>
</tr>
<tr>
<td>includes</td>
<td>一组文件名的匹配模式，被匹配的资源文件将被构建过程处理</td>
</tr>
<tr>
<td>excludes</td>
<td>一组文件名的匹配模式，被匹配的资源文件将被构建过程忽略。同时被includes和excludes匹配的资源文件，将被忽略</td>
</tr>
<tr>
<td>filters</td>
<td>给出对资源文件进行过滤的属性文件的路径，默认位于${basedir}/src/main/filters/目录下。属性文件中定义若干键值对。在构建过程中，对于资源文件中出现的变量（键），将使用属性文件中该键对应的值替换</td>
</tr>
<tr>
<td>testResources</td>
<td>test过程中涉及的资源文件，默认位于${basedir}/src/test/resources/目录下。这里的资源文件不会被构建到目标构件中</td>
</tr>
</tbody>
</table>
<h2><span id="build-profiles">Build Profiles</span></h2>
<p>通过如下POM配置来为当前项目配置build profile</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 profile 天然代表众多可选配置中的一个所以由复数形式的 profiles 标签统一管理。<br>
由于 profile 标签覆盖了 pom.xml 中的默认配置，所以 profiles 标签通常是 pom.xml 中的最后一个标签</p>
<p>一个 profile 可以覆盖项目的最终名称、项目依赖、插件配置等各个方面以影响构建行为</p>
<h3><span id="profile触发">Profile触发</span></h3>
<p><strong>默认配置触发</strong></p>
<p>POM文件中没有被<code>&lt;profile&gt;</code>标签嵌套的内容作为默认的Profile触发</p>
<p><strong>基于环境配置触发</strong></p>
<p>不同的build profile可以在不同的情况下被触发，使得其中配置的内容可以对POM文件中的内容进行补充或覆盖。这使得POM文件拥有可以根据不同情况产生不同配置的能力</p>
<p>设置build profile的触发方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当jdk版本为...时，将触发profile-1；--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>profile-1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当操作系统为...时，将触发profile2；--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>profile-2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当构建命令中带了environment=test参数时，将触发profile-3--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--（mvn &lt;build phase&gt; -Denvironment=test）；--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当构建命令中带了-P profile-x时，将触发profile-x--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--（mvn &lt;build phase&gt; -P profile-x）；--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>profile-3<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>environment<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>test<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>profile-4<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当未触发任何一个build profile时，将默认触发profile-5。--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--多个build profile可被同时触发。对于发生冲突的配置，先触发的build profile中的内容会被后触发的build profile中的内容覆盖。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>profile-5<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>若一个profile存在多个触发条件：</strong></p>
<ol>
<li>Maven 3.2.2 之前：满足第一个条件即可触发</li>
<li>Maven 3.2.2 开始：需满足所有条件才能触发</li>
</ol>
<h3><span id="运行环境">运行环境</span></h3>
<ul>
<li>开发环境：供不同开发工程师开发的各个模块之间互相调用、访问；内部使用</li>
<li>测试环境：供测试工程师对项目的各个模块进行功能测试；内部使用</li>
<li>生产环境：供最终用户访问——所以这是正式的运行环境，对外提供服务</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/64a76b2f1ddac507cca1df6d.jpg" alt></p>
<h3><span id="spring-boot-多环境">Spring Boot 多环境</span></h3>
<p>在不同的环境中的配置可能不同，如数据源、日志文件</p>
<p>为了避免部署不同环境下反复修改环境配置文件，可定义多个 profile对应不同的环境，从而达到不同环境使用不同配置信息的效果</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- profile对资源的操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 先排除所有环境相关的配置文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否替换 @xx@ 表示的maven properties属性值 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--通过开启 filtering，maven 会将文件中的 @xx@ 替换 profile 中定义的 xx 变量/属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profileActive&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--多环境文件配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--默认激活--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--正式环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在application.yml 中配置spring.profiles.active= ‘@profileActive@’（或者dev、prod、test）指定使用的配置文件</li>
<li>在 idea 右侧Maven栏中的Profiles中可以看到配置的多环境，可勾选指定环境打包</li>
<li>SpringBoot 本身支持多环境配置，application-dev.yml、application-test.yml、application.prod.yml分别存放三个环境的配置</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/649f9d401ddac507cc1c4579.jpg" alt></p>
<h2><span id="maven在idea中的应用">Maven在IDEA中的应用</span></h2>
<h3><span id="idea配置maven">IDEA配置Maven</span></h3>
<p>File —&gt; Settings —&gt; Build, Execution, Deployment —&gt; Build Tools —&gt; Maven</p>
<ol>
<li>设置maven安装主目录</li>
<li>maven的settings.xml文件和本地仓库所在位置</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/64a67b131ddac507ccdd0129.jpg" alt></p>
<h3><span id="idea创建maven版java工程">IDEA创建Maven版java工程</span></h3>
<p>File–&gt;New–&gt;Module</p>
<img src="https://pic.imgdb.cn/item/64a67b6d1ddac507ccddbfd7.jpg" style="zoom:67%;">
<h3><span id="idea创建maven版web工程">IDEA创建Maven版web工程</span></h3>
<p>File–&gt;New–&gt;Module</p>
<img src="https://pic.imgdb.cn/item/64a67c441ddac507cce08cf8.jpg" style="zoom:67%;">
<p>创建后的视图：</p>
<img src="https://pic.imgdb.cn/item/64a67f1d1ddac507cce72c7c.jpg" style="zoom:67%;">
<p>显然，按照maven archetype原型创建的maven web工程缺少maven项目的完整结构：src-main-<a href="http://lib.csdn.net/base/javase">java</a> / resources，src-test-java/resources，所以需要我们手动添加文件目录</p>
<img src="https://pic.imgdb.cn/item/64a67faa1ddac507cce83aec.jpg" style="zoom:67%;">
<p>File —&gt; Project  Structure —&gt; Modules</p>
<p>给文件夹选择Mask as</p>
<img src="https://pic.imgdb.cn/item/64a67ff01ddac507cce8c0a5.jpg" style="zoom:67%;">
<h3><span id="idea中导入maven工程module">IDEA中导入Maven工程(module)</span></h3>
<p>File —&gt; Project  Structure</p>
<img src="https://pic.imgdb.cn/item/64a680961ddac507ccea59bb.jpg" style="zoom:67%;">
<img src="https://pic.imgdb.cn/item/64a680cb1ddac507cceb1fe5.jpg" style="zoom:67%;">
<h3><span id="idea中导入maven项目project">IDEA中导入Maven项目(Project)</span></h3>
<p>File–&gt;New–&gt;Project from Existing Sources</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>nacos</title>
    <url>/post/nacos/</url>
    <content><![CDATA[<p><a href="https://nacos.io/zh-cn/docs/quick-start.html">nacos官方文档</a></p>
<h1><span id="cap原则">CAP原则</span></h1>
<p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中，</p>
<p>一致性（Consistency）</p>
<p>可用性（Availability）</p>
<p>分区容错性（Partition tolerance）（这个特性是不可避免的），这三个要素最多只能同时实现两点，不可能三者兼顾</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>一致性（C）</td>
<td>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</td>
</tr>
<tr>
<td>可用性（A）</td>
<td>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</td>
</tr>
<tr>
<td>分区容错性（P）</td>
<td>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</td>
</tr>
</tbody>
</table>
<p>在分布式系统中网络会存在脑裂的问题，部分Server与整个集群失去节点联系，无法组成一个群体。只有在AP和CP选择一个平衡点</p>
<p><strong>分布式特征</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Nacos</th>
<th>Zookeeper</th>
<th>Eureka</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据一致性</td>
<td></td>
<td>注重数据的一致性</td>
<td>不是很注重数据的一致性！</td>
</tr>
<tr>
<td>服务可用性Paxos（多数派）</td>
<td></td>
<td>若集群中的master挂了，则 zk 集群整体不对外提供服务了，需要选一个新的出来（120s</td>
<td>注重服务的可用性，当 Eureka 集群只有一台活着，它就能对外提供服务</td>
</tr>
<tr>
<td>分区容错性</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Zookeeper注重数据的一致性，Eureka注重服务的可用性</p>
<h1><span id="版本依赖关系">版本依赖关系</span></h1>
<p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">版本说明 · alibaba/spring-cloud-alibaba Wiki · GitHub</a></p>
<h2><span id="毕业版本依赖关系推荐使用">毕业版本依赖关系(推荐使用)</span></h2>
<p>由于 Spring Boot 3.0，Spring Boot 2.7~2.4 和 2.4 以下版本之间变化较大，目前企业级客户老项目相关 Spring Boot 版本仍停留在 Spring Boot 2.4 以下，为了同时满足存量用户和新用户不同需求，社区以 Spring Boot 3.0 和 2.4 分别为分界线，同时维护 2022.x、2021.x、2.2.x 三个分支迭代。如果不想跨分支升级，如需使用新特性，请升级为对应分支的新版本。 为了规避相关构建过程中的依赖冲突问题，我们建议可以通过 <a href="https://start.aliyun.com/">云原生应用脚手架</a> 进行项目创建。</p>
<h3><span id="2022x-分支">2022.x 分支</span></h3>
<p>适配 Spring Boot 3.0，Spring Cloud 2022.x 版本及以上的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用标记）： (注意，该分支 Spring Cloud Alibaba 版本命名方式进行了调整，未来将对应 Spring Cloud 版本，前三位为 Spring Cloud 版本，最后一位为扩展版本，比如适配 Spring Cloud 2022.0.0 版本对应的 Spring Cloud Alibaba 第一个版本为：2022.0.0.0，第个二版本为：2022.0.0.1，依此类推)</p>
<table>
<thead>
<tr>
<th>Spring Cloud Alibaba Version</th>
<th>Spring Cloud Version</th>
<th>Spring Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>2022.0.0.0-RC2*</td>
<td>Spring Cloud 2022.0.0</td>
<td>3.0.2</td>
</tr>
<tr>
<td>2022.0.0.0-RC1</td>
<td>Spring Cloud 2022.0.0</td>
<td>3.0.0</td>
</tr>
</tbody>
</table>
<h3><span id="2021x-分支">2021.x 分支</span></h3>
<p>适配 Spring Boot 2.4，Spring Cloud 2021.x 版本及以上的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）：</p>
<table>
<thead>
<tr>
<th>Spring Cloud Alibaba Version</th>
<th>Spring Cloud Version</th>
<th>Spring Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>2021.0.5.0*</td>
<td>Spring Cloud 2021.0.5</td>
<td>2.6.13</td>
</tr>
<tr>
<td>2021.0.4.0</td>
<td>Spring Cloud 2021.0.4</td>
<td>2.6.11</td>
</tr>
<tr>
<td>2021.0.1.0</td>
<td>Spring Cloud 2021.0.1</td>
<td>2.6.3</td>
</tr>
<tr>
<td>2021.1</td>
<td>Spring Cloud 2020.0.1</td>
<td>2.4.2</td>
</tr>
</tbody>
</table>
<h3><span id="22x-分支">2.2.x 分支</span></h3>
<p>适配 Spring Boot 为 2.4，Spring Cloud Hoxton 版本及以下的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）：</p>
<table>
<thead>
<tr>
<th>Spring Cloud Alibaba Version</th>
<th>Spring Cloud Version</th>
<th>Spring Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>2.2.10-RC1*</td>
<td>Spring Cloud Hoxton.SR12</td>
<td>2.3.12.RELEASE</td>
</tr>
<tr>
<td>2.2.9.RELEASE</td>
<td>Spring Cloud Hoxton.SR12</td>
<td>2.3.12.RELEASE</td>
</tr>
<tr>
<td>2.2.8.RELEASE</td>
<td>Spring Cloud Hoxton.SR12</td>
<td>2.3.12.RELEASE</td>
</tr>
<tr>
<td>2.2.7.RELEASE</td>
<td>Spring Cloud Hoxton.SR12</td>
<td>2.3.12.RELEASE</td>
</tr>
<tr>
<td>2.2.6.RELEASE</td>
<td>Spring Cloud Hoxton.SR9</td>
<td>2.3.2.RELEASE</td>
</tr>
<tr>
<td>2.2.1.RELEASE</td>
<td>Spring Cloud Hoxton.SR3</td>
<td>2.2.5.RELEASE</td>
</tr>
<tr>
<td>2.2.0.RELEASE</td>
<td>Spring Cloud Hoxton.RELEASE</td>
<td>2.2.X.RELEASE</td>
</tr>
<tr>
<td>2.1.4.RELEASE</td>
<td>Spring Cloud Greenwich.SR6</td>
<td>2.1.13.RELEASE</td>
</tr>
<tr>
<td>2.1.2.RELEASE</td>
<td>Spring Cloud Greenwich</td>
<td>2.1.X.RELEASE</td>
</tr>
<tr>
<td>2.0.4.RELEASE(停止维护，建议升级)</td>
<td>Spring Cloud Finchley</td>
<td>2.0.X.RELEASE</td>
</tr>
<tr>
<td>1.5.1.RELEASE(停止维护，建议升级)</td>
<td>Spring Cloud Edgware</td>
<td>1.5.X.RELEASE</td>
</tr>
</tbody>
</table>
<h2><span id="组件版本关系">组件版本关系</span></h2>
<p>每个 Spring Cloud Alibaba 版本及其自身所适配的各组件对应版本如下表所示（注意，Spring Cloud Dubbo 从 2021.0.1.0 起已被移除出主干，不再随主干演进）：</p>
<table>
<thead>
<tr>
<th>Spring Cloud Alibaba Version</th>
<th>Sentinel Version</th>
<th>Nacos Version</th>
<th>RocketMQ Version</th>
<th>Dubbo Version</th>
<th>Seata Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>2022.0.0.0-RC2</td>
<td>1.8.6</td>
<td>2.2.1</td>
<td>4.9.4</td>
<td>~</td>
<td>1.7.0-native-rc2</td>
</tr>
<tr>
<td>2021.0.5.0</td>
<td>1.8.6</td>
<td>2.2.0</td>
<td>4.9.4</td>
<td>~</td>
<td>1.6.1</td>
</tr>
<tr>
<td>2.2.10-RC1</td>
<td>1.8.6</td>
<td>2.2.0</td>
<td>4.9.4</td>
<td>~</td>
<td>1.6.1</td>
</tr>
<tr>
<td>2022.0.0.0-RC1</td>
<td>1.8.6</td>
<td>2.2.1-RC</td>
<td>4.9.4</td>
<td>~</td>
<td>1.6.1</td>
</tr>
<tr>
<td>2.2.9.RELEASE</td>
<td>1.8.5</td>
<td>2.1.0</td>
<td>4.9.4</td>
<td>~</td>
<td>1.5.2</td>
</tr>
<tr>
<td>2021.0.4.0</td>
<td>1.8.5</td>
<td>2.0.4</td>
<td>4.9.4</td>
<td>~</td>
<td>1.5.2</td>
</tr>
<tr>
<td>2.2.8.RELEASE</td>
<td>1.8.4</td>
<td>2.1.0</td>
<td>4.9.3</td>
<td>~</td>
<td>1.5.1</td>
</tr>
<tr>
<td>2021.0.1.0</td>
<td>1.8.3</td>
<td>1.4.2</td>
<td>4.9.2</td>
<td>~</td>
<td>1.4.2</td>
</tr>
<tr>
<td>2.2.7.RELEASE</td>
<td>1.8.1</td>
<td>2.0.3</td>
<td>4.6.1</td>
<td>2.7.13</td>
<td>1.3.0</td>
</tr>
<tr>
<td>2.2.6.RELEASE</td>
<td>1.8.1</td>
<td>1.4.2</td>
<td>4.4.0</td>
<td>2.7.8</td>
<td>1.3.0</td>
</tr>
<tr>
<td>2021.1 or 2.2.5.RELEASE or 2.1.4.RELEASE or 2.0.4.RELEASE</td>
<td>1.8.0</td>
<td>1.4.1</td>
<td>4.4.0</td>
<td>2.7.8</td>
<td>1.3.0</td>
</tr>
<tr>
<td>2.2.3.RELEASE or 2.1.3.RELEASE or 2.0.3.RELEASE</td>
<td>1.8.0</td>
<td>1.3.3</td>
<td>4.4.0</td>
<td>2.7.8</td>
<td>1.3.0</td>
</tr>
<tr>
<td>2.2.1.RELEASE or 2.1.2.RELEASE or 2.0.2.RELEASE</td>
<td>1.7.1</td>
<td>1.2.1</td>
<td>4.4.0</td>
<td>2.7.6</td>
<td>1.2.0</td>
</tr>
<tr>
<td>2.2.0.RELEASE</td>
<td>1.7.1</td>
<td>1.1.4</td>
<td>4.4.0</td>
<td>2.7.4.1</td>
<td>1.0.0</td>
</tr>
<tr>
<td>2.1.1.RELEASE or 2.0.1.RELEASE or 1.5.1.RELEASE</td>
<td>1.7.0</td>
<td>1.1.4</td>
<td>4.4.0</td>
<td>2.7.3</td>
<td>0.9.0</td>
</tr>
<tr>
<td>2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE</td>
<td>1.6.3</td>
<td>1.1.1</td>
<td>4.4.0</td>
<td>2.7.3</td>
<td>0.7.1</td>
</tr>
</tbody>
</table>
<h1><span id="微服务注册">微服务注册</span></h1>
<h2><span id="导入依赖">导入依赖</span></h2>
<table>
<thead>
<tr>
<th>SpringBoot</th>
<th>SpringCloud</th>
<th>SpringCloudAlibaba</th>
<th>Nacos</th>
<th>Sentinel</th>
<th>Seata</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>2.3.12.RELEASE</code></td>
<td><code>Hoxton.SR12</code></td>
<td><code>2.2.9.RELEASE</code></td>
<td><code>2.1.0</code></td>
<td><code>1.8.5</code></td>
<td><code>1.5.2</code></td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>User模块中添加如下配置</strong></p>
<p>nacos 注册中心、配置中心依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot web启动、测试依赖</p>
<p>mybatisPlus依赖</p>
<p>mysql连接java依赖</p>
<h2><span id="填写配置">填写配置</span></h2>
<p>在application.yml中配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 微服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">crm-user</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="comment"># 命名空间，默认是public，不用写</span></span><br><span class="line"><span class="comment">#        namespace:</span></span><br><span class="line">        <span class="comment"># 注册的群组名称</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="comment"># Nacos用户名和密码</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure>
<p><strong>数据源配置</strong></p>
<p><strong>MybatisPlus配置</strong></p>
<h2><span id="引导类添加注解">引导类添加注解</span></h2>
<p><code>@EnableDiscoveryClient</code>：将当前微服务注册到注册中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将当前微服务注册到注册中心中</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//MybatisPlus的mapper包扫描</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="查看微服务">查看微服务</span></h2>
<p>进入本地nacos <code>http://localhost:8848/nacos</code>，输入用户名、密码</p>
<p>在服务管理下的服务列表中可以看到注册的微服务<img src="https://pic.imgdb.cn/item/64bf3ebc1ddac507cc641da5.jpg" alt></p>
<h1><span id="远程调用">远程调用</span></h1>
<h2><span id="resttemplate"><code>RestTemplate</code></span></h2>
<p>不同微服务之间可通过RestTemplate进行调用</p>
<h3><span id="注入spring容器">注入Spring容器</span></h3>
<p>在引导类中将RestTemplate交给Spring管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityApplication</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ActivityApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;activity&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="resttemplate的api">RestTemplate的API</span></h3>
<p><strong><code>T getForObject(url,T ResponseType,uriVariables)</code></strong></p>
<ol>
<li>url：请求地址</li>
<li>ResponseType：响应字节码类型</li>
<li>uriVariables：若地址栏占位符有参数，则代表地址栏占位符封装的Map集合</li>
<li>直接返回T类型的结果</li>
</ol>
<p><strong><code>ResponseEntity&lt;T&gt; getForEntity(url,T ResponseType,uriVariables)</code></strong></p>
<ol>
<li>url：请求地址</li>
<li>ResponseType：响应字节码类型</li>
<li>uriVariables：若地址栏占位符有参数，则代表地址栏占位符封装的Map集合</li>
<li>返回<code>ResponseEntity&lt;T&gt;</code>封装的结果</li>
</ol>
<p><strong><code>T postForObject(url,Object request, T ResponseType,uriVariables)</code></strong></p>
<ol>
<li>url：请求地址</li>
<li>request：请求体封装的参数</li>
<li>ResponseType：响应字节码类型</li>
<li>uriVariables：若地址栏占位符有参数，则代表地址栏占位符封装的Map集合</li>
<li>直接返回T类型的结果</li>
</ol>
<p><strong><code>ResponseEntity&lt;T&gt; postForEntity(url,Object request, T ResponseType,uriVariables)</code></strong></p>
<ol>
<li>url：请求地址</li>
<li>request：请求体封装的参数</li>
<li>ResponseType：响应字节码类型</li>
<li>uriVariables：若地址栏占位符有参数，则代表地址栏占位符封装的Map集合</li>
<li>返回<code>ResponseEntity&lt;T&gt;</code>封装的结果</li>
</ol>
<p><strong><code>void put(url,Object request, uriVariables)</code></strong></p>
<ol>
<li>url：请求地址</li>
<li>request：要修改的数据</li>
<li>uriVariables：若地址栏占位符有参数，则代表地址栏占位符封装的Map集合</li>
</ol>
<p><strong><code>void delete(url,uriVariables)</code></strong></p>
<ol>
<li>url：请求地址</li>
<li>uriVariables：若地址栏占位符有参数，则代表地址栏占位符封装的Map集合</li>
</ol>
<p><strong><code>exchange(url,HttpMethod,HttpEntity,ResponseType,uriVarialbes)</code></strong></p>
<ol>
<li>url：请求地址</li>
<li>HttpMethod：请求方式</li>
<li>HttpEntity：封装请求头（可用于权限校验，比如传递令牌，传递身份信息）或请求体（POST或PUT的请求体数据）</li>
<li>ResponseType：响应字节码类型</li>
<li>uriVariables：若地址栏占位符有参数，则代表地址栏占位符封装的Map集合</li>
<li>返回<code>ResponseEntity&lt;T&gt;</code>封装的结果</li>
</ol>
<p>当需要发送请求时传递请求头信息或远程调用PUT、DELETE并有Boolean作为返回值时可使用</p>
<h2><span id="openfeign"><code>OpenFeign</code></span></h2>
<p>直接根据微服务名称进行负载均衡请求调用，使用方式类似一个控制器</p>
<p>请求参数的接收上：<br>
get/delete请求方式接收参数：<br>
url/111 -&gt; @PathVariable<br>
url?id=111 -&gt; @RequestParam<br>
post/put请求方式接收参数：<br>
传递的都是json数据，封装到请求体中 -&gt; @RequestBody<br>
怎么进行接收的参数，我就怎么传递！！！<br>
实现：</p>
<h3><span id="导入依赖">导入依赖</span></h3>
<p>引入pom.xml起步依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Feign远程调用起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="添加注解">添加注解</span></h3>
<p>引导类上添加新的注解，开启Feign远程调用，@EnableFeignClients</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//开启Feign远程调用</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityApplication</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ActivityApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="创建接口">创建接口</span></h3>
<p>创建一个接口，作为Feign的调用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.feign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加注解<code>@FeignClient(&quot;crm-user&quot;)</code>，使SpringBoot能够扫描到Feign的接口，并创建它的代理对象，交给Spring容器进行管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;crm-user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口中声明远程微服务的控制器方法（没有方法体），根据注解确定发送的请求方式与请求地址</p>
<p>注意在映射路径中添加控制器最上方的映射路径，如<code>/list =&gt; /user/list</code></p>
<p>可通过反射注入远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoWired</span></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>
<p>注意：只要是在接口中声明的参数，在远程调用时必须填写（<code>required = false</code>不生效）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; <span class="title function_">list</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;,required = false)</span>String name)</span>；</span><br><span class="line"><span class="comment">//远程调用,name不能为空，</span></span><br><span class="line">userService.list(<span class="string">&quot;111&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1><span id="负载均衡">负载均衡</span></h1>
<p>请求均衡的分配到每个节点中</p>
<h2><span id="idea创建集群">IDEA创建集群</span></h2>
<p>本质上是服务名称一致，端口号名称不一致的微服务</p>
<p><img src="https://pic.imgdb.cn/item/64c0d7da1ddac507cceb3960.jpg" alt></p>
<p>选中要复制的微服务，点击复制</p>
<p><img src="https://pic.imgdb.cn/item/64c0d88c1ddac507cced1fac.jpg" alt></p>
<p>点击编辑选项<code>Modify options</code>，添加<code>VM Options</code>选项</p>
<p><img src="https://pic.imgdb.cn/item/64c0d8d01ddac507ccedca09.jpg" alt></p>
<p>在添加的选项中输入 <code>-Dserver.port=2001</code>为主机分配端口后，集群分配端口号同理</p>
<p><img src="https://pic.imgdb.cn/item/64c0d93b1ddac507ccee8560.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/64c0d9fc1ddac507ccf00d86.jpg" alt></p>
<p>在Nacos页面中可以看到 crm-user 微服务下有两个实例</p>
<p><img src="https://pic.imgdb.cn/item/64c0da401ddac507ccf08540.jpg" alt></p>
<h2><span id="resttemplate"><code>RestTemplate</code></span></h2>
<p>Ribbon实现</p>
<h3><span id="添加注解">添加注解</span></h3>
<p>在注入RestTemplate方法上添加<code>@LoadBalanced</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityApplication</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//负载均衡</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ActivityApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="远程调用">远程调用</span></h3>
<p>在远程调用的地址上将具体IP（localhost:2001）改为微服务的名称（crm-user）</p>
<p>此时对于拥有多个节点的微服务，无法再通过IP直接访问，只能通过微服务名称访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://crm-user/user/list  </span><br><span class="line">均衡分配到：</span><br><span class="line">=&gt;  http://localhost:2001/user/list</span><br><span class="line">=&gt;  http://localhost:2002/user/list</span><br></pre></td></tr></table></figure>
<p>可通过打印被调用节点的端口号进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer port;</span><br></pre></td></tr></table></figure>
<h2><span id="openfeign"><code>OpenFeign</code></span></h2>
<p>feign通过微服务名远程调用，自动负载均衡</p>
<h1><span id="配置中心">配置中心</span></h1>
<h2><span id="加载自定义配置">加载自定义配置</span></h2>
<h3><span id="新建配置">新建配置</span></h3>
<p>在<code>http://localhost:8848</code>中的配置管理下的配置列表页面点击＋号</p>
<p><img src="https://pic.imgdb.cn/item/64c1edd91ddac507cc905a85.jpg" alt></p>
<p>填写Data Id以及配置内容</p>
<p><img src="https://pic.imgdb.cn/item/64c1f0061ddac507cc93b67f.jpg" alt></p>
<h3><span id="spring-boot配置">Spring Boot配置</span></h3>
<p>在项目中新建文件 <code>bootstrap.yml</code></p>
<p><code>application.yml</code> 为用户级别配置文件，<code>bootstrap.yml</code> 为系统级别配置文件，作为配置中心加载的内容，优先级最高</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">32b466f9-2121-4b5a-908b-392ca6acb647</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="comment"># 加载配置文件的前缀名称</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">application</span></span><br><span class="line">        <span class="comment"># 加载配置文件的后缀名称（配置格式）</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 加载配置文件的环境名称</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">crm</span></span><br></pre></td></tr></table></figure>
<h3><span id="控制器测试">控制器测试</span></h3>
<p>控制器添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;getInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64c1f4091ddac507cc996b05.jpg" alt></p>
<h3><span id="配置热更新">配置热更新</span></h3>
<p>在控制器上添加<code>@RefreshScope</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置热更新</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;activity&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityController</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="多配置文件拆分">多配置文件拆分</span></h2>
<p>对于配置文件中可能重用的公共部分，可以根据功能拆分成多个配置文件，例如一下可以拆分成</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 微服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">crm-user</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="comment"># 命名空间，默认是public，不用写</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">32b466f9-2121-4b5a-908b-392ca6acb647</span></span><br><span class="line">        <span class="comment"># 注册的群组名称</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="comment"># Nacos用户名和密码</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:1111/crm?characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="comment"># Mybatis配置信息(MybatisPlus是对Mybatis的增强)</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">is_delete</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>application-nacos.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="comment"># 命名空间，默认是public，不用写</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">32b466f9-2121-4b5a-908b-392ca6acb647</span></span><br><span class="line">        <span class="comment"># 注册的群组名称</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="comment"># Nacos用户名和密码</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure>
<p>application-mybatis-plus.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mybatis配置信息(MybatisPlus是对Mybatis的增强)</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">is_delete</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>application-datasource.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:1111/crm?characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h2><span id="多配置文件加载">多配置文件加载</span></h2>
<p>在<code>bootstrap.yml</code>文件的<code>Spring.profiles.active</code>进行加载</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">32b466f9-2121-4b5a-908b-392ca6acb647</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">application</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">      <span class="string">crm,mybatis-plus,nacos,datasource</span></span><br></pre></td></tr></table></figure>
<h2><span id="持久化保存配置文件">持久化保存配置文件</span></h2>
<p>nacos内置了数据库Derby</p>
<h3><span id="创建mysql数据库">创建MySQL数据库</span></h3>
<p>执行nacos安装目录下的 <code>/conf/nacos-mysql.sql</code> 文件</p>
<h3><span id="导出配置">导出配置</span></h3>
<p><img src="https://pic.imgdb.cn/item/64c214181ddac507ccdc0481.jpg" alt></p>
<h3><span id="修改配置文件">修改配置文件</span></h3>
<p>nacos安装目录下的 <code>/conf/application.properties</code> 文件，找到并修改如下配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#*************** Config Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If use MySQL as datasource:</span></span><br><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Count of DB:</span></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Connect URL of DB:</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:1111/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 127.0.0.1/16 biyixia</span><br><span class="line"></span><br><span class="line">docker run -<span class="built_in">id</span> --name=nacos --hostname=nacos -p 8848:8848 -p 9848:9848  -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql -e MYSQL_SERVICE_HOST=host.docker.internal -e MYSQL_SERVICE_PORT=1111 -e MYSQL_SERVICE_DB_NAME=nacos_config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=123456 -e MYSQL_DATABASE_NUM=1 -e MYSQL_SERVICE_DB_PARAM=<span class="string">&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&quot;</span> -e JVM_XMS=256m -e JVM_XMX=256m nacos/nacos-server:v2.1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="重启nacos">重启nacos</span></h3>
<p>注意：此时保存配置数据源从nacos内置数据库修改成MySQL数据库，<strong>重启nacos前必须导出原有的配置</strong>，否则将会丢失数据</p>
<h3><span id="导入配置">导入配置</span></h3>
<p><img src="https://pic.imgdb.cn/item/64c216911ddac507cce25760.jpg" alt></p>
<p>此时配置文件也被同步到上述配置的<code>nacos_config</code>数据库中的<code>config_info</code>表</p>
<p><img src="https://pic.imgdb.cn/item/64c2171e1ddac507cce3c4bd.jpg" alt></p>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>rabbitMQ</title>
    <url>/post/rabbitMQ/</url>
    <content><![CDATA[<h1><span id="消息队列message-queue">消息队列(Message Queue)</span></h1>
<p>消息指的是两个应用间传递的数据（字符串、对象等）</p>
<p>消息队列是在消息的传输过程中保存消息的容器</p>
<p>在消息队列中，通常有生产者和消费者两个角色</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>生产者</td>
<td>只负责发送数据到消息队列，无需关心谁从消息队列中取出数据处理</td>
</tr>
<tr>
<td>消费者</td>
<td>只负责从消息队列中取出数据处理，无需关心是谁发送的数据</td>
</tr>
</tbody>
</table>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE5LzE3MzY3NTNjNDc1M2M2Zjk?x-oss-process=image/format,png" alt="img"></p>
<h2><span id="消息队列的作用">消息队列的作用</span></h2>
<p><strong>解耦</strong></p>
<img src="https://pic.imgdb.cn/item/64c774ca1ddac507cc90bee8.jpg" style="zoom:67%;">
<p>如上图，系统A通过调用三个方法（sendMsgForB、sendMsgForC、sendMsgForD）分别发送数据到系统B、C、D</p>
<p>若系统D不再需要系统A的数据且新增系统E需要系统A的数据，则需要删除系统A的sendMsgForD方法并添加sendMsgForE方法</p>
<p>使用MQ可以降低这种强耦合，系统A只需要把数据发送到MQ，需要数据的其他系统可从MQ中获取</p>
<p><strong>异步</strong></p>
<img src="https://pic.imgdb.cn/item/64c774fe1ddac507cc911621.jpg" style="zoom:67%;">
<p>如上图，客户端发送一个请求到系统A，系统A会顺序调用系统B、C、D三个系统，响应时间为系统A、B、C、D的总和，也就是800ms</p>
<p><strong>若使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能</strong></p>
<p>应用于一些非必要的业务，比如发送短信，发送邮件等等</p>
<p><strong>削峰</strong></p>
<img src="https://pic.imgdb.cn/item/64c7751c1ddac507cc914516.jpg" style="zoom:67%;">
<p>如上图，假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL无法处理如此多的请求，MySQL就会崩溃导致系统瘫痪</p>
<p><strong>如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃</strong></p>
<h1><span id="rabbitmq">RabbitMQ</span></h1>
<h2><span id="rabbitmq特点">RabbitMQ特点</span></h2>
<p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件</p>
<ul>
<li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li>
<li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>
<li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li>
<li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li>
<li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li>
<li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li>
</ul>
<h2><span id="rabbitmq组成部分">RabbitMQ组成部分</span></h2>
<p><img src="https://pic.imgdb.cn/item/64c771bd1ddac507cc8ac3fb.jpg" alt></p>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Producer</td>
<td>生产者。生产方客户端将消息同交换机路由发送到队列中</td>
</tr>
<tr>
<td>Broker</td>
<td>中间服务进程。此进程包括两个部分：Exchange和Queue</td>
</tr>
<tr>
<td>Exchange</td>
<td>交换机。按一定的规则将消息路由转发到某个队列</td>
</tr>
<tr>
<td>Queue</td>
<td>消息队列，存储消息的队列（先进先出）</td>
</tr>
<tr>
<td>Consumer</td>
<td>消费者。消费队列中存储的消息</td>
</tr>
</tbody>
</table>
<ol>
<li>消息的生产者创建连接对象（Connect）并开启管道对象（Channel），从而连接中间服务进程</li>
<li>生产者声明交换机类型、名称、是否持久化等</li>
<li>生产者发送消息，并指定消息是否持久化等属性和路由键（routing key）</li>
<li>交换机接收消息并根据路由键（routing key）路由到当前交换机绑定（binding）的消息队列</li>
<li>消费者监听接收到消息之后开始业务处理</li>
</ol>
<h2><span id="交换机">交换机</span></h2>
<p><strong>直连交换机（direct）</strong></p>
<p>适用于一对一、点对点的发送消息，即只能被一个消费者消费，若有多个消费者，则最先的消费者消费</p>
<p>若没有消费者消费，则消息会被持久化保存到消息队列中</p>
<p>绑定消息队列的参数 交换机名称、路由键、消息队列名称</p>
<p><strong>Fanout类型交换机</strong></p>
<p>适用于一对多发送消息（广播模式）</p>
<p>若没有消费者及时监听，则该消息被丢失（不会持久化保存到消息队列中）</p>
<p>绑定消息队列参数：交换机名称、消息队列名称</p>
<p><strong>Topic类型交换机</strong></p>
<p>适用于一对一、一对多的发送消息，可根据Topic类型交换机匹配的通配规则来将消息路由转发</p>
<p>若没有消费者消费，则消息会被持久化保存到消息队列中</p>
<p>绑定消息队列参数：交换机名称、通配符、消息队列、路由键</p>
<p><strong>Headers类型交换机</strong></p>
<p>特殊队列容器：延迟队列、死信队列，都可以在某种情况下进行扣除或补回的操作</p>
<h3><span id="队列">队列</span></h3>
<table>
<thead>
<tr>
<th>队列属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>队列名称（name）</td>
<td>队列的名称</td>
</tr>
<tr>
<td>持久化（durable）</td>
<td>消息将持久化保存到消息队列中</td>
</tr>
<tr>
<td>排外（exclusive）</td>
<td>该消息只能被一个消费者（创建者）消费，反之，排外表示该消息能被多个消费者消费</td>
</tr>
<tr>
<td>自动删除（autoDelete）</td>
<td>是否自动删除，也就是临时队列。当最后一个消费者断开连接后，会自动删除</td>
</tr>
<tr>
<td>其他属性</td>
<td>可以在控制台获取参数的key来针对性配置，例如，延迟队列、死信队列、消息的过期时间、消息的倒计时</td>
</tr>
</tbody>
</table>
<h1><span id="环境搭建">环境搭建</span></h1>
<h2><span id="容器安装">容器安装</span></h2>
<h3><span id="拉取镜像">拉取镜像</span></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>
<h3><span id="创建容器">创建容器</span></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开放端口：5672(Java通信端口) 15672(管理控制台通信端口) 25672(集群通信端口) 4369(集群通信端口)</span></span><br><span class="line">docker run -d --hostname rabbitmq --name rabbitmq -p 5672:5672 -p 15672:15672 -p 25672:25672 -p 4369:4369 -e RABBITMQ_DEFAULT_VHOST=/ -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=root rabbitmq:management</span><br></pre></td></tr></table></figure>
<h2><span id="导入依赖">导入依赖</span></h2>
<p>在pom.xml文件中导入如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--RabbitMQ起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以及Springboot、nacos依赖</p>
<h2><span id="添加配置">添加配置</span></h2>
<p>在application.yml中添加如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>
<h1><span id="使用rabbitmq">使用RabbitMQ</span></h1>
<h2><span id="生产者发送消息">生产者发送消息</span></h2>
<p><strong>模板对象</strong></p>
<p>RabbitTemplate、AmqpTemplate</p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>convertAndSend(String routingKey, Object object)</td>
<td>使用直流交换机进行消息的路由转发<br>routingKey代表当前消息队列名称<br>Object代表要传输的消息数据</td>
</tr>
<tr>
<td>convertAndSend(String exchange, String routingKey, Object object)</td>
<td>exchange代表要使用的交换机<br>routingKey代表路由键信息<br>Object代表要传输的消息数据</td>
</tr>
</tbody>
</table>
<p>在生产者微服务中发送消息</p>
<h3><span id="使用默认交换机">使用默认交换机</span></h3>
<p><strong>配置消息队列，使用默认绑定关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="comment">//声明消息队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">basicQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;basicQueue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDefaultExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;basicQueue&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\&quot;id\&quot;:111&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="指定直流交换机direct">指定直流交换机（direct）</span></h3>
<p><strong>配置消息队列、交换机以及它们的绑定关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="comment">//声明消息队列（首次创建必须声明）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">basicQueue</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;basicQueue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">amqDirect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;amp.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">amqDirectBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(basicQueue()).to(amqDirect()).with(<span class="string">&quot;basic&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;directExchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;directRoutingKey&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\&quot;id\&quot;:111&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="指定扇出交换机fanout">指定扇出交换机（fanout）</span></h3>
<p><strong>配置消息队列、交换机以及它们的绑定关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanoutExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanoutQueue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanoutQueue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">fanoutExchangeBinding1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">fanoutExchangeBinding2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送消息</strong></p>
<p>无需指定路由键，将发送到指定交换机绑定的所有消息队列上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;fanoutExchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\&quot;id\&quot;:321&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="指定主题交换机topic">指定主题交换机（topic）</span></h3>
<p><strong>配置消息队列、交换机以及它们的绑定关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;topicExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topicQueue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topicQueue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueue3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topicQueue3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">topicExchangeBinding1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//精准匹配aa</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">topicExchangeBinding2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//匹配以aa开头的两段英文字母</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(<span class="string">&quot;aa.*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">topicExchangeBinding3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//匹配以aa开头的所有英文字母</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue3()).to(topicExchange()).with(<span class="string">&quot;aa.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;topicExchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;aa&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\&quot;id\&quot;:111&quot;</span></span><br><span class="line">        );</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;topicExchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;aa.bb&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\&quot;id\&quot;:222&quot;</span></span><br><span class="line">        );</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;topicExchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;aa.bb.cc&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\&quot;id\&quot;:333&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者接收结果</strong></p>
<p><img src="https://pic.imgdb.cn/item/64c86a101ddac507cc2a31b9.jpg" alt></p>
<h2><span id="消费者接收消息">消费者接收消息</span></h2>
<p>在消费者微服务中接收消息，添加如下配置类以及注解<code>@RabbitListener(queues = &#123;&quot;【消息队列名称】&quot;&#125;)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;basicQueue&quot;,&quot;directQueue&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveBasicQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="comment">//当消费者从消息队列中接收消息时，消息队列默认将该数据删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;fanoutQueue1&quot;,&quot;fanoutQueue2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveFanoutQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">    System.out.println(message.getMessageProperties().getConsumerQueue()+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">    //监听器中也能声明绑定关系，如下声明了一个绑定了“fanoutExchange”的随机名称的消息队列</span></span><br><span class="line"><span class="meta">    //它默认属性为exclusive：true，auto-delete：true</span></span><br><span class="line"><span class="meta">    //当把消费者服务关闭（没有消费者监听该消息队列），则该消息队列自动删除</span></span><br><span class="line"><span class="meta">    @QueueBinding(value = @Queue,exchange = @Exchange(name = &quot;fanoutExchange&quot;,type = &quot;fanout&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveSpringQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">    <span class="comment">//当消费者从消息队列中接收消息时，消息队列默认将该数据删除</span></span><br><span class="line">    System.out.println(message.getMessageProperties().getConsumerQueue()+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="生产者消息确认机制">生产者消息确认机制</span></h2>
<h3><span id="添加配置">添加配置</span></h3>
<p>在<code>application.yml</code>中添加如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">provider</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="comment"># 以下开启生产者消息确认模式</span></span><br><span class="line">    <span class="comment"># 是否路由到指定交换机</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="comment"># 是否路由到指定消息队列</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3><span id="发送确认">发送确认</span></h3>
<p>是否发送到指定交换机或消息队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProducerConfirm</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//消息是否发送到指定交换机与消息队列中</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------------------returnedMessage----------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;message:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            System.out.println(<span class="string">&quot;replyCode:&quot;</span> + replyCode);</span><br><span class="line">            System.out.println(<span class="string">&quot;replyText:&quot;</span> + replyText);</span><br><span class="line">            System.out.println(<span class="string">&quot;exchange:&quot;</span> + exchange);</span><br><span class="line">            System.out.println(<span class="string">&quot;routingKey:&quot;</span> + routingKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------------------confirm----------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(correlationData.getReturnedMessage().getBody()));</span><br><span class="line">            System.out.println(<span class="string">&quot;ack:&quot;</span> + ack);</span><br><span class="line">            System.out.println(<span class="string">&quot;cause:&quot;</span> + cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">//设置回调信息</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    correlationData.setReturnedMessage(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;&#123;id:111&#125;&quot;</span>.getBytes()));</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(</span><br><span class="line">        <span class="string">&quot;directExchange&quot;</span>,</span><br><span class="line">        <span class="string">&quot;directRoutingKey&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&#123;\&quot;id\&quot;:123&#125;&quot;</span>,</span><br><span class="line">        <span class="comment">//当无法找到指定的交换机，会执行回调的方法进行消息的确认</span></span><br><span class="line">        correlationData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p><strong>当指定交换机不存在时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------confirm----------------------------------</span><br><span class="line">correlationData:&#123;id:111&#125;</span><br><span class="line">ack:false</span><br><span class="line">cause:channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;directExchange123&#x27; in vhost &#x27;/&#x27;, class-id=60, method-id=40)</span><br></pre></td></tr></table></figure>
<p><strong>当指定路由不存在时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------returnedMessage----------------------------------</span><br><span class="line">message:&#123;&quot;id&quot;:123&#125;</span><br><span class="line">replyCode:312</span><br><span class="line">replyText:NO_ROUTE</span><br><span class="line">exchange:directExchange</span><br><span class="line">routingKey:directRoutingKey123</span><br><span class="line">-----------------------------confirm----------------------------------</span><br><span class="line">correlationData:&#123;id:111&#125;</span><br><span class="line">ack:true</span><br><span class="line">cause:null</span><br></pre></td></tr></table></figure>
<h2><span id="消费者消息确认机制">消费者消息确认机制</span></h2>
<h3><span id="添加配置">添加配置</span></h3>
<p>在<code>application.yml</code>中添加如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="comment"># 消费者确认模式设置为  手动确认模式</span></span><br><span class="line">        <span class="comment"># 默认为自动设置模式，当消息队列中的消息被消费者消费，自动确认后删除消息队列中的消息</span></span><br><span class="line">        <span class="comment"># 设置手动确认模式后，必须手动确认消费消息，否则不会删除消息队列中的消息</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
<h3><span id="消息确认">消息确认</span></h3>
<p>监听器中添加参数<code>channel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;basicQueue&quot;,&quot;directQueue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveBasicQueue</span><span class="params">(Message message, Channel channel)</span>&#123;</span><br><span class="line">    <span class="comment">//当消费者从消息队列中接收消息时，消息队列默认将该数据删除</span></span><br><span class="line">    System.out.println(message.getMessageProperties().getConsumerQueue()+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(</span><br><span class="line">            <span class="comment">//消费者消息id</span></span><br><span class="line">            message.getMessageProperties().getDeliveryTag(),</span><br><span class="line">            <span class="comment">//是否批量消费</span></span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="延迟队列与死信队列">延迟队列与死信队列</span></h2>
<p>若在指定时间没有消费者接收消息队列（延迟队列）中的消息，则该消息将被转发至死信队列，并进行消息的补回操作</p>
<p><strong>声明延迟队列（配置属性）、死信队列、死信交换机以及死信队列与死信交换机的绑定关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明延迟队列</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">delayQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//声明消息过期时间(以ms为单位)</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;deadLetterExchange&quot;</span>);</span><br><span class="line">    <span class="comment">//死信路由键</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;deadLetterRoutingKey&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delayQueue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明死信队列</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">deadLetterQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;deadLetterQueue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明死信交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">deadLetterExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;deadLetterExchange&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明死信交换机与死信队列的绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">deadLetterBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(deadLetterQueue()).to(deadLetterExchange()).with(<span class="string">&quot;deadLetterRoutingKey&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送消息至延迟队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelayMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                <span class="string">&quot;delayQueue&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;\&quot;id:\&quot;:321&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>经过指定时间后接收死信队列消息（手动确认）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;deadLetterQueue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDeadLetterQueue</span><span class="params">(Message message,Channel channel)</span> &#123;</span><br><span class="line">    <span class="comment">//消息补回操作</span></span><br><span class="line">    System.out.println(message.getMessageProperties().getConsumerQueue()+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    <span class="comment">//手动确认消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(</span><br><span class="line">            message.getMessageProperties().getDeliveryTag(),</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>redis</title>
    <url>/post/redis/</url>
    <content><![CDATA[<h1><span id="nosql介绍">NoSQL介绍</span></h1>
<p>NoSQL(Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库</p>
<h2><span id="为什么需要nosql">为什么需要NoSQL</span></h2>
<p>随着互联网Web2.0（Ajax）网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS（Social Networking Services，即社会性网络服务）类型的Web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如：</p>
<ol>
<li>
<p>High performance — 对数据库高并发读写的需求</p>
<p>Web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。</p>
</li>
<li>
<p>Huge Storage — 对海量数据的高效率存储和访问的需求</p>
<p>类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯、盛大，动辄（zhé）数以亿计的帐号，关系数据库也很难应付。</p>
</li>
<li>
<p>High Scalability &amp;&amp; High Availability — 对数据库的高可扩展性和高可用性的需求。</p>
<p>在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？</p>
</li>
</ol>
<p>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<h2><span id="nosql特点">NoSQL特点</span></h2>
<p>在大数据存取上具备关系型数据库无法比拟的性能优势：</p>
<ol>
<li>
<p>大数据量，高性能</p>
<p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。</p>
<p>绝大多数NoSQL数据库都是基于内存存储的！</p>
</li>
<li>
<p>易扩展</p>
<p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>
</li>
<li>
<p>灵活的数据模型</p>
<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的Web2.0时代尤其明显。</p>
</li>
<li>
<p>高可用</p>
<p>NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。高可用：通过特殊手段减少不能提供服务的时间！</p>
</li>
</ol>
<p>综上所述，NoSQL的非关系特性使其成为了后Web2.0时代的宠儿，助力大型Web2.0网站的再次起飞，是一项全新的数据库革命性运动。</p>
<h2><span id="主流nosql产品">主流NoSQL产品</span></h2>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps1.jpg)</p>
<p>NoSQL数据库的四大分类如下：</p>
<p>n 键值(Key-Value)存储数据库</p>
<p>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</p>
<p>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。</p>
<p>数据模型： 一系列键值对</p>
<p>优势： 快速查询</p>
<p>劣势： 存储的数据缺少结构化</p>
<p>n 列存储数据库</p>
<p>相关产品：Cassandra, HBase, Riak</p>
<p>典型应用：分布式的文件系统</p>
<p>数据模型：以列簇式存储，将同一列数据存在一起</p>
<p>优势：查找速度快，可扩展性强，更容易进行分布式扩展</p>
<p>劣势：功能相对局限</p>
<p>n 文档型数据库</p>
<p>相关产品：CouchDB、MongoDB</p>
<p>典型应用：Web应用（与Key-Value类似，Value是结构化的）</p>
<p>数据模型： 一系列键值对</p>
<p>优势：数据结构要求不严格</p>
<p>劣势： 查询性能不高，而且缺乏统一的查询语法</p>
<p>n 图形(Graph)数据库</p>
<p>相关数据库：Neo4J、InfoGrid、Infinite Graph</p>
<p>典型应用：社交网络</p>
<p>数据模型：图结构</p>
<p>优势：利用图结构相关算法。</p>
<p>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p>
<h1><span id="redis介绍">Redis介绍</span></h1>
<h2><span id="redis由来">Redis由来</span></h2>
<p>2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久，该公司的创始人Salvatore Sanfilippo便对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。</p>
<p>Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用 Redis。国内如新浪、网易、知乎，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。VMware公司从2010年开始赞助Redis的开发， Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。</p>
<h2><span id="什么是redis">什么是Redis</span></h2>
<p>Redis(Remote Dictionary Server)，即远程词典服务器，通常被称为数据结构服务器。</p>
<p>Redis是使用C语言编写的、开源的、高性能的（基于内存亦可持久化）、键值对（key-value）数据库。</p>
<p>Redis还提供多种语言的API，当然也包括Java，这意味着我们可以使用Java来操作Redis数据库。</p>
<p>官方提供测试数据：50个并发执行100000个请求，读的速度是110000次/s，写的速度是81000次/s 。</p>
<p>数据仅供参考，根据服务器配置会有不同结果。</p>
<h2><span id="redis的应用场景">Redis的应用场景</span></h2>
<ul>
<li>缓存（数据查询、短连接、新闻内容、商品内容等等）（使用最多）</li>
<li>聊天室的在线好友列表</li>
<li>任务队列（秒杀、抢购、12306等等）</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒）</li>
<li>分布式集群架构中的session分离</li>
</ul>
<h1><span id="redis安装和使用">Redis安装和使用</span></h1>
<h2><span id="搭建环境">搭建环境</span></h2>
<p>前提：搭建虚拟机、Linux以及Linux远程连接工具</p>
<p>redis建议安装在linux服务器上运行，官方并未提供windows版的redis</p>
<p>但是微软开发了基于windows的redis，用法和Linux的redis一样</p>
<h2><span id="在centos中安装redis">在CentOS中安装Redis</span></h2>
<h3><span id="安装redis的编译环境">安装redis的编译环境</span></h3>
<p>Redis是C语言开发，安装redis前需要先将官网下载的源码进行编译，需要安装编译环境，gcc-c++：</p>
<p>安装命令：yum install gcc-c++</p>
<p>如果安装时出错，原因是软件仓库地址过时了！</p>
<p>解决方案：</p>
<p>cd /etc/yum.repos.d/</p>
<p>使用资料中的CentOS-Base.repo替换到该位置下的同名文件</p>
<p><strong>rpm和yum的区别</strong>：</p>
<p>rpm是由红帽公司开发的软件包管理方式，使用rpm可以方便的进行软件的安装、卸载、升级、查询等工作。但是rpm软件包之间可能有依赖关系，处理这些依赖性问题往往会很繁琐。例如使用rpm安装gcc环境时，首先要有gcc的rpm包，如果没有则需要先下载gcc的软件包并上传到Linux服务器，但是在安装gcc-c++时，会出现如下错误提示：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps2.jpg)</p>
<p>意思是gcc-c++环境需要依赖gcc、libmpfr、libstdc这3个包，费了九牛二虎之力从网上找到这3个包并上传到服务进行安装，但是！在安装这3个包时，又会出现新的类似的错误提示，然后接下来：下载、安装、看到错误提示、下载、安装、看到错误提示、下载、安装……最后终于搞定了！</p>
<p>整个过程安装了N个软件包，而且需要按照一定的顺序安装，显然你的内心是崩溃的！</p>
<p>YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>
<h3><span id="安装redis">安装Redis</span></h3>
<p>步骤：</p>
<p>1、 上传redis到Linux服务器</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps3.jpg)</p>
<p>2、 解压文件：tar -xvf redis-4.0.0.tar.gz</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps4.jpg)</p>
<p>3、 编译redis(将.c文件编译为.o文件)</p>
<p>cd redis-4.0.0</p>
<p>make</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps5.jpg)</p>
<p>4、 安装redis</p>
<p>make PREFIX=/usr/soft/redis install</p>
<p>PREFIX=/usr/soft/redis的意思是将redis安装到/usr/soft/redis目录下</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps6.jpg)</p>
<p>安装完成！在/usr/soft目录下，会有一个redis目录</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps7.jpg)</p>
<p>进入redis目录，下面有个bin目录，bin目录下有几个可执行文件</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps8.jpg)</p>
<p>redis-benchmark		----性能测试工具</p>
<p>redis-check-aof			----AOF文件修复工具</p>
<p>redis-check-dump		----RDB文件检查工具（快照持久化文件）</p>
<p>redis-cli						----命令行客户端</p>
<p>redis-server				----启动redis服务器命令</p>
<h2><span id="redis的启动和停止">Redis的启动和停止</span></h2>
<h3><span id="前端模式启动">前端模式启动</span></h3>
<p>进入到/usr/soft/redis/bin目录下，执行redis-server</p>
<p>cd /usr/soft/redis/bin</p>
<p>./redis-server</p>
<p>此种方式启动，我们习惯称为前端模式启动，前端模式启动的缺点是启动完成后，不能再进行其他操作，</p>
<p>如果要操作必须使用ctrl+c，此时redis-server程序结束，不推荐使用此方法。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps9.jpg)</p>
<p>使用Ctrl + C 停止前端启动模式</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps10.jpg)</p>
<h3><span id="后端模式启动">后端模式启动</span></h3>
<p>后端启动方式，需要使用redis的配置文件redis.conf，该文件的位置：/usr/soft/redis-6.2.6/redis.conf，在这个配置文件中，</p>
<p>可以修改端口号等信息，为了方便使用，将该配置文件copy一份到redis的bin目录下</p>
<p>cp /usr/soft/redis-6.2.6/redis.conf  /usr/soft/redis/bin</p>
<p>然后修改该配置文件中的daemonize no为daemonize yes</p>
<p>vim /usr/soft/redis/bin/redis.conf，先不进入编辑模式，内容太多，需要搜索，在命令模式下输入/daemonize no，回车。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps11.jpg)</p>
<p>然后再按 Shift + A，进入编辑模式并将光标定位在当前行的末尾，将no改为yes</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps12.jpg)</p>
<p>启动redis服务器：</p>
<p>cd /usr/soft/redis/bin</p>
<p>./redis-server  redis.conf</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps13.jpg)</p>
<p>提示：或者在启动服务时： ./redis-server &amp;</p>
<h3><span id="停止redis">停止Redis</span></h3>
<p>l 强制结束程序，可能会导致redis持久化数据丢失！企业中禁止使用！</p>
<p>查看redis进程端口占用：ps -ef | grep -i redis</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps14.jpg)</p>
<p>强制杀死进程：kill -9 31123</p>
<p>l 正确停止Redis的方式应该是向Redis发送SHUTDOWN命令：</p>
<p>cd /usr/sfot/redis/bin</p>
<p>./redis-cli shutdown</p>
<p>​</p>
<p>​</p>
<h2><span id="redis的简单使用">Redis的简单使用</span></h2>
<p>使用客户端连接服务器：</p>
<p>cd /usr/soft/redis/bin</p>
<p>./redis-cli</p>
<p><strong>ping</strong> [message]：测试客户端与Redis服务的连接是否正常，如果连接正常会收到回复PONG（如果指定message，则原样回复）</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps15.jpg)</p>
<p><strong>set/get</strong>**：**向redis数据库中存取字符串类型的数据</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps16.jpg)</p>
<p>取中文时不能正常显示，实际上保存进去的的确是中文，不能正常显示跟redis的编解码有关系。</p>
<p>解决方式是：./redis-cli --raw  raw的意思是未经过加工（编码）的</p>
<p>windows版客户端同样存在该问题，在运行客户端的时候，通过dos命令运行：在redis客户端</p>
<p>所在的目录中，在地址栏中输入cmd，回车，输入redis-cli --raw</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps17.jpg)</p>
<h2><span id="key的常用操作">key的常用操作</span></h2>
<p>l keys pattern：查看所有与pattern匹配的key。pattern中 * 表示任意多个字符，?表示任意一个字符</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps18.jpg)</p>
<p>l del key…：删除指定的key</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps19.jpg)</p>
<p>l exists key…：判断指定的key是否存在，0代表不存在，大于0表示存在</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps20.jpg)</p>
<p>l rename oldkeyname newkeyname：为当前的key重命名</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps21.jpg)</p>
<p>l expire key ：设置过期时间，单位：秒</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps22.jpg)</p>
<p>l ttl key：获取该key所剩的超时时间，如果没有设置，返回-1，返回-2 表示key本身不存在。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps23.jpg)</p>
<p>l type key：获取指定的key对应数据的类型：string、hash、list、set或zset，如果key不存在返回none。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps24.jpg)</p>
<p>清除所有数据：flushdb</p>
<h1><span id="redis的数据结构">Redis的数据结构</span></h1>
<p>Redis是一种高级的key-value的存储系统</p>
<p>l 关于key的定义，需要注意的几点：</p>
<p>\1. key不要太长，最好不要超过1024个字节，这不仅会消耗内存还会降低查找效率</p>
<p>\2. key不要太短，如果太短会降低key的可读性，而且容易发生key冲突</p>
<p>\3. 在项目中，key最好有统一的命名规范</p>
<p>目前最流行、最通用的命名方式为: key由多个部分(单词)组成，多个部分使用冒号分开，例如：</p>
<p>code:register:18105185234</p>
<p>code:register:18105185235</p>
<p>code:register:18105185236</p>
<p>code:login:18105185234</p>
<p>code:login:18105185235</p>
<p>code:login:18105185236</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps25.jpg)</p>
<p>l value支持五种基本数据类型。</p>
<p>\1. 字符串（String）  最基础、最常用！</p>
<p>\2. 哈希（hash）</p>
<p>\3. 列表（list）</p>
<p>\4. 集合（set）</p>
<p>\5. 有序集合（sorted set）</p>
<h1><span id="五种数据类型">五种数据类型</span></h1>
<h2><span id="string重要">String(重要！)</span></h2>
<h3><span id="概述">概述</span></h3>
<p>字符串类型是Redis中最基础最常用的数据类型，Value最多可以容纳的数据长度是512M</p>
<h3><span id="常用命令">常用命令</span></h3>
<p><strong>赋值命令</strong>：set key value，如果该key存在则进行覆盖操作</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps26.jpg)</p>
<p>正常情况下，为一个key指定值的时候，可以不加引号（单引号和双引号都可以用来表示字符串）</p>
<p>三种特殊情况：</p>
<p>\1. 如果值中包含空格等特殊符号时，必须在值的两端使用单引号或双引号，如果不确定有哪些特殊字符必须使用引号，可以都添加引号</p>
<p>\2. 如果字符串中有单引号，则值必须放在双引号中</p>
<p>\3. 如果字符串中有双引号，则值必须放在单引号中</p>
<p>\4. 如果字符串中既有单引号，又有双引号</p>
<p>a) 如果字符串两端使用单引号，则值中的单引号需要使用\进行转义</p>
<p>b) 如果字符串两端使用双引号，则值中的双引号需要使用\进行转义</p>
<p><strong>取值命令</strong>：get key，根据key获取值</p>
<p>注意：如果存在该key，但是对应的value不是String类型，将返回错误信息，</p>
<p>因为get命令只能用于获取String value，如果该key不存在，返回(nil)，即“无”。</p>
<p><strong>取值并赋值命令</strong>：getset key  value：先获取该key的值，然后再设置该key的值。没有setget！</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps27.jpg)</p>
<p><strong>删除命令</strong>**：**del key1 key2 key3…  返回的数字表示删除成功的个数</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps28.jpg)</p>
<p>数值递增：incr key</p>
<p>将指定的key对应的value递增1，如果该key不存在，其初始值为0，在incr之后其值为1。</p>
<p>如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。</p>
<p>数值递减：decr key</p>
<p>将指定的key的value递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。</p>
<p>如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps29.jpg)</p>
<p>**数值增加：**incrby  key  increment</p>
<p>将指定的key的value增加increment，如果该key不存在，则初始值为0，在incrby之后，该值为increment。如果该值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。</p>
<p>**数值减少：**decrby key  decrment</p>
<p>将指定的 key 的value减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为-decrement。如果该值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。</p>
<p><em><strong>*注意：如果希望操作小数，可以使用命令：incrbyfloat  ，没有decrbyfloat，可以使用正数表示增加，负数表示减少*</strong></em></p>
<p>**字符串拼接：**append key value</p>
<p>如果该key存在，则在原有的value后追加该值；如果该key不存在，则重新创建一个key/value</p>
<p>返回值为追加后的长度！</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps30.jpg)</p>
<h2><span id="hash">Hash</span></h2>
<h3><span id="概述">概述</span></h3>
<p>Redis中的Hash类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。每一个Hash可以存储4294967295个键值对。</p>
<h3><span id="常用命令">常用命令</span></h3>
<h4><span id="赋值">赋值</span></h4>
<p>hset key field value：为指定的key设定field/value对（键值对）。</p>
<p>hmset key field value [field2 value2 …]：设置key中的多个filed/value</p>
<p>m: multiple</p>
<h4><span id="取值">取值</span></h4>
<p>hget key field：返回指定的key中的field的值</p>
<p>hmget key fileds：获取key中的多个filed的值</p>
<p>hgetall key：获取key中的所有filed-vaule</p>
<p>multiple</p>
<h4><span id="删除">删除</span></h4>
<p>hdel key field [field … ] ：可以删除一个或多个字段，返回值是被删除的字段个数</p>
<p>del key ：删除整个hash</p>
<h4><span id="增加数字">增加数字</span></h4>
<p>hincrby key field increment：设置key中filed的值增加increment，如：age增加20</p>
<p>hincrbyfloat key field increment: 设置key中filed的值增加increment，如：age增加20，与hincrby的区别在可以对浮点型数据进行操作！</p>
<p>没有hdcriby和hdecrbyfloag，如果需要进行减法操作，给一个负数即可</p>
<h3><span id="其它命令">其它命令</span></h3>
<p>hexists key field：判断指定的key中的filed是否存在</p>
<p>hlen key：获取key所包含的field的数量</p>
<p>hkeys key ：获得所有的key</p>
<p>hvals key：获得所有的value</p>
<p>更多Redis学习参考菜鸟教程：<a href="http://www.runoob.com/redis/redis-tutorial.html">http://www.runoob.com/redis/redis-tutorial.html</a></p>
<p>该网站还有很多其他技术的基础教程，仅供参考！</p>
<h2><span id="list">List</span></h2>
<h3><span id="概述">概述</span></h3>
<p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。从元素插入和删除的效率视角来看，如果我们是在链表的****两头****插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在很短的时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。</p>
<p>\1. ArrayList 使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。</p>
<p>\2. LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps31.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps32.jpg)</p>
<h3><span id="常用命令">常用命令</span></h3>
<p><strong>两端插入：</strong></p>
<p>lpush key value…：在list的头部插入所有给定的值，如果该key不存在，则自动创建新list再操作，返回所有元素的个数。</p>
<p>rpush key value…：在list的尾部插入所有给定的值，如果该key不存在，则自动创建新list再操作，返回所有元素的个数。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps33.jpg)</p>
<p><strong>查看列表：</strong></p>
<p>lrange key start end：获取列表中索引在指定区间内的元素（包括start和end）。</p>
<p>索引：从0开始，0表示第一个，1表示第二个，以此类推；而最后一个使用-1表示，倒数第二个使用-2表示，以此类推。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps34.jpg)</p>
<p><strong>两端弹出：</strong></p>
<p>lpop key [count]：弹出并返回list中第一个元素，如果该key不存在，返回(nil)。,count表示弹出几个，默认为1</p>
<p>rpop key [count]：弹出并返回list中最后一个元素，如果该key不存在，返回(nil)。,count表示弹出几个，默认为1</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps35.jpg)</p>
<p><strong>获取长度：</strong></p>
<p>llen key：返回指定的key关联的链表中的元素的数量，如果list不存在，返回0</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps36.jpg)</p>
<p>l lpushx key value [value…]：将给定的值插入到已存在的列表头部，如果列表不存在，则不插入。</p>
<p>l rpushx key value [value…]：将给定的值插入到已存在的列表尾部，如果列表不存在，则不插入。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps37.jpg)</p>
<p>l lrem key count value：删除count个值为value的元素，count 的值可以是以下几种：</p>
<p>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count。</p>
<p>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</p>
<p>count = 0 : 移除表中所有与 value 相等的值。</p>
<p>准备数据：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps38.jpg)</p>
<p>从头开始删除2个3</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps39.jpg)</p>
<p>从尾开始删除2个1</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps40.jpg)</p>
<p>删除所有的2</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps41.jpg)</p>
<p>l lset key index value：设置链表中索引为index的元素值，0表示第一个，-1表示最后一个，索引不存在则抛异常。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps42.jpg)</p>
<p>l linsert key before|after pivot value：在pivot元素前或者后插入值。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps43.jpg)</p>
<p>l rpoplpush resource destination：移除resource列表的最后一个元素，并将该元素添加到destination列表的头部</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps44.jpg)</p>
<p>将mylist5右端弹出，压入到mylist6左边。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps45.jpg)</p>
<p>将mylist6右端数据弹出，压入到左端</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps46.jpg)</p>
<p><strong>rpoplpush的使用场景：</strong></p>
<p>Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为&quot;生产者(Producer)“，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为&quot;消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出的消息会自动插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps47.jpg)</p>
<h2><span id="set">Set</span></h2>
<h3><span id="概述">概述</span></h3>
<p>在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。Set可包含的最大元素数量是4294967295。</p>
<p>和List类型不同的是，Set集合中不允许出现重复的元素，这一点和java中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的<strong>聚合计算</strong>操作，如求并集、交集和差集。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。</p>
<h3><span id="常用命令">常用命令</span></h3>
<p><strong>添加/删除元素：</strong></p>
<p>l sadd key value…	：向Set中添加值，如果值已存在则不添加，返回添加成功的元素个数</p>
<p>l srem key value…	：删除Set中指定的值，返回移除元素的个数</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps48.jpg)</p>
<p>l smembers key：获得集合中的所有元素</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps49.jpg)</p>
<p>l sismember key member：判断Set中是否存在指定的值，1表示存在，0表示不存在或者该key本身就不存在。</p>
<p>如果希望准确判断到底是key本身不存在，还是key对应的set中的值不存在，可以结合exists key先判断key对应的set是否存在（返回0表示key对应的set不存在），从而得出准确结论。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps50.jpg)</p>
<p>l sdiff key1 key2…：只在key1中存在的元素，称为“差集”。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps51.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps52.jpg)</p>
<p>l sinter key1 key2…：在key1和key2中都存在的元素，称为“交集”。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps53.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps54.jpg)</p>
<p>l sunion key1 key2…：在key1和key2中的所有元素（去重），称为“并集”。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps55.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps56.jpg)</p>
<p>l scard key：获取set中成员的数量</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps57.jpg)</p>
<p>l srandmember key：随机返回set中的一个成员，可以用于抽取幸运用户！</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps58.jpg)</p>
<p>l sdiffstore destination key1 key2…：将key1、key2相差的成员存储在destination上</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps59.jpg)</p>
<p>l sinterstore destination key[key…]：将返回的交集存储在destination上</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps60.jpg)</p>
<p>l sunionstore destination key[key…]：将返回的并集存储在destination上</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps61.jpg)</p>
<h3><span id="使用场景">使用场景</span></h3>
<p>\1. 利用Set数据类型的特性，来确保数据的唯一性，比如访问某一博客的IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。</p>
<p>\2. 利用Set数据类型聚合操作方便、高效的特性，可以用来做数据统计。比如所有购买某一产品的客户ID被存储在一个指定的Set中，而购买另一产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种产品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。</p>
<p>奖品：</p>
<p>特等奖（1名）：iPhone 13 pro max</p>
<p>一等奖（2名）：iPhone 13</p>
<p>二等奖（10名）：xxx</p>
<p>三等奖（100名）：xxx</p>
<p>t</p>
<p>one1</p>
<p>one2</p>
<p>two1</p>
<p>two2</p>
<p>…</p>
<p>two10</p>
<p>three1</p>
<p>three2</p>
<p>…</p>
<p>three100</p>
<h2><span id="sorted-set">Sorted Set</span></h2>
<h3><span id="概述">概述</span></h3>
<p>Sorted-Set和Set类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Set中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Set中的成员必须是唯一的，但是分数(score)却是可以重复的。</p>
<p>在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，由于Sorted-Set中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。例如：游戏排名、微博热点话题等使用场景。</p>
<h3><span id="常用命令">常用命令</span></h3>
<p><strong>添加元素</strong>**：**</p>
<p>l zadd key score member score2 member2 …：将所有成员以及该成员的分数存放到sorted-set中。如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps62.jpg)</p>
<p><strong>获得元素</strong>**：**</p>
<p>l zscore key member：返回指定成员的分数</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps63.jpg)</p>
<p>l zcard key：获取集合中的成员数量</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps64.jpg)</p>
<p>l zrange key start stop [withscores]：获取集合中脚标(索引)为start-stop的成员，[withscores]参数表明返回的成员包含其分数。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps65.jpg)</p>
<p>l zrevrange key start stop [withscores]：按分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps66.jpg)</p>
<p><strong>删除元素</strong>**：**</p>
<p>l zrem key member [member…]：移除集合中指定的成员，可以指定多个成员。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps67.jpg)</p>
<p>l zremrangebyrank key start stop: 按照索引范围删除元素，最低分的索引是0</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps68.jpg)</p>
<p>l zremrangebyscore key min max：按照分数范围删除元素</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps69.jpg)</p>
<p>l zremrangebylex key min max：按照字典（元素）范围删除元素</p>
<p>该命令的使用前提是所有元素的分数必须一致！</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps70.jpg)</p>
<p>l zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；</p>
<p>[limit offset count]：offset，索引从offset开始的count个元素，类似mysql的limit start, count</p>
<p>可以使用-inf和+inf表示最小最大值</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps71.jpg)</p>
<p>l zincrby key increment member：给指定的成员增加指定的分数。返回值是更改后的分数。</p>
<p>该命令常用于投票，或者点击某个微博标题增加热度的时候使用！</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps72.jpg)</p>
<p>l zcount key min max：获取分数在[min,max]之间的成员</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps73.jpg)</p>
<p>l zrank key member：返回成员在集合中的排名。（从小到大）</p>
<p>l zrevrank key member：返回成员在集合中的排名。（从大到小）</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps74.jpg)</p>
<h1><span id="三种特殊数据类型">三种特殊数据类型</span></h1>
<h2><span id="bitmaps">bitmaps</span></h2>
<p>位图：一般用于完成类似打卡这样的操作。</p>
<p>记录一周的打卡状态。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps75.jpg)</p>
<h2><span id="hyperloglogs">hyperloglogs</span></h2>
<p>用于基数（集合中不重复元素的个数）统计。</p>
<p>{1,2,3,4,5,4,6}  基数：6</p>
<p>特点：不管有多少个元素，只需要占用12KB的内存！</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps76.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps77.jpg)</p>
<p>在使用hyperloglogs做基数统计时，可能会存在0.81%的误差，如果这个误差在可接收的范围内，</p>
<p>那么使用hyperloglogs将是一个非常不错的选择，如果对于一些特殊需求不允许出现任何误差，</p>
<p>那么就可以考虑使用set数据结构来完成，区别在于set会占用更多的内存空间！而hyperloglogs</p>
<p>只会占用固定的12KB内存！</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps78.jpg)</p>
<h2><span id="geospatial">geospatial</span></h2>
<p>geospatial可以用地理空间位置的计算，例如计算两地之间的距离、某一地理位置指定半径范围内的所有地理位置等。。</p>
<p>城市经纬度查询：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p>
<p><a href="http://www.jsons.cn/">http://www.jsons.cn/</a>  大量的查询、转换等工具。</p>
<p>添加北京和上海的地理位置：</p>
<p>geoadd geo1 116.405285 39.904989 beijing 121.472644 31.231706 shanghai</p>
<p>获取北京到上海的直线距离：</p>
<p>geodist geo1 beijing shanghai km</p>
<p>返回一个地理位置的geohash字符串，可以访问 <a href="http://geohash.org/hash%E5%AD%97%E7%AC%A6%E4%B8%B2">http://geohash.org/hash字符串</a> 来查询对应地理空间的经纬度，一般不使用</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps79.jpg)</p>
<p>返回指定地理位置的经纬度（和添加时的经纬度有细微的区别）：</p>
<p>geopos geo1 shanghai</p>
<p>以给定的经纬度为中心， 返回与中心的距离不超过给定最大距离的所有位置元素。</p>
<p>GEORADIUS geo1 121.472644 31.231706 2000 km</p>
<p>如果希望获取指定的地理位置指定半径内的所有元素，可以先使用geopos先获取到指定地理位置的经纬度。</p>
<p>或者使用下面的命令：</p>
<p>GEORADIUSBYMEMBER geo1 shanghai 2000 km</p>
<h1><span id="redis高级话题">Redis高级话题</span></h1>
<h2><span id="多数据库">多数据库</span></h2>
<h3><span id="概念">概念</span></h3>
<p>一个redis实例包括16个数据库，下标从0到15，客户端默认连接第0号数据库。</p>
<h3><span id="多数据库操作命令">多数据库操作命令</span></h3>
<p>l select index：切换到指定的库，索引范围为0-15</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps80.jpg)</p>
<p>l move key index：将当前库指定的key移植到指定的库</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps81.jpg)</p>
<p>l dbsize：返回当前数据库中 key 的数目。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps82.jpg)</p>
<p>l flushdb：删除当前选择数据库中的所有key。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps83.jpg)</p>
<p>l flushall：删除所有数据库中的所有key。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps84.jpg)</p>
<h2><span id="redis事务">redis事务</span></h2>
<h3><span id="概念">概念</span></h3>
<p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/这三个命令是我们实现事务的基石。</p>
<h3><span id="redis事务特征">redis事务特征</span></h3>
<p>\1. 在事务中的所有命令都将会被<strong>串行化</strong>的顺序执行，<strong>事务执行期间，Redis不会再为其它客户端的请求提供任何服务（<strong><strong>接收请求，但暂不进行处理</strong></strong>）</strong>，从而保证了事物中的所有命令被原子的执行。</p>
<p>\2. 和关系型数据库中的事务相比，<strong>在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</strong>**，并且可以执行成功！**</p>
<p>\3. 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为&quot;BEGIN TRANSACTION&quot;语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。</p>
<p>\4. 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</p>
<p>\5. 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕(dàng)机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p>
<h3><span id="命令解释">命令解释</span></h3>
<p>l multi：开启事务用于标记事务的开始，<strong>其后执行的命令都将被存入命令队列</strong>，直到执行EXEC时，这些命令才会被原子的执行。</p>
<p>l exec：提交事务</p>
<p>l discard：事务回滚</p>
<h3><span id="测试事务">测试事务</span></h3>
<p><strong>正常执行事务</strong>**：**</p>
<p>l 步骤1：在窗口1，设置num，并获取num</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps85.jpg)</p>
<p>l 步骤2：在窗口2，递增num，并获取num</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps86.jpg)</p>
<p>l 步骤3：在窗口1，获取num</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps87.jpg)</p>
<p>l 步骤4：在窗口1，开启事务，然后递增num。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps88.jpg)</p>
<p>l 步骤5：在窗口2，获取num</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps89.jpg)</p>
<p>l 步骤6：在窗口1，提交事务</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps90.jpg)</p>
<p>l 步骤7：再次在窗口2，获取num</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps91.jpg)</p>
<p><strong>回滚****事务：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps92.jpg)</p>
<p><strong>事务中的异常：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps93.jpg)</p>
<h3><span id="redis实现乐观锁">redis实现乐观锁</span></h3>
<p>悲观锁：认为操作时一定会出现问题，因此在操作之前都会对数据进行上锁，效率低下。</p>
<p>乐观锁(本质不是锁！)：认为操作时一定不会出现问题，只在提交时通过查询来确保操作是否可以正常执行，效率高。</p>
<p>mysql实现乐观锁：在表中添加一个version字段，在执行事务之前，查询出version的值，</p>
<p>在最终提交时，检查version字段是否发生了改变，如果没有改变，则操作执行成功，否则不执行（不满足where条件）</p>
<p>悲观锁：</p>
<p>select * from xxx where id=1 for update; // 数据必然上锁（其它线程无法对该数据进行任何操作），比较悲观</p>
<p>user</p>
<p>id  name  age  sex  version</p>
<p>1  张三  20  男   1</p>
<p>select * from xxx where id=1; version=1</p>
<p>update user set age=21,version=version+1 where id=1 and version=1</p>
<p>// 购物扣款流程：</p>
<p>//1. 查询账户余额  balance=500</p>
<p>// 2. 判断账户余额是否大于商品金额</p>
<p>if (balance &gt;= 产品金额） {</p>
<p>// 线程的”时间片“到期，CPU线程切换（切换的这个线程可能影响金额，导致上面if不再满足）</p>
<p>// 扣除账户余额—余额为负数！</p>
<p>}</p>
<p>// 解决方案1：悲观锁，对数据进行上锁！  不推荐–影响效率</p>
<p>// 解决方案2：乐观锁</p>
<p>update xx set balance=balance-产品金额 where uid=xx and balance&gt;=产品金额</p>
<p>redis中，通过watch命令，来对某个要在事务中操作的数据进行监视，如果在最终执行的时候，发现监视的数据已经被修改了，则自动放弃事务对监视数据的改变。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps94.jpg)</p>
<h2><span id="消息订阅与发布">消息订阅与发布</span></h2>
<p>l subscribe channel：订阅频道，例：subscribe mychat，订阅mychat这个频道</p>
<p>l psubscribe channel*：订阅的频道支持模式（pattern），可以进行批量订阅频道，例：psubscribe s*，订阅以&quot;s&quot;开头的频道</p>
<p>l publish channel content：在指定的频道中发布消息，如 publish mychat  “Today is the weekend”</p>
<p>演示步骤：</p>
<p>1、在第一个窗口中，订阅mychannel频道，此时如果没有人“发布”消息，当前窗口处于等待状态。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps95.jpg)</p>
<p>2、打开第二个窗口，在mychannel频道中发布消息“hello”</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps96.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps97.jpg)</p>
<p>3、打开第三个窗口，批量订阅以my开头的所有频道。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps98.jpg)</p>
<p>4、在第二个窗口中，分别在mychannel和mychannel2频道发布消息</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps99.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps100.jpg)</p>
<h2><span id="redis持久化">redis持久化</span></h2>
<h3><span id="概述">概述</span></h3>
<p>Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。</p>
<p>\1. RDB持久化（默认支持，无需配置）</p>
<p>该机制是以指定的时间间隔内将内存中的数据集快照写入磁盘。</p>
<p>\2. AOF持久化</p>
<p>该机制将以日志的形式记录服务器所处理的每一个写操作(对数据产生改变的操作)，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</p>
<p>\3. redis可以同时使用RDB和AOF</p>
<p>\4. 无持久化</p>
<p>我们可以通过配置的方式禁用Redis服务器的持久化功能，这样我们就可以将Redis视为一个功能加强版的memcached了。</p>
<h3><span id="rdb持久化">RDB持久化</span></h3>
<h4><span id="优势">优势</span></h4>
<p>\1. 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</p>
<p>\2. 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上</p>
<p>\3. 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork（分叉）出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
<p>\4. 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<h4><span id="劣势">劣势</span></h4>
<p>\1. 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<p>\2. 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟</p>
<h4><span id="snapshotting快照配置说明">Snapshotting（快照）配置说明</span></h4>
<p><strong>持久化时间设置：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps101.jpg)</p>
<p>l save 900 1 		#每900秒(15分钟)，至少有1个key发生变化时，才持久化内存快照。</p>
<p>l save 300 10 		#每300秒(5分钟)，至少有10个key发生变化时，才持久化内存快照。</p>
<p>l save 60 10000 	#每60秒(1分钟)，至少有10000个key发生变化时，才持久化内存快照。</p>
<p>另外，当客户端调用shutdown命令时，在redis服务器在关闭之前，会自动持久化内存中的数据到磁盘，</p>
<p>除非在关闭redis时不进行持久化：shutdown <strong>nosave</strong>，或者强制杀死redis进程：kill -9  进程id</p>
<p>1分钟</p>
<p><strong>保存位置设置</strong>**：**</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps102.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps103.jpg)</p>
<h3><span id="aof持久化">AOF持久化</span></h3>
<h4><span id="优势">优势</span></h4>
<p>\1. 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即<strong>每秒同步、<strong><strong>每修改同步</strong></strong>和不同步</strong>。事实上，每秒同步也是异步完成的，其效率也是非常高的，不好的地方是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</p>
<p>\2. 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，可以在Redis下一次启动之前，通过redis-check-aof工具来帮助我们解决数据一致性的问题。</p>
<p>\3. 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p>
<p>\4. AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p>
<h4><span id="劣势">劣势</span></h4>
<p>\1. 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。</p>
<p>\2. 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。</p>
<h4><span id="配置aof">配置AOF</span></h4>
<p><strong>开启AOF持久化：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps104.jpg)</p>
<p><strong>同步策略配置：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps105.jpg)</p>
<p>l always			#只要有数据改变时都会写入AOF文件。</p>
<p>l everysec		#每秒钟同步一次，默认策略。</p>
<p>l no    		#从不同步。</p>
<p>手动重写同步命令：<strong>bgrewriteaof</strong>，执行一个 AOF文件 重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 BGREWRITEAOF 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 BGREWRITEAOF 成功之前不会被修改。</p>
<p><strong>数据恢复演示</strong>**：**</p>
<p>\1. 开启AOF</p>
<p>\2. 清空数据库：flushall</p>
<p>\3. 设置一些数据</p>
<p>\4. 关闭redis：shutdown nosave</p>
<p>\5. 启动redis，并查看数据</p>
<h2><span id="启动多个redis">启动多个Redis</span></h2>
<p>l 方法1：启动时指定端口（多个Redis实例）</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps106.jpg)</p>
<p>l 方式2：复制redis.conf文件，修改端口【推荐使用】</p>
<p>\1) cp redis.conf redis6380.conf</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps107.jpg)</p>
<p>\2) 修改redis6380.conf中的启动端口为6380</p>
<p>vim redis6380.conf</p>
<p>输入/port 回车</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps108.jpg)</p>
<p>\3) 启动redis时，指定配置文件redis6380.conf</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps109.jpg)</p>
<p>关闭指定端口redis： ./redis-cli -p 6380 shutdown</p>
<h2><span id="主从复制">主从复制</span></h2>
<h3><span id="主从复制读写分离">主从复制–读写分离</span></h3>
<p>通过持久化功能，Redis 保证了即使在服务器重启的情况下也不会丢失（或少量丢失）数据，但是由于数据是存储在一台服务器上的，如果这台服务器出现故障，比如硬盘坏了，也会导致数据丢失。</p>
<p>为了避免单点故障，我们需要将数据复制多份部署在多台不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。</p>
<p>这就要求当一台服务器上的数据更新后，自动将更新的数据同步到其他服务器上，那该怎么实现呢？Redis的主从复制。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps110.jpg)</p>
<p>Redis 提供了复制（replication）功能来自动实现多台 redis 服务器的数据同步（每天19 点新闻联播，基本从 cctv1-8,各大卫视都会播放）我们可以通过部署多台 redis，并在配置文件中指定这几台 redis 之间的主从关系，主负责写入数据，同时把写入的数据实时同步到从机器，这种模式叫做主从复制，即master/slave，并且 redis 默认 master 用于写，slave 用于读，向 slave 写数据会导致错误</p>
<p>（1） Redis 主从复制实现（master/salve）</p>
<p>修改配置文件，启动时，服务器读取配置文件，并自动成为指定服务器的从服务器，从而构成主从复制的关系</p>
<p>实现步骤：</p>
<p>模拟多 Reids 服务器，在一台已经安装 Redis 的机器上，运行多个 Redis 应用模拟多个 Reids 服务器。一个 Master，两个 Slave.</p>
<p>\1. 新建三个 Redis 的配置文件</p>
<p>如果 Redis 启动，先停止。</p>
<p>作为 Master 的 Redis 端口是 6380</p>
<p>作为 Slaver 的 Redis 端口分别是 6382 , 6384</p>
<p>从原有的 redis.conf 拷贝三份，分别命名为 redis6380.conf, redis6382.conf , redis6384.conf</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps111.jpg)</p>
<p>\2. 编辑 Master 配置文件</p>
<p>编辑 Master 的配置文件 redis6380.conf : 在空文件加入如下内容</p>
<p><em><strong>*include /usr/local/redis-4.0.13/redis.conf*</strong></em></p>
<p><em><strong>*daemonize yes*</strong></em></p>
<p><em><strong>*port 6380*</strong></em></p>
<p><em><strong>*pidfile /var/run/redis_6380.pid*</strong></em></p>
<p><em><strong>*logfile 6380.log*</strong></em></p>
<p><em><strong>*dbfilename dump6380.rdb*</strong></em></p>
<p>配置项说明：</p>
<p>include ：包含原来的配置文件内容。/usr/local/ redis-4.0.13/redis.conf 按照自己的目录设置。</p>
<p>daemonize：yes 后台启动应用，相当于 ./redis-server &amp; 的作用。</p>
<p>port : 自定义的端口号</p>
<p>pidfile : 自定义的文件，表示当前程序的 pid ,进程 id。</p>
<p>logfile：日志文件名</p>
<p>dbfilename：持久化的 rdb 文件名</p>
<p>\3. 编辑 Slave 配置文件</p>
<p>编辑 Slave 的配置文件 redis6382.conf 和 redis6384.conf: 在空文件加入如下内容</p>
<p>①：redis6382.conf：</p>
<p><em><strong>*include /usr/local/redis-4.0.13/redis.conf*</strong></em></p>
<p><em><strong>*daemonize yes*</strong></em></p>
<p><em><strong>*port 6382*</strong></em></p>
<p><em><strong>*pidfile /var/run/redis_6382.pid*</strong></em></p>
<p><em><strong>*logfile 6382.log*</strong></em></p>
<p><em><strong>*dbfilename dump6382.rdb*</strong></em></p>
<p><em><strong>*slaveof 127.0.0.1 6380*</strong></em></p>
<p>配置项说明：</p>
<p>slaveof ：表示当前 Redis 是谁的从。当前是 127.0.0.0 端口 6380 这个 Master 的从。</p>
<p>②：redis6384.conf：</p>
<p><em><strong>*include /usr/local/redis-4.0.13/redis.conf*</strong></em></p>
<p><em><strong>*daemonize yes*</strong></em></p>
<p><em><strong>*port 6384*</strong></em></p>
<p><em><strong>*pidfile /var/run/redis_6384.pid*</strong></em></p>
<p><em><strong>*logfile 6384.log*</strong></em></p>
<p><em><strong>*dbfilename dump6384.rdb*</strong></em></p>
<p><em><strong>*slaveof 127.0.0.1 6380*</strong></em></p>
<p>\4. 启动服务器 Master/Slave 都启动</p>
<p>启动方式 ./redis-server 配置文件</p>
<p>启动 Redis,并查看启动进程</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps112.jpg)</p>
<p>\5. 查看配置后的服务信息</p>
<p>命令：</p>
<p>①： Redis 客户端使用指定端口连接 Redis 服务器</p>
<p>./redis-cli -p 端口</p>
<p>②：查看服务器信息</p>
<p>info replication</p>
<p>登录到 Master：6380</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps113.jpg)</p>
<p>查看当前服务信息</p>
<p>在客户端的 Redis 内执行命令 info replication</p>
<p>Master 服务的查看结果:</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps114.jpg)</p>
<p>在新的 Xshell 窗口分别登录到 6382 ，6384 查看信息</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps115.jpg)</p>
<p>6384 也登录内容同 6382.</p>
<p>\6. 向 Master 写入数据</p>
<p>在 6380 执行 flushall 清除数据，避免干扰的测试数据。生产环境避免使用。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps116.jpg)</p>
<p>\7. 在从 Slave 读数据</p>
<p>6382,6384 都可以读主 Master 的数据，不能写</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps117.jpg)</p>
<p>Slave 写数据失败</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps118.jpg)</p>
<p>--------------------------------------------------------------------------------------------------------------------</p>
<p>（2） 容灾处理</p>
<p>当 Master 服务出现故障，需手动将 slave 中的一个提升为 master，剩下的 slave 挂至新的</p>
<p>master 上（冷处理：机器挂掉了，再处理）</p>
<p>命令：</p>
<p>①：slaveof no one，将一台 slave 服务器提升为 Master （提升某 slave 为 master）</p>
<p>②：slaveof 127.0.0.1 6382 （将 slave 挂至新的 master 上）</p>
<p>执行步骤：</p>
<p>\1. 将 Master:6380 停止（模拟挂掉）</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps119.jpg)</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps120.jpg)</p>
<p>\2. 选择一个 Slave 升到 Master，其它的 Slave 挂到新提升的 Master</p>
<p><em><strong>*在6382客户端执行slaveof no one*</strong></em></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps121.jpg)</p>
<p>\3. 将其他 Slave 挂到新的 Master</p>
<p><em><strong>*在 Slave 6384 上执行：slaveof 127.0.0.1 6382*</strong></em></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps122.jpg)</p>
<p>现在的主从（Master/Slave）关系：Master 是 6382， Slave 是 6384</p>
<p>查看 6382：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps123.jpg)</p>
<p>\4. 原来的服务器重新添加到主从结构中</p>
<p>6380 的服务器修改后，从新工作，需要把它添加到现有的 Master/Slave 中</p>
<p>先启动 6380 的 Redis 服务</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps124.jpg)</p>
<p>连接到 6380 端口</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps125.jpg)</p>
<p>当前服务挂到 Master 上</p>
<p><em><strong>*在 Slave 6380 上执行：slaveof 127.0.0.1 6382*</strong></em></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps126.jpg)</p>
<p>\5. 查看新的 Master 信息</p>
<p>在 6382 执行：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps127.jpg)</p>
<p>现在的 Master/Slaver 关系是： Master: 6382</p>
<p>Slave: 6380、6384</p>
<p>（3） 操作命令</p>
<p>进入客户端需指定端口：./redis-cli -p 6380</p>
<p>不配置启动默认都是主 master</p>
<p>info replication 查看 redis 服务器所处角色</p>
<p>（4） 总结</p>
<p>1、一个 master 可以有多个 slave</p>
<p>2、slave 下线，读请求的处理性能下降</p>
<p>3、master 下线，写请求无法执行</p>
<p>4、当 master 发生故障，需手动将其中一台 slave 使用 slaveof no one 命令提升为 master，其它 slave 执行 slaveof 命令指向这个新的 master，从新的 master 处同步数据</p>
<p>5、主从复制模式的故障转移需要手动操作，要实现自动化处理，这就需要 Sentinel 哨兵，实现故障自动转移。</p>
<h3><span id="高可用哨兵sentine">高可用哨兵Sentine</span></h3>
<p>Sentinel 哨兵是 redis 官方提供的高可用方案，可以用它来监控多个 Redis 服务实例的运行情况。Redis Sentinel 是一个运行在特殊模式下的 Redis 服务器。Redis Sentinel 是在多个Sentinel 进程环境下互相协作工作的。</p>
<p>Sentinel 系统有三个主要任务：</p>
<p>Ø 监控：Sentinel 不断的检查主服务和从服务器是否按照预期正常工作。</p>
<p>Ø 提醒：被监控的 Redis 出现问题时，Sentinel 会通知管理员或其他应用程序。</p>
<p>Ø 自动故障转移：监控的主 Redis 不能正常工作，Sentinel 会开始进行故障迁移操作。将一个从服务器升级新的主服务器。让其他从服务器挂到新的主服务器。同时向客户端提供新的主服务器地址。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps128.jpg)</p>
<p>（1） Sentinel 配置</p>
<p>1）Sentinel 配置文件</p>
<p>在/usr/soft/redis/bin下：新建3个哨兵配置文件：</p>
<p>touch sentinel26380.conf sentinel26382.conf sentinel26384.conf</p>
<p>Sentinel 系统默认 port 是 26379 。三个配置 port 分别设置为 26380 , 26382 , 26384。</p>
<p>编辑3个哨兵配置，内容如下：</p>
<p><strong>include /usr/soft/redis-6.2.6/sentinel.conf</strong></p>
<p><em><strong>*daemonize yes*</strong></em></p>
<p><strong>port 2638****0</strong></p>
<p><strong>logfile 26380.log</strong></p>
<p><strong>sentinel monitor</strong> <strong>m****6380</strong> <strong>127.0.0.1 638****0</strong> <strong>2</strong></p>
<p>修改完成之后，启动3个哨兵进程：</p>
<p><strong>./redis-</strong> <strong>sentinel</strong> <strong>sentinel26380.conf</strong></p>
<p><strong>./redis-</strong> <strong>sentinel</strong> <strong>sentinel2638<strong><strong>2</strong></strong>.conf</strong></p>
<p><strong>./redis-</strong> <strong>sentinel</strong> <strong>sentinel2638<strong><strong>4</strong></strong>.conf</strong></p>
<p>手动干掉master，稍等1分钟，再次查看当前master/slave情况，最后再把之前的master启动，查看新的主从关系</p>
<p>（2） 三份 sentinel 配置文件修改：</p>
<p>1、修改 port 26380、 port 26382、 port 26384</p>
<p>2、修改 sentinel monitor mymaster 127.0.0.1 6382 2</p>
<p>格式：sentinel monitor <name> <masterip> <masterport> &lt;Quorum 投票数&gt;</masterport></masterip></name></p>
<p>Sentinel监控主(Master)Redis, Sentinel根据Master的配置自动发现Master的Slave,Sentinel</p>
<p>默认端口号为26379。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps129.jpg)</p>
<p>sentinel26380.conf</p>
<p>\1) 修改 port</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps130.jpg)</p>
<p>2）修改监控的 master 地址</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps131.jpg)</p>
<p><strong>mymaster必须修改！</strong></p>
<p>sentinel26382.conf 修改port 26382 , master的port 6382</p>
<p>sentinel26384.conf 修改port 26384 , master的port 6382</p>
<p>（3） 启动主从（Master/Slave）Redis</p>
<p>启动 Reids</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps132.jpg)</p>
<p>查看 Master 的配置信息</p>
<p>连接到 6382 端口</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps133.jpg)</p>
<p>使用 info 命令查看 Master/Slave</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps134.jpg)</p>
<p>（4） 启动 Sentinel</p>
<p>redis安装时make编译后就产生了redis-sentinel程序文件，可以在一个redis中运行多个sentinel进程。</p>
<p>启动一个运行在Sentinel模式下的Redis服务实例语法：</p>
<p>./redis-sentinel  sentinel配置文件</p>
<p>在 XShell 开启三个窗口分别执行：</p>
<p>执行以下三条命令，将创建三个监视主服务器的Sentinel实例：</p>
<p><em><strong>*第一个窗口：*</strong></em><em><strong>*./redis-sentinel …/sentinel26380.conf*</strong></em></p>
<p><em><strong>*第二个窗口：*</strong></em><em><strong>*./redis-sentinel …/sentinel26382.conf*</strong></em></p>
<p><em><strong>*第三个窗口：*</strong></em><em><strong>*./redis-sentinel …/sentinel26384.conf*</strong></em></p>
<p>（5） 主 Redis 不能工作</p>
<p>让 Master 的 Redis 停止服务，执行 shutdown</p>
<p>先执行 info replication 确认 Master 的 Redis，再执行 shutdown</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps135.jpg)</p>
<p>查看当前 Redis 的进程情况</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps136.jpg)</p>
<p>（6） Sentinel 的起作用</p>
<p>在 Master 执行 shutdown 后，稍微等一会 Sentinel 要进行投票计算，从可用的 Slave 选举新的 Master。</p>
<p>查看 Sentinel 日志，三个 Sentinel 窗口的日志是一样的。</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps137.jpg)</p>
<p>查看新的 Master</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps138.jpg)</p>
<p>查看原 Slave 的变化</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps139.jpg)</p>
<p>（7） 新的 Redis 加入 Sentinel 系统，自动加入 Master</p>
<p>重新启动 6382</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps140.jpg)</p>
<p>查看 6384 的信息</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps141.jpg)</p>
<p>测试数据：在 Master 写入数据</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps142.jpg)</p>
<p>在 6382 上读取数据，不能写入</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps143.jpg)</p>
<p>（8） 监控</p>
<p>1）Sentinel 会不断检查 Master 和 Slave 是否正常</p>
<p>2）如果 Sentinel 挂了，就无法监控，所以需要多个哨兵，组成 Sentinel 网络，一个健康的Sentinel 至少有 3 个 Sentinel 应用。彼此在独立的物理机器或虚拟机。</p>
<p>3）监控同一个 Master 的 Sentinel 会自动连接，组成一个分布式的 Sentinel 网络，互相通信并交换彼此关于被监控服务器的信息</p>
<p>4）当一个 Sentinel 认为被监控的服务器已经下线时，它会向网络中的其它 Sentinel 进行确认，判断该服务器是否真的已经下线</p>
<p>5）如果下线的服务器为主服务器，那么 Sentinel 网络将对下线主服务器进行自动故障转移，通过将下线主服务器的某个从服务器提升为新的主服务器，并让其从服务器转移到新的主服务器下，以此来让系统重新回到正常状态</p>
<p>6）下线的旧主服务器重新上线，Sentinel 会让它成为从，挂到新的主服务器下</p>
<p>（9） 总结</p>
<p>主从复制，解决了读请求的分担，从节点下线，会使得读请求能力有所下降，Master 下线，写请求无法执行</p>
<p>Sentinel 会在 Master 下线后自动执行故障转移操作，提升一台 Slave 为 Master，并让其它Slave 成为新 Master 的 Slave</p>
<h2><span id="安全设置">安全设置</span></h2>
<p>（1） 设置密码</p>
<p>访问 Redis 默认是没有密码的，这样不安全，任意用户都可以访问。可以启用使用密码才能访问 Redis。设置 Redis 的访问密码，修改 redis.conf 中这行 requirepass 密码。密码要比较复杂，不容易破解，而且需要定期修改。因为 redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，需要指定非常非常强大的密码来防止暴力破解。</p>
<p>\1. 开启访问密码设置</p>
<p>修改 redis.conf , 使用 vim 命令。找到 requirepass 行去掉注释，requirepass 空格后就是密码。</p>
<p>例 1：设置访问密码是 123456 ,这是练习使用，生产环境要设置复杂密码</p>
<p>修改 redis.conf 原始内容：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps144.jpg)</p>
<p>修改后：</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps145.jpg)</p>
<p>\2. 访问有密码的 Redis</p>
<p>如果 Redis 已经启动，关闭后，重新启动。</p>
<p>访问有密码的 Redis 两种方式：</p>
<p>①：在连接到客户端后，使用命令 auth 密码，命令执行成功后，可以正常使用 Redis</p>
<p>②：在连接客户端时使用 -a 密码。例如 ./redis-cli -h ip -p port -a password</p>
<p>启动 Redis</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps146.jpg)</p>
<p>使用①访问</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps147.jpg)</p>
<p>输入命令 auth 密码</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps148.jpg)</p>
<p>使用②方式</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps149.jpg)</p>
<p>（2） 修改默认端口</p>
<p>修改 redis 的端口，这一点很重要，使用默认的端口很危险，redis.conf 中修改 port 6379</p>
<p>将其修改为自己指定的端口（可随意），端口 1024 是保留给操作系统使用的。用户可以使用</p>
<p>的范围是 1024-65535</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps150.jpg)</p>
<p>使用 -p 参数指定端口，例如：./redis-cli -p 新设置端口</p>
<h1><span id="redis的使用场景了解">Redis的使用场景（了解）</span></h1>
<p>\1. <strong>取最新N个数据的操作</strong></p>
<p>比如典型的取你网站的最新文章，通过下面方式，我们可以将最新的5000条评论的ID放在Redis的List集合中，并将超出集合部分从数据库获取</p>
<p>(1)使用LPUSH latest.comments <id>命令，向list集合中插入数据</id></p>
<p>(2)插入完成后再用LTRIM latest.comments 0 5000命令使其永远只保存最近5000个ID</p>
<p>(3)然后我们在客户端获取某一页评论时可以用下面的逻辑（伪代码）</p>
<p># 伪代码</p>
<p>FUNCTION get_latest_comments(start, num_items):</p>
<p>id_list = redis.lrange(“latest.comments”, start, start+num_items-1)</p>
<p>IF id_list.length &lt; num_items</p>
<p>​    id_list = SQL_DB(“SELECT … ORDER BY time LIMIT …”)</p>
<p>END</p>
<p>RETURN id_list</p>
<p>END</p>
<p>如果你还有不同的筛选维度，比如某个分类的最新N条，那么你可以再建一个按此分类的List，只存ID的话，Redis是非常高效的。</p>
<p>\2. <strong>排行榜应用，取TOP N操作</strong></p>
<p>这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。</p>
<p>\3. <strong>需要精准设定过期时间的应用</strong></p>
<p>比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把 Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。</p>
<p>\4. <strong>计数器应用</strong></p>
<p>Redis的命令都是原子性的，你可以轻松地利用INCR，DECR命令来构建计数器系统。</p>
<p>\5. <strong>Uniq操作，获取某段时间所有数据排重值</strong></p>
<p>这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。</p>
<p>\6. <strong>实时系统，反垃圾系统</strong></p>
<p>通过上面说到的set功能，你可以知道一个终端用户是否进行了某个操作，可以找到其操作的集合并进行分析统计对比等。没有做不到，只有想不到。</p>
<p>\7. <strong>Pub/Sub构建实时消息系统</strong></p>
<p>Redis的Pub/Sub系统可以构建实时的消息系统，比如很多用Pub/Sub构建的实时聊天系统的例子。</p>
<p>\8. <strong>构建队列系统</strong></p>
<p>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。</p>
<h1><span id="jedis-入门">Jedis 入门</span></h1>
<h2><span id="jedis介绍">Jedis介绍</span></h2>
<p>​	Redis不仅可以使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。</p>
<p>在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis等，其中官方推荐使用Jedis和Redisson。</p>
<p>在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。</p>
<p>Jedis同样也是托管在github上，地址：<a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></p>
<h2><span id="java连接redis">Java连接Redis</span></h2>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="jedis单实例连接">Jedis单实例连接</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedis</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、设置ip地址和端口(不指定时，默认6379)</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.125.129&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 2、设置数据</span></span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、获得数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">// 4、释放资源</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Jedis连接池</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedisPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建连接池配置对象</span></span><br><span class="line">    <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">    <span class="comment">// 1.1、 最大连接数</span></span><br><span class="line">    config.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 1.2、最大空闲连接数</span></span><br><span class="line">    config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 2、连接池对象</span></span><br><span class="line">    <span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 3、核心对象</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4、初始化连接池</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, <span class="string">&quot;192.168.125.129&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 5、获取连接</span></span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        <span class="comment">// 6、设置数据</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="comment">// 7、获取数据</span></span><br><span class="line">        Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String m : smembers) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将连接返回给连接池</span></span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁连接池，释放资源，一般在程序关闭时调用</span></span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">null</span>) &#123;</span><br><span class="line">            pool.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="springboot-集成-redis">SpringBoot 集成 Redis</span></h1>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">1111</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">spring-boot-redis-test</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">		<span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">		<span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">		<span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">		<span class="attr">database:</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2><span id="注入redis模板类"><strong>注入redis模板类</strong></span></h2>
<ul>
<li>RedisTemplate，操作类型是Object，以二进制的方式将数据存储到Redis中</li>
<li>StringRedisTemplate，操作类型是String，将数据存储到Redis中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(stringRedisTemplate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="string类型">String类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOpsString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取String类型的ops对象</span></span><br><span class="line">    ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue();</span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    operations.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    operations.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//单独设置过期时间</span></span><br><span class="line">    stringRedisTemplate.expire(<span class="string">&quot;username&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//批量查询值</span></span><br><span class="line">    operations.multiGet(</span><br><span class="line">        Arrays.asList(</span><br><span class="line">            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            <span class="string">&quot;username&quot;</span></span><br><span class="line">        )</span><br><span class="line">    ).forEach(System.out::println);</span><br><span class="line">    System.out.println(stringRedisTemplate.getExpire(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    stringRedisTemplate.delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="list类型">List类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOpsList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取list的ops对象</span></span><br><span class="line">    ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();</span><br><span class="line">    <span class="comment">//左圧栈，先进后出，后进先出</span></span><br><span class="line">    listOperations.leftPushAll(<span class="string">&quot;nameList&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">    <span class="comment">//右压栈，先进先出，后进后出</span></span><br><span class="line">    listOperations.rightPushAll(<span class="string">&quot;usernameList&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">    <span class="comment">//查询数据列表</span></span><br><span class="line">    listOperations.range(<span class="string">&quot;nameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    listOperations.range(<span class="string">&quot;usernameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//设置过期时间</span></span><br><span class="line">    stringRedisTemplate.expire(<span class="string">&quot;nameList&quot;</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//删除指定元素</span></span><br><span class="line">    listOperations.remove(<span class="string">&quot;nameList&quot;</span>, <span class="number">2</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="comment">//查询列表数据</span></span><br><span class="line">    listOperations.range(<span class="string">&quot;nameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    listOperations.range(<span class="string">&quot;usernameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//替换头部元素</span></span><br><span class="line">    listOperations.set(<span class="string">&quot;nameList&quot;</span>, <span class="number">0</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="comment">//查询列表数据</span></span><br><span class="line">    listOperations.range(<span class="string">&quot;nameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    listOperations.range(<span class="string">&quot;usernameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="hash类型">Hash类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOpsHash</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取ops的hash对象</span></span><br><span class="line">    HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">    <span class="comment">//设置hash的键值对</span></span><br><span class="line">    hashOperations.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;loginAct&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;loginPwd&quot;</span>, <span class="string">&quot;123123&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;address&quot;</span>, <span class="string">&quot;深圳市&quot;</span>);</span><br><span class="line">    <span class="comment">//查询列表数据并输出到控制台</span></span><br><span class="line">    <span class="comment">//查询所有key及value集合</span></span><br><span class="line">    Set&lt;Object&gt; user = hashOperations.keys(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    user.forEach(</span><br><span class="line">        field -&gt;</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">&quot;field:&quot;</span> + field + <span class="string">&quot;,value:&quot;</span> + hashOperations.get(<span class="string">&quot;user&quot;</span>, field)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//获取所有的field和value的map集合</span></span><br><span class="line">    hashOperations.entries(<span class="string">&quot;user&quot;</span>).entrySet().forEach(</span><br><span class="line">        entry -&gt; System.out.println(<span class="string">&quot;field:&quot;</span> + entry.getKey() + <span class="string">&quot;,value:&quot;</span> + entry.getValue())</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//删除集合中的元素</span></span><br><span class="line">    hashOperations.delete(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;address&quot;</span>);</span><br><span class="line">    <span class="comment">//删除集合.</span></span><br><span class="line">    stringRedisTemplate.delete(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="set类型">Set类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOpsSet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取set集合的ops对象</span></span><br><span class="line">    <span class="comment">//set集合是无序、唯一的</span></span><br><span class="line">    SetOperations&lt;String, String&gt; setOperations = stringRedisTemplate.opsForSet();</span><br><span class="line">    <span class="comment">//新增操作</span></span><br><span class="line">    setOperations.add(<span class="string">&quot;userList&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    setOperations.members(<span class="string">&quot;userList&quot;</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//弹出操作</span></span><br><span class="line">    System.out.println(setOperations.pop(<span class="string">&quot;userList&quot;</span>));</span><br><span class="line">    <span class="comment">//查询集合长度</span></span><br><span class="line">    System.out.println(setOperations.size(<span class="string">&quot;userList&quot;</span>));</span><br><span class="line">    <span class="comment">//查询value是否存在</span></span><br><span class="line">    System.out.println(setOperations.isMember(<span class="string">&quot;userList&quot;</span>, <span class="string">&quot;lisi&quot;</span>));</span><br><span class="line">    <span class="comment">//随机返回集合中的元素（不删除该元素）</span></span><br><span class="line">    System.out.println(setOperations.randomMember(<span class="string">&quot;userList&quot;</span>));</span><br><span class="line">    <span class="comment">//删除集合中的元素</span></span><br><span class="line">    setOperations.remove(<span class="string">&quot;userList&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="zset类型">ZSet类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOpsZSet</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//获取zset集合的ops对象</span></span><br><span class="line">    ZSetOperations&lt;String, String&gt; zSetOperations = stringRedisTemplate.opsForZSet();</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    zSet.add(<span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;String&gt;(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100.00</span>));</span><br><span class="line">    zSet.add(<span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;String&gt;(<span class="string">&quot;lisi&quot;</span>, <span class="number">200.00</span>));</span><br><span class="line">    zSet.add(<span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;String&gt;(<span class="string">&quot;wangwu&quot;</span>, <span class="number">300.00</span>));</span><br><span class="line">    zSet.add(<span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;String&gt;(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">400.00</span>));</span><br><span class="line">    <span class="comment">//新增操作</span></span><br><span class="line">    zSetOperations.add(<span class="string">&quot;nameList&quot;</span>, zSet);</span><br><span class="line">    <span class="comment">//查询并输出(升序)</span></span><br><span class="line">    zSetOperations.range(<span class="string">&quot;nameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//降序</span></span><br><span class="line">    zSetOperations.reverseRange(<span class="string">&quot;nameList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//查询并升序输出指定分数内的集合数据</span></span><br><span class="line">    zSetOperations.rangeByScore(<span class="string">&quot;nameList&quot;</span>, <span class="number">100</span>, <span class="number">200</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//查询并升序输出指定分数内的集合</span></span><br><span class="line">    zSetOperations.rangeByScoreWithScores(<span class="string">&quot;nameList&quot;</span>, <span class="number">100</span>, <span class="number">200</span>).forEach(</span><br><span class="line">        stringTypedTuple -&gt; System.out.println(stringTypedTuple.getValue() + <span class="string">&quot;,&quot;</span> + stringTypedTuple.getScore())</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//查询并降序输出指定分数内的集合数据</span></span><br><span class="line">    zSetOperations.reverseRangeByScore(<span class="string">&quot;nameList&quot;</span>, <span class="number">100</span>, <span class="number">200</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//查询并降序输出指定分数内的集合</span></span><br><span class="line">    zSetOperations.reverseRangeByScoreWithScores(<span class="string">&quot;nameList&quot;</span>, <span class="number">100</span>, <span class="number">200</span>).forEach(</span><br><span class="line">        stringTypedTuple -&gt; System.out.println(stringTypedTuple.getValue() + <span class="string">&quot;,&quot;</span> + stringTypedTuple.getScore())</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="附录">附录</span></h1>
<h2><span id="redisconf-配置详情">redis.conf 配置详情</span></h2>
<p>Redis 支持很多的参数，但都有默认值。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>daemonize</td>
<td>默认情况下，redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为yes</td>
</tr>
<tr>
<td>pidfile</td>
<td>当Redis 在后台运行的时候，Redis 默认会把pid 文件放在/var/run/redis.pid，你可以配置到其他地址。当运行多个redis 服务时，需要指定不同的pid 文件和端口</td>
</tr>
<tr>
<td>bind</td>
<td>指定Redis 只接收来自于该IP 地址的请求，如果不进行设置，那么将处理所有请求，在生产环境中最好设置该项</td>
</tr>
<tr>
<td>port</td>
<td>监听端口，默认为6379</td>
</tr>
<tr>
<td>timeout</td>
<td>设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接</td>
</tr>
<tr>
<td>loglevel</td>
<td>log 等级分为4 级，debug, verbose, notice, 和warning。生产环境下一般开启notice</td>
</tr>
<tr>
<td>logfile</td>
<td>配置log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上</td>
</tr>
<tr>
<td>databases</td>
<td>设置数据库的个数，可以使用SELECT <dbid>命令来切换数据库。默认使用的数据库是0</dbid></td>
</tr>
<tr>
<td>save</td>
<td>设置Redis 进行数据库镜像的频率。if(在60 秒之内有10000 个keys 发生变化时){进行镜像备份}else if(在300 秒之内有10 个keys 发生了变化){进行镜像备份}else if(在900 秒之内有1 个keys 发生了变化){进行镜像备份}</td>
</tr>
<tr>
<td>rdbcompression</td>
<td>在进行镜像备份时，是否进行压缩</td>
</tr>
<tr>
<td>dbfilename</td>
<td>镜像备份文件的文件名</td>
</tr>
<tr>
<td>dir</td>
<td>数据库镜像备份的文件放置的路径。这里的路径跟文件名要分开配置是因为Redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中</td>
</tr>
<tr>
<td>slaveof</td>
<td>设置该数据库为其他数据库的从数据库</td>
</tr>
<tr>
<td>masterauth</td>
<td>当主数据库连接需要密码验证时，在这里指定</td>
</tr>
<tr>
<td>requirepass</td>
<td>设置客户端连接后进行任何其他指定前需要使用的密码。警告：因为redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150K 次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解。</td>
</tr>
<tr>
<td>maxclients</td>
<td>限制同时连接的客户数量。当连接数超过这个值时，redis 将不再接收其他连接请求，客户端尝试连接时将收到error 信息。</td>
</tr>
<tr>
<td>maxmemory</td>
<td>设置redis 能够使用的最大内存。当内存满了的时候，如果还接收到set 命令，redis 将先尝试剔除设置过expire 信息的key，而不管该key 的过期时间还没有到达。在删除时，将按照过期时间进行删除，最早将要被过期的key 将最先被删除。如果带有expire 信息的key 都删光了，那么将返回错误。这样，redis 将不再接收写请求，只接收get 请求。maxmemory 的设置比较适合于把redis 当作于类似memcached 的缓存来使用。</td>
</tr>
<tr>
<td>appendonly</td>
<td>默认情况下，redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。所以redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。开启append only 模式之后，redis 会把所接收到的每一次写操作请求都追加到appendonly.aof 文件中，当redis 重新启动时，会从该文件恢复出之前的状态。但是这样会造成appendonly.aof 文件过大，所以redis 还支持了BGREWRITEAOF 指令，对appendonly.aof 进行重新整理。所以我认为推荐生产环境下的做法为关闭镜像，开启appendonly.aof，同时可以选择在访问较少的时间每天对appendonly.aof 进行重写一次。</td>
</tr>
<tr>
<td>appendfsync</td>
<td>设置对appendonly.aof 文件进行同步的频率。always 表示每次有写操作都进行同步，everysec 表示对写操作进行累积，每秒同步一次。这个需要根据实际业务场景进行配置</td>
</tr>
<tr>
<td>vm-enabled</td>
<td>是否开启虚拟内存支持。因为redis 是一个内存数据库，而且当内存满的时候，无法接收新的写请求，所以在redis 2.0 中，提供了虚拟内存的支持。但是需要注意的是，redis中，所有的key 都会放在内存中，在内存不够时，只会把value 值放入交换区。这样保证了虽然使用虚拟内存，但性能基本不受影响，同时，你需要注意的是你要把vm-max-memory 设置到足够来放下你的所有的key</td>
</tr>
<tr>
<td>vm-swap-file</td>
<td>设置虚拟内存的交换文件路径</td>
</tr>
<tr>
<td>vm-max-memory</td>
<td>这里设置开启虚拟内存之后，redis 将使用的最大物理内存的大小。默认为0，redis 将把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。在生产环境下，需要根据实际情况设置该值，最好不要使用默认的0</td>
</tr>
<tr>
<td>vm-page-size</td>
<td>设置虚拟内存的页大小，如果你的value 值比较大，比如说你要在value 中放置博客、新闻之类的所有文章内容，就设大一点，如果要放置的都是很小的内容，那就设小一点。</td>
</tr>
<tr>
<td>vm-pages</td>
<td>设置交换文件的总的page 数量，需要注意的是，page table 信息会放在物理内存中，每8 个page 就会占据RAM 中的1 个byte。总的虚拟内存大小 ＝ vm-page-size * vm-pages</td>
</tr>
<tr>
<td>vm-max-threads</td>
<td>设置VM IO 同时使用的线程数量。因为在进行内存交换时，对数据有编码和解码的过程，所以尽管IO 设备在硬件上本上不能支持很多的并发读写，但是还是如果你所保存的vlaue 值比较大，将该值设大一些，还是能够提升性能的</td>
</tr>
<tr>
<td>glueoutputbuf</td>
<td>把小的输出缓存放在一起，以便能够在一个TCP packet 中为客户端发送多个响应，具体原理和真实效果我不是很清楚。所以根据注释，你不是很确定的时候就设置成yes</td>
</tr>
<tr>
<td>hash-max-zipmap-entries</td>
<td>在redis 2.0 中引入了hash 数据结构。当hash 中包含超过指定元素个数并且最大的元素没有超过临界时，hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值</td>
</tr>
<tr>
<td>activerehashing</td>
<td>开启之后，redis 将在每100 毫秒时使用1 毫秒的CPU 时间来对redis 的hash 表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis 时不时的对请求有2 毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存</td>
</tr>
</tbody>
</table>
<h2><span id="远程连接redis设置"><em><strong>*远程连接Redis设置*</strong></em></span></h2>
<p><strong>连接超时错误：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps151.jpg)</p>
<p>开放Linux的对外访问的端口6379：</p>
<p>/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT</p>
<p>/etc/rc.d/init.d/iptables save</p>
<p><strong>连接被拒绝错误：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps152.jpg)</p>
<p>redis默认只允许本机连接，修改redis.conf，找到bind 127.0.0.1，将其注释掉：</p>
<p>vim redis.conf</p>
<p>输入/bind 127.0.0.1 回车，找到下图位置</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps153.jpg) ![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps154.jpg)</p>
<p><strong>访问再次被拒：</strong></p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps155.jpg)</p>
<p>redis默认开启了保护模式，修改redis.conf，找到protected-mode yes，将yes改为no</p>
<p>![img](file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml14104\wps156.jpg)</p>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>sentinel</title>
    <url>/post/sentinel/</url>
    <content><![CDATA[<h1><span id="基础概念">基础概念</span></h1>
<h2><span id="资源">资源</span></h2>
<p>通过 Sentinel API 某一代码定义为资源，可以是 Java 应用程序中的任何内容（服务、调用的服务、代码段），可以使用方法签名，URL，甚至服务名称作为资源名来标示资源</p>
<h2><span id="规则">规则</span></h2>
<p>对指定资源（某一代码段）的实时状态设定的规则（包括流量控制规则、熔断降级规则以及系统保护规则），所有规则可以动态实时调整</p>
<h2><span id="设置规则">设置规则</span></h2>
<h3><span id="java代码">Java代码</span></h3>
<p>直接在代码中对指定资源进行规则的设置</p>
<h3><span id="sentinel控制台">sentinel控制台</span></h3>
<p>在Sentinel控制台中对指定资源进行规则的设置</p>
<p>使用控制台的方式进行规则设置时，需对控制台所在地址进行配置，从而使应用可从控制台处获取到动态的规则配置</p>
<h1><span id="基础配置">基础配置</span></h1>
<h2><span id="下载sentinel控制台">下载sentinel控制台</span></h2>
<p><code>sentinel-dashboard-1.8.5.jar</code></p>
<h2><span id="启动sentinel控制台">启动sentinel控制台</span></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar -Dserver.port=8888 sentinel-dashboard-1.8.5.jar</span><br></pre></td></tr></table></figure>
<h2><span id="spring-boot-导入sentinel">Spring Boot 导入sentinel</span></h2>
<h3><span id="引入sentinel依赖">引入sentinel依赖</span></h3>
<p>在pom.xml文件中导入如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="添加配置">添加配置</span></h3>
<p>在application.xml中添加如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment"># sentinel仪表盘地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8888</span></span><br><span class="line">        <span class="comment"># 客户端与sentinel通信地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br></pre></td></tr></table></figure>
<h1><span id="流量控制">流量控制</span></h1>
<p>根据系统的处理能力对流量进行控制</p>
<p>Sentinel 可以根据需要把随机的请求调整成合适的形状</p>
<p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果</p>
<img src="https://sentinelguard.io/docs/zh-cn/img/sentinel-flow-overview.jpg" alt="arch" style="zoom:67%;">
<h2><span id="基于qps并发线程数的流控">基于QPS/并发线程数的流控</span></h2>
<img src="https://pic.imgdb.cn/item/64c3acd11ddac507cc9305a8.jpg" style="zoom:50%;">
<h3><span id="qpsquery-per-second">QPS（Query Per Second）</span></h3>
<p>每秒查询率，即服务器在一秒的时间内处理了多少个请求</p>
<p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制</p>
<h3><span id="并发线程数">并发线程数</span></h3>
<p>用于保护业务线程数不被耗尽</p>
<p>Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝</p>
<p>当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽</p>
<p>为应对高线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），或者使用信号量来控制同时请求的个数（信号量隔离）</p>
<p>这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间。当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力</p>
<h3><span id="系统负载">系统负载</span></h3>
<p>系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环</p>
<p>当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去</p>
<p>如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p>
<p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求</p>
<h3><span id="流控效果">流控效果</span></h3>
<h4><span id="快速失败直接限流">快速失败（直接限流）</span></h4>
<p>默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code></p>
<p>适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时</p>
<h4><span id="warm-up冷启动">Warm up（冷启动）</span></h4>
<p>于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况</p>
<p>通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：</p>
<p><img src="https://github.com/alibaba/Sentinel/wiki/image/warmup.gif" alt="冷启动过程 QPS 曲线"></p>
<h4><span id="排队等待">排队等待</span></h4>
<p>严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法</p>
<p>用于处理间隔性突发的流量，例如消息队列。在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求</p>
<p><img src="https://github.com/alibaba/Sentinel/wiki/image/queue.gif" alt="img"></p>
<h2><span id="基于调用关系的流控">基于调用关系的流控</span></h2>
<p>调用关系包括调用方、被调用方；方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterNodeBuilderSlot</code> 记录每个资源的实时统计信息。</p>
<h3><span id="调用方限流">调用方限流</span></h3>
<p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。可通过以下命令来展示不同的调用方对同一个资源的调用数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8719/origin?id=nodeA</span><br></pre></td></tr></table></figure>
<p>调用数据示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id: nodeA</span><br><span class="line">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class="line">1   caller1 0         0         0          0        0     0         0          0</span><br><span class="line">2   caller2 0         0         0          0        0     0         0          0</span><br></pre></td></tr></table></figure>
<p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p>
<p>限流规则中的 <code>limitApp</code> 字段用于根据调用方进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p>
<ul>
<li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li>
<li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li>
<li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li>
</ul>
<p>同一个资源名可以配置多条规则，规则的生效顺序为：<strong>{some_origin_name} &gt; other &gt; default</strong></p>
<h3><span id="关联流控">关联流控</span></h3>
<p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联；当关联资源超出流控规则限制的调用时，Sentinel对当前资源进行流控</p>
<p>例如，对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，这样当写库操作过于频繁时，读数据的请求会被限流。</p>
<h3><span id="链路限流">链路限流</span></h3>
<p>根据调用链路入口限流</p>
<p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p>
<p>一棵典型的调用树如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          machine-root</span><br><span class="line">              /       \</span><br><span class="line">             /         \</span><br><span class="line">       Entrance1     Entrance2</span><br><span class="line">          /             \</span><br><span class="line">         /               \</span><br><span class="line">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure>
<p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.CHAIN</code>，同时设置 <code>FlowRule.ref_identity</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而对来自 <code>Entrance2</code> 的调用漠不关心。</p>
<p>调用链的入口是通过 API 方法 <code>ContextUtil.enter(name)</code> 定义的</p>
<h1><span id="熔断降级">熔断降级</span></h1>
<p>不同服务之间相互调用，组成复杂的调用链路，熔断降级用于降低调用链路中的不稳定的弱依赖服务调用（暂时切断）</p>
<p>如果调用链路中的某个资源出现了不稳定，可能层层级联，最终会导致请求发生堆积</p>
<p>例如，请求响应时间变长或异常比例升高时，调用服务的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身不可用，则需要对这个资源的调用进行限制，并让请求快速失败，避免该服务的不稳定因素导致整体的雪崩</p>
<p>熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置</p>
<img src="https://user-images.githubusercontent.com/9434884/62410811-cd871680-b61d-11e9-9df7-3ee41c618644.png" alt="image" style="zoom:67%;">
<table>
<thead>
<tr>
<th>Hystrix设计理念</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过线程池隔离资源</td>
<td>资源和资源之间彻底隔离</td>
<td>增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Sentinel设计理念</th>
<th></th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过并发线程数进行限制</td>
<td>减少不稳定资源对其他资源的影响</td>
<td>没有线程切换的损耗无需预先分配线程池的大小</td>
</tr>
<tr>
<td>通过响应时间对资源进行降级</td>
<td>直接拒绝响应时间过长的请求访问资源，经过指定时间后恢复</td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="熔断降级规则">熔断降级规则</span></h2>
<p>熔断触发后，将拒绝请求并抛出异常<code>com.alibaba.csp.sentinel.slots.block.degrade.DegradeException: null</code></p>
<table>
<thead>
<tr>
<th>熔断规则</th>
<th>熔断触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>慢调用比例</td>
<td>单位统计时长内请求数目大于设置的最小请求数目，并且慢调用（请求的响应时间大于最大RT）的比例大于阈值</td>
</tr>
<tr>
<td>异常比例</td>
<td>单位统计时长内请求数目大于设置的最小请求数目，并且异常的比例大于阈值（范围：<code>[0.0, 1.0]对应0% - 100%</code>）</td>
</tr>
<tr>
<td>异常数</td>
<td>单位统计时长内请求数目大于设置的最小请求数目，并且异常数目超过阈值</td>
</tr>
</tbody>
</table>
<p>熔断后经过<strong>熔断时长</strong>后熔断器会进入探测恢复状态（HALF-OPEN 状态），此时的恢复条件如下</p>
<table>
<thead>
<tr>
<th>熔断规则</th>
<th>熔断后恢复条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>慢调用比例</td>
<td>若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断</td>
</tr>
<tr>
<td>异常比例</td>
<td>若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断</td>
</tr>
<tr>
<td>异常数</td>
<td>若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断</td>
</tr>
</tbody>
</table>
<h3><span id="慢调用比例">慢调用比例</span></h3>
<img src="https://pic.imgdb.cn/item/64c888441ddac507cc6b4987.jpg" style="zoom: 50%;">
<ol>
<li>对于userList资源采取慢调用比例熔断策略</li>
<li>在5秒内超过2个请求时，且有超过一半的请求的响应时间超过500毫秒则进行熔断降级</li>
<li>5秒后的第一个请求响应时间小于500毫秒则恢复，否则再次熔断</li>
</ol>
<h3><span id="异常比例">异常比例</span></h3>
<img src="https://pic.imgdb.cn/item/64c8a9471ddac507ccab6e59.jpg" style="zoom:50%;">
<ol>
<li>对于userList资源采取异常比例熔断策略</li>
<li>在5秒内超过2个请求时，且有超过一半的请求发生异常则进行熔断降级</li>
<li>5秒后的第一个请求没有异常则恢复，否则再次熔断</li>
</ol>
<h3><span id="异常数">异常数</span></h3>
<img src="https://pic.imgdb.cn/item/64c8b03d1ddac507ccb98a87.jpg" style="zoom:50%;">
<ol>
<li>对于userList资源采取异常数熔断策略</li>
<li>在5秒内超过2个请求时，且至少有一个以上请求发生异常则进行熔断降级</li>
<li>5秒后的第一个请求没有异常则恢复，否则再次熔断</li>
</ol>
<h3><span id="资源名">资源名</span></h3>
<p><strong>未在代码段配置资源名</strong>时，可以通过微服务中某个控制器的访问相对路径来指定，例如 <code>/user/list</code></p>
<p>当超出流控规则限制的调用时，服务器返回<code>429 Too Many Requests</code>，且返回响应体：<code>Blocked by Sentinel (flow limiting)</code></p>
<p><strong>在代码段配置资源名</strong></p>
<p>为微服务中某个控制器添加注解：<code>@SentinelResource(value = &quot;【资源名】&quot;)</code></p>
<p>重启服务器（流控规则将丢失），重新配置流控规则</p>
<p>当超出流控规则限制的调用时，服务器返回<code>500 Internal Server Error</code>，且在服务器触发异常：</p>
<p><code>com.alibaba.csp.sentinel.slots.block.flow.FlowException: null</code></p>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>关于配置servlet的url-pattern的问题</title>
    <url>/post/servlet%20url-pattern%E7%9A%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2><span id="servlet-url-pattern的匹配问题">servlet url-pattern的匹配问题</span></h2>
<p>url-pattern 有三种匹配模式，分别是路径匹配、精确匹配、后缀匹配</p>
<h3><span id="精确匹配">精确匹配</span></h3>
<p>url-pattern 中配置的项必须与url完全精确匹配。 代码举例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Kata/detail.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/table<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当在浏览器中输入如下几种url时，都会被匹配到该servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/Kata/detail.html</span><br><span class="line">http://localhost:8080/demo.html</span><br><span class="line">http://localhost:8080/table </span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><code>http://localhost:8080/table/</code> 是非法的url，不会被当作<code>http://localhost:8080/table</code> 识别</li>
<li>另外上述url后面可以跟任意的查询条件，都会被匹配，如 <code>http://localhost:8080/table?hello</code> 这个请求就会被匹配到MyServlet。</li>
</ol>
<h3><span id="路径匹配">路径匹配</span></h3>
<p>以“/”字符开头，并以“/*”结尾的字符串用于路径匹配</p>
<p>代码举例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>路径以/user/开始，后面的路径可以任意。比如下面的url都会被匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/user/users.html </span><br><span class="line">http://localhost:8080/user/admin/addUser.action </span><br></pre></td></tr></table></figure>
<p>/* 为优先级最低的路径匹配，匹配所有请求(所有的后台请求和所有的前端请求)</p>
<h3><span id="后缀匹配">后缀匹配</span></h3>
<p>以“ *. ”开头的字符串被用于后缀匹配</p>
<p>代码举例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则任何扩展名为jsp或action的url请求都会匹配，比如下面的url都会被匹配</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/user/users.jsp </span><br><span class="line">http://localhost:8080/toHome.action</span><br></pre></td></tr></table></figure>
<p>注意：路径和后缀匹配无法同时设置 ,如果设置，启动tomcat服务器会报错</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>user*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="url-pattern的优先级问题">url-pattern的优先级问题</span></h2>
<ol>
<li>当配置了多个Servlet的url-pattern同时匹配同一个请求时，会将请求匹配给优先级高的Servlet</li>
<li>精确匹配&gt;路径匹配（/*）&gt;扩展名匹配&gt;缺省匹配</li>
</ol>
<h2><span id="url-pattern中-和-的区别">url-pattern中 / 和 /* 的区别</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em><em>web.xml中配置dispatcherServlet， /</em> 不能访问jsp而 / 可以访问jsp</em>*</p>
<p>/* 能匹配所有请求 ， / 当所有其他匹配都不合适时匹配</p>
<ol>
<li>
<p>在tomcat/conf/web.xml里 面单独配置了 *.jsp 的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>/*作为路径匹配优先级高于tomcat里的后缀匹配，因此匹配，jsp不再交给tomcat中的JspServlet处理导致jsp文件无法访问</p>
</li>
<li>
<p>/ 是最低优先级的匹配，因此匹配tomcat中的JspServlet</p>
</li>
</ol>
<p><em><em>web.xml中配置dispatcherServlet， /</em> 和 / 都不能访问html</em>*</p>
<ol>
<li>
<p>在tomcat/conf/web.xml里 面单独配置了 / （缺省）的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>/*作为路径匹配优先级高于tomcat里的缺省匹配，因此匹配，jsp不再交给tomcat中的DefaultServlet处理导致无法访问</p>
</li>
<li>
<p>/ 与 tomcat中的DefaultServlet同优先级导致无法访问html</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>/*</th>
<th>/</th>
</tr>
</thead>
<tbody>
<tr>
<td>范围</td>
<td>最广，所有的请求都符合它的要求（jsp、servlet、Controller等）</td>
<td>当所有其他匹配都不合适时匹配</td>
</tr>
<tr>
<td>匹配优先级</td>
<td>它是路径匹配的一种，相对 / 较高</td>
<td>最低，当一个url和所有的 url-pattern 匹配都不合适时匹配</td>
</tr>
</tbody>
</table>
<p><strong>根路径 / 的匹配问题</strong></p>
<p>/ 访问<code>http://localhost:8080/</code>可以自动转发到<code>http://localhost:8080/index.html</code></p>
<p>而/*不能自动转发，只能直接访问<code>http://localhost:8080/index.html</code>（spring容器里面配置了<code>&lt;mvc:default-servlet-handler/&gt;</code>）</p>
<p><code>http://localhost:8080/</code>会被url-pattern为/*的匹配，但他不会被url-pattern为/匹配。</p>
<p>在tomcat中，/默认是属于会被defaultservlet匹配，但是其优先级低于路径匹配，所以当某一个servlet的url-pattern为/*时，/就 会被这个servlet匹配，从而不被defaultservlet匹配。 <code>http://localhost:8080/</code>自动转发到<code>http://localhost:8080/index.html</code>的前提是/必须被defaultservlet匹配。</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/post/servlet/</url>
    <content><![CDATA[<h2><span id="web应用目录结构">web应用目录结构</span></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(Web应用程序根目录)</span><br><span class="line">src</span><br><span class="line">----- main</span><br><span class="line">--------- java</span><br><span class="line">--------- resources</span><br><span class="line">--------- webapp(视图相关文件)</span><br><span class="line">------------- WEB-INF(源代码)</span><br><span class="line">----------------- classes(编译后的Servlet类)</span><br><span class="line">--------------------- XXX.class</span><br><span class="line">--------------------- XXX.class</span><br><span class="line">----------------- lib(web应用程序需要的外部jar包)</span><br><span class="line">--------------------- XXX.jar</span><br><span class="line">--------------------- XXX.jar</span><br><span class="line">----------------- web.xml (Web应用程序配置文件)</span><br><span class="line">------------- JSP，HTML，图片等资源(放在WEB-INF外,用户只要输入资源URL就可以直接访问到)</span><br></pre></td></tr></table></figure>
<p>下图中，Servlet/JSP容器对应于如Tomcat这类程序，里面的三个框框对应于各种Servlet类的实例</p>
<p>当容器收到请求时，则会根据请求的url去调用相应的servlet类的实例的方法去处理响应该请求</p>
<p>注：在一个应用程序中，容器会为每个Servlet类生成一个实例<br>
<img src="https://pic.imgdb.cn/item/64ad17391ddac507ccbbcf38.jpg" style="zoom:67%;"></p>
<h2><span id="servlet结构">Servlet结构</span></h2>
<img src="https://pic.imgdb.cn/item/64acba0c1ddac507cc27c59d.jpg" style="zoom:67%;">
<h3><span id="servlet接口">Servlet接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void init(ServletConfig var1)</td>
<td>初始化在实例化后自动执行，默认首次请求该Servlet时实例化，可配置为服务器启动时实例化（避免首次请求耗时过长），且Servlet使用单例模式，只执行一次实例化、初始化</td>
</tr>
<tr>
<td>void service(ServletRequest v1,ServletResponse v2)</td>
<td>当客户端发送请求访问该Servlet时，服务器就会自动调用该方法处理请求</td>
</tr>
<tr>
<td>void destroy()</td>
<td>服务器关闭或重启时需要清空内存，将会调用该方法销毁Servlet</td>
</tr>
<tr>
<td>ServletConfig getServletConfig()</td>
<td>返回当前Servlet的ServletConfig对象</td>
</tr>
<tr>
<td>String getServletInfo()</td>
<td>返回对当前Servlet的描述</td>
</tr>
</tbody>
</table>
<p>其中init、Service和destroy是生命周期方法</p>
<h3><span id="genericservlet">GenericServlet</span></h3>
<ol>
<li>提供了Servlet接口的默认实现（除了service）</li>
<li>当我们要创建自己的Servlet时只需要继承GenericServlet类，覆盖需要改写的方法即可</li>
</ol>
<h3><span id="httpservlet">HttpServlet</span></h3>
<p><strong>继承并重写了父类GenericServlet中的service方法</strong></p>
<ol>
<li>参数(ServletRequest req, ServletResponse resp) 强制转换为 (HttpServletRequest, HttpServletResponse)</li>
<li>并调用重载的方法：service(HttpServletRequest req, HttpServletResponse  )</li>
</ol>
<p><strong>重载的Service方法</strong></p>
<ol>
<li>获取请求方式，并根据请求方式的不同执行对应的doXXX方法（doGet、doPost、doHead、doPut、doTrace、doOptions、doDelete）</li>
<li>对应的doXXX方法在自定义Servlet中继承重写，用于实际处理请求</li>
</ol>
<h2><span id="request和response结构">Request和Response结构</span></h2>
<img src="https://pic.imgdb.cn/item/64acbbc41ddac507cc2eb6e5.jpg" style="zoom:67%;">
<h3><span id="servletrequest接口">ServletRequest接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getParameter(String var1)</td>
<td>获得客户端传来的参数的，即Parameter是用于客户端和服务端之间的信息传递</td>
</tr>
<tr>
<td>String[] getParameterValues(java.lang.String name)</td>
<td>返回一个包含所有的给定请求参数的值的字符串对象的向量。若该参数不存在，则返回一个空值</td>
</tr>
<tr>
<td>Object getAttribute(String var1)</td>
<td>在服务端获得另一个服务端通过setAttribute传进去的参数</td>
</tr>
<tr>
<td>void setAttribute(String var1, Object var2)</td>
<td>用于服务端之间的信息传递</td>
</tr>
<tr>
<td>void removeAttribute(String var1)</td>
<td>删除服务端中存储的数据</td>
</tr>
<tr>
<td>getRemoteAddr</td>
<td>浏览器的IP地址</td>
</tr>
<tr>
<td>getRemotePort</td>
<td>浏览器端端口号</td>
</tr>
<tr>
<td>getServerName</td>
<td>服务器名称</td>
</tr>
<tr>
<td>getServerPort</td>
<td>服务器端口号</td>
</tr>
<tr>
<td>getScheme</td>
<td>协议名称</td>
</tr>
<tr>
<td>setCharacterEncoding(String var1)</td>
<td>设置字符集编码</td>
</tr>
</tbody>
</table>
<h3><span id="servletresponse接口">ServletResponse接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PrintWriter getWriter()</td>
<td>获取writer（打印流），通过调用writer的print方法向response中写入内容（可识别前端代码html,css,javascript）</td>
</tr>
<tr>
<td>void setContentType(String var1)</td>
<td>设置response的内容类型，一般用于处理响应中的中文乱码现象</td>
</tr>
</tbody>
</table>
<h3><span id="httpservletrequst">HttpServletRequst</span></h3>
<p>实现ServletRequest接口，封装了http请求报文，使得我们可以不用自己去解析http报文</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getMethod()</td>
<td>请求方式</td>
</tr>
<tr>
<td>getRequestURL</td>
<td>请求的完整路径URL</td>
</tr>
<tr>
<td>getRequestURI</td>
<td>请求的相对路径URI</td>
</tr>
</tbody>
</table>
<h3><span id="httpservletresponse">HttpServletResponse</span></h3>
<p>实现ServletResponse接口，封装了响应报文，使得我们不用自己管http协议中的许多细节</p>
<p><strong>响应状态码</strong></p>
<p>表示程序的运行状态</p>
<table>
<thead>
<tr>
<th>响应状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>404</td>
<td>无法通过路径找到资源文件</td>
</tr>
<tr>
<td>500</td>
<td>服务端运行发生了异常</td>
</tr>
<tr>
<td>200</td>
<td>程序运行一切正常</td>
</tr>
</tbody>
</table>
<p><strong>手动发送状态码</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void sendError(int sc)</td>
<td>向客户端发送【sc】状态码响应错误</td>
</tr>
<tr>
<td>void sendError(<em>int</em> var1, String var2)</td>
<td>向客户端发送【var1】状态码、【var2】描述信息响应错误</td>
</tr>
</tbody>
</table>
<h2><span id="cookie和httpsession">Cookie和HttpSession</span></h2>
<h3><span id="cookie">cookie</span></h3>
<p>通过浏览器将键值对数据保存在客户端硬盘上（如商城的购物车、登录的记住密码或免登录）</p>
<p><strong>保存键值对</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.需要实例化cookie对象，需要键值对参数</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(id,name);</span><br><span class="line"><span class="comment">//2.设置cookie数据的有效时间，单位是秒</span></span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>);</span><br><span class="line"><span class="comment">//3.利用响应对象将cookie数据保存在浏览器硬盘中</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p><strong>查看键值对</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过请求对象获取cookie对象数组</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//遍历cookies数组查看每个cookie的键值数据</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookies != <span class="literal">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        System.out.println(cookie.getName());</span><br><span class="line">        System.out.println(cookie.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="httpsession">HttpSession</span></h3>
<p>可存储键值对数据（setAttribute），一般应用于登录功能</p>
<p><img src="https://pic.imgdb.cn/item/64113030ebf10e5d5374df8a.jpg" alt></p>
<ol>
<li>HttpSession对象存储在服务器中（tomcat）</li>
<li>相同客户端、相同浏览器对应一个HttpSession对象</li>
<li>一个HttpSession对象可以存储多个键值对，且在该对象中共享（即同一客户端、同一浏览器范围内共享数据）</li>
</ol>
<p><strong>生命周期</strong></p>
<ul>
<li>HttpSession对象生命周期为整个浏览器运行期间，浏览器运行结束，即浏览器关闭（所有页面关闭），HttpSession对象的生命周期结束</li>
<li>不同品牌的浏览器HttpSession对象生命周期不一样</li>
</ul>
<p><strong>实例化</strong></p>
<p>当浏览器首次使用httpSession的任意方法，服务器会自动的创建一个session对象（先创建该客户端的该浏览器的JSESSIONID并存储到浏览器的Cookies中，浏览器可以通过Cookies携带的SessionID从服务器的HttpSession对象获取键值对数据）</p>
<p>当浏览器中存储SessionID的Cookies丢失（手动删除），此时使用HttpSession任意方法，则服务器自动重新生成Session对象（重新存储JSESSIONID到新的Cookies）</p>
<p>当浏览器禁用Cookies，由于浏览器无法通过Cookies访问服务器中的HttpSession对象，则每次使用HttpSession任意方法，服务器都会重新生成Session对象（此时可通过url找到之前的HttpSession）</p>
<p><strong>客户端浏览器访问HttpSession的方式</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过Cookies携带SessionID</td>
<td>默认使用Cookies</td>
</tr>
<tr>
<td>通过url携带SessionID（<code>url + &quot;;jsessionid=【sessionID】&quot;</code>）</td>
<td>与Cookies同时使用时Cookies传递优先级更高</td>
</tr>
</tbody>
</table>
<p><strong>销毁</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>HttpSession</th>
</tr>
</thead>
<tbody>
<tr>
<td>浏览器关闭或手动删除Cookies</td>
<td>仅cookies销毁，浏览器无法通过之前的SessionID找到HttpSession</td>
<td>存在</td>
</tr>
<tr>
<td><code>httpSession.removeAttribute(K);</code></td>
<td>仅HttpSession中的key删除</td>
<td>存在</td>
</tr>
<tr>
<td><code>httpSession.setMaxInactiveInterval</code></td>
<td>设置过期时间(单位是秒)，HttpSession对象将被GC清除</td>
<td>销毁</td>
</tr>
<tr>
<td>服务器重启或关闭</td>
<td>tomcat重启或关闭</td>
<td>销毁</td>
</tr>
</tbody>
</table>
<p><strong>请求对象request获取HttpSession对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回关于该请求的当前会话。或者若该请求没有会话则就创建一个</span></span><br><span class="line">getSession();</span><br><span class="line"><span class="comment">//返回有关本请求的当前HttpSession，或者若该请求没有会话，且“创建”属性为真，则就创建一个</span></span><br><span class="line">getSession(<span class="type">boolean</span> create);</span><br></pre></td></tr></table></figure>
<h2><span id="其他接口">其他接口</span></h2>
<h3><span id="servletconfig接口">ServletConfig接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getInitParameter(String var1)</td>
<td>获取该servlet的初始参数。初始参数以键值对的形式在注解中或者在部署描述符web.xml中设置</td>
</tr>
<tr>
<td><em>ServletContext</em> getServletContext();</td>
<td>获得该Servlet的上下文信息，返回一个ServletContext对象</td>
</tr>
<tr>
<td>void setContentType(String type)</td>
<td>处理响应中的中文乱码（代码开始处添加）</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.write(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;title&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;hello!!!!!!!!!!&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/title&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:50px&#x27;&gt;helloWorld!!!!!!!&lt;/div&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<h3><span id="servletcontext接口">ServletContext接口</span></h3>
<p>整个当前的web应用程序的上下文</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getInitParameter(String var1)</td>
<td>相较于ServletConfig是全局范围，所有Servlet都能访问</td>
</tr>
<tr>
<td>Object getAttribute(String var1)</td>
<td>相较于ServletConfig是全局范围，所有Servlet都能访问</td>
</tr>
<tr>
<td>void setAttribute(String var1, Object var2)</td>
<td>相较于ServletConfig是全局范围，所有Servlet都能访问</td>
</tr>
</tbody>
</table>
<h2><span id="servlet配置">Servlet配置</span></h2>
<h3><span id="webxml">web.xml</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>【servlet_name】<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>【servlet_class】<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--修改类实例化时间为服务器启动时,多个类在服务器启动时共同实例化时，数字越小越先实例化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>【servlet_name】<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>【servlet_path】<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3><span id="注解">注解</span></h3>
<p><strong>@WebServlet</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>servlet类的名称，如果没有定义默认使用的是类名，servlet-name标签一致(一般不写)</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>servlet类的请求名称，以/开始，不能重复，可以有多个(必须存在)</td>
</tr>
<tr>
<td>loadOnStartup</td>
<td>服务器启动时实例化该类对象(有选择使用)</td>
</tr>
</tbody>
</table>
<p>当@WebServlet只配置一个请求名称可简化属性名称，@WebServlet(urlPatterns =“/anno”)    ==&gt;     @WebServlet(“/anno”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;【servlet_name】&quot;,urlPatterns =&#123;&quot;/【servlet_path】&quot;,&quot;/【servlet_path】&quot;&#125;,loadOnStartup =1)</span></span><br><span class="line"><span class="keyword">public</span> class 【servlet_class】 <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="欢迎页面">欢迎页面</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置欢迎首页，省略第一个页面的路径编写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/a.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/b.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/hello.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="会话跟踪">会话跟踪</span></h2>
<p>保存键值对参数</p>
<table>
<thead>
<tr>
<th>保存键值对方式</th>
<th>客户端请求</th>
<th>服务端接收</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL重写</td>
<td>加在url地址后面，如<code>url?key1=value1&amp;key2=value2...</code></td>
<td>request.getParameter(key)</td>
</tr>
<tr>
<td>隐藏域</td>
<td>表单中的隐藏域中<code>&lt;input type='hidden' name='id' value='1'/&gt;</code></td>
<td>request.getParameter(“id”)</td>
</tr>
<tr>
<td>Cookie</td>
<td><code>Cookie cookie = new Cookie(String key, String value);</code><br><code>httpServletResponse.addCookie(cookie);</code></td>
<td><code>request.getCookies();</code><br><code>cookie.getValue;</code><br><code>cookie.getName;</code></td>
</tr>
<tr>
<td>Session</td>
<td><code>HttpSession session = request.getSession;</code><br><code>session.setAttribute(name,value);</code></td>
<td><code>HttpSession session = request.getSession;</code><br><code>session.getAttribute(name);</code></td>
</tr>
</tbody>
</table>
<p>s服务端会为每一个客户端在服务端的内存中保存一个HttpSession对象，该对象可以通过HttpServletRequest对象的getSession方法获得（若该客户端在服务端中没有对应的HttpSession对象，则调用该方法会为其创建一个；若该客户端的HttpSession对象已经存在于服务端中了，则该方法会直接返回该对象）。当服务端为该客户端在服务端内存中创建HttpSession对象时，会为该客户端生成给一个独一无二的id，并通过cookie的方式回复给该客户端（该过程无需我们管），则在之后该客户端对服务端的访问中，都会带上这个写有id的cookie，从而使得服务端可以通过该id在服务端的内存中找到与该客户端对应的session对象</p>
<table>
<thead>
<tr>
<th>不同</th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody>
<tr>
<td>键值对存储</td>
<td>客户端，服务端将键值对参数写进cookie后相应给客户端，让客户端保存存有键值对参数的cookie</td>
<td>服务端，服务端将键值对参数写进HttpSession对象中存在自己的内存里</td>
</tr>
<tr>
<td>说明</td>
<td>当服务端需要获取键值对参数时，需要从客户端发来的cookie中获取</td>
<td>当服务端需要获取键值对参数时，只需要从客户端获取其id，就可以从自己的内存中获取到对应的键值对参数</td>
</tr>
</tbody>
</table>
<p>对于在多个页面中跳转并保存键值对参数的情况，前两种方式存取较为复杂，而后两种方法由于将键值对保存在客户端或服务端，可直接通过客户端或服务端获取，且能较持久的保存</p>
<p><strong>当使用Post请求方式且请求参数为中文时会出现乱码现象</strong></p>
<p>请求：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code> 设置字符编码，避免中文乱码现象</p>
<p><strong>响应参数为中文时，响应到客户端页面会出现乱码现象</strong></p>
<p>响应：<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code> 处理响应的中文乱码</p>
<h2><span id="servlet跳转">Servlet跳转</span></h2>
<h3><span id="请求转发">请求转发</span></h3>
<img src="https://pic.imgdb.cn/item/64abcf1d1ddac507cce9ef9e.jpg" style="zoom: 50%;">
<p>服务端在执行servlet执行到这个动作时发生的跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取转发器对象,参数：目标的请求名称</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;【参数】&quot;</span>);</span><br><span class="line">requestDispatcher.forward(request,response);</span><br></pre></td></tr></table></figure>
<h3><span id="响应重定向">响应重定向</span></h3>
<img src="https://pic.imgdb.cn/item/64abcf331ddac507ccea4c66.jpg" style="zoom:50%;">
<p>服务端通过HttpServletResponse去回复给客户端一个url，让客户端再去发请求给这个新的url</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：目标的请求名称</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;【参数】&quot;</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>请求转发</th>
<th>响应重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用方法的对象</td>
<td>HttpServletRequest</td>
<td>HttpServletResponse</td>
</tr>
<tr>
<td>URL</td>
<td>转发前的路径</td>
<td>转发后的路径</td>
</tr>
<tr>
<td>客户端请求参数</td>
<td>转发与被转发的Servlet都能获取，转发前后共用一个Request</td>
<td>仅被转发的Servlet能获取</td>
</tr>
<tr>
<td>转发前存储在request作用域的键值对数据</td>
<td>只有一次请求，转发后的Servlet能获取</td>
<td>多次请求、响应，转发后的Servlet不能获取</td>
</tr>
<tr>
<td>执行顺序</td>
<td>类似方法调用，转发后仍继续执行原Servlet下行代码</td>
<td>执行完当前Servlet再重定向，即访问第二个请求</td>
</tr>
<tr>
<td>转发后的请求方式</td>
<td>转发后执行doPost</td>
<td>转发后执行doGet</td>
</tr>
<tr>
<td>执行效率</td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td>访问范围</td>
<td>服务器内部资源</td>
<td>任意资源路径</td>
</tr>
</tbody>
</table>
<p><strong>当执行对数据增删改操作时，应使用response.sendRedirect()</strong></p>
<p>若使用request.getRequestDispatcher().forward(request,response)，转发前后的URL不发生改变，因此对页面刷新则再次发送转发前的请求，即刷新一次页面后就修改了一条数据的原因</p>
<h2><span id="jsp">JSP</span></h2>
<p>JSP本质上时另一种形式的Servlet类，当jsp页面首次被访问时会被服务器翻译为一个Servlet实现类</p>
<p>当jsp后续被访问时，服务器会检查jsp是否改动，若改动则重新编译，否则按原来的Servlet生命周期执行</p>
<p>jsp本身包含html，也能写java</p>
<p>JSP中的内容由语法元素和模板数据两部分构成。语法元素由如&lt;% %&gt;这种类型的符号包裹。其余的内容都为模板数据。模板数据在转换成servlet时，会全部原封不动的被writer.print到response中，而语法元素部分则会被转为相应的Java代码。</p>
<h3><span id="jsp隐式对象">JSP隐式对象</span></h3>
<p>以下对象可在jsp中直接使用</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>所属类</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>javax.servlet.http.HttpServletRequest</td>
</tr>
<tr>
<td>response</td>
<td>javax.servlet.http.HttpServletResponse</td>
</tr>
<tr>
<td>out</td>
<td>javax.servlet.jsp.JspWriter</td>
</tr>
<tr>
<td>session</td>
<td>javax.servlet.http.HttpSession</td>
</tr>
<tr>
<td>application</td>
<td>javax.servlet.ServletContext</td>
</tr>
<tr>
<td>config</td>
<td>javax.servlet.ServletConfig</td>
</tr>
<tr>
<td>pageContext</td>
<td>javax.servlet.jsp.PageContext</td>
</tr>
</tbody>
</table>
<ol>
<li>out 相当于从HttpServletResponse中获得的PrintWriter对象</li>
<li>pageContext的 getAttribute(String name, int scope)和setAttribute(String name, Object value, int scope)方法可以指定Attribute的作用范围</li>
</ol>
<table>
<thead>
<tr>
<th>scope参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUEST_ SCOPE</td>
<td>HttpServletRequest中的get/setAttribute方法</td>
</tr>
<tr>
<td>SESSION_SCOPE</td>
<td>HttpSession中的get/setAttribute方法</td>
</tr>
<tr>
<td>APPLICATION_SCOPE</td>
<td>ServletContext中的get/setAttribute方法</td>
</tr>
<tr>
<td>PAGE_SCOPE</td>
<td>只是在当前页面有效</td>
</tr>
</tbody>
</table>
<h3><span id="语法元素">语法元素</span></h3>
<hr>
<h4><span id="指令">指令</span></h4>
<p><strong>page</strong></p>
<p>语法格式：<code>&lt;%@ page attr1=&quot;value1&quot; attr2=&quot;value2&quot;...%&gt;</code></p>
<p>示例：</p>
<ol>
<li><code>&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot; language=&quot;java&quot; %&gt;</code> 指定响应字符集编码以及编码语言</li>
<li><code>&lt;%@ page import=&quot;java.util.ArrayList, java.util.Date&quot; errorPage=&quot;errorHandler.jsp&quot;%&gt;</code> 引入了ArrayList和Date包；指定了当前页面的errorPage（当前页面发生异常后会跳转到errorPage且那个跳转重点jsp也要用page指令声明属性isErrorPage=“True”）</li>
</ol>
<hr>
<p><strong>include</strong></p>
<p>语法格式：<code>&lt;%@ include file=&quot;【路径】&quot;%&gt;</code></p>
<p>在jsp被服务器翻译前，该指令会被【路径】所指向文件内容所替换；然后被翻译为一个Servlet实现类（url所指向的文件不会被翻译成Servlet）</p>
<hr>
<h4><span id="脚本">脚本</span></h4>
<table>
<thead>
<tr>
<th>脚本元素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;% ... %&gt;</code></td>
<td>Java代码（局部变量、循环、选择、方法体），被服务器拼接到Servlet的service方法中</td>
</tr>
<tr>
<td><code>&lt;%! ... %&gt;</code></td>
<td>声明方法、成员变量、代码块、内部类，被服务器翻译成Servlet的成员方法、成员变量</td>
</tr>
<tr>
<td><code>&lt;%= ... %&gt;</code></td>
<td>打印流输出到浏览器显示</td>
</tr>
<tr>
<td><code>&lt;%-- ... --%&gt;</code></td>
<td>jsp注释（推荐）</td>
</tr>
<tr>
<td><code>&lt;!-- --&gt;</code></td>
<td>html注释</td>
</tr>
</tbody>
</table>
<h4><span id="动作">动作</span></h4>
<p><strong>include</strong></p>
<p>语法格式：&lt;jsp:include page=“XXX.jsp”/&gt;</p>
<p>在jsp被服务器翻译时，将不同页面分别翻译为对应的Servlet实现类，然后依次运行输出（多个Servlet实现类）</p>
<hr>
<p><strong>forward</strong></p>
<p>语法格式：&lt;jsp:forward page=“XXX.jsp”/&gt;</p>
<p>在jsp被服务器翻译时，该动作会被翻译成一个forward方法，类似于方法调用，当前jsp余下部分在XXX.jsp执行完成后执行</p>
<hr>
<p>目前推荐 在jsp页面中使用 <strong>EL</strong> 、<strong>JSTL</strong> ，替代脚本元素的使用（&lt;% … %&gt;），使得JSP中不包含Java后端代码，使得前后端能更好的解耦</p>
<h2><span id="el表达式">EL表达式</span></h2>
<p>语法：<code>$&#123;表达式&#125;</code></p>
<p>从内存中  <strong>从作用域范围最小开始</strong>  <strong>根据键检索数据</strong> 作为jsp数据（找不到则进入作用域范围更大范围检索)</p>
<p>语法： <code>$&#123;a[b]&#125;</code> 或 <code>$&#123;a.b&#125;</code></p>
<table>
<thead>
<tr>
<th>a的数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>List或者数组</td>
<td>b的数据类型为int，b作为索引取值，本质上调用 <code>$&#123;a.get(b)&#125;</code></td>
</tr>
<tr>
<td>Map</td>
<td>b作为键，返回值，本质上调用 <code>$&#123;a.get(&quot;b&quot;)&#125;</code></td>
</tr>
<tr>
<td>对象</td>
<td>b为对象a的属性，本质上调用 <code>$&#123;a.getB()&#125;</code></td>
</tr>
</tbody>
</table>
<p><strong>EL隐式对象</strong></p>
<p>和JSP隐式对象类似，表达式语言也有隐式对象用于访问request，response这类的对象</p>
<table>
<thead>
<tr>
<th>EL隐式对象</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>applicationScope<br>sessionScope<br>requestScope<br>pageScope</td>
<td>可以获取不同范围的Attribute</td>
<td>${applicationScope.myVar}相当于&lt;%application.getAttribute(“myVar”)%&gt;</td>
</tr>
<tr>
<td>cookie</td>
<td>可以获取当前请求中的所有cookie（用key唯一识别）</td>
<td></td>
</tr>
<tr>
<td>pageContext</td>
<td>可以获取所有JSP隐式对象</td>
<td>${pageContext.request.method}相当于&lt;%request.getMethod()%&gt;</td>
</tr>
<tr>
<td>initParam</td>
<td>可以获取当前ServletContext的初始参数</td>
<td>${initParam.key}相当于&lt;%application.getInitParameter(“key”)%&gt;</td>
</tr>
<tr>
<td>param</td>
<td>可以获取当前请求的参数</td>
<td>${param.key}相当于&lt;%request.getParameter(“key”)%&gt;</td>
</tr>
<tr>
<td>paramValues</td>
<td>与param类似，只不过value都是数组，用于获取值是数组的参数</td>
<td>${paramValues.selectedOptions[0]}表示取出selectedOptions参数的第一个值</td>
</tr>
<tr>
<td>header</td>
<td>Map，可以获取请求的头</td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="jstl">JSTL</span></h2>
<p>JSP标准标签库，JSP Standard Tag Library</p>
<ol>
<li>使用前导入jstl依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在jsp中声明</li>
</ol>
<p><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;	</code></p>
<hr>
<p><strong>set标签</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--在当前request中set一个名字为job的attribute，并将value赋给这个attribute--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;job&quot;</span> scope=<span class="string">&quot;request&quot;</span> value=<span class="string">&quot;$&#123;...&#125;&quot;</span>/&gt;</span><br><span class="line">&lt;%--相当于&lt;%request.setAttribute(<span class="string">&quot;job&quot;</span>, value)%&gt;--%&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--调用address对象的setCity方法将value的值set进去--%&gt;</span><br><span class="line">&lt;c:set target=<span class="string">&quot;$&#123;address&#125;&quot;</span> property=<span class="string">&quot;city&quot;</span> value=<span class="string">&quot;$&#123;...&#125;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>remove标签</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--删除request中job这个attribute--%&gt;</span><br><span class="line">&lt;c:remove <span class="keyword">var</span>=<span class="string">&quot;job&quot;</span> scope=<span class="string">&quot;request&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>if标签</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--如果请求参数中的user为<span class="string">&#x27;usr&#x27;</span>，password为<span class="string">&#x27;psw&#x27;</span>，则中间的JSP片段会被执行，反之被忽略--%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;param.user==&#x27;usr&#x27; &amp;&amp; param.password==&#x27;psw&#x27;&#125;&quot;</span>&gt; </span><br><span class="line">    JSP segment</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--遵循的是ifelse的规则,只执行其中一条语句--%&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 90 &amp;&amp; requestScope.score &lt;= 100&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为优秀!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 80 &amp;&amp; requestScope.score &lt; 90&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为良好!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 70 &amp;&amp; requestScope.score &lt; 80&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为中等!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 60 &amp;&amp; requestScope.score &lt; 70&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为及格!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 0 &amp;&amp; requestScope.score &lt; 60&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为不及格!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt; &lt;%--上面所有的都不成立，执行此代码--%&gt;</span><br><span class="line">        &lt;h2&gt;分数有误!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>forEach标签</strong></p>
<table>
<thead>
<tr>
<th>标签属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>items</td>
<td>数据源，也就是要遍历的集合容器(EL表达式结合)</td>
</tr>
<tr>
<td>var</td>
<td>自定义一个变量，这个变量自动接收每次循环从集合中获取的一个元素</td>
</tr>
<tr>
<td>varStatus</td>
<td>自定义一个变量，变量用来记录循环的运行</td>
</tr>
<tr>
<td>begin</td>
<td>varStatus属性定义变量初始值</td>
</tr>
<tr>
<td>end</td>
<td>varStatus属性定义变量结束值</td>
</tr>
<tr>
<td>step</td>
<td>varStatus属性定义变量在每次循环后的变化</td>
</tr>
</tbody>
</table>
<p>后四个属性用于自定义控制循环，map集合没有索引值，因此遍历时无法使用后四个属性</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--遍历address.phones。其中varStatus是一个LoopTagStatus类型的对象，它有一个index属性可以获得当前遍历到的索引--%&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;requestScope.userList&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;user&quot;</span>&gt; </span><br><span class="line">    $&#123;user&#125;--------------------</span><br><span class="line">    $&#123;user.uid&#125;===&gt;</span><br><span class="line">    $&#123;user.username&#125;===&gt;</span><br><span class="line">    $&#123;user.password&#125;&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;requestScope.userList&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;user&quot;</span> varStatus=<span class="string">&quot;i&quot;</span> begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;30000&quot;</span> step=<span class="string">&quot;2&quot;</span>&gt;</span><br><span class="line">    $&#123;user&#125;--------------------</span><br><span class="line">    $&#123;user.uid&#125;===&gt;</span><br><span class="line">    $&#123;user.username&#125;===&gt;</span><br><span class="line">    $&#123;user.password&#125;&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>综上，EL更倾向用于访问或者获取某些东西和对它们进行一些算术或逻辑运算，而JSTL则用于完成其余部分。两者共同配合使用来完成对scriplet的替代</p>
<h2><span id="监听器listener">监听器Listener</span></h2>
<p>对监听器接口进行实现并注册，便可以对当前web应用程序的某些行为进行监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 实现监听器接口ListenerInterface</span></span><br><span class="line"><span class="comment">//2. 通过注解WebListener进行注册（也可通过web.xml注册）</span></span><br><span class="line"><span class="meta">@WebListener</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerClass</span> <span class="keyword">implements</span> <span class="title class_">ListenerInterface</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> xxx <span class="title function_">methodA</span><span class="params">(...)</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> xxx <span class="title function_">methodB</span><span class="params">(...)</span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>监听器接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServletContextListener</td>
<td>当ServletContext被创建和销毁时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>ServletContextAttributeListener</td>
<td>当ServletContext中的Attributes被添加、删除、修改时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>HttpSessionListener</td>
<td>当HttpSession被创建和销毁时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>HttpSessionAttributeListener</td>
<td>当HttpSession中的Attributes被添加、删除、修改时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>ServletRequestListener</td>
<td>当ServletRequest被创建和销毁时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>ServletRequestAttributeListener</td>
<td>当ServletRequest中的Attributes被添加、删除、修改时，接口中对应的那个方法会被调用</td>
</tr>
</tbody>
</table>
<p>这些接口中的方法都会接收一个xxxEvent类型的对象，通过该对象可以拿到触发当前方法的对象</p>
<p>如ServletContextListener中的方法都会接收一个ServletContextEvent对象，通过该对象的getServletContext方法可以拿到触发该方法的ServletContext</p>
<p>ServletRequestListener中的方法都会接收一个ServletRequestEvent对象，通过该对象的getServletRequest方法可以拿到触发该方法的ServletRequest</p>
<h2><span id="过滤器filter">过滤器Filter</span></h2>
<p>过滤器可以对客户端的请求、响应进行拦截，在其对应Servlet执行serivce方法前做处理</p>
<p><strong>多个过滤器可以形成一个链条，不同配置方式下的过滤器链执行顺序不同</strong></p>
<table>
<thead>
<tr>
<th>web.xml</th>
<th>注解</th>
<th>两种配置都存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>由filter-mapping顺序决定</td>
<td>由类名的字典顺序由小到大决定</td>
<td>先执行所有xml配置，再执行所有注解配置</td>
</tr>
</tbody>
</table>
<p>注意：过滤器链在请求过程 与 响应过程 中的处理顺序相反</p>
<p><img src="https://pic.imgdb.cn/item/64acfdf21ddac507cc4cc398.jpg" alt></p>
<h3><span id="过滤器配置">过滤器配置</span></h3>
<p><strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>XXX.XXX.XXX<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--拦截指定路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--拦截HTTP类型请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>dispatcher</th>
<th>拦截请求类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUEST</td>
<td>拦截HTTP请求</td>
</tr>
<tr>
<td>FORWORD</td>
<td>拦截请求转发方式的请求</td>
</tr>
<tr>
<td>INCLUDE</td>
<td>拦截通过<code>request.getRequestDispatcher(&quot;&quot;).indeclude()</code>以及通过<code>&lt;jsp:include page=&quot;…&quot;&gt;</code>发出的请求</td>
</tr>
<tr>
<td>ERROR</td>
<td>拦截&lt;error - page&gt;发出的请求</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter.destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拦截并处理请求，注意参数为ServletRequest、ServletResponse，而非Servlet的HttpServletRequest、HttpServletResponse</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//1. 执行chain对象中的doFilter方法则继续运行下一个过滤器或目标程序，否则终止运行</span></span><br><span class="line">        <span class="comment">//2. chain对象的doFilter方法将过滤器分为上下两部分，方法之上的代码请求时运行，方法之下的代码响应时运行   </span></span><br><span class="line">        chain.doFilter(request,response);  <span class="comment">//放行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter.init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解配置拦截指定路径</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/testServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain Chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>init(FilterConfig filterConfig)</td>
<td>过滤器初始化，服务器启动时直接实例化过滤器对象，自动调用该方法</td>
</tr>
<tr>
<td>doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)</td>
<td>方法最后必须要调用FilterChain接口的doFilter(request, response)方法，用于将request继续向后传递给链条中的下一个（可能是Filter或者Servlet）进行处理</td>
</tr>
<tr>
<td>destroy()</td>
<td>过滤器销毁的方法,服务器关闭时自动销毁对象，自动调用该方法</td>
</tr>
</tbody>
</table>
<h3><span id="过滤器应用">过滤器应用</span></h3>
<ol>
<li>过滤乱码</li>
<li>限制资源访问</li>
</ol>
<h2><span id="同步与异步">同步与异步</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>同步</th>
<th>异步</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用某方法时</td>
<td>必须得到方法执行结果后才继续执行后续指令，否则一致等待方法执行完成（阻塞）</td>
<td>即使没有得到方法执行结果也能继续执行后续指令（调用完成后一般通过状态、通知和回调来通知调用者）</td>
</tr>
</tbody>
</table>
<h2><span id="异步处理">异步处理</span></h2>
<p>每次有请求进来时，容器会从线程池中为该请求分配一个线程来处理该请求。然而，容器中的线程池能分配的线程数是有上限的。当处理请求的程序（如service或doFilter方法）较耗时时，会导致线程无法短时间内完成并归还池中，线程池将很快耗尽，便无法接受新进来的请求</p>
<p>为了解决这个问题，可以使用异步的Servlet或Filter，使得处理请求的过程不在当前的方法（如service或doFilter方法）中进行，而是只在当前方法中新建一个线程去处理该请求，然后就结束当前方法，使得该条从容器线程池中取出的线程能很快被还回</p>
<p>可以认为只是换了个线程（不使用容器的线程池中的线程）去处理这个请求，其它完全没有区别。当新建的线程结束后，便会发回response给客户端（同非异步的过程）</p>
<p><strong>使用方法</strong></p>
<ol>
<li>
<p>在Servlet或Filter上注解为异步的（也可以通过web.xml部署）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(asyncSupported=true)</span></span><br><span class="line"><span class="meta">@WebFilter(asyncSupported=true)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在如service、doFilter、doGet、doPost这类处理请求的方法中新建线程去处理该请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">asyncContext.start(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(asyncContext));</span><br></pre></td></tr></table></figure>
<ol>
<li>调用ServletRequest的startAsync方法获得一个AsyncContext 的实例。该实例包含了当前的ServletRequest和ServletResponse，可通过getter方法取出</li>
<li>调用AsyncContext实例的start方法并传一个Runnable实例来开启一个新线程去执行Runnable中的run方法</li>
<li>如果run方法中需要用到request，则可以把AsyncContext实例传递过去（也可以使用匿名内部类，就可以直接访问AsyncContext实例了）</li>
<li>在run方法的最后需要调用AsyncContext实例的complete()方法（用以结束当前线程）或者dispatch(String url)方法（用以将请求转发给url指定的servlet并结束当前线程）</li>
</ol>
</li>
</ol>
<h2><span id="异步监听器">异步监听器</span></h2>
<p>AsyncListener接口：当异步操作启动完毕、执行完成、执行出错、执行超时时，接口中对应的那个方法会被调用。接口中的每个方法都会接收一个AsyncEvent对象，可以从中获取到AsyncContex和当执行出错时抛出的异常</p>
<p>异步监听器的注册：在调用AsyncContext对象的start方法前，通过调用AsyncContext对象的addListener(a AsyncListener instance)方法进行注册</p>
<h2><span id="文件上传">文件上传</span></h2>
<h3><span id="前端代码">前端代码</span></h3>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;upload&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;!--显示为一个选择要上传的文件的按钮,multiple属性可选择多个文件上传--&gt;</span><br><span class="line">    Select a file &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;fieldName&quot;</span> multiple=<span class="string">&quot;multiple&quot;</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Upload&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="后端代码">后端代码</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="comment">//为Servlet增加MultipartConfig注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取表单中文件的部分</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">part</span> <span class="operator">=</span> request.getPart(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line">        <span class="comment">//写入硬盘</span></span><br><span class="line">        part.write(<span class="string">&quot;D:\\temp\\1.jpg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="文件下载">文件下载</span></h2>
<ol>
<li>客户端直接访问要下载的文件的url（文件位于web应用程序目录下）</li>
<li>在servlet中将文件放进response中响应到客户端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//若设置file-type为octet-stream，则浏览器会提示用户进行下载；若设置file-type为pdf或者图片之类的，则浏览器会直接解析显示出来</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;application/pdf&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Temp\\1.pdf&quot;</span>);</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line">    <span class="comment">//将文件通过输入流读取成二进制放进byte数组中</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferedInputStream.available()];</span><br><span class="line">    bufferedInputStream.read(bytes);</span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">    <span class="comment">//将byte数组中的内容通过输出流写进response中</span></span><br><span class="line">    outputStream.write(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Spring学习</title>
    <url>/post/spring%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2><span id="spring能做什么">Spring能做什么</span></h2>
<ul>
<li>IOC【依赖反转/控制反转】【Inversion of Control】
<ul>
<li>类产生对象的过程交给Spring去管理，不用程序员创建类的对象</li>
<li>把类交给Spring容器</li>
<li>把对象从Spring容器拿出来</li>
<li>依赖Spring容器里面的对象</li>
</ul>
</li>
<li>AOP</li>
</ul>
<h3><span id="传统mapper-service实现">传统Mapper、Service实现</span></h3>
<p>Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mapper实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperImplA</span> <span class="keyword">implements</span> <span class="title class_">StuMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAAAAAAAAAAAAStuMapperImplA is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">	<span class="type">Mapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mapper</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="依赖">依赖</span></h2>
<p><strong>主要依赖context</strong></p>
<ul>
<li>org.springframework:spring-aop:5.3.25</li>
<li>org.springframework:spring-beans:5.3.25</li>
<li>org.springframework:spring-core:5.3.25</li>
<li>org.springframework:spring-expression:5.3.25</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="实战">实战</span></h2>
<h3><span id="xml配置方式">xml配置方式</span></h3>
<p><strong>把类交给Spring容器</strong></p>
<ul>
<li>在resource文件夹下创建spring.xml配置文件</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/63f872e4f144a0100733bdb9.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63f872fff144a0100733e016.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63f8730af144a0100733f069.jpg" alt></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans 						  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--    使用bean标签把需要的类交给Spring--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperImplA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.mapper.MapperImplA&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperImplB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.mapper.MapperImplB&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceImplA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.service.ServiceImplA&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Mapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mapperImplA&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring采用注入手法，让业务的Mapper属性等于引用了Spring容器里面的对象--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--属性必须要求getting,setting--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImplB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.service.ServiceImplB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Mapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mapperImplB&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用bean标签把需要的类交给Spring</li>
<li>Spring采用注入手法，让业务的Mapper属性等于引用了Spring容器里面的对象</li>
<li>此时可以通过修改spring.xml文件来修改mapper注入的实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    Mapper mapper;	<span class="comment">//业务层的mapper不需创建对象，而是作为类的属性，在刚刚的spring.xml文件中注入了mapperImplA</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mapper <span class="title function_">getMapper</span><span class="params">()</span> &#123;	<span class="comment">//实现getting,setting方法</span></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapper</span><span class="params">(Mapper mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplB</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    Mapper mapper;	<span class="comment">//业务层的mapper不需创建对象，而是作为类的属性，在刚刚的spring.xml文件中注入了mapperImplB</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mapper <span class="title function_">getMapper</span><span class="params">()</span> &#123;	<span class="comment">//实现getting,setting方法</span></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapper</span><span class="params">(Mapper mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性必须要求实现getting,setting方法</li>
<li>此时的接口无需创建对象，根据刚刚的spring.xml文件自动指向对应的实现类</li>
</ul>
<p><img src="/post/spring%E5%AD%A6%E4%B9%A0/C:%5CUsers%5Cmomo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230224170715705.png" alt="image-20230224170715705"></p>
<p><strong>获取Spring容器里的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建ClassPathXmlApplicationContext对象，导入spring.xml配置文件</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">classPathXmlApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:spring.xml&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取外部配置文件，用于byName指定接口</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> MyApp.class.getResourceAsStream(<span class="string">&quot;/my.properties&quot;</span>);</span><br><span class="line">properties.load(resourceAsStream);</span><br><span class="line"><span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;dbc.Service&quot;</span>);</span><br><span class="line"><span class="comment">//3.通过getBean方法获取实现类</span></span><br><span class="line"><span class="comment">//Service service = classPathXmlApplicationContext.getBean(Service.class);</span></span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> classPathXmlApplicationContext.getBean(property, Service.class);</span><br><span class="line">service.doing();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>创建ClassPathXmlApplicationContext对象，导入spring.xml配置文件</p>
</li>
<li>
<p>通过getBean方法获取实现类</p>
<blockquote>
<p>getBean方法有两种传参方式：getBean(class&lt;T&gt;)、getBean(String name,class&lt;T&gt;)</p>
<p>对应两种取出对象方式：byType、byName</p>
<p>byType：根据类类型找到实现类，当Service接口有多个实现类，必然报错，只能用于Service接口唯一实现类的情况</p>
<p>byName：根据类类型以及类名查找实现类，适用Service接口有多个实现类，从而达到开闭原则【对修改关闭，对扩展开放】</p>
</blockquote>
</li>
<li>
<p>当Service接口有多个实现类时，可以从外部配置文件获取类名，用于byName指定接口</p>
</li>
<li>
<p>my.properties文件</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dbc.Service</span>=<span class="string">serviceImplA  #此时可以通过修改外部文件来改变Service实现类</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时可以通过修改外部文件来改变Service实现类</li>
</ul>
<h3><span id="注解配置方式">注解配置方式</span></h3>
<p>spring.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans 						  http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>把类交给Spring容器</strong></p>
<ul>
<li>@Component：所有mapper实现类、Service实现类</li>
<li>@Autowired：自动属性注入，即byType方式</li>
<li>@Qualifier：配合@Autowired实现byName</li>
</ul>
<p>注意：</p>
<ul>
<li>
<p>注解方式可以不实现属性的getting,setting方法</p>
</li>
<li>
<p>注解方式不适用HttpServlet的控制子类，因为tomcat会优先于Spring，因此需要整合tomcat</p>
<p><img src="https://pic.imgdb.cn/item/63f8894ef144a0100757b815.jpg" alt></p>
</li>
</ul>
<p>以ServiceImplA为例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;mapperImplA&quot;)</span></span><br><span class="line">    Mapper mapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63f8815bf144a010074ab58a.jpg" alt></p>
<p><strong>获取Spring容器里的对象</strong></p>
<p>与xml方式一致</p>
<table>
<thead>
<tr>
<th></th>
<th>xml配置</th>
<th>注解配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mapper有多个实现类</td>
<td>spring.xml中注入</td>
<td>@Autowired配合@Qualifier</td>
</tr>
<tr>
<td>Service有多个实现类</td>
<td>通过外部资源文件，getBean的ByName方式</td>
<td>与xml配置一致</td>
</tr>
</tbody>
</table>
<h3><span id="整合第三方依赖">整合第三方依赖</span></h3>
<p>通过&lt;bean&gt;方式把第三方类放入到|Spring进行管理，并把第三方类的对象取出使用</p>
<p><strong>导入第三方依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-context.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.xml配置文件（原spring.xml）</strong></p>
<p>原mybatis.xml文件会有删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载外部文件jdbc.properties    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> <span class="attr">ignore-resource-not-found</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--JDBC和连接池的管理 数据库连接池配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis的配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--dao接口在哪【接口本身】？数据层的dao接口在哪个包    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--basePackage属性值必须是你的mapper接口目录        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis的SqlSessionFactoryBean类交给Spring管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载mybatis mapper接口实现类文件的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载原mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63f88856f144a010075686f7.jpg" alt></p>
<h3><span id="spring环境下的单元测试">Spring环境下的单元测试</span></h3>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-test --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-context.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter-engine --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter-params --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-params<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-vintage-engine --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-platform-launcher --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-launcher<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建单元测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:application.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StuServices stuServices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>    <span class="comment">//必须是org.junit.jupiter.api.Test类，绝对不能是org.junit.Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Stu&gt; all = stuServices.getAll();</span><br><span class="line">        <span class="keyword">for</span> (Stu stu : all) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ClassroomMapper classroomMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Classroom&gt; all = classroomMapper.getAll();</span><br><span class="line">        <span class="keyword">for</span> (Classroom classroom : all) &#123;</span><br><span class="line">            System.out.println(classroom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="springmvc整合tomcat">SpringMVC整合tomcat</span></h3>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-context.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-mvc.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描控制器包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打开springMVC注解    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图解析器ViewResolver【目前解析JSP视图】 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  prefix【前缀】指的是视图放在哪个目录     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--WEB-INF为安全目录只有通过控制器的跳转才能访问【req.getRequestDispatcher】        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  suffix【后缀】指的是视图文件的扩展名     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>扫描控制器包</li>
<li>—打开springMVC注解</li>
<li>视图解析器ViewResolver【目前解析JSP视图】</li>
<li>WEB-INF为安全目录只有通过控制器的跳转才能访问【req.getRequestDispatcher】</li>
<li>prefix【前缀】指的是视图放在哪个目录</li>
<li>suffix【后缀】指的是视图文件的扩展名</li>
</ul>
<p><strong>web.xml配置文件</strong></p>
<ul>
<li>tomcat通过tomcat服务启动监听器，来启动Spring</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1——利用tomcat启动监听器，并启动Spring    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局变量设置Spring的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:application.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启Spring【监听器】--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tomcat通过注册Servlet来注册SpringMVC中的DispatcherServlet</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2——springMVC本身是一个Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化springMVC，主要目的是为了加载SpringMVC的配置文件        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务器启动时创建核心处理器实例--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet本身是在第一次请求的时候才会实例化，且只有一个对象【懒汉式（懒加载）（节约内存，但效率低）】--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在tomcat启动的时候直接Servlet实例化对象【饿汉式（耗费内存，但效率高）】--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Spring代劳做了一个字符集过滤器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--3——SpringMVC编写的过滤器，主要过滤编码--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--乱码处理--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC自带的CharacterEncodingFilter过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>控制器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/stu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StuServices stuServices;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;view.action&quot;)</span></span><br><span class="line">    <span class="comment">//使用org.springframework.ui.Model传递参数</span></span><br><span class="line">    <span class="keyword">public</span> String  <span class="title function_">getAll</span><span class="params">(Model model)</span>&#123;<span class="comment">//方法返回值String</span></span><br><span class="line">        ArrayList&lt;Stu&gt; all = stuServices.getAll();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;stus&quot;</span>,all);</span><br><span class="line">        <span class="comment">//1——代表跳转</span></span><br><span class="line">        <span class="comment">//2——return的字符串代表文件名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;stuView&quot;</span>;<span class="comment">//如果返回的字符串要代表重定向，可以使用redirect: return &quot;redirect:/index.html&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="controller注解">@Controller注解</span></h3>
<p>在一个类上添加@Controller注解，表明了这个类是一个控制器类。但想要让这个类成为一个处理请求的处理器光有@Controller注解是不够的，他还需要进一步修炼才能成为一个处理器。</p>
<p>1.在spring容器中创建该类的实例。创建实例的方式有两种：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;test.controller.MyController&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述这种方式是在spring容器中注入单个bean，当项目比较大，控制器类比较多时，用这种方式向Spring容器中注入bean非常的让人苦恼，索性有第二种方式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-scan</span>=<span class="string">&quot;test.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式会扫描指定包中的所有类，并生成相应的bean注入到spring容器中。使用这种方式当然能够极大提高我们的开发效率，但是有时候我们不想某一类型的类注入到spring容器中。这个时候第二种方式也可以解决。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;test&quot;</span>&gt;</span>　　</span><br><span class="line">	<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码表示扫描test包中除有@Service注解之外的类。</p>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>vue</title>
    <url>/post/vue/</url>
    <content><![CDATA[<h2><span id="vue安装">vue安装</span></h2>
<h3><span id="cdn引入">CDN引入</span></h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="下载引入">下载引入</span></h3>
<table>
<thead>
<tr>
<th>环境</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发环境</td>
<td><a href="https://cn.vuejs.org/js/vue.js">https://cn.vuejs.org/js/vue.js</a></td>
</tr>
<tr>
<td>生产环境</td>
<td><a href="https://cn.vuejs.org/js/vue.min.js">https://cn.vuejs.org/js/vue.min.js</a></td>
</tr>
</tbody>
</table>
<h3><span id="npm安装">NPM安装</span></h3>
<p>通过webpack和CLI的使用</p>
<h1><span id="基础语法">基础语法</span></h1>
<h2><span id="插值操作">插值操作</span></h2>
<h3><span id="mustache胡须">Mustache（胡须）</span></h3>
<p>即双大括号，插（取）值表达式，且数据是响应式更新的（双向绑定）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1. 引入vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2. 准备页面的容器，加载vue的页面内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--双大括号，是Vue提供的一种模板语法、插值表达式，将vue对象中的data数据集加载到页面中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3. 创建vue对象，关联页面中的容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建vue全局对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 加载页面容器</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// data数据集封装页面展示数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">msg</span>: <span class="string">&quot;Vue&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击“+”或“-”按钮更新页面内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1. 引入vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2. 创建vue容器，展示页面内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    计数器：&#123;&#123;count&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3. 创建vue对象，关联页面容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">count</span>++;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">count</span>--;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="v-once"><code>v-once</code></span></h3>
<p>该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)</p>
<p>该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--v-once代表被当前属性渲染的内容只加载一次--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-once</span>&gt;</span>v-once : Hello &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--v-model代表双向绑定，将当前输入框的内容绑定为data对象中的msg属性当页面发生变化时，通过v-model双向绑定，可以将数据更新到msg属性中，从而也会影响页面中的内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&quot;Vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="v-html"><code>v-html</code></span></h3>
<p>若从服务器请求到的数据为HTML代码，使用v-html进行输出，会对HTML代码进行解析渲染并且展示对应的内容</p>
<p>指令后通常跟data数据集中定义的HTML代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&quot;&lt;a href=&#x27;http://www.bjpowernode.com&#x27;&gt;跳转到动力节点&lt;/a&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="v-text"><code>v-text</code></span></h3>
<p>作用和Mustache一致，但不能拼接标签中的内容</p>
<p>指令后通常跟data数据集中定义的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以文本的形式将data中的属性加载到标签体中，类似插值表达式的作用是一样的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&quot;Vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="v-pre"><code>v-pre</code></span></h3>
<p>用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法</p>
<p>以下第一个h1元素中的内容会直接显示，第二个h1元素中会被编译解析出来对应的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将未编译的内容输出到页面中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载编译后的内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&quot;Vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="v-cloak斗篷"><code>v-cloak（斗篷）</code></span></h3>
<p>在使用Mustache展示页面数据且网速较慢时，用户会先看到未编译的插值表达式，再看到data中对应的值（闪烁）</p>
<p>此时通过使用v-cloak指令并设置css样式可以解决</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    ... </span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*!important将其优先级设置为最高，防止display属性被优先级别高的样式覆盖*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: none <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>Hello &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&quot;Vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="绑定属性">绑定属性</span></h2>
<h3><span id="v-bind">v-bind</span></h3>
<p>属性的动态绑定，可简写为 ：</p>
<p>用于绑定一个或多个属性值，或者向另一个组件传递props值（如图片的链接src、网站的链接href、动态绑定一些类、样式等）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.basic</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.happy</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.644</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">30deg</span>, yellow, pink, orange, yellow);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.sad</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">4px</span> dashed <span class="built_in">rgb</span>(<span class="number">2</span>, <span class="number">197</span>, <span class="number">2</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.normal</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.bjpowernode1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.bjpowernode2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">10px</span> red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.bjpowernode3</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--样式效果--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span>&gt;</span>basic样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;happy&quot;</span>&gt;</span>happy样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sad&quot;</span>&gt;</span>sad样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;normal&quot;</span>&gt;</span>normal样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bjpowernode1&quot;</span>&gt;</span>bjpowernode1样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bjpowernode2&quot;</span>&gt;</span>bjpowernode2样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bjpowernode3&quot;</span>&gt;</span>bjpowernode3样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--绑定样式：单向绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;mod&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;changeMod&quot;</span>&gt;</span>v-bind动态绑定class<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;node&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;changeNode&quot;</span>&gt;</span>v-bind简写方式动态绑定class<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;blackStyle&quot;</span>&gt;</span>v-bind方式动态绑定style<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;blackStyleArr&quot;</span>&gt;</span>v-bind方式集合动态绑定style<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//创建Vue对象，全局对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//加载页面的容器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//data数据集，封装页面展示的数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">mod</span>: <span class="string">&quot;normal&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">node</span>: <span class="string">&quot;bjpowernode1&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">arrMod</span>: [<span class="string">&quot;happy&quot;</span>, <span class="string">&quot;sad&quot;</span>, <span class="string">&quot;normal&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">nodeMod</span>: [<span class="string">&quot;bjpowernode1&quot;</span>, <span class="string">&quot;bjpowernode2&quot;</span>, <span class="string">&quot;bjpowernode3&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">blackStyle</span>: <span class="string">&quot;color: #FF0000&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">blackStyleArr</span>: [</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">fontSize</span>: <span class="string">&#x27;40px&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;gray&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">changeMod</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//获取一个0~2之间的随机数的索引值</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//改变mod的属性值</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">mod</span> = <span class="variable language_">this</span>.<span class="property">arrMod</span>[index];</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">changeNode</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">node</span> = <span class="variable language_">this</span>.<span class="property">nodeMod</span>[index];</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="绑定class">绑定class</span></h3>
<p>如动态切换字体颜色</p>
<p><strong>对象语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--直接通过&#123;&#125;绑定一个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过判断，传入多个值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--和普通的类同时存在，并不冲突--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注：如果isActive和isLine都为true，那么会有title/active/line三个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--如果过于复杂，可以放在一个methods或者computed中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注：classes是一个计算属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>数组语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用法一：直接通过&#123;&#125;绑定一个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;]&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--用法二：也可以传入多个值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">“[‘active’,</span> &#x27;<span class="attr">line</span>&#x27;]&quot;&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--用法三：和普通的类同时存在，并不冲突--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注：会有title/active/line三个类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">“[‘active’,</span> &#x27;<span class="attr">line</span>&#x27;]&quot;&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--用法四：如果过于复杂，可以放在一个methods或者computed中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注：classes是一个计算属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="绑定style">绑定style</span></h3>
<p>v-bind:style来绑定一些CSS内联样式</p>
<p>CSS属性名使用驼峰式 (camelCase) 或短横线分隔 (kebab-case) 且用单引号括起来</p>
<p><strong>对象语法</strong></p>
<p>style后面跟的是一个对象类型，对象的key是CSS属性名称，对象的value是具体赋的值，值可以来自于data中的属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:style=<span class="string">&quot;&#123;color: currentColor, fontSize: fontSize + &#x27;px&#x27;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>数组语法</strong></p>
<p>style后面跟的是一个数组类型多个值以，分割即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="计算属性">计算属性</span></h2>
<h3><span id="计算属性使用场景">计算属性使用场景</span></h3>
<p>假设有如下包含嵌套数组的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">author</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,</span><br><span class="line">            <span class="attr">books</span>: [</span><br><span class="line">                <span class="string">&#x27;Vue 2 - Advanced Guide&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;Vue 3 - Basic Guide&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;Vue 4 - The Mystery&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>当需要根据 <code>author</code> 是否已有一些书籍来展示不同的信息</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Has published books:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>无法从该模板中直接看出结果依赖于 <code>author.books</code></li>
<li>若该模板需要执行多次计算，代码重复，且耗费较大性能</li>
</ol>
<p>因此对于<strong>描述依赖响应式状态的复杂逻辑</strong>，可以定义一个计算属性（如下中的<code>publishedBooksMessage</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">publishedBooksMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// `this` 指向当前组件实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">author</span>.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;Yes&#x27;</span> : <span class="string">&#x27;No&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Has published books:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; publishedBooksMessage&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当计算属性所依赖的属性发生改变时，任何依赖于该计算属性的绑定将同时更新</li>
<li>反之，计算属性响应式依赖未发生改变时，计算属性都返回之前计算的结果（被缓存）</li>
</ol>
<h3><span id="计算属性的缓存">计算属性的缓存</span></h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;getDate()&quot;</span>&gt;</span>打印当前时间戳<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="title function_">msg</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">getDate</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">msg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>无论重复点击多少次“打印当前时间戳”按钮，控制台显示的时间戳不变</p>
<p><img src="https://pic.imgdb.cn/item/64b8d84c1ddac507cc2c3388.jpg" alt></p>
<p>这是由于<code>Date.now()</code> 不是响应依赖，它跟 Vue 的数据观察系统无关。因此在访问<code>msg</code>时将发现时间戳不变</p>
<p>若需要每次访问 <code>msg</code> 时都调用 getter，可以为指定的计算属性关闭缓存：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="attr">msg</span>:&#123;</span><br><span class="line">        <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64b8d9fd1ddac507cc333aee.jpg" alt></p>
<ol>
<li>现在每次访问 <code>msg</code> 时，时间戳都是新的（ JavaScript 中访问）</li>
<li>**但是数据绑定仍是依赖驱动的。**若在模块中通过Mustache语法绑定计算属性 <code>&#123;&#123;example&#125;&#125;</code>，仍仅响应依赖发生变化时才更新 DOM‘</li>
</ol>
<h3><span id="计算属性setter">计算属性setter</span></h3>
<p>计算属性默认是 getter，不过在需要时也提供一个 setter</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;fullname = &#x27;李 四&#x27;&quot;</span>&gt;</span>更新fullname<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;fullname&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">        <span class="attr">lastName</span>: <span class="string">&quot;三&quot;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">fullName</span>: &#123;</span><br><span class="line">        <span class="comment">// getter</span></span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// setter</span></span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> names = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>]</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lastName</span> = names[names.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>现在在调用 <code>fullname = '李 四'</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会有相应更新</p>
<h2><span id="事件监听">事件监听</span></h2>
<h3><span id="事件监听使用场景">事件监听使用场景</span></h3>
<p>当需要监听用户的某个操作（点击、拖拽、键盘事件等）并触发相应的程序时，需要使用事件监听</p>
<h3><span id="v-on"><code>v-on</code></span></h3>
<p>可使用 <code>v-on</code> 指令来监听 DOM 事件，并在事件触发时执行对应的 JavaScript</p>
<p>用法：<code>v-on:click=&quot;handler&quot;</code> 或 <code>@click=&quot;handler&quot;</code>（语法糖）</p>
<p>事件处理器 (handler) 的值可以是：</p>
<p>模板编译器会通过检查 <code>v-on</code> 的值是否是合法的 <strong>JavaScript 标识符</strong>或<strong>属性访问路径</strong>来断定是何种形式的事件处理器</p>
<ol>
<li><strong>内联事件处理器</strong>：事件被触发时执行的内联 JavaScript 语句 (与 <code>onclick</code> 类似)（如 <code>foo()</code> 和 <code>count++</code>）</li>
<li><strong>方法事件处理器</strong>：一个指向组件上定义的方法的属性名或是路径（如<code>foo</code>、<code>foo.bar</code> 和 <code>foo['bar']</code>）</li>
</ol>
<h3><span id="内联事件处理器">内联事件处理器</span></h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以调用方法，且可传入自定义参数或原生DOM时间（<code>$event</code> 变量或内联箭头函数）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;say(&#x27;hello&#x27;)&quot;</span>&gt;</span>Say hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;say(&#x27;bye&#x27;,$event)&quot;</span>&gt;</span>Say bye<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用内联箭头函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;(event) =&gt; say(&#x27;yes&#x27;, event)&quot;</span>&gt;</span>Say yes<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="params">message, event</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里可以访问 DOM 原生事件</span></span><br><span class="line">        <span class="keyword">if</span> (event) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">tagName</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">alert</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="方法事件处理器">方法事件处理器</span></h3>
<p>随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 <code>v-on</code> 也可以接受一个方法名或对某个方法的调用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `greet` 是下面定义过的方法名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 方法中的 `this` 指向当前活跃的组件实例</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Hello <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>)</span><br><span class="line">    <span class="comment">// `event` 是 DOM 原生事件</span></span><br><span class="line">    <span class="keyword">if</span> (event) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">tagName</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="事件修饰符">事件修饰符</span></h3>
<p>在处理事件时调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。</p>
<p>为解决这一问题，Vue 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。修饰符是用 <code>.</code> 表示的指令后缀，包含以下这些：</p>
<table>
<thead>
<tr>
<th>事件修饰符</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.stop</code></td>
<td><code>&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</code></td>
<td>单击事件将停止传递</td>
</tr>
<tr>
<td><code>.prevent</code></td>
<td><code>&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></td>
<td>提交事件将不再重新加载页面</td>
</tr>
<tr>
<td><code>.self</code></td>
<td><code>&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</code></td>
<td>仅当 event.target 是元素本身时才会触发事件处理器（子元素不处理）</td>
</tr>
<tr>
<td><code>.capture</code></td>
<td><code>&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</code></td>
<td>添加事件监听器时，使用 <code>capture</code> 捕获模式，指向内部元素的事件，在被内部元素处理前，先被外部处理</td>
</tr>
<tr>
<td><code>.once</code></td>
<td><code>&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</code></td>
<td>点击事件最多被触发一次</td>
</tr>
<tr>
<td><code>.passive</code></td>
<td><code>&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</code></td>
<td>滚动事件的默认行为 (scrolling) 将立即发生而非等待 <code>onScroll</code> 完成，一般用于触摸事件的监听器，可以用来[改善移动端设备的滚屏性能]</td>
</tr>
</tbody>
</table>
<ol>
<li>修饰语可以使用链式书写,<code>&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</code></li>
<li>也可以只有修饰符，<code>&lt;form @submit.prevent&gt;&lt;/form&gt;</code></li>
<li>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。<code>@click.prevent.self</code> 会阻止元素及其子元素的所有点击事件的默认行为，而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为。</li>
</ol>
<p>请勿同时使用 <code>.passive</code> 和 <code>.prevent</code>，因为 <code>.passive</code> 已经向浏览器表明了你<em>不想</em>阻止事件的默认行为。如果你这么做了，则 <code>.prevent</code> 会被忽略，并且浏览器会抛出警告</p>
<h3><span id="按键修饰符">按键修饰符</span></h3>
<p>监听指定的键盘按键</p>
<table>
<thead>
<tr>
<th>按键修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.enter</code></td>
</tr>
<tr>
<td><code>.tab</code></td>
</tr>
<tr>
<td><code>.delete</code> (捕获“Delete”和“Backspace”两个按键)</td>
</tr>
<tr>
<td><code>.esc</code></td>
</tr>
<tr>
<td><code>.space</code></td>
</tr>
<tr>
<td><code>.up</code></td>
</tr>
<tr>
<td><code>.down</code></td>
</tr>
<tr>
<td><code>.left</code></td>
</tr>
<tr>
<td><code>.right</code></td>
</tr>
</tbody>
</table>
<p>你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。</p>
<table>
<thead>
<tr>
<th>系统按键修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.ctrl</code></td>
</tr>
<tr>
<td><code>.alt</code></td>
</tr>
<tr>
<td><code>.shift</code></td>
</tr>
<tr>
<td><code>.alt</code></td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + Enter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.enter</span>=<span class="string">&quot;clear&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + 点击 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>系统按键修饰符和常规按键不同</p>
<p>与 <code>keyup</code> 事件一起使用时，该按键必须在事件发出时处于按下状态</p>
<p>换句话说，<code>keyup.ctrl</code> 只会在你仍然按住 <code>ctrl</code> 但松开了另一个键时被触发。若你单独松开 <code>ctrl</code> 键将不会触发。</p>
<h3><span id="exact修饰符">exact修饰符</span></h3>
<p><code>.exact</code> 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="鼠标按键修饰符">鼠标按键修饰符</span></h3>
<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<h2><span id="条件判断">条件判断</span></h2>
<h3><span id="v-if"><code>v-if</code></span></h3>
<p>用于条件性地渲染一块内容。这块内容只会在<code>v-if</code>后的表达式为真值时才被渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="v-else"><code>v-else</code></span></h3>
<p>为 <code>v-if</code> 添加一个“else 区块”</p>
<p>一个 <code>v-else</code> 元素必须跟在一个 <code>v-if</code> 或者 <code>v-else-if</code> 元素后面，否则它将不会被识别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;awesome = !awesome&quot;</span>&gt;</span>Toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>Oh no 😢<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="v-else-if"><code>v-else-if</code></span></h3>
<p>提供的是相应于 <code>v-if</code> 的“else if 区块”。它可以连续多次重复使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;score &gt;= 90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt;= 80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt;= 70&quot;</span>&gt;</span>中等<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt;= 60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和 <code>v-else</code> 类似，一个使用 <code>v-else-if</code> 的元素必须紧跟在一个 <code>v-if</code> 或一个 <code>v-else-if</code> 元素后面。</p>
<h3><span id="v-show"><code>v-show</code></span></h3>
<p>与<code>v-if</code>基本一致</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不同之处：</p>
<ol>
<li>在 DOM 渲染中保留该元素，<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性（<code>style=&quot;display: none;&quot;</code>）</li>
<li><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用</li>
</ol>
<h3><span id="v-if-vsv-show"><code>v-if</code> vs<code>v-show</code></span></h3>
<table>
<thead>
<tr>
<th></th>
<th><code>v-if</code></th>
<th><code>v-show</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>渲染</td>
<td>仅条件首次为“true”时才被渲染，否则不做任何操作（惰性）</td>
<td>无论初始条件如何始终会被渲染</td>
</tr>
<tr>
<td>切换</td>
<td>条件区块内的事件监听器和子组件都会被销毁与重建</td>
<td>只有 CSS <code>display</code> 属性会被切换</td>
</tr>
<tr>
<td>开销</td>
<td>更高的切换开销</td>
<td>更高的初始渲染开销</td>
</tr>
<tr>
<td>应用</td>
<td>运行时绑定条件很少改变</td>
<td>频繁切换</td>
</tr>
</tbody>
</table>
<h3><span id="v-if-和-v-for"><code>v-if</code> 和 <code>v-for</code></span></h3>
<p>不推荐的同时使用 <code>v-if</code> 和 <code>v-for</code></p>
<p>因为<code>v-if</code> 和 <code>v-for</code> 同时存在于一个元素上时，<code>v-if</code> 会首先被执行</p>
<p><img src="https://pic.imgdb.cn/item/64b901271ddac507ccc50eae.jpg" alt></p>
<h2><span id="循环遍历">循环遍历</span></h2>
<h3><span id="v-for"><code>v-for</code></span></h3>
<p>基于一个数组来渲染一个列表</p>
<p><code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据的数组，而 <code>item</code> 是迭代项的别名（也可以<code>item of items</code> ）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    items: [&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以完整地访问父作用域内的属性和变量。也支持使用可选的第二个参数表示当前项的位置索引</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">parentMessage</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">    <span class="attr">items</span>: [&#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="多层嵌套">多层嵌套</span></h3>
<p>作用域和函数的作用域很类似,每个 <code>v-for</code> 作用域都可以访问到父级作用域</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;childItem in item.children&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.message &#125;&#125; &#123;&#123; childItem &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="遍历对象">遍历对象</span></h3>
<p>遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 <code>Object.keys()</code> 的返回值来决定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in myObject&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; value &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">myObject</span>: &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">            <span class="attr">author</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">            <span class="attr">publishedAt</span>: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供第二个参数表示属性名 (例如 key)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in myObject&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第三个参数表示位置索引</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in myObject&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="遍历整数值">遍历整数值</span></h3>
<p>基于 <code>1...n</code> 的取值范围重复多次</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此处 <code>n</code> 的初值是从 <code>1</code> 开始而非 <code>0</code></p>
<h3><span id="lttemplategt-上的-v-for"><code>&lt;template&gt;</code> 上的 <code>v-for</code></span></h3>
<p>可以在 <code>&lt;template&gt;</code> 标签上使用 <code>v-for</code> 来渲染一个包含多个元素的块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="通过-key-管理状态">通过 key 管理状态</span></h3>
<p>将key值相同的虚拟dom进行对比</p>
<p>若新生成的虚拟dom与旧的虚拟dom一致，则直接沿用之前生成的真实dom</p>
<p>若不一致，则生成新的虚拟dom</p>
<p><img src="https://pic.imgdb.cn/item/64b935bb1ddac507cc7c6aaf.jpg" alt></p>
<p>Vue 默认按照“就地更新”的策略来更新通过 <code>v-for</code> 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染</p>
<p>默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p>
<p>为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 <code>key</code> attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>当你使用 <code>&lt;template v-for&gt;</code> 时，<code>key</code> 应该被放置在这个 <code>&lt;template&gt;</code> 容器上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt;</span><br><span class="line">  &lt;li&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<p><code>key</code> 在这里是一个通过 <code>v-bind</code> 绑定的特殊 attribute。请不要和<a href="https://cn.vuejs.org/guide/essentials/list.html#v-for-with-an-object">在 <code>v-for</code> 中使用对象</a>里所提到的对象属性名相混淆。</p>
<p><a href="https://cn.vuejs.org/style-guide/rules-essential.html#use-keyed-v-for">推荐</a>在任何可行的时候为 <code>v-for</code> 提供一个 <code>key</code> attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。</p>
<p><code>key</code> 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 <code>v-for</code> 的 key。关于 <code>key</code> attribute 的更多用途细节，请参阅 <a href="https://cn.vuejs.org/api/built-in-special-attributes.html#key"><code>key</code> API 文档</a>。</p>
<h3><span id="组件上使用-v-for">组件上使用 <code>v-for</code></span></h3>
<p>组件上使用 <code>v-for</code>和在一般的元素上使用没有区别 (别忘记提供一个 <code>key</code>)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:index</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>不自动将 <code>item</code> 注入组件的原因是，这会使组件与 <code>v-for</code> 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。</p>
<h3><span id="数组变化侦测">数组变化侦测</span></h3>
<h4><span id="变更方法">变更方法</span></h4>
<p>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h4><span id="替换一个数组">替换一个数组</span></h4>
<p>变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 <code>filter()</code>，<code>concat()</code> 和 <code>slice()</code>，这些都不会更改原数组，而总是<strong>返回一个新数组</strong>。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.items = this.items.filter((item) =&gt; item.message.match(/Foo/))</span><br></pre></td></tr></table></figure>
<p>你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作</p>
<h3><span id="展示过滤或排序后的结果">展示过滤或排序后的结果</span></h3>
<p>有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">numbers</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">evenNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">numbers</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in evenNumbers&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在计算属性不可行的情况下 (例如在多层嵌套的 <code>v-for</code> 循环中)，你可以使用以下方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">sets</span>: [[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">even</span>(<span class="params">numbers</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;numbers in sets&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in even(numbers)&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在计算属性中使用 <code>reverse()</code> 和 <code>sort()</code> 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p>
<p>diff</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- return numbers.reverse()</span><br><span class="line">+ return [...numbers].reverse()</span><br></pre></td></tr></table></figure>
<h2><span id="阶段案例">阶段案例</span></h2>
<h2><span id="v-model">v-model</span></h2>
<h2><span id="vue生命周期">Vue生命周期</span></h2>
<p><img src="https://pic.imgdb.cn/item/64b790b91ddac507cc4d7756.jpg" alt></p>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>动力商城</title>
    <url>/post/%E5%8A%A8%E5%8A%9B%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[<h1><span id="商品管理">商品管理</span></h1>
<h2><span id="文件上传">文件上传</span></h2>
<p>使用七牛云的对象存储，<code>pom.xml</code>文件中导入七牛云的maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖的七牛云--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qiniu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>qiniu-java-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--依赖的第三方库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用字节数组方式上传文件，将内存中的字节数组上传到空间中</p>
<p>将上传文件的方法封装到工具类<code>UploadUtils</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> QiniuProperties qiniuProperties;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.uploadFile(bytes, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 七牛云官方JavaSDK的字节数组上传方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="type">byte</span>[] bytes, String fileName)</span> &#123;</span><br><span class="line">        <span class="comment">//构造一个带指定 Region 对象的配置类，此处为华南</span></span><br><span class="line">        com.qiniu.storage.<span class="type">Configuration</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.qiniu.storage.Configuration(Region.huanan());</span><br><span class="line">        <span class="comment">// 指定分片上传版本</span></span><br><span class="line">        cfg.resumableUploadAPIVersion = com.qiniu.storage.Configuration.ResumableUploadAPIVersion.V2;</span><br><span class="line">        <span class="comment">//...其他参数参考类注释</span></span><br><span class="line">        <span class="type">UploadManager</span> <span class="variable">uploadManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadManager</span>(cfg);</span><br><span class="line">        <span class="comment">//...生成上传凭证，然后准备上传</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">accessKey</span> <span class="operator">=</span> qiniuProperties.getAccessKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">secretKey</span> <span class="operator">=</span> qiniuProperties.getSecretKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> qiniuProperties.getBucketName();</span><br><span class="line">        <span class="comment">//默认不指定key的情况下，以文件内容的hash值作为文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> fileName;</span><br><span class="line">        <span class="type">Auth</span> <span class="variable">auth</span> <span class="operator">=</span> Auth.create(accessKey, secretKey);</span><br><span class="line">        <span class="type">String</span> <span class="variable">upToken</span> <span class="operator">=</span> auth.uploadToken(bucket);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> uploadManager.put(bytes, key, upToken);</span><br><span class="line">            <span class="comment">//解析上传成功的结果</span></span><br><span class="line">            <span class="type">DefaultPutRet</span> <span class="variable">putRet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">            System.out.println(putRet.key);</span><br><span class="line">            System.out.println(putRet.hash);</span><br><span class="line">            <span class="keyword">return</span> qiniuProperties.getHostName() + putRet.key;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (QiniuException ex) &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">r</span> <span class="operator">=</span> ex.response;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.err.println(r.toString());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.println(r.bodyString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (QiniuException ex2) &#123;</span><br><span class="line">                <span class="comment">//ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个带指定 Region 对象的配置类</span></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(Region.region0());</span><br><span class="line">cfg.resumableUploadAPIVersion = Configuration.ResumableUploadAPIVersion.V2;<span class="comment">// 指定分片上传版本</span></span><br><span class="line"><span class="comment">//...其他参数参考类注释</span></span><br><span class="line"></span><br><span class="line"><span class="type">UploadManager</span> <span class="variable">uploadManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadManager</span>(cfg);</span><br><span class="line"><span class="comment">//...生成上传凭证，然后准备上传</span></span><br><span class="line"><span class="type">String</span> <span class="variable">accessKey</span> <span class="operator">=</span> <span class="string">&quot;your access key&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="string">&quot;your secret key&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> <span class="string">&quot;your bucket name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认不指定key的情况下，以文件内容的hash值作为文件名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] uploadBytes = <span class="string">&quot;hello qiniu cloud&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">Auth</span> <span class="variable">auth</span> <span class="operator">=</span> Auth.create(accessKey, secretKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">upToken</span> <span class="operator">=</span> auth.uploadToken(bucket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> uploadManager.put(uploadBytes, key, upToken);</span><br><span class="line">        <span class="comment">//解析上传成功的结果</span></span><br><span class="line">        <span class="type">DefaultPutRet</span> <span class="variable">putRet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">        System.out.println(putRet.key);</span><br><span class="line">        System.out.println(putRet.hash);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (QiniuException ex) &#123;</span><br><span class="line">        <span class="type">Response</span> <span class="variable">r</span> <span class="operator">=</span> ex.response;</span><br><span class="line">        System.err.println(r.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.err.println(r.bodyString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (QiniuException ex2) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException ex) &#123;</span><br><span class="line">    <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="批量导入">批量导入</span></h2>
<table>
<thead>
<tr>
<th>导入方式</th>
<th>业务场景</th>
<th>代码实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>全量导入</td>
<td>项目初步启动则要导入大量数据</td>
<td>分页  自定义导入批量大小  300-500条</td>
</tr>
<tr>
<td>增量导入</td>
<td>启动后更新数据</td>
<td>每隔30分钟（时间窗口）进行一次数据更新</td>
</tr>
<tr>
<td>快速导入</td>
<td>下达订单后削减库存需要立刻修改es的数据</td>
<td>（MQ）</td>
</tr>
</tbody>
</table>
<p>定义接口<code>ImportService </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportService</span> &#123;     </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 全量导入    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">importAll</span><span class="params">()</span>;     </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 增量导入    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateImport</span><span class="params">()</span>;     </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 快速导入    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickImport</span><span class="params">()</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/64d499f41ddac507cc864142.jpg" style="zoom: 67%;">
<h1><span id="消息管理">消息管理</span></h1>
<p>异步发送短信、消息</p>
<h2><span id="阿里短信发送">阿里短信发送</span></h2>
<p>发送短信验证码绑定手机号</p>
<img src="https://pic.imgdb.cn/item/64d9e1651ddac507cc8b2ea0.jpg">
<h2><span id="微信公众号推送">微信公众号推送</span></h2>
<h1><span id="订单管理">订单管理</span></h1>
<h2><span id="遇到的问题">遇到的问题</span></h2>
]]></content>
      <categories>
        <category>第五阶段</category>
      </categories>
  </entry>
  <entry>
    <title>基础</title>
    <url>/post/%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1><span id="java语言概述">Java语言概述</span></h1>
<h2><span id="一个java源文件中是否可以包含多个类不是内部类有什么限制">一个“.java”源文件中是否可以包含多个类（不是内部类）有什么限制?</span></h2>
<p>一个&quot;.java&quot;源文件中可以包含多个类</p>
<p>但是最多只能有一个类使用public声明，并且要求声明public类的类名与源文件名相同</p>
<hr>
<h2><span id="java语言的优势">Java语言的优势</span></h2>
<ul>
<li>跨平台性</li>
<li>安全性高</li>
<li>高性能</li>
<li>面向对象</li>
<li>健壮性</li>
<li>社区繁荣（开源框架多）</li>
</ul>
<hr>
<h2><span id="java中是否存在内存溢出-内存泄露如何解决举例说明">Java中是否存在内存溢出、内存泄露，如何解决？举例说明</span></h2>
<p><strong>内存溢出（Memory Overflow）</strong></p>
<p>当Java应用程序请求更多内存资源时，如果没有足够的可用内存，就会发生内存溢出。这通常是由于创建过多的对象或者持有大对象而耗尽了可用内存</p>
<p>解决方法：</p>
<p>检查代码中是否存在对象创建过多的问题，可以通过使用对象池或者缓存来重用对象，避免不必要的对象创建。<br>
避免在循环中频繁创建大对象，可以将其移到循环外部，或者使用更低内存占用的数据结构。<br>
优化算法或数据结构，减少内存消耗。<br>
增加JVM堆内存大小，通过调整-Xmx和-Xms参数来增加可用内存空间</p>
<p><strong>内存泄漏（Memory Leak）</strong></p>
<p>内存泄漏指的是对象在不再需要时无法被垃圾回收器释放，导致内存占用不断增加。常见的内存泄漏情况包括未正确关闭I/O资源、静态集合类持有对象导致无法被回收等。</p>
<p>解决方法：</p>
<p>确保及时关闭文件、数据库连接、网络连接等资源，在不再使用时及时释放。可以使用try-with-resources语句或者在适当的地方显式关闭资源。<br>
避免静态集合类持有对象，并定期检查并清理这些集合，确保不再需要的对象能够被及时释放。<br>
使用合适的数据结构来存储数据，避免造成过多的对象引用和占用过多的内存空间。<br>
使用内存分析工具（如VisualVM、MAT等）来检测和分析内存泄漏问题。<br>
举例说明： 一个常见的内存泄漏案例是未正确关闭文件流，导致资源无法释放。例如下面的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123;</span><br><span class="line">                reader.close(); <span class="comment">// 关闭文件流</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果在读取文件时发生异常，reader对象可能无法正常关闭，导致资源泄漏。为了解决这个问题，可以使用try-with-resources语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath))) &#123;</span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>try-with-resources</code>语句可以确保文件流会在代码块执行完毕后自动关闭，避免了手动关闭资源的繁琐，同时也避免了资源泄漏的问题</p>
<hr>
<h2><span id="一个java源文件可以有名称相同大小写不同的两个类吗">一个java源文件可以有名称相同，大小写不同的两个类吗?</span></h2>
<p>Java源文件可以有名称相同，大小写不同的两个类；</p>
<p>因为Java标识符严格区分大小写</p>
<p>不过在编译过程中，由于window系统不区分大小写，windows将前后编译生成的字节码文件视为同一个（即使这两个文件的命名一个是大写，一个是小写），后编译的类产生的字节码文件将替换掉先编译的类产生的字节码文件</p>
<hr>
<h2><span id="java可不可以使用中文命名">java可不可以使用中文命名?</span></h2>
<p>可以 因为jdk使用的是unicode编码(全球统一编码),能够识别中文</p>
<hr>
<h2><span id="如何看待java是一门半编译半解释型语言">如何看待Java是一门半编译半解释型语言？</span></h2>
<p><img src="https://pic.imgdb.cn/item/66501f4fd9c307b7e92ca8ec.png" alt></p>
<hr>
<h1><span id="标识符">标识符</span></h1>
<h2><span id="java源文件可以不可以数字开头">java源文件可以不可以数字开头?</span></h2>
<p>可以 java源文件不用遵循命名规则（public的类不行）</p>
<h1><span id="基本数据类型">基本数据类型</span></h1>
<hr>
<h2><span id="byte的取值范围是多少怎么计算出来的">byte的取值范围是多少，怎么计算出来的？</span></h2>
<p>一个 byte 类型在计算机中占据一个字节，那么就是 8 bit，所以最大就是 2^7 = 1111 1111</p>
<p>Java 中用补码来表示二进制数，补码的最高位是符号位，最高位用 0 表示正数，最高位 1 表示负数</p>
<p>所以正数表示的就是 0111 1111 ，也就是 127。最大负数就是 1111 1111</p>
<p>其中会涉及到两个 0 ，一个 +0 ，一个 -0 ，+0 归为正数，也就是 0 ，-0 归为负数，也就是 -128</p>
<p>所以 byte 的范围就是 -128 – 127。一共是 256 位</p>
<hr>
<h2><span id="char-型变量中能不能存储一个中文汉字为什么">char 型变量中能不能存储一个中文汉字，为什么？</span></h2>
<p>char 类型可以存储一个中文汉字</p>
<p>Java中使用的编码是Unicode编码</p>
<p>一个char 类型占2个字节（16 比特），所以放一个中文是没问题的</p>
<p>补充：使用Unicode 意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是 Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务。</p>
<hr>
<h1><span id="运算符">运算符</span></h1>
<h2><span id="amp-和-ampamp-的区别">&amp; 和 &amp;&amp; 的区别？</span></h2>
<table>
<thead>
<tr>
<th>&amp;</th>
<th>&amp;&amp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑与</td>
<td>短路与</td>
</tr>
<tr>
<td>当运算符左侧是false,逻辑与右侧继续运算</td>
<td>当运算符左侧是false,逻辑与右侧<strong>不运算</strong>（短路现象）</td>
</tr>
<tr>
<td>可以作为位运算符，进行按位与操作</td>
<td>一定条件下运行性能好</td>
</tr>
</tbody>
</table>
<h2><span id="用最有效率的方法计算2乘以8">用最有效率的方法计算2乘以8？</span></h2>
<p>2 &lt;&lt; 3，将2左移3位</p>
<h2><span id="java移位运算符">Java移位运算符？</span></h2>
<ol>
<li>&lt;&lt; ：左移运算符，x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0</li>
<li>&gt;&gt; ：带符号右移，x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1</li>
<li>&gt;&gt;&gt; ：无符号右移，忽略符号位，空位都以0补齐</li>
</ol>
<h2><span id="301-03-将会返回什么-true-还是-false">3*0.1 == 0.3 将会返回什么? true 还是 false?</span></h2>
<p>false，因为二进制浮点运算无法精确表示3*0.1的结果（0.30000000000000004）</p>
<h2><span id="short-s1-1-s1-s1-1-有错吗short-s1-1-s1-1-有错吗">short s1 = 1; s1 = s1 + 1; 有错吗?short s1 = 1; s1 += 1 有错吗？</span></h2>
<p>前者不正确，后者正确</p>
<p>short s1 = 1; s1 = s1 + 1；由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型</p>
<p>short s1 = 1; s1 += 1；可以正确编译，因为 s1+= 1;相当于 s1 = (short)(s1 + 1)；其中有隐含的强制类型转换</p>
<h1><span id="流程控制">流程控制</span></h1>
<h2><span id="在-java-中如何跳出当前的多重嵌套循环">在 Java 中，如何跳出当前的多重嵌套循环？</span></h2>
<ol>
<li>
<p>标号方式：可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号break语句，即可跳出外层循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ok:<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">        System.out.println(“i=” + i + “,j=” + j);</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">5</span>) </span><br><span class="line">            <span class="keyword">break</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>break跳出当前循环，通过内部跳出条件控制跳出外部循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;; j=&quot;</span>+j);</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">3</span>) &#123;</span><br><span class="line">            i=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抛出异常也可以跳出多重循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;; j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length &amp;&amp; !found;i++)	&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">        System.out.println(“i=” + i + “,j=” + j);</span><br><span class="line">        <span class="keyword">if</span>(arr[i][j]  == <span class="number">5</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2><span id="switch-是否能作用在-byte-上能否作用在-long-上能否作用在-string-上">switch 是否能作用在 byte 上，能否作用在 long 上，能否作用在 String 上?</span></h2>
<table>
<thead>
<tr>
<th>JDK版本</th>
<th>switch（expr）expr允许的参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>早期的 JDK</td>
<td>byte、short、char、int</td>
</tr>
<tr>
<td>JDK1.5开始</td>
<td>byte、short、char、int、枚举类型（enum）</td>
</tr>
<tr>
<td>JDK1.7开始</td>
<td>byte、short、char、int、枚举类型（enum）、字符串（String）</td>
</tr>
</tbody>
</table>
<p>长整型（long）<strong>是不可以的</strong></p>
<hr>
<h2><span id="break-continue-return-的区别及作用">break ,continue ,return 的区别及作用</span></h2>
<table>
<thead>
<tr>
<th>break</th>
<th>continue</th>
<th>return</th>
</tr>
</thead>
<tbody>
<tr>
<td>结束当前的循环体</td>
<td>结束正在执行的循环 ，继续执行下次循环</td>
<td>程序返回，不再执行下面的代码</td>
</tr>
</tbody>
</table>
<p>在switch…case语句中，如果没有break,后面的一旦有case匹配成功，后面的case将无条件的向下执行其它的case</p>
<hr>
<h1><span id="math类">Math类</span></h1>
<h2><span id="mathround115等于多少mathround-115-又等于多少">Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?</span></h2>
<p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11</p>
<p>四舍五入的原理是在参数上加0.5然后进行取整</p>
<hr>
<h2><span id="如何取小数点前两位并四舍五入">如何取小数点前两位并四舍五入?</span></h2>
<p>可用该小数构造 java.math.BigDecimal对象，再利用其 round()方法进行四舍五入到保留小数点后两位，再将其转换为字符串截取最后两位</p>
<hr>
<h2><span id="如何在java中生成随机数">如何在Java中生成随机数？</span></h2>
<ul>
<li>Math.random()可以生成0.1到1.0范围内的随机数字</li>
<li>然后通过数学方法实现生成 符合要求的随机数</li>
</ul>
<hr>
<h1><span id="数组">数组</span></h1>
<h2><span id="数组有没有length方法string有没有length方法">数组有没有length()方法？String有没有length()方法？</span></h2>
<p>Java中的数组没有length()方法，但是有length属性</p>
<p>String有length()方法。</p>
<h1><span id="包装类">包装类</span></h1>
<h2><span id="下面-integer-类型的数值比较输出的结果为">下面 Integer 类型的数值比较输出的结果为？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>; </span><br><span class="line">System.out.println(f1 == f2);</span><br><span class="line">System.out.println(f3 == f4);</span><br></pre></td></tr></table></figure>
<p>f1==f2的结果是 true，而f3==f4 的结果是false</p>
<p>当给Integer 对象赋int 值的时候，会调用 Integer 类的静态方法 valueOf</p>
<p>如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的Integer对象</p>
<hr>
<h2><span id="int-和-integer-有什么区别">int 和 Integer 有什么区别?</span></h2>
<table>
<thead>
<tr>
<th>区别</th>
<th>int</th>
<th>Integer</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>基础数据类型</td>
<td>包装数据类型</td>
</tr>
<tr>
<td>默认值</td>
<td>0</td>
<td>null</td>
</tr>
<tr>
<td>内存中存储的方式</td>
<td>在内存中直接存储的是数据值</td>
<td>实际存储的是对象引用，（-128,127）之外</td>
</tr>
<tr>
<td>实例化方式</td>
<td>无需实例化即可使用</td>
<td>必须实例化才可以使用</td>
</tr>
<tr>
<td>变量的比较方式</td>
<td>可以使用 == 来对比两个变量是否相等</td>
<td>一定要使用 equals 来比较两个变量是否相等</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="什么是方法的返回值返回值的作用是什么">什么是方法的返回值？返回值的作用是什么？</span></h2>
<p>指某个方法体执行后产生的结果</p>
<hr>
<h2><span id="如何将数值型字符转换为数字">如何将数值型字符转换为数字？</span></h2>
<p>调用数值类型相应包装类中的方法 parse(String)或 valueOf(String) 即可返回相应基本类型或包装类型数值；</p>
<hr>
<h2><span id="如何将数字转换为字符">如何将数字转换为字符？</span></h2>
<p>将数字与空字符串相加即可获得其所对应的字符串</p>
<p>基本类型 数字还可调用 String 类中的 valueOf(…)方法返回相应字符串</p>
<p>包装类型数字则可调用其 toString()方法获得相应字符串；</p>
<hr>
<h1><span id="泛型">泛型</span></h1>
<h2><span id="如何理解java中的泛型是伪泛型">如何理解Java中的泛型是伪泛型？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">ArrayList b=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">System.out.println(a.getClass()==b.getClass());</span><br></pre></td></tr></table></figure>
<p>泛型只存在于编译期</p>
<p>JDK 1.5开始，Java在语法上支持泛型，在运行时会进行“类型擦除”，将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型）</p>
<hr>
<h1><span id="注解">注解</span></h1>
<h2><span id="注解的作用">注解的作用？</span></h2>
<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面： 生成文档，通过代码里标识的元数据生成javadoc文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</p>
<hr>
<h2><span id="42-注解的常见分类">42. 注解的常见分类？</span></h2>
<p><strong>Java自带的标准注解</strong>，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。<br>
<strong>元注解</strong>:元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented @Retention用于标明注解被保留的阶段 @Target用于标明注解使用的范围 @Inherited用于标明注解可继承 @Documented用于标明是否生成javadoc文档 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p>
<hr>
<h1><span id="面向对象">面向对象</span></h1>
<h2><span id="java面向对象的理解面向对象的特征">java面向对象的理解？面向对象的特征？</span></h2>
<p><strong>面向对象是一种思想，是相对于面向过程而言的</strong></p>
<p>对实际的事物进行抽象，再描述其特征与行为，最后组织各种对象的特征和行为，完成业务需求</p>
<ol>
<li>封装：将描述事物的数据和操作封装在一起，形成一个类；被封装的数据和操作只有通过提供的公共方法才能被外界访问，私有属性和方法是无法被访问的，增加数据的安全性</li>
<li>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承的过程，就是从一般到特殊的过程</li>
<li>多态：一个对象可以指向多种实际类型的现象</li>
</ol>
<hr>
<h2><span id="java中实现多态的机制是什么">Java中实现多态的机制是什么？</span></h2>
<p>Java实现多态有三个必要条件：</p>
<ol>
<li>继承：在多态中必须存在有继承关系的子类和父类</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法</li>
</ol>
<p>依靠父类指向子类或接口定义的引用变量指向具体实现类的实例对象。从而实现了一个对象多种形态的特性</p>
<p>其中父类的引用是在程序运行时动态的指向具体的实例，调用该引用的方法时，不是根据引用变量的类型中定义的方法来运行，而是根据具体的实例的方法</p>
<hr>
<h2><span id="构造方法有哪些特性">构造方法有哪些特性？</span></h2>
<ol>
<li>名字与类名相同</li>
<li>没有返回值，但不能用void声明构造方法</li>
<li>生成类的对象时自动执行，无需调用</li>
</ol>
<hr>
<h2><span id="构造器constructor是否可被重写override">构造器（constructor）是否可被重写（override）？</span></h2>
<p>构造器不能被继承，因此不能被重写，但可以被重载</p>
<hr>
<h2><span id="super关键字的用法">super关键字的用法</span></h2>
<p>super是引用超（父）类（离自己最近的一 个父类）对象的关键字，用来调用父类的成员</p>
<ul>
<li>指向父类对象；如果父类和子类拥有同样名称的字段，super 关键字可以用来访问父类的同名字段</li>
<li>调用父类的方法； super 关键字可以用于方法重写时访问到父类的方法</li>
<li><code>super(参数列表)</code> 可以调用父类的构造方法，但必须在方法的第一行</li>
<li>不能在static修饰的静态方法中使用</li>
</ul>
<hr>
<h2><span id="this与super的区别">this与super的区别？</span></h2>
<p><strong>相同点</strong></p>
<ul>
<li>都是Java中的关键字</li>
<li>只能在类的非静态方法中使用，用来访问非静态成员方法和字段</li>
<li>在构造方法中调用时，必须是构造方法的第一条语句，并且不能同时使用</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用</li>
<li>this可用于区分函数中的形参与成员属性（名称一致的情况），super可用于区分父类与子类有相同成员定义</li>
<li>在非静态成员方法中，this用来访问本来的方法和属性，super用来访问父类继承下来的方法和属性</li>
<li>在构造方法中，this（）用于调用本类构造方法，super（）用于调用父类的构造方法</li>
<li>两种调用不能同时在构造方法中出现，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在</li>
<li>构造方法中一定会存在super（）的调用，用户没有写编译器也会增加，但是this（）用户不写则没有</li>
<li>在底层（字节码层面）this是存在的，指向本对象的指针，但是super是不存在的，super是代码层面的一个关键字，在代码中可以通过super访问子类对象中从基类继承下来的成员，但是代码经过javac编译之后，super就不存在了</li>
</ul>
<hr>
<h2><span id="java中重写和重载有哪些区别">Java中重写和重载有哪些区别？</span></h2>
<table>
<thead>
<tr>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>在一个类中</td>
<td>在子类和父类中</td>
</tr>
<tr>
<td>同名方法的参数列表不同(参数类型，参数个数以及参数顺序)</td>
<td><strong>同名方法的参数列表都必须相同</strong></td>
</tr>
<tr>
<td>返回类型没有要求</td>
<td><strong>返回类型与父类一致（引用类型要能向上转型）</strong></td>
</tr>
<tr>
<td>访问权限没有要求</td>
<td>相比于重写前的方法，<strong>访问权限不能更低</strong></td>
</tr>
<tr>
<td>异常没有要求</td>
<td>相比于重写前的方法，不能申明更加宽泛的检查型异常</td>
</tr>
<tr>
<td>可以与private的方法彼此之间构成重载的</td>
<td>不能重写父类中声明为private权限的方法</td>
</tr>
<tr>
<td>实现类中的多态（编译时的多态性）</td>
<td>多态的前提（运行时的多态性）</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="接口和抽象类有哪些区别">接口和抽象类有哪些区别？</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键字</td>
<td>abstract</td>
<td>interface</td>
</tr>
<tr>
<td>成员方法</td>
<td>除了能有抽象方法外，还可以有实例方法</td>
<td>只能有公共静态常量、抽象方法（jdk8及以上可以有默认方法、静态方法）</td>
</tr>
<tr>
<td>构造器</td>
<td>有构造器方法</td>
<td>没有构造器方法</td>
</tr>
<tr>
<td>使用</td>
<td>需要被类继承（extends），位于类体系的顶层</td>
<td>需要被类实现（implemens）或被接口继承，类实现接口不构成继承体系</td>
</tr>
<tr>
<td>限制</td>
<td>一个类最多继承一个抽象类</td>
<td>一个类可以实现多个接口，一个接口可以继承多个接口</td>
</tr>
<tr>
<td>特点</td>
<td>作为模板</td>
<td>作为标准或某种特性</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="接口是否可继承extends接口-抽象类是否可实现implements-接口-抽象类是否可继承具体类concrete-class">接口是否可继承（extends）接口? 抽象类是否可实现（implements） 接口? 抽象类是否可继承具体类（concrete class）？</span></h2>
<p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。</p>
<hr>
<h2><span id="描述一下值传递和引用传递的区别">描述一下值传递和引用传递的区别？</span></h2>
<p>值传递是指在调用函数时将实际参数复制一份到函数中，这样的话如果函数对其传递过来的形式参数进行修改，将不会影响到实际参数</p>
<p>引用传递是指在调用函数时将对象的地址直接传递到函数中，如果在对形式参数进行修改，将影响到实际参数的值</p>
<hr>
<h2><span id="java中和equals有哪些区别">Java中==和equals有哪些区别？</span></h2>
<table>
<thead>
<tr>
<th>==</th>
<th>equals</th>
</tr>
</thead>
<tbody>
<tr>
<td>比较运算符</td>
<td>object中的方法</td>
</tr>
<tr>
<td>比较基本类型时比较的是数值是否相等</td>
<td>不能用于基本数据类型数据比较</td>
</tr>
<tr>
<td>比较引用数据类型，比较的是地址</td>
<td>默认情况下equals方法底层使用==实现比较内存地址是否相同</td>
</tr>
<tr>
<td></td>
<td>可重写成比较属性是否相等（自定义比较逻辑）如String：比较字符串内容是否相同</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="hashcode方法的作用">hashCode()方法的作用？</span></h2>
<p>hashCode() 的作用是获取哈希码，也称为散列码</p>
<p>它实际上是返回一个int整数。这个哈希码可以确定该对象在哈希表中的索引位置</p>
<hr>
<h2><span id="如果两个对象的hashcode方法返回的值相同那么它们是否相等">如果两个对象的hashCode()方法返回的值相同，那么它们是否相等？</span></h2>
<p>不一定相等，两个不同的对象可能会产生相同的哈希码，这就是所谓的哈希冲突，还需要使用equals()方法进行进一步比较</p>
<hr>
<h2><span id="请简述java中的默认hashcode方法的实现">请简述Java中的默认hashCode()方法的实现</span></h2>
<p>如果对象是一个基本类型，则返回对象的值</p>
<p>如果对象是一个引用类型，则返回对象的对象引用，以对象的地址为基本数据，进行二进制换算</p>
<p>如果对象是一个自定义类型，则返回对象的类型和对象引用</p>
<hr>
<h2><span id="请简述java中的equals方法的作用">请简述Java中的equals()方法的作用</span></h2>
<p>默认情况下使用==比较运算符比较对象的地址是否相等</p>
<p>重写后用于比较对象的内容是否相等（自定义比较逻辑）</p>
<hr>
<h2><span id="请简述java中的objectshash方法的作用">请简述Java中的Objects.hash()方法的作用</span></h2>
<p>Objects.hash()方法用于计算对象的哈希码</p>
<p>如果对象是一个基本类型，则返回对象的值</p>
<p>如果对象是一个引用类型，则返回对象的对象引用，以对象的地址为基本数据，进行二进制换算</p>
<p>如果对象是一个自定义类型，则返回对象的类型和对象引用</p>
<hr>
<h2><span id="请简述java中的objectstostring方法的作用">请简述Java中的Objects.toString()方法的作用</span></h2>
<p>Objects.toString()方法用于将对象转换为一个字符串</p>
<hr>
<h2><span id="hashcode方法和equals方法区别">hashcode方法和equals方法区别？</span></h2>
<p>equals相等的两个对象他们的hashCode值一定相等，而hashCode值相等的两个对象他们的equals不一定相等，equals可靠性更强</p>
<p>但是重写equals往往有着复杂的比较逻辑，使用equals比较效率比hashCode比较效率更低</p>
<p>因此比较两个对象先使用hashCode方法，若他们的hashCode值不同，则一定不同，再进一步调用equals方法进行比较</p>
<hr>
<h2><span id="为什么重写-equals-方法必须重写-hashcode-方法">为什么重写 equals 方法必须重写 hashcode 方法？</span></h2>
<p>因为Object规范约定如果两个对象通过equals方法比较是相等的，那么它们的hashCode方法结果值也是相等的</p>
<p>重写equals方法而不重写hashCode方法可能会出现equals方法相同的对象hashCode不同，违反了Object规范约定</p>
<hr>
<h2><span id="两个对象值相同xequalsy-true但却可有不同的hash-code这句话对不对">两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</span></h2>
<p>不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。</p>
<p>Object规范约定：</p>
<ul>
<li>如果两个对象通过equals方法比较是相等的，那么它们的hashCode方法结果值也是相等的</li>
<li>如果两个对象通过equals方法比较是不相等的，那么不要求它们的hashCode方法结果值是相等的</li>
</ul>
<p>如果违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）</p>
<hr>
<h2><span id="抽象的abstract方法是否可同时是静态的static-是否可同时是本地方法native是否可同时被-synchronized">抽象的(abstract)方法是否可同时是静态的(static)， 是否可同时是本地方法(native)，是否可同时被 synchronized？</span></h2>
<p>都不能</p>
<ol>
<li>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li>
<li>本地方法是由本地代码（如 C++ 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li>
<li>synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的</li>
</ol>
<hr>
<h2><span id="final关键字的用法">final关键字的用法?</span></h2>
<ul>
<li>修饰类：表明这个类不能被继承</li>
<li>修饰方法：表示该方法不能被重写</li>
<li>修饰变量：
<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改</li>
<li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。但是它指向的对象的内容是可变的</li>
<li>如果是类成员变量，则必须对其显示赋值（初始化、也可以在每个构造方法或代码块中初始化不同的值）</li>
</ul>
</li>
</ul>
<hr>
<h2><span id="60-final和static的区别">60. final和static的区别？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        System.out.println(myClass1.i);</span><br><span class="line">        System.out.println(myClass2.i);</span><br><span class="line">        System.out.println(myClass1.j);</span><br><span class="line">        System.out.println(myClass2.j);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">i</span> <span class="operator">=</span> Math.random();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> Math.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.3222977275463088</span></span><br><span class="line"><span class="number">0.2565532218939688</span></span><br><span class="line"><span class="number">0.36856868882926397</span></span><br><span class="line"><span class="number">0.36856868882926397</span></span><br></pre></td></tr></table></figure>
<p>每次打印的两个j值都是一样的，而i的值却是不同的</p>
<p>从这里就可以知道final和static变量的区别了。static属于类级别的不可变，而final是对象级别的不可变</p>
<hr>
<h2><span id="final与finally-finalize-的区别">final与finally、finalize 的区别？</span></h2>
<p>final</p>
<ul>
<li>修饰类表示该类不能被继承</li>
<li>修饰方法表示该方法不能被重写</li>
<li>修饰基本数据类型变量时值无法修改</li>
<li>修饰引用型变量时地址无法修改，但引用变量的内容可以修改</li>
<li>修饰成员变量时必须显式赋值（初始化或在每个构造器方法或代码块中初始值）</li>
</ul>
<p>finally</p>
<ul>
<li>一般作用在异常处理try-catch代码中，表示不管是否出现异常，该代码块都会执行，一般用来关闭资源</li>
<li>有些情况不会执行finally：
<ul>
<li>如果在执行try语句块之前已经返回或抛出异常，那么try对应的finally语句不会执行；但若在try语句块中执行return，finally语句还是会执行（撤销return）</li>
<li>在try语句块中执行了System.exit (0) 语句，终止了Java虚拟机的运行</li>
</ul>
</li>
</ul>
<p>finalize</p>
<ul>
<li>Object 类的一个方法，当对象没有被引用时，JVM自动通过垃圾回收器来调用此方法进行回收前的准备工作（new创建的对象都能自动回收）</li>
<li>特殊情况下，需要手动调用finalize，如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接</li>
</ul>
<hr>
<h2><span id="静态变量和实例变量区别">静态变量和实例变量区别？</span></h2>
<ul>
<li>实例变量是属于每个对象的属性，每次创建对象都会为其分配内存空间；而静态变量是属于整个类的属性，在类的加载过程中，JVM只为静态变量分配一次内存空间</li>
<li>实例变量必须创建对象后才能使用；而静态变量则可以直接使用类名来引用</li>
</ul>
<hr>
<h2><span id="静态方法和实例方法有何不同">静态方法和实例方法有何不同？</span></h2>
<ul>
<li>实例方法通过实例对象调用，；而静态方法是通过类自身调用，无需创建对象</li>
<li>实例方法允许访问静态成员与实例成员；而静态方法只允许访问静态成员</li>
</ul>
<hr>
<h2><span id="指出下面程序的运行结果">指出下面程序的运行结果？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; </span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;2&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123; </span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;a&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;b&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] ars)</span>&#123; </span><br><span class="line">        <span class="type">A</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//执行到此处,结果: 1a2b </span></span><br><span class="line">        ab = <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//执行到此处,结果: 1a2b2b </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出结果为 1a2b2b；<br>
静态代码块可以看作是类首次加载执行的代码,而对于类加载,首先要执行其基类的构造,再执行其本身的构造</p>
<hr>
<h2><span id="访问修饰符publicprivateprotected以及不写默认时的区别">访问修饰符public,private,protected,以及不写（默认）时的区别？</span></h2>
<table>
<thead>
<tr>
<th>位置</th>
<th>public</th>
<th>protected</th>
<th>默认修饰符（default）</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>类内部</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>子类中</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>任意位置</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开 （public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对 子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符 只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<hr>
<h2><span id="java有没有goto">Java有没有goto？</span></h2>
<ul>
<li>goto 是Java中的保留字，在目前版本的Java中没有使用</li>
<li>根据James Gosling（Java之 父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列 表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保 留字</li>
</ul>
<hr>
<h2><span id="java-的接口和-c的虚类的相同和不同处">Java 的接口和 C++的虚类的相同和不同处?</span></h2>
<p>接口相比抽象类的单继承有更高的灵活性，一个类可以实现多个接口</p>
<hr>
<h2><span id="string-是最基本的数据类型吗">String 是最基本的数据类型吗?</span></h2>
<ul>
<li>不是；基本数据类型为byte、short、int、long、float、double、char、boolean，其余为引用类型</li>
</ul>
<hr>
<h2><span id="string-stringbuffer-stringbuilder区别及使用场景">String、StringBuffer、StringBuilder区别及使用场景？</span></h2>
<ul>
<li>String引用的字符串内容是不能被改变的，StringBuffer和StringBuilder表示的字符串对象可以直接进行修改</li>
<li>StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同</li>
<li>StringBuilder非线程安全（单线程使用）因为它的所有方法都没有被 synchronized 修饰</li>
<li>String与StringBuffer线程安全（多线程使用）</li>
</ul>
<hr>
<h2><span id="string-str-i-和string-str-new-string1一样吗">String str = “i” 和String str = new String(“1”)一样吗？</span></h2>
<p>不一样</p>
<ul>
<li>String str = &quot;i&quot;的方式JVM会将其分配到常量池中</li>
<li>String str = new String(“i”)JVM会将其分配到堆内存中</li>
</ul>
<hr>
<h2><span id="是否可以继承string类">是否可以继承String类？</span></h2>
<p>不可以继承String类，String类被final修饰</p>
<hr>
<h2><span id="string-snew-stringxyz创建了几个字符串对象">String s=new String(“xyz”);创建了几个字符串对象</span></h2>
<p>两个对象，一个是静态存储区的&quot;xyz&quot;,一个是用 new 创建在堆上的对象。</p>
<hr>
<h2><span id="string类的常用方法有哪些">String类的常用方法有哪些？</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>indexof()</td>
<td>返回指定字符的的索引</td>
</tr>
<tr>
<td>charAt()</td>
<td>返回指定索引处的字符</td>
</tr>
<tr>
<td>replace()</td>
<td>字符串替换</td>
</tr>
<tr>
<td>trim()</td>
<td>去除字符串两端空格</td>
</tr>
<tr>
<td>splt()</td>
<td>字符串分割，返回分割后的字符串数组</td>
</tr>
<tr>
<td>getBytes()</td>
<td>返回字符串byte类型数组</td>
</tr>
<tr>
<td>length()</td>
<td>返回字符串长度</td>
</tr>
<tr>
<td>toLowerCase()</td>
<td>将字符串转换为小写字母</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td>将字符串转换为大写字母</td>
</tr>
<tr>
<td>substring()</td>
<td>字符串截取</td>
</tr>
<tr>
<td>equals()</td>
<td>比较字符串是否相等</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="数组有没有-length方法string-有没有-length方法">数组有没有 length()方法?String 有没有 length()方法？</span></h2>
<p>数组没有 length()方法，有 length 的属性</p>
<p>String 有 length()方法。JavaScript 中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java混淆</p>
<hr>
<h2><span id="怎样将-gb2312-编码的字符串转换为-iso-8859-1-编码的字符串">怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> newString(s1.getBytes(<span class="string">&quot;GB2312&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="string-中的-equals-是如何重写的">String 中的 equals 是如何重写的？</span></h2>
<ul>
<li>首先比较两个字符串的引用是否相等，如果引用相等的话，直接返回 true</li>
<li>引用不相等再判断被比较的对象是否是 String 的实例，如果不是的话直接返回 false</li>
<li>如果是的话，再比较两个字符串的长度是否相等，如果长度不相等直接返回false</li>
<li>长度如果相同，会比较字符串中的每个字符 是否相等，一旦有一个字符不相等，就会直接返回 false</li>
</ul>
<hr>
<h2><span id="如何实现字符串的反转及替换">如何实现字符串的反转及替换？</span></h2>
<p>用递归实现字符串反转，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String originStr)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(originStr == <span class="literal">null</span> || originStr.length() &lt;= <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> originStr;</span><br><span class="line">   <span class="keyword">return</span> reverse(originStr.substring(<span class="number">1</span>)) + originStr.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>string.substring(from)：相当于从from位置截取到原字符串末尾</p>
<p>charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>
<hr>
<h2><span id="写一个函数要求输入一个字符串和一个字符长度对该字符串进行分隔">写一个函数，要求输入一个字符串和一个字符长度，对该字符串进行分隔</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String str, <span class="type">int</span> chars)&#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (str.length()+ chars - <span class="number">1</span>)/chars; </span><br><span class="line">    String ret[] = <span class="keyword">new</span> <span class="title class_">String</span>[n]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(i &lt; n-<span class="number">1</span>)&#123; </span><br><span class="line">            ret[i] = str.substring(i*chars , (i+<span class="number">1</span>)*chars); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            ret[i] = str.substring(i*chars); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="写一个函数2-个参数1-个字符串1-个字节数返回截取的字符串要求字符串中的中文不能出现乱码如我-abc4应该截为我-ab输入我abc-汉-def6应该输出为我-abc而不是我-abc汉的半个">写一个函数，2 个参数，1 个字符串，1 个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我 ABC”，4）应该截为“我 AB”，输入（“我ABC 汉 DEF”，6）应该输出为“我 ABC”而不是“我 ABC+汉的半个”</span></h2>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">subString</span><span class="params">(String str, <span class="type">int</span> subBytes)</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来存储字符串的总字节数 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (bytes == subBytes) &#123; </span><br><span class="line">            <span class="keyword">return</span> str.substring(<span class="number">0</span>, i); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i); </span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">256</span>) &#123; </span><br><span class="line">            bytes += <span class="number">1</span>; <span class="comment">// 英文字符的字节数看作 1 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            bytes += <span class="number">2</span>; <span class="comment">// 中文字符的字节数看作 2 </span></span><br><span class="line">            <span class="keyword">if</span>(bytes - subBytes == <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="keyword">return</span> str.substring(<span class="number">0</span>, i); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> str; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="用程序给出随便大小的-10-个数序号为-1-10按从小到大顺序输出并输出相应的序号">用程序给出随便大小的 10 个数，序号为 1-10，按从小到大顺序输出，并输出相应的序号</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomSort</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printRandomBySort</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); <span class="comment">// 创建随机数生成器 </span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 生成 10 个随机数，并放在集合 list 中 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            list.add(random.nextInt(<span class="number">1000</span>)); </span><br><span class="line">        &#125; </span><br><span class="line">        Collections.sort(list); <span class="comment">// 对集合中的元素进行排序 </span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123; <span class="comment">// 顺序输出排序后集合中的元素 </span></span><br><span class="line">            System.out.println(++count + <span class="string">&quot;: &quot;</span> + it.next()); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        printRandomBySort(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="写一个方法输入一个文件名和一个字符串统计这个字符串在这个文件中出现的次数">写一个方法,输入一个文件名和一个字符串,统计这个字符串在这个文件中出现的次数</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWords</span><span class="params">(String file, String find)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file); </span><br><span class="line">    <span class="type">int</span> c; </span><br><span class="line">    <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">while</span> (c == find.charAt(<span class="number">0</span>)) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; find.length(); i++) &#123; </span><br><span class="line">                c = in.read(); </span><br><span class="line">                <span class="keyword">if</span> (c != find.charAt(i)) </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">if</span> (i == find.length() - <span class="number">1</span>) </span><br><span class="line">                    count++; </span><br><span class="line">             &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="介绍一下object类中的方法">介绍一下Object类中的方法？</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class&lt;?&gt; getClass()</td>
<td>返回该对象的运行时类</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>判断指定对象与该对象是否相等</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值</td>
</tr>
<tr>
<td>String toString()</td>
<td>Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串</td>
</tr>
<tr>
<td>wait()、notify()、notifyAll()</td>
<td>过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="为什么要重写hashcode和equals">为什么要重写hashCode()和equals()？</span></h2>
<ul>
<li>重写equals（）方法：Object类中的equals方法使用==比较两个引用所指向的对象是否一致，而在实际的业务中，需要两个对象内容相同则相等</li>
<li>重写hashCode（）方法：为了满足以下原则，若两个对象equals返回true，则它们的hashCode也要返回相同的int值，反之它们的hashCode也要返回不同的值，因此重写了equals方法也需要丝血hashCode方法</li>
</ul>
<hr>
<h2><span id="object类中finalize方法作用">Object类中finalize()方法作用？</span></h2>
<ul>
<li>执行时机：当对象不再被程序使用时，JVM垃圾回收器将会调用fianlize方法将其回收</li>
<li>垃圾回收是在后台自动运行的且运行时间不确定，因此不建议手动调用finalize方法（尽快回收资源可使用<strong>System.gc</strong> 和 Runtime.getRuntime().gc()）</li>
<li>主要用于重写finalize方法，从而在对象销毁时机执行指定的业务逻辑</li>
</ul>
<hr>
<h2><span id="systemgc-和-runtimegc-作用">System.gc() 和 Runtime.gc() 作用？</span></h2>
<p>提示JVM尽快执行垃圾回收，由JVM决定是立即开始还是延迟执行垃圾回收</p>
<hr>
<h1><span id="日期-时间">日期、时间</span></h1>
<h2><span id="如何格式化日期">如何格式化日期？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dtf1=DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf2</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 EE HH:mm&quot;</span>, Locale.US);<span class="comment">//根据字符串、指定的地区创建格式</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> dtf1.format(localDateTime);	<span class="comment">//2022年01月27日 10:10:47 星期四</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format2</span> <span class="operator">=</span> dtf2.format(localDateTime);	<span class="comment">//2022年01月27日 Thu 10:12</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2019年11月30日 15:16:17 星期六&quot;</span>, dtf1);<span class="comment">//自定义格式解析:</span></span><br></pre></td></tr></table></figure>
<p>利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date)方法可将日期格式化</p>
<hr>
<h2><span id="打印昨天的当前时刻">打印昨天的当前时刻。</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YesterdayCurrent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        localTime.minus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1><span id="内部类">内部类</span></h1>
<h2><span id="什么是内部类">什么是内部类？</span></h2>
<ul>
<li>将一个类的定义放在另外一个类的定义内部，就是 内部类，内部类本身就 是类的一个属性，与其他属性定义方式一致</li>
</ul>
<hr>
<h2><span id="内部类的分类有哪些">内部类的分类有哪些？</span></h2>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态内部类</li>
</ul>
<hr>
<h2><span id="内部类可以引用它的包含类外部类的成员吗有没有什么限制">内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制</span></h2>
<p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员</p>
<hr>
<h2><span id="anonymous-inner-class匿名内部类是否可以继承其它类是否可以-实现接口">Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以 实现接口</span></h2>
<p>可以继承其他类或实现其他接口，在 Swing 编程中常用此方式来实现事件监听和回调</p>
<hr>
<h1><span id="异常">异常</span></h1>
<h2><span id="简单概述下异常">简单概述下异常</span></h2>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220920/1663637207@de13957bbd8247bc2511ec86fba6c130.png" alt="img"></p>
<ul>
<li>Throwable 是 Java 语言中所有错误与异常的超类</li>
<li>Error 类及其子类，程序中无法处理的错误，表示运行应用程序中出现了严重的错误</li>
<li>Exception 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常</li>
<li><strong>运行时异常</strong> 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过</li>
<li>**非运行时异常 （编译异常）**是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常</li>
</ul>
<hr>
<h2><span id="异常如何处理的">异常如何处理的？</span></h2>
<ul>
<li>编译时异常，都是可以被处理的异常，，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked 异常，该程序在编译时就会发生错误无法编译。这体现了Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行
<ul>
<li>当前方法知道如何处理该异常，则用try…catch块来处理该异常</li>
<li>当前方法不知道如何处理，则在定义该方法时声明抛出该异常<br>
运行时异常只有当代码在运行时才发行的异常，编译的时候不需要try…catch。Runtime如除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们</li>
</ul>
</li>
<li>运行时异常</li>
</ul>
<hr>
<h2><span id="异常处理中的throws-throw-try-catch-finally-分别如何使用">异常处理中的throws、throw、try、catch、finally 分别如何使用？</span></h2>
<ul>
<li>try 用来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理</li>
<li>try 用来指定一块预防所有“异常”的程序</li>
<li>catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型</li>
<li>throw 语句用来明确地抛出一个“异常”</li>
<li>throws 用来标明一个成员函数可能抛出的各种“异常”</li>
<li>finally 为确保一段代码不管发生什么“异常”都被执行一段代码</li>
<li>可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语句保护其他代码。每当遇到一个 try 语句，“异常”的框架就放到栈上面，直到所有的try 语句都完成。如果下一级的 try 语句没有对某种&quot;异常&quot;进行处理，栈就会展开，直到遇到有处理这种&quot;异常&quot;的 try 语句</li>
</ul>
<hr>
<h2><span id="try里有一个-return-语句那么紧跟在这个-try-后的-finally里的-code-会不会被执行什么时候被执行在-return-前还是后">try{}里有一个 return 语句，那么紧跟在这个 try 后的 finally{}里的 code 会不会被执行，什么时候被执行，在 return 前还是后?</span></h2>
<ul>
<li>当try代码块中含有return语句，finally代码块会在方法返回调用者前被执行</li>
<li>但是如果在 finally 中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事</li>
</ul>
<hr>
<h2><span id="error-和-exception-有什么区别">Error 和 Exception 有什么区别？</span></h2>
<ul>
<li>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况</li>
<li>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况</li>
</ul>
<hr>
<h2><span id="异常编程题下面代码的输出结果">异常编程题：下面代码的输出结果？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第3行的时候遇到了一个MathException，这时第4行的代码就不会执行了</li>
<li>代码直接跳转到catch语句中，走到第 6 行的时候，异常机制有一个原则：如果在catch中遇到了return或者异常等能使该函数终止的话那么有finally就必须先执行完finally代码块里面的代码然后再返回值</li>
<li>因此代码又跳到第8行，可惜第8行是一个return语句，那么这个时候方法就结束了，因此第6行的返回结果就无法被真正返回。因此上面返回值是3。</li>
</ul>
<hr>
<h2><span id="类-example-a-继承-exception类-exampleb-继承-example-a">类 Example A 继承 Exception，类 ExampleB 继承 Example A</span></h2>
<p>有如下代码片断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExampleB</span>(“b”)；</span><br><span class="line">&#125;<span class="keyword">catch</span>（ExampleA e）&#123;</span><br><span class="line">    System.out.printfln（“ExampleA”）；</span><br><span class="line">&#125;<span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">    System.out.printfln（“Exception”）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的内容应该是：ExampleA</p>
<hr>
<h2><span id="常见的异常有哪些">常见的异常有哪些？</span></h2>
<table>
<thead>
<tr>
<th>异常</th>
<th>出现原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang.NullPointerException 空指针异常</td>
<td>调用了未经初始化的对象或者是不存在的对象</td>
</tr>
<tr>
<td>java.lang.IndexOutOfBoundsException 数组角标越界异常</td>
<td>常见于操作数组对象时发生</td>
</tr>
<tr>
<td>java.lang.ClassNotFoundException 指定的类找不到</td>
<td>类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常</td>
</tr>
<tr>
<td>java.lang.ClassCastException</td>
<td>数据类型转换异常</td>
</tr>
<tr>
<td>java.lang.SQLException SQL异常</td>
<td>常见于操作数据库时的 SQL 语句错误</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="throw-和-throws-的区别">throw 和 throws 的区别？</span></h2>
<ul>
<li>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。throws语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理</li>
<li>throw是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw一定是抛出了某种异常。throws主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型</li>
</ul>
<hr>
<h2><span id="java-7-的-try-with-resource">Java 7 的 try-with-resource?</span></h2>
<p>资源实现AutoCloseable 接口从而使用try-with-resource语句</p>
<p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">automaticallyCloseResource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="异常的底层">异常的底层？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap来分析这段代码（需要先使用javac编译）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//javap -c Main</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleTryCatch</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">3</span>                  <span class="comment">// Method testNPE:()V</span></span><br><span class="line">       <span class="number">3</span>: goto          <span class="number">11</span></span><br><span class="line">       <span class="number">6</span>: astore_0</span><br><span class="line">       <span class="number">7</span>: aload_0</span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">      <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>     <span class="number">6</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure>
<p>异常表中包含了一个或多个异常处理者(Exception Handler)的信息</p>
<ul>
<li>from 可能发生异常的起始点</li>
<li>to可能发生异常的结束点</li>
<li>target上述from和to之前发生异常后的异常处理者的位置</li>
<li>type异常处理者处理的异常的类信息</li>
</ul>
<hr>
<h1><span id="io流">IO流</span></h1>
<h2><span id="什么是io流">什么是IO流？</span></h2>
<ul>
<li>以流的方式进行输入输出，主要用来处理设备之间的传输，文件的上传，下载和复制</li>
<li>流分输入和输出，输入流从文件中读取数据存储到进程中，输出流从进程中读取数据然后写入到目标文件</li>
</ul>
<hr>
<h2><span id="java-中有几种类型的流">Java 中有几种类型的流？</span></h2>
<ul>
<li>按照流的方向：输入流（inputStream）和输出流（outputStream）</li>
<li>按照实现功能分：节点流（可以从或向一个特定的地方（节点）读写数据。如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如 BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。）</li>
<li>按照处理数据的单位： 字节流和字符流。字节流继承于 InputStream 和 OutputStream， 字符流继承于Reader 和 Writer</li>
</ul>
<hr>
<h2><span id="106-字节流和字符流的区别">106. 字节流和字符流的区别？</span></h2>
<ul>
<li>字节流读取的时候，读到一个字节就返回一个字节；字符流读取的时候会读到一个或多个字节（这个要根据字符流中编码设置，一般中文对应的字节数是两个，在UTF-8码表中是3个字节）</li>
<li>字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流</li>
<li>字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件</li>
</ul>
<p>在写操作的过程中，没有关闭字节流操作，但是文件中也依然存在了输出的内容代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">// 第1步：使用File类找到一个文件 </span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>); <span class="comment">// 声明File 对象 </span></span><br><span class="line">    <span class="comment">// 第2步：通过子类实例化父类对象 </span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f); </span><br><span class="line">    <span class="comment">// 第3步：进行写操作 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!!!&quot;</span>; <span class="comment">// 准备一个字符串 </span></span><br><span class="line">    <span class="type">byte</span> b[] = str.getBytes(); <span class="comment">// 字符串转byte数组 </span></span><br><span class="line">    out.write(b); <span class="comment">// 将内容输出 </span></span><br><span class="line">    <span class="comment">// 第4步：关闭输出流 </span></span><br><span class="line">    <span class="comment">// out.close();</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在写操作的过程中，没有关闭字符流操作，发现文件中没有任何内容输出。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;         </span><br><span class="line">    <span class="comment">// 第1步：使用File类找到一个文件    </span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);<span class="comment">// 声明File 对象    </span></span><br><span class="line">    <span class="comment">// 第2步：通过子类实例化父类对象    </span></span><br><span class="line">    <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);            </span><br><span class="line">    <span class="comment">// 第3步：进行写操作    </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!!!&quot;</span>; <span class="comment">// 准备一个字符串    </span></span><br><span class="line">    out.write(str); <span class="comment">// 将内容输出</span></span><br><span class="line">    out.flush();     </span><br><span class="line">    <span class="comment">// 第4步：关闭输出流    </span></span><br><span class="line">    <span class="comment">// out.close();  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这是因为字符流操作时使用了缓冲区，而在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果程序没有关闭，则缓冲区中的内容是无法输出的。当然如果在不关闭字符流的情况下也可以使用Writer类中的flush()强制性的清空缓存，从而将字符流的内容全部输出。</p>
<hr>
<h2><span id="怎么样把字节流转换成字符流说出它的步骤">怎么样把字节流转换成字符流,说出它的步骤？</span></h2>
<p>把字节流转成字符流就要用到适配器模式，需要用到OutputStreamWriter。它继承了Writer接口，但要创建它必须在构造函数中传入一个OutputStream的实例，OutputStreamWriter的作用也就是将OutputStream适配到Writer。它实现了Reader接口，并且持有了InputStream的引用。利用转换流OutputStreamWriter.创建一个字节流对象,将其作为参数传入转换流OutputStreamWriter中得到字符流对象.</p>
<hr>
<h2><span id="什么是序列化">什么是序列化？</span></h2>
<p>序列化是指把对象转换为字节序列的过程，序列化后的字节流保存了对象的状态以及相关的描述信息，从而方便在网络上传输或者保存在本地文件中，达到对象状态的保存与重建的目的。<br>
反序列化:客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。<br>
序列化的优势：一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。三是通过序列化在进程间传递对象；</p>
<hr>
<h2><span id="io如何实现序列化和反序列化">IO如何实现序列化和反序列化？</span></h2>
<p>(1)java.io.ObjectOutputStream：表示对象输出流；它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；<br>
(2)java.io.ObjectInputStream：表示对象输入流；它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；<br>
注意：只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p>
<p><strong>序列化和反序列化的示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">	    <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xuliugen&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">		<span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ <span class="string">&quot; &quot;</span> + </span><br><span class="line">	    user2.getPassword() + <span class="string">&quot; &quot;</span> + user2.getSex());</span><br><span class="line">        <span class="comment">//反序列化的输出结果为：xuliugen 123456 male</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">//全参构造方法、get和set方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="printstream-bufferedwriter-printwriter-的比较">PrintStream、BufferedWriter、PrintWriter 的比较？</span></h2>
<p>\1. PrintStream 类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成PrintStream 后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了自动刷新，可以创建一个 PrintStream<br>
2.BufferedWriter:将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write()方法可以将获取到的字符输出，然后通过 newLine()进行换行操作。BufferedWriter 中的字符流必须通过调用 flush 方法才能将其刷出去。并且 BufferedWriter 只能对字符流进行操作。如果要对字节流操作，则使用 BufferedInputStream<br>
3.PrintWriter 的 println 方法自动添加换行，不会抛异常，若关心异常，需要调用 checkError方法看是否有异常发生，PrintWriter 构造方法可指定参数，实现自动刷新缓存(autoflush)。</p>
<hr>
<h2><span id="如果我要对字节流进行大量的从硬盘读取要用那个流为什么">如果我要对字节流进行大量的从硬盘读取,要用那个流,为什么？</span></h2>
<p>因为明确说了是对字节流的读取，所以肯定是InputStream或者他的子类，又因为要大量读取，肯定要考虑到高效的问题，自然想到缓冲流BufferedInputStream。<br>
原因：BufferedInputStream是InputStream的缓冲流，使用它可以防止每次读取数据时进行实际的写操作，代表着使用缓冲区。不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多！并且也可以减少对磁盘的损伤。</p>
<hr>
<h1><span id="集合">集合</span></h1>
<h2><span id="什么是集合">什么是集合?</span></h2>
<ul>
<li>集合就是一个存放数据对象引用的容器</li>
<li>集合类存放的都是对象的引用，而不是对象本身</li>
<li>集合的类型主要有3中：set（集）、list（列表）和map（映射）</li>
</ul>
<hr>
<h2><span id="集合框架中的泛型有什么优点">集合框架中的泛型有什么优点？</span></h2>
<ul>
<li>java从Jdk1.5开始引入了泛型，集合接口及其实现类开始大量使用泛型</li>
<li>泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。</li>
<li>泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令</li>
</ul>
<hr>
<h2><span id="iterator是什么">Iterator是什么？</span></h2>
<p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。</p>
<hr>
<h2><span id="集合和数组的区别">集合和数组的区别?</span></h2>
<ul>
<li>数组的长度时固定的，集合的长度时可变的，可以自动扩容</li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型，集合只能存储引用数据类型</li>
<li>数组存储的元素必须时同一个数据类型， 而集合存储的对象可以是不同的数据类型</li>
</ul>
<hr>
<h2><span id="常用的集合类有哪些">常用的集合类有哪些？</span></h2>
<ul>
<li>Map接口和Collection接口是所有集合框架的父接口</li>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<hr>
<h2><span id="collection-和-collections-有什么区别">Collection 和 Collections 有什么区别？</span></h2>
<ul>
<li>Collection 是一个集合接口（集合框架的父接口），Collections则是集合类的一个工具类/帮助类</li>
<li>Collection 提供了对集合对象进行基本操作的通用接口方法，其直接继承接口有List与Set；而Collections 提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作</li>
</ul>
<hr>
<h2><span id="set和list的区别">Set和List的区别？</span></h2>
<ul>
<li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素</li>
<li>Set和List都可以存储null值，但是set不能重复所以最多只能有一个空元素</li>
<li>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;</li>
<li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector</li>
</ul>
<hr>
<h2><span id="arraylist与-linkedlist-异同">Arraylist与 LinkedList 异同？</span></h2>
<ul>
<li>Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构</li>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。插入末尾还好，如果是中间，则（add(int index, E element)）接近O（n）；LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针</li>
<li>LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。所以ArrayList随机访问快，插入慢；LinkedList随机访问慢，插入快</li>
<li>ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li>
</ul>
<hr>
<h2><span id="arraylist和vector有何异同点">ArrayList和Vector有何异同点？</span></h2>
<p>相同点：</p>
<ul>
<li>两者都是基于索引的，内部由一个数组支持</li>
<li>两者维护插入的顺序，我们可以根据插入顺序来获取元素</li>
<li>ArrayList和Vector的迭代器实现都是fail-fast的</li>
<li>)ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问</li>
</ul>
<p>不同点：</p>
<ul>
<li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList</li>
<li>ArrayList比Vector快，它因为有同步，不会过载</li>
<li>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表</li>
</ul>
<hr>
<h2><span id="遍历一个list有哪些不同的方式">遍历一个List有哪些不同的方式？</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//使用for-each循环</span></span><br><span class="line"><span class="keyword">for</span>(String obj : strList)&#123;</span><br><span class="line">  System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//using iterator</span></span><br><span class="line">Iterator&lt;String&gt; it = strList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">  System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="hashset如何检查重复">HashSet如何检查重复？</span></h2>
<ul>
<li>当把对象加入到HashSet中时，HashSet会先计算对象的hashCode值来判断对象加入的下标位置，同时也会与其他的对象的hashCode进行比较如果没有相同的，就直接插入数据</li>
<li>如果有相同的，就进一步使用equals来进行比较对象是否相同，如果相同，就不会加入成功</li>
</ul>
<hr>
<h2><span id="hashmap如何遍历">HashMap如何遍历？</span></h2>
<p>1.使用foreach循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;:&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.使用foreach迭代键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : hashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String value : hashMap.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; next = iterator.next();</span><br><span class="line">    System.out.println(next.getKey()+<span class="string">&quot;:&quot;</span>+next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.使用lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;study&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;day&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;up&quot;</span>);</span><br><span class="line">hashMap.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="hashmap-和-hashtable-的区别">HashMap 和 Hashtable 的区别?</span></h2>
<p>相同点：</p>
<ul>
<li>都实现了Map接口（hashTable还实现了Dictionary 抽象类）</li>
</ul>
<p>不同点：</p>
<ul>
<li>历史原因:Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map 接口<br>
的一个实现，HashMap把Hashtable 的contains方法去掉了，改成containsvalue 和containsKey。因为contains方法容易让人引起误解</li>
<li>同步性:Hashtable 的方法是 Synchronize 的，线程安全；而 HashMap 是线程不安全的，不是同步的。所以只有一个线程的时候使用hashMap效率要高</li>
<li>值：HashMap对象的key、value值均可为null。HahTable对象的key、value值均不可为null</li>
<li>容量：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75</li>
<li>HashMap扩容时是当前容量翻倍即:capacity * 2，Hashtable扩容时是容量翻倍+1 即:capacity * 2+1</li>
</ul>
<hr>
<h2><span id="hashset-和-hashmap-区别">HashSet 和 HashMap 区别？</span></h2>
<ul>
<li>HashMap实现了Map接口，而HashSet实现了Set接口</li>
<li>HashMap存放键值对，而HashSet仅存储对象</li>
<li>HashMap使用键（key）计算HashCode，而HashSet使用成员对象来计算HashCode，对于两个对象来说HashCode可能相同，所以equals方法用来判断对象的相等性，如果两个对象不同的话返回false</li>
<li>HashMap相对于HashSet较快，因为使用唯一的键获取对象，而HashSet较慢</li>
<li>HashSet 底层就是基于 HashMap 实现的。只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的</li>
</ul>
<hr>
<h2><span id="haspmap与treemap的区别">HaspMap与TreeMap的区别？</span></h2>
<ul>
<li>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）</li>
<li>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现</li>
</ul>
<hr>
<h2><span id="arraylist自动扩容">ArrayList自动扩容？</span></h2>
<ul>
<li>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求</li>
<li>数组扩容通过ensureCapacity(int minCapacity)方法来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量</li>
<li>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时 ，我们应该尽量避免数组容量的扩张</li>
<li>当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量</li>
</ul>
<hr>
<h2><span id="arraylist的fail-fast机制">ArrayList的Fail-Fast机制？</span></h2>
<ul>
<li>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现</li>
<li>在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li>
</ul>
<h1><span id="反射">反射</span></h1>
<h2><span id="java-中的反射是什么意思有哪些应用场景">Java 中的反射是什么意思？有哪些应用场景？</span></h2>
<p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName,这种方式来控制类的加载，该方法会返回一个 Class 对象。<br>
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：<br>
(1)Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；<br>
(2)Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；<br>
(3)Constructor ：可以用 Constructor 创建新的对象。<br>
应用举例：工厂模式，使用反射机制，根据全限定类名获得某个类的 Class 实例。</p>
<hr>
<h2><span id="什么是反射">什么是反射？</span></h2>
<p>反射是Java中用于动态获取类的属性和方法、动态调用对象的属性和方法的功能</p>
<p>对于任意一个类，都能够知道这个类的所有属性和方法</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性</p>
<hr>
<h2><span id="反射的范围">反射的范围？</span></h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>用来描述类本身</td>
</tr>
<tr>
<td>Packge</td>
<td>用来描述类所属的包</td>
</tr>
<tr>
<td>Field</td>
<td>用来描述类中的属性</td>
</tr>
<tr>
<td>Method</td>
<td>用来描述类中的方法</td>
</tr>
<tr>
<td>Constructor</td>
<td>用来描述类中的构造方法</td>
</tr>
<tr>
<td>Annotation</td>
<td>用来描述类中的注解</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="如何获取class">如何获取Class？</span></h2>
<ol>
<li>Class clazz=class.forName(“包名.类名”)</li>
<li>Class clazz=类名.class;</li>
<li>Class clazz=对象.getClass();</li>
</ol>
<hr>
<h2><span id="17-反射中常用的方法">17. 反射中常用的方法?</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int result=clazz.getModifiers();</td>
<td>获取类的权限修饰符</td>
</tr>
<tr>
<td>string name=clazz.getName()</td>
<td>获取名字</td>
</tr>
<tr>
<td>Packge p=clazz.getPackge()</td>
<td>获取包名</td>
</tr>
<tr>
<td>clazz.getConstructor([String.class]);</td>
<td>寻找clazz中无参数构造方法</td>
</tr>
<tr>
<td>clazz.newInstance([参数])</td>
<td>执行构造方法创建对象</td>
</tr>
<tr>
<td>Field c=clazz.getFields()</td>
<td>获得某个类的所有的公共（public）的字段，包括父类中的字段</td>
</tr>
<tr>
<td>Field c=clazz.getDeclaredFields()</td>
<td>获得某个类的所有声明的字段，即包括public、private和 protected，但是不包括父类的声明字段</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="反射的利与弊">反射的利与弊?</span></h2>
<ol>
<li>
<p>优点：</p>
<ol>
<li>
<p>动态性和灵活性<br>
反射使得程序可以在运行时获取操作类、方法、字段等信息，而不需要在编译时固定类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的全限定名可以配置在xml或properties文件中，便于维护</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="comment">//调用对象方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line">method.invoke(instance);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通用性<br>
反射机制是通用的，适用于任何Java类。这使得您可以编写通用的代码，以处理不同类型的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持第三方插件，用于扩展未知应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printFieldValues</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(field.getName() + <span class="string">&quot;: &quot;</span> + field.get(obj));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>框架和库的实现<br>
反射广泛用于Java框架和库的实现，例如Spring、Hibernate、JUnit等。这些框架需要在运行时获取和操作类信息以提供灵活的功能</p>
</li>
<li>
<p>动态代理<br>
反射允许创建动态代理，用于在运行时生成代理对象以实现特定接口的方法。这对AOP（面向切面编程）非常有用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在方法执行前后执行额外的逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>
<p>性能开销<br>
反射通常比直接调用代码更慢，因为它需要在运行时进行类加载、方法查找方法以及动态调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line">method.invoke(instance);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类型安全问题<br>
使用反射可以绕过编译时类型检查，这可能导致类型安全问题。如果不小心操作对象的类型，可能会引发ClassCastException等异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line"><span class="comment">// 期望 myMethod 返回一个 String，但这是在运行时才知道的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(instance); <span class="comment">// 可能引发ClassCastException</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可维护性问题<br>
由于反射允许操作私有方法和字段，这可能导致代码不可读和难以维护。此外，类结构的更改可能导致反射代码无法正常工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;myField&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(instance, newValue);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安全性问题<br>
反射允许执行敏感操作，可能会导致安全漏洞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;doDangerousOperation&quot;</span>);</span><br><span class="line">method.invoke(instance); <span class="comment">// 可能引发安全问题</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<hr>
<h2><span id="getname-getcanonicalname与getsimplename的区别">getName、getCanonicalName与getSimpleName的区别?</span></h2>
<table>
<thead>
<tr>
<th>getName</th>
<th>getSimpleName</th>
<th>getCanonicalName</th>
</tr>
</thead>
<tbody>
<tr>
<td>类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName</td>
<td>只获取类名</td>
<td>返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了</td>
</tr>
</tbody>
</table>
<hr>
<h1><span id="jdbc">JDBC</span></h1>
<h2><span id="什么是jdbc">什么是JDBC？</span></h2>
<p>熟练度：☆</p>
<ol>
<li>JDBC的全称是Java DataBase Connectivity</li>
<li>它是由一组用Java语言编写的类和接口组成（java.sql 和javax.sql）的标准Java API</li>
<li>用于Java编程语言与数据库连接、执⾏SQL查询，存储过程，并处理返回的结果</li>
<li>JDBC接⼝让Java程序和JDBC驱动实现了松耦合，对于多种关系型数据库提供统一访问，使得切换不同的数据库变得更加简单</li>
</ol>
<hr>
<h2><span id="如何理解classfornamecommysqlcjjdbcdriver">如何理解<code>Class.forName(com.mysql.cj.jdbc.Driver)</code>？</span></h2>
<p>熟练度：☆</p>
<ol>
<li><code>com.mysql.cj.jdbc.Driver</code>是Driver驱动所在的位置</li>
<li><code>Class.forName()</code>是一个反射，但是他没有返回一个Class对象，而是初始化了Driver类，执行其中的静态代码块，即<code>DriverManager.registerDriver(new Driver());</code>注册驱动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="jdbc的drivermanager是用来做什么的">JDBC的DriverManager是用来做什么的？</span></h2>
<p>熟练度：☆</p>
<p>DriverManager是一个工厂类，我们可以通过它来注册JDBC驱动，当JDBC的Driver类被加载进来时，它将被自动注册</p>
<hr>
<h2><span id="说下jdbc连接数据库的6个步骤">说下JDBC连接数据库的6个步骤？</span></h2>
<p>熟练度：☆</p>
<ol>
<li>注册驱动</li>
<li>获取连接</li>
<li>创建一个Statement语句对象</li>
<li>执行SQL语句</li>
<li>处理结果集</li>
<li>关闭资源</li>
</ol>
<hr>
<h2><span id="statement-preparedstatement和callablestatement的区别">Statement 、PreparedStatement和CallableStatement的区别？</span></h2>
<p>熟练度：☆</p>
<table>
<thead>
<tr>
<th>Statement</th>
<th>PreparedStatement</th>
<th>CallableStatement</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般用于执行固定的没有参数的SQL</td>
<td>继承于 Statement，一般用于执行有？参数预编译的SQL语句。可以防止SQL注入，安全性高于Statement</td>
<td>适用于执行存储过程</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="executeexecutequeryexecuteupdate的区别是什么">execute，executeQuery，executeUpdate的区别是什么？</span></h2>
<p>熟练度：</p>
<table>
<thead>
<tr>
<th></th>
<th>execute(String query)</th>
<th>executeQuery(String query)</th>
<th>executeUpdate(String query)</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用</td>
<td>⽤来执⾏任意的SQL查询</td>
<td>⽤来执⾏select查询语句</td>
<td>⽤来执⾏insert或者update/delete（DML）语句</td>
</tr>
<tr>
<td>执行</td>
<td>如果查询的结果是⼀个ResultSet，这个⽅法就返回true。如果结果不是ResultSet，⽐如insert或者update查询，它就会返回false</td>
<td>返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。如果传进来的是insert或者update语句，它会抛出错误信息为“executeQuery method can not be used for update”的java.util.SQLException</td>
<td></td>
</tr>
</tbody>
</table>
<p>当不确定是什么语句的时候才应该使⽤execute()⽅法，否则应该使⽤executeQuery或者executeUpdate⽅法</p>
<hr>
<h2><span id="jdbc中大数据量的分页解决方法">JDBC中大数据量的分页解决方法？</span></h2>
<p>使用sql语句进行分页，每次查询出的结果集中就只包含某页的数据内容</p>
<p>假设一共有38条数据，每页有10条数据，查询第3页的数据</p>
<p><strong>Oracle</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span>,rownum <span class="keyword">as</span> tempid <span class="keyword">from</span> student ) t</span><br><span class="line"><span class="keyword">where</span> t.tempid <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p><strong>mysql</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students limit <span class="number">20</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>sql server</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">10</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">select</span> top <span class="number">20</span> id <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> id) </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="在jdbc编程中处理事务的步骤">在JDBC编程中处理事务的步骤？</span></h2>
<p>事务是作为单个逻辑⼯作单元执⾏的⼀系列操作</p>
<p>⼀个逻辑⼯作单元必须有四个属性，称为原⼦性、⼀致性、隔离性和持久性(ACID) 属性</p>
<p>JDBC处理事务有如下操作：</p>
<ol>
<li>conn.setAutoComit(false);设置提交⽅式为⼿⼯提交。</li>
<li>conn.commit()提交事务。</li>
<li>conn.rollback()回滚事务。</li>
<li>提交与回滚只选择⼀个执⾏。正常情况下提交事务，如果出现异常，则回滚。</li>
</ol>
<hr>
<h2><span id="说说数据库连接池工作原理和实现方案">说说数据库连接池工作原理和实现方案？</span></h2>
<p><strong>数据库连接</strong></p>
<ol>
<li>频繁的进行数据库连接耗时长、占用大量内存资源</li>
<li>对于未能关闭的连接将导致数据库系统的内存泄露，因而不得不重启数据库</li>
<li>创建的数据库连接过多，也可能导致内存泄漏，服务器崩溃</li>
</ol>
<p>因此数据库连接是⼀种关键的、有限的、昂贵的资源，对数据库连接的管理能显著影响到程序的性能指标</p>
<p><strong>数据库连接池</strong></p>
<p>数据库连接池负责分配、管理和释放数据库连接</p>
<p>它允许应⽤程序重复使⽤⼀个现有的数据库连接，⽽不是重新建⽴⼀个</p>
<p>释放空闲时间超过最⼤空闲时间的数据库连接来避免因为没有释放数据库连接⽽引起的数据库连接遗漏</p>
<p>数据库连接池在初始化时将创建⼀定数量的数据库连接放到连接池中，这些数据库连接的数量是由最⼩数据库连接数来设定的</p>
<p>⽆论这些数据库连接是否被使⽤，连接池都将⼀直保证⾄少拥有这么多的连接数量</p>
<p>连接池的最⼤数据库连接数量限定了这个连接池能占有的最⼤连接数，当应⽤程序向连接池请求的连接数超过最⼤连接数量时，这些请求将被加⼊到等待队列中。</p>
<p>其实我们查询完数据库后，如果不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。就避免了一次建立数据库连接和断开的操作时间消耗</p>
<p>解决资源的频繁分配﹑释放所造成的问题。基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据。</p>
<pre><code>①   编写class 实现DataSource 接口

   ②   在class构造器一次性创建10个连接，将连接保存LinkedList中

   ③   实现getConnection  从 LinkedList中返回一个连接

   ④   提供将连接放回连接池中方法
</code></pre>
<p>**工作原理：**JAVA EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</p>
<p>**实现方案：**返回的Connection是原始Connection的代理，代理Connection的close方法，当调用close方法时，不是真正关连接，而是把它代理的Connection对象放回到连接池中，等待下一次重复利用。</p>
<hr>
<h2><span id="jdbc规范使用到设计模式">jdbc规范使用到设计模式？</span></h2>
<p>桥接模式，首先DriverManager获得Connection是通过反射和类加载机制从数据库驱动包的driver中拿到连接，所以这里真正参与桥接模式的是driver，而DriverManager和桥接模式没有关系，DriverManager只是对driver的一个管理器。而我们作为使用者只去关心Connection，不会去关心driver，因为我们的操作都是通过操作Connection来实现的。这样分析下来这个桥接就清晰了逻辑——java.sql.Driver作为抽象桥类，而驱动包如com.mysql.jdbc.Driver具体的实现桥接类，而Connection是被桥接的对象。</p>
<hr>
<h2><span id="jdbc的事务管理是什么为什么需要它">JDBC的事务管理是什么，为什么需要它？</span></h2>
<p>默认情况下，我们创建的数据库连接，是工作在自动提交的模式下的。这意味着只要我们执行完一条查询语句，就会自动进行提交。因此我们的每条查询，实际上都是一个事务，如果我们执行的是DML或者DDL，每条语句完成的时候，数据库就已经完成修改了。有的时候我们希望由一组SQL查询组成一个事务，如果它们都执行OK我们再进行提交，如果中途出现异常了，我们可以进行回滚。<br>
JDBC接口提供了一个setAutoCommit(boolean flag)方法，我们可以用它来关闭连接自动提交的特性。我们应该在需要手动提交时才关闭这个特性，不然的话事务不会自动提交，每次都得手动提交。数据库 通过表锁来管理事务，这个操作非常消耗资源。因此我们应当完成操作后尽快的提交事务。在这里有更多关于事务的示例程序。</p>
<hr>
<h2><span id="jdbc里的clob和blob数据类型分别代表什么">JDBC里的CLOB和BLOB数据类型分别代表什么？</span></h2>
<p>CLOB意思是Character Large OBjects，字符大对象，它是由单字节字符组成的字符串数据，有自己专门的代码页。这种数据类型适用于存储超长的文本信息，那些可能会超出标准的VARCHAR数据类型长度限制（上限是32KB）的文本。<br>
BLOB是Binary Larget OBject，它是二进制大对象，由二进制数据组成，没有专门的代码页。它能用于存储超过VARBINARY限制（32KB）的二进制数据。这种数据类型适合存储图片，声音，图形，或者其它业务程序特定的数据。</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2><span id="为什么引入进程的概念">为什么引入进程的概念？</span></h2>
<p>- 从理论角度看，是对正在运行的程序过程的抽象<br>
 - 从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序</p>
<h2><span id="什么是程序">什么是程序？</span></h2>
<ul>
<li>程序是用于完成某个指定任务的指令集合</li>
<li>是一段静态的代码</li>
</ul>
<h2><span id="什么是进程">什么是进程？</span></h2>
<ul>
<li>进程就是一段程序的执行过程（内存中正在运行的应用程序）</li>
</ul>
<h2><span id="进程有怎么样的特征">进程有怎么样的特征？</span></h2>
<ul>
<li>动态性：相比于静态的程序，进程是一段程序的执行过程，包括了进程从创建、运行到消亡的过程（生命周期）</li>
<li>独立性：进程是操作系统调度和资源分配的最小单位（系统运行的基本单位），系统在运行时为每个进程分配不同的内存（进程间的内存不共享导致相互数据交换和通信的成本高）</li>
<li>并发性：任何进程都可以同其他进程一起并发执行，现代操作系统大多都支持多进程</li>
<li>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果； 但是执行过程中，程序不能发生改变</li>
</ul>
<h2><span id="什么是线程">什么是线程？</span></h2>
<p>进程进一步细化为线程，是程序内部的一条执行路径，一个进程中至少有一个线程</p>
<p>是CPU调度和执行的最小单位</p>
<p>线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源（程序计数器(PC)、虚拟机栈和本地方法栈），但它可与同属一个进程的其它线程共享进程所拥有的全部资源（内存单元）</p>
<p><img src="https://pic.imgdb.cn/item/665193bbd9c307b7e9992370.png" alt></p>
<p>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行</p>
<h2><span id="进程和线程的区别">进程和线程的区别？</span></h2>
<ul>
<li>进程是正在运行中的程序，是系统进行资源调度和分配的的基本单位；线程是进程的子任务，是任务调度和执行的基本单位</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在</li>
<li>进程在执行过程中拥有独立的内存单元，而线程不拥有系统资源，但可以与同属于一个进程的其他线程共享进程的全部资源</li>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>
<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li>
<li>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销</li>
<li>每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文</li>
</ul>
<hr>
<h2><span id="什么是并行-并发">什么是并行、并发？</span></h2>
<ul>
<li>
<p>并行：两个或以上的事件在同一时刻发生（在同一时刻有多条CPU指令在多个CPU上同时执行）</p>
<p><img src="https://pic.imgdb.cn/item/66519c89d9c307b7e9a40d34.png" alt></p>
</li>
<li>
<p>并发：两个或以上的事件在同一时间段内发生（在一段时间内有多条CPU指令在一个CPU上快速轮换、交替），宏观上具有多个进程同时执行的效果</p>
<p><img src="https://pic.imgdb.cn/item/66519ca5d9c307b7e9a432d3.png" alt></p>
</li>
</ul>
<hr>
<h2><span id="什么是多进程-多线程">什么是多进程、多线程？</span></h2>
<ul>
<li>多进程是指操作系统能同时运行多个任务（程序）</li>
<li>多线程是指在同一程序中有多个顺序流在执行（一个进程同一时间并行执行多个线程）</li>
</ul>
<p>那什么是多线程？提到多线程这里要说两个概念，就是串行和并行</p>
<p>所谓串行，其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子：当我们下载多个文件时，在串行中它是按照一定的顺序去进行下载的，也就是说，必须等下载完A之后才能开始下载B，它们在时间上是不可能发生重叠的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/df594ffe5bcceb97c4f7796f50baa006.png" alt="640"></p>
<p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的，在同一时刻发生的，并行在时间上是重叠的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/23c3fbc0f394789e150fdf8781cafadd.png" alt="640"></p>
<p>举个例子，我们打开腾讯管家，腾讯管家本身就是一个程序，也就是说它就是一个进程，它里面有很多的功能，能查杀病毒、清理垃圾、电脑加速等众多功能。</p>
<p>按照单线程来说，无论你想要清理垃圾、还是要病毒查杀，那么你必须先做完其中的一件事，才能做下一件事，这里面是有一个执行顺序的。</p>
<p>如果是多线程的话，我们其实在清理垃圾的时候，还可以进行查杀病毒、电脑加速等等其他的操作，这个是严格意义上的同一时刻发生的，没有执行上的先后顺序</p>
<h2><span id="什么是线程安全">什么是线程安全？</span></h2>
<p>当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的</p>
<p>确保在多条线程访问同一个方法时，程序是否还能按照预期的行为执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    count ++;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启3条线程，每个线程循环10次执行以上方法，得到以下结果：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ceb145de48e6c58699c65b55c909804b.png" alt="640"></p>
<p>我们可以看到，这里出现了两个26，出现这种问题的原因有很多。</p>
<p>最常见的一种，就是我们A线程在进入方法后，拿到了count的值，刚把这个值读取出来，还没有改变count的值的时候，结果线程B也进来的，那么导致线程A和线程B拿到的count值是一样的。</p>
<p>Java中确保线程安全最常用的两种方式。先来看段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">    j = j + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家觉得这段代码是线程安全的吗？</p>
<p>毫无疑问，它绝对是线程安全的，我们来分析一下，为什么它是线程安全的？</p>
<p>我们可以看到这段代码是没有任何状态的，就是说我们这段代码，不包含任何的作用域，也没有去引用其他类中的域进行引用，它所执行的作用范围与执行结果只存在它这条线程的局部变量中，并且只能由正在执行的线程进行访问。当前线程的访问，不会对另一个访问同一个方法的线程造成任何的影响。</p>
<p>两个线程同时访问这个方法，因为没有共享的数据，所以他们之间的行为，并不会影响其他线程的操作和结果，所以说无状态的对象，也是线程安全的。</p>
<p><strong>添加一个状态呢？</strong></p>
<p>如果我们给这段代码添加一个状态，添加一个count，来记录这个方法并命中的次数，每请求一次count+1，那么这个时候这个线程还是安全的吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;   </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 记录方法的命中次数   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;  </span><br><span class="line">        count++ ;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;      </span><br><span class="line">        j = j + i;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显已经不是了，单线程运行起来确实是没有任何问题的，但是当出现多条线程并发访问这个方法的时候，问题就出现了，我们先来分析下count+1这个操作。</p>
<p>进入这个方法之后首先要读取count的值，然后修改count的值，最后才把这把值赋值给count，总共包含了三步过程：“读取”一&gt;“修改”一&gt;“赋值”，既然这个过程是分步的，那么我们先来看下面这张图，看看你能不能看出问题：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b32fdb479959903bf9dd76408b2867c1.png" alt="640?"></p>
<p>可以发现，count的值并不是正确的结果，当线程A读取到count的值，但是还没有进行修改的时候，线程B已经进来了，然后线程B读取到的还是count为1的值，正因为如此所以我们的count值已经出现了偏差，那么这样的程序放在我们的代码中，是存在很多的隐患的。</p>
<h2><span id="如何确保线程安全">如何确保线程安全？</span></h2>
<p>synchronized关键字</p>
<ul>
<li>
<p>控制线程同步的，保证我们的线程在多线程环境下，不被多个线程同时执行，确保我们数据的完整性</p>
</li>
<li>
<p>当synchronized锁住一个对象之后，别的线程如果想要获取锁对象，那么就必须等这个线程执行完释放锁对象之后才可以，否则一直处于等待状态</p>
</li>
<li>
<p>要注意缩小synchronized的使用范围，如果随意使用时很影响程序的性能，别的对象想拿到锁，结果你没用锁还一直把锁占用，这样就有点浪费资源</p>
</li>
<li>
<p>使用方法一般是加在方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 记录方法的命中次数  </span></span><br><span class="line">    <span class="comment">// 锁的是括号里的对象，而不是代码，其次，对于非静态的synchronized方法，锁的是对象本身也就是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;    </span><br><span class="line">        count++ ;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;    </span><br><span class="line">        j = j + i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Lock</p>
<ul>
<li>从Java1.6开始引入Lock，Lock的引入让锁有了可操作性，就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// ReentrantLock是Lock的子类   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span>&#123;    </span><br><span class="line">    lock.lock(); </span><br><span class="line">    <span class="comment">// 获取锁对象  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        <span class="comment">// Thread.sleep(2000);    </span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;       </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);     </span><br><span class="line">        lock.unlock(); <span class="comment">// 手动释放锁对象，无论如何都会执行    </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="type">LockTest</span> <span class="variable">lockTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockTest</span>();    </span><br><span class="line">    <span class="comment">// 线程1     </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;     </span><br><span class="line">        <span class="meta">@Override</span>         </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;      </span><br><span class="line">            <span class="comment">// Thread.currentThread()  返回当前线程的引用     </span></span><br><span class="line">            lockTest.method(Thread.currentThread());      </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);    </span><br><span class="line">    <span class="comment">// 线程2   </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;   </span><br><span class="line">        <span class="meta">@Override</span>   </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;      </span><br><span class="line">            lockTest.method(Thread.currentThread());   </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);   </span><br><span class="line">    t1.start();     </span><br><span class="line">    t2.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e508507c0b74d1503d6d1a75b5668cf7.png" alt="640?"></p>
<p>其实在Lock还有几种获取锁的方式，我们这里再说一种，就是tryLock()这个方法跟Lock()是有区别的，Lock在获取锁的时候，如果拿不到锁，就一直处于等待状态，直到拿到锁，但是tryLock()却不是这样的，tryLock是有一个Boolean的返回值的，如果没有拿到锁，直接返回false，停止等待，它不会像Lock()那样去一直等待获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span>&#123;     </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象   </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;    </span><br><span class="line">        <span class="keyword">try</span> &#123;          </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);    </span><br><span class="line">            <span class="comment">// Thread.sleep(2000);      </span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;     </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);      </span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 释放锁对象    </span></span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：我们继续使用刚才的两个线程进行测试可以发现，在线程t1获取到锁之后，线程t2立马进来，然后发现锁已经被占用，那么这个时候它也不在继续等待。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a2997ff879b806a31a0d8debcaae457b.png" alt="640?"></p>
<p>似乎这种方法，感觉不是很完美，如果我第一个线程，拿到锁的时间，比第二个线程进来的时间还要长，是不是也拿不到锁对象？</p>
<p>那我能不能，用一中方式来控制一下，让后面等待的线程，可以等待5秒，如果5秒之后，还获取不到锁，那么就停止等，其实tryLock()是可以进行设置等待的相应时间的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象      </span></span><br><span class="line">    <span class="comment">// 如果2秒内获取不到锁对象，那就不再等待       </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>,TimeUnit.SECONDS)) &#123;         </span><br><span class="line">        <span class="keyword">try</span> &#123;              </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);    </span><br><span class="line">            <span class="comment">// 这里睡眠3秒            </span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);         </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;             </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;             </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);    </span><br><span class="line">            lock.unlock(); </span><br><span class="line">            <span class="comment">// 释放锁对象  </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：看上面的代码，我们可以发现，虽然我们获取锁对象的时候，可以等待2秒，但是我们线程t1在获取锁对象之后，执行任务缺花费了3秒，那么这个时候线程t2是不在等待的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2034afb57a67bb10615cd4002d887abc.png" alt="640?"></p>
<p>我们再来改一下这个等待时间，改为5秒，再来看下结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException &#123;   </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象     </span></span><br><span class="line">    <span class="comment">// 如果5秒内获取不到锁对象，那就不再等待     </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS)) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;             </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;         </span><br><span class="line">            e.printStackTrace();         </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;           </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);  </span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 释放锁对象    </span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：这个时候我们可以看到，线程t2等到5秒获取到了锁对象，执行了任务代码。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1df3ef93e83b5c5fd84c100c15a0b8ef.png" alt="640?"></p>
<p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p>
<p>在Java中，一个应用程序可以包含多个线程。每个线程执行特定的任务，并可与其他线程并发执行多线程使系统的空转时间最少，提高CPU利用率、多线程编程环境用方便的模型隐藏CPU在任务间切换的事实在Java程序启动时，一个线程立刻运行，该线程通常称为程序的主线程。</p>
<p>主线程的重要性体现在两个方面：</p>
<p>1、它是产生其他子线程的线程。</p>
<p>2、通常它必须最后完成执行，因为它执行各种关闭动作。</p>
<p>进程和线程的关系：</p>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源</li>
<li>处理机分给线程，即真正在处理机上运行的是线程</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体</li>
</ul>
<hr>
<h2><span id="为什么要使用多线程呢">为什么要使用多线程呢?</span></h2>
<p>我们现在所使用操作系统都是多任务操作系统(早期使用的DOS操作系统为单任务操作系统)，多任务操作指在同一时刻可以同时做多件事(可以同时执行多个程序)。<br>
多进程:每个程序都是一个进程，在操作系统中可以同时执行多个程序,多进程的目的是为了有效的使用CPU资源，每开一个进程系统要为该进程分配相关的系统资源(内存资源)；<br>
多线程:线程是进程内部比进程更小的执行单元(执行流|程序片段),每个线程完成一个任务,每个进程内部包含了多个线程每个线程做自己的事情，在进程中的所有线程共享该进程的资源；<br>
主线程:在进程中至少存在一个主线程，其他子线程都由主线程开启,主线程不一定在其他线程结束后结束，有可能在其他线程结束前结束。Java中的主线程是main线程,是Java的main函数;</p>
<hr>
<h2><span id="多线程应用场景">多线程应用场景?</span></h2>
<p>当应用场景为计算密集型时：为了将每个cpu充分利用起来，线程数量正常是cpu核数+1，还可以看jdk的使用版本，1.8版本中可以使用cpu核数*2。<br>
当应用场景为io密集型时：做web端开发的时候，涉及到大量的网络传输，不进入持，缓存和与数据库交互也会存在大量io，当发生io时候，线程就会停止，等待io结束，数据准备好，线程才会继续执行，所以当io密集时，可以多创建点线程，让线程等待时候，其他线程执行，更高效的利用cpu效率，他有一个计算公式，套用公式的话，双核cpu理想的线程数就是20。</p>
<hr>
<h2><span id="多线程的好处">多线程的好处?</span></h2>
<p>采用多线程技术的应用程序可以更好地利用系统资源。主要优势在于充分利用了CPU的空闲时间片，用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。</p>
<ul>
<li>易于调度</li>
<li>提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分</li>
<li>开销少。创建线程比创建进程要快，所需开销很少</li>
<li>利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行</li>
</ul>
<p>使用线程可以把占据时间长的程序中的任务放到后台去处理<br>
用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>
程序的运行速度可能加快<br>
在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。<br>
多线程技术在IOS软件开发中也有举足轻重的位置。<br>
多线程的缺点</p>
<ul>
<li>提高应用程序的响应。如图形化界面，可增强用户的体验</li>
<li>提高计算机CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程独立运行，利于理解和修改</li>
</ul>
<hr>
<h2><span id="使用多线程可能带来什么问题">使用多线程可能带来什么问题?</span></h2>
<p>如果有大量的线程可能会降低程序的运行速度，可能发生内存泄露、死锁、线程不安全等等问题</p>
<hr>
<h2><span id="多核cpu的效率会是单核cpu的倍数吗">多核CPU的效率会是单核CPU的倍数吗？</span></h2>
<ul>
<li>多个和核心有其他共享资源的限制：如cache、寄存器没有同步扩充</li>
<li>多核CPU之间的协调管理损耗</li>
</ul>
<hr>
<h2><span id="创建线程的几种方式">创建线程的几种方式？</span></h2>
<ul>
<li>继承于Thread类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//重写Thread类的run()---&gt;将此线程要执行的操作声明在run()中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//业务逻辑:获取当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Thread类的子类对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//通过start方法调用当前线程的run方法</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现Runnable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个类去实现Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//实现类去重写run()</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//业务逻辑:获取当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建实现类的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//将此对象作为参数传递到Thread类中的构造器中,创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//通过start方法调用当前线程的run方法</span></span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现Callable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创接一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">// 2.实现call方法,将此线程需要执行的操作声明在call()中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//业务逻辑:获取当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">// 4.将此对象作为传递到FutureTask构造器中,创建FutureTask的对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">// 5.将FutureTask的对象传递到Thread的构造器中,创建Thread对象并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//get()得到的即为线程重写方法的返回值</span></span><br><span class="line">		   <span class="comment">// 6.如果对返回值感兴趣可以用该Object sum = FutureTask的对象.get();</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span>+sum);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个类实现Runable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnalbe</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现类中重写run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个类实现Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现类中重写call()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//3.提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.<span class="keyword">new</span> <span class="title class_">FixedThreadPool</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//设置线程的属性</span></span><br><span class="line">        service.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line">        <span class="comment">//4.创建实现类的对象</span></span><br><span class="line">        <span class="type">NumberThread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberThread1</span>();</span><br><span class="line">        <span class="comment">//5.执行指定的线程操作</span></span><br><span class="line">        service.execute(thread1);<span class="comment">//适合用与Runnalbe</span></span><br><span class="line">        <span class="comment">//6.关闭线程</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());<span class="comment">//适合用于Callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="创建线程用runnable还是thread">创建线程用Runnable还是Thread？</span></h2>
<p>共同点：</p>
<ul>
<li>启动线程使用的都是Thread类中定义的start()方法</li>
<li>创建线程的对象，都是Thread的子类或Thread的实现类</li>
</ul>
<p>不同点：</p>
<ul>
<li>一个是继承类，一个是实现接口</li>
<li>相比与Java只支持单继承，实现Runnable没有单继承的局限</li>
<li>实现Runnable更适合处理有共享数据的问题</li>
<li>实现Runnbale能够分离代码和数据</li>
</ul>
<p>联系：</p>
<ul>
<li>public class Thread implements Runnable  （代理模式）</li>
</ul>
<hr>
<h2><span id="实现runnable接口和callable接口的区别">实现Runnable接口和Callable接口的区别？</span></h2>
<table>
<thead>
<tr>
<th>区别</th>
<th>Runnalbe</th>
<th>Callable</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法</td>
<td>run()</td>
<td>call()</td>
</tr>
<tr>
<td>返回值</td>
<td>没有返回值，void类型</td>
<td>必须有一个返回值，且能通过泛型指定</td>
</tr>
<tr>
<td>异常处理</td>
<td>无法对run()方法抛出的异常进行任何处理</td>
<td>自定义的call()方法可以抛出一个checked Exception，并由其执行者Handler进行捕获并处理</td>
</tr>
<tr>
<td>使用场景</td>
<td>适用于不需要返回值，且不会抛出checked Exception的情况，比如简单的打印输出或者修改一些共享的变量</td>
<td>适用于那些需要返回值或者需要抛出checked Exception的情况，比如对某个任务的计算结果进行处理，或者需要进行网络或IO操作等。常常使用Callable来实现异步任务的处理，以提高系统的吞吐量和响应速度</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="线程的-run和-start有什么区别">线程的 run()和 start()有什么区别？</span></h2>
<table>
<thead>
<tr>
<th>调用该方法时的区别</th>
<th>run()</th>
<th>start()</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否创建新的线程</td>
<td>在当前线程中执行run()方法中的代码，不会创建新的线程，相当于普通方法</td>
<td>会创建一个新线程去执行run()方法中的代码，因此start方法用来启动相应的线程</td>
</tr>
<tr>
<td>是否能重复调用</td>
<td>可以重复调用</td>
<td>启动后无法重复调用，否则会报IllegalStateException异常</td>
</tr>
<tr>
<td>同步或异步</td>
<td>同步调用run()方法，因此不支持多线程</td>
<td>异步地调用run()方法，支持多线程</td>
</tr>
</tbody>
</table>
<p>使用时调用线程的 start() 方法后，线程处于可运行状态，此时它可以由 JVM 调度并执行，这并不意味着线程就会立即运行;<br>
run() 方法是线程运行时由 JVM 回调的方法，无需手动写代码调用</p>
<hr>
<h2><span id="说说线程的生命周期和状态">说说线程的生命周期和状态?</span></h2>
<p><img src="https://pic.imgdb.cn/item/66521814d9c307b7e93bce26.png" alt></p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220830/1661828121@6f4fc75b826c73cf923e44f0f1abfd3d.jpg" alt="img"></p>
<p><img src="https://pic.imgdb.cn/item/6652183fd9c307b7e93bfa6a.png" alt></p>
<ul>
<li>
<p>创建状态（New）：新创建了一个线程对象</p>
</li>
<li>
<p>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权</p>
</li>
<li>
<p>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码</p>
</li>
<li>
<p>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态</p>
<p>阻塞的情况分三种：</p>
<ul>
<li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li>
</ul>
</li>
<li>
<p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期</p>
</li>
</ul>
<hr>
<h2><span id="什么是上下文切换">什么是上下文切换?</span></h2>
<p>上下文切换指的是内核操作系统的核心在CPU上对进程或者线程进行切换</p>
<p>在多线程编程中，一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式</p>
<p>当一个线程执行完 CPU 时间片时，就会退回就绪状态，并切换其他的线程，这个过程就是进行了一次上下文切换</p>
<hr>
<h2><span id="如何创建守护线程">如何创建守护线程？</span></h2>
<p>通过Thread类的setDaemon(true)方法将线程设置为守护线程，但是要在线程启动（start方法）前调用，否则抛出IllegalThreadStateException异常</p>
<hr>
<h2><span id="用户线程和守护线程有什么区别">用户线程和守护线程有什么区别？</span></h2>
<ul>
<li>用户线程是虚拟机启动的线程中的普通线程，当所有用户线程结束运行后，虚拟机才会停止运行（守护线程自动关闭）</li>
<li>守护线程是在程序中创建的线程，它的作用是为其他线程提供服务。当所有的用户线程结束运行后，守护线程也会随之结束，而不管它是否执行完毕。守护线程通常用于执行一些辅助性任务，如垃圾回收、缓存清理等，它们不需要等待所有的任务完成后再退出</li>
<li>一个守护线程创建的子线程依然是守护线程</li>
</ul>
<hr>
<h2><span id="为什么thread类的sleep和yield方法是静态的">为什么Thread类的sleep()和yield()方法是静态的？</span></h2>
<p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<p>首先明确一点，在一个线程拿到锁的时候，其他线程向拿到锁就必须要等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepYield</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">                thread1.<span class="keyword">yield</span>();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; have finished.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>假设yield()为非静态方法，若thread2拿到锁，调用了thread1的yield()方法，意为让thread1暂时放弃当前占有的CPU时间片，与大家一起再进行时间片竞争。关键是thread1现在处于阻塞状态！它在等待thread2释放锁，它根本没有占用CPU时间片。所以此时调用thread1的yield()方法是没有意义的！<br>
sleep()方法道理类似，本来就是阻塞状态，所以没必要再阻塞，即使“自然阻塞状态”比如是10ms，你设置了100ms，而“自然阻塞状态”持续时间是无法预测的，所以设定的休眠时间便失去了意义！<br>
而对于单线程而言，即使没有锁的争夺，在一个线程执行的时候另外一个线程也处于“不占有CPU时间片的状态”，什么时候再拿到时间片或者多长时间竞争一次CPU时间片都是无法预测的。所以在正在执行的线程里调用另外一个线程的yield()和sleep()方法依然是没有意义的。<br>
ps:有人可能会问怎么没有列举线程调用自己的实例方法来yield或者sleep的情况呢？<br>
答：调用自己的实例方法跟调用类方法效果是一样的，所以不用考虑这种情况。</p>
<hr>
<h2><span id="多线程的常用方法">多线程的常用方法？</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>start()</td>
<td>启动线程，并执行线程的 run() 方法</td>
</tr>
<tr>
<td>run()</td>
<td>线程在被调度时执行的方法，子线程执行的业务逻辑放在该方法体中</td>
</tr>
<tr>
<td>currentThread()</td>
<td>返回当前线程 。在Thread子类中就是this ，通常用于主线程和Runnable 实现类</td>
</tr>
<tr>
<td>setName(String)</td>
<td>设置线程的名称</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回线程的名称</td>
</tr>
<tr>
<td>sleep(long millis)</td>
<td>睡眠指定时间，程序暂停运行，睡眠期间会让出CPU的执行权，去执行其它线程，同时CPU也会监视睡眠的时间，一旦睡眠时间到就会立刻执行(因为睡眠过程中仍然保留着锁，有锁只要睡眠时间到就能立刻执行)（强迫一个线程睡眠N毫秒）</td>
</tr>
<tr>
<td>yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程（线程让步）</td>
</tr>
<tr>
<td>join(long millis)</td>
<td>等待该线程终止的时间最长为 millis 毫秒。join()方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行。注意该方法也需要捕捉异常（等待线程终止）</td>
</tr>
<tr>
<td>isAlive()</td>
<td>测试线程是否处于活动状态，线程调用start后，即处于活动状态</td>
</tr>
<tr>
<td>getPriority()</td>
<td>获取当前线程优先值（优先级取值范围[1,10]，默认为5）</td>
</tr>
<tr>
<td>setPriority (int newPriority)</td>
<td>设置当前线程优先级<br>线程优先级高，被CPU调度的概率大，但不代表一定会运行，还有小概率运行优先级低的线程。</td>
</tr>
<tr>
<td>interrupt()</td>
<td>中断线程，由运行状态到死亡状态</td>
</tr>
<tr>
<td>wait()</td>
<td>一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。而当前线程排队等候其他线程调用notify() 或 notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行（强迫一个线程等待）</td>
</tr>
<tr>
<td>notify()</td>
<td>一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个（通知一个线程继续执行）</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>一旦执行此方法，就会唤醒所有被wait的线程（所有线程继续执行）</td>
</tr>
</tbody>
</table>
<p>过时的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop()</td>
<td>强制线程生命周期结束，已经废止</td>
</tr>
<tr>
<td>suspend()/resume()</td>
<td>可能死锁，已经废止</td>
</tr>
</tbody>
</table>
<p><strong>yield() 和 sleep() 的异同</strong></p>
<p>相同点：yield() 方法和 sleep() 方法类似，也不会释放“锁”。</p>
<p>不同点：yield() 方法只是使当前线程重新回到可执行状态，所以执行 yield()的线程有可能在进入到可执行状态后马上又被执行。 yield() 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep()方法不同。</p>
<p><strong>join() 和 sleep() 的异同</strong></p>
<p>相同点：都可以实现等待<br>
不同点：由于join的内部实现是wait()，所以使用join()方法时会释放锁，那么其他线程就可以调用此线程的同步方法了。<br>
sleep() 方法不释放锁，因此线程会一直等待下去，直到任务完成，才会释放锁。</p>
<p><strong>sleep() 与 wait() 的异同</strong></p>
<p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>
不同点：<br>
（1） 两个方法声明的位置不同：Thread类中声明sleep() ,<br>
Object类中声明wait()<br>
（2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中<br>
（3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。<br>
（4）当调用某一对象的 wait() 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify() 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll() 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</p>
<hr>
<h2><span id="如何在-windows-和-linux-上查找哪个线程cpu利用率最高">如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</span></h2>
<p>Windows系统下执行java  -jar  arthas-boot.jar<br>
Linux系统下解压arthas，执行ps  -ef  |  grep  java找出java进程pid数字</p>
<hr>
<h2><span id="为什么我们调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></h2>
<ul>
<li>创建线程，即线程进入新建状态</li>
<li>调用线程的start()方法，将启动线程并使线程进入就绪状态</li>
<li>当分配到时间片后就开始运行run()方法，线程进入运行状态，从而实现多线程</li>
</ul>
<p>而直接调用run()方法只是将run()方法作为主线程下的普通方法执行，并不会在其他线程中执行</p>
<hr>
<h2><span id="什么是-callable-和-future">什么是 Callable 和 Future?</span></h2>
<p>Callable和Future是Java并发包中用于支持并发编程的两个接口。它们通常与ExecutorService（线程池）一起使用，用于执行具有返回值的任务，并在任务执行完成后获取结果或取消任务。</p>
<p>Callable 接口<br>
Callable是一个接口，类似于Runnable接口，但是它有返回值，并且可以抛出异常。Callable定义了一个带有泛型的call方法，该方法返回一个结果并可能抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 执行一些耗时的任务，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future 接口</p>
<p>Future接口用于表示异步计算的结果，它提供了一些方法来检查计算是否完成、等待计算完成并获取结果，以及取消计算等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(callable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取结果</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Future通过get方法等待任务执行完成，并获取返回结果。如果任务还未完成，get方法会阻塞当前线程，直到任务完成为止。</p>
<p>组合使用：<br>
Callable和Future通常一起使用，通过submit方法提交Callable任务给ExecutorService，然后通过返回的Future对象来管理任务的执行和获取结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(callable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 阻塞等待任务执行完成，并获取结果</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<p>​        总的来说，Callable和Future提供了一种更灵活的方式来处理并发任务的执行和获取结果，尤其适用于需要在任务执行完成后获取结果的情况。</p>
<ul>
<li>Callable接口类似于Runnable</li>
<li>Runnable不会返回结果，并且无法抛出返回结果的异常；而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到</li>
<li>Future可以拿到异步执行任务的返回值。可以认为是带有返回值的Runnable.Future接口表示异步任务，是还没有完成的任务给出的未来结果</li>
<li>所以说Callable用于产生结果，Future用于获取结果</li>
</ul>
<hr>
<h2><span id="线程调度策略有哪些">线程调度策略有哪些？</span></h2>
<p><strong>抢占式调度(Preemptive Scheduling)</strong></p>
<ul>
<li>Java运行时系统采用抢占式调度策略</li>
<li>Java运行时系统让优先级高的线程以较大的概率使用CPU，如果线程优先级相同则随机选择（简单的、非抢占式的轮转的调度顺序）</li>
</ul>
<p>操作系统根据线程的优先级和时间片来决定当前运行的线程。当时间片用完或更高优先级的线程就绪时，当前线程会被抢占并让出CPU资源</p>
<p><strong>时间片轮转调度(Round-Robin Scheduling)</strong></p>
<ul>
<li>所有线程轮流使用CPU，并且平均分配每个线程占用CPU的时间</li>
<li>从所有处于就绪状态的线程中选择优先级最高的线程分配一定的CPU时间运行。该时间过后再选择其他线程运行</li>
<li>只有当线程运行结束、放弃(yield)CPU或由于某种原因进入阻塞状态，低优先级的线程才有机会执行</li>
<li>如果有两个优先级相同的线程都在等待CPU，则调度程序以轮转的方式选择运行的线程</li>
</ul>
<p>每个线程被分配一个固定的时间片(通常是几毫秒)，线程在该时间片内运行。当时间片用完后，操作系统会将当前线程放到就绪队列的尾部，并选择下一个就绪线程执行</p>
<p><strong>优先级调度(Priority Scheduling)</strong></p>
<ul>
<li>根据线程的优先级来决定线程的调度顺序</li>
<li>较高优先级的线程会优先执行，而较低优先级的线程会等待</li>
<li>优先级可以由开发人员手动设置，操作系统也可以根据一些策略自动调整线程的优先级</li>
</ul>
<p><strong>公平调度(Fair Scheduling)</strong></p>
<ul>
<li>试图确保每个线程都能公平地分享CPU资源</li>
<li>所有线程按照其就绪的顺序获得CPU时间。这意味着较长等待的线程会更早地获得执行机会</li>
</ul>
<hr>
<h2><span id="java中用到的线程调度算法是什么">Java中用到的线程调度算法是什么？</span></h2>
<p>在Java中，线程调度的算法是由操作系统负责的，Java虚拟机(JVM)只是利用操作系统提供的调度机制来实现线程调度。因此，Java中使用的线程调度算法由底层操作系统决定，Java虚拟机无法直接控制或修改这些算法。Java中的线程调度方法(如Thread.yield()、Thread.sleep()和Object.wait()等)主要用于协调线程之间的交互和同步，而不是直接控制线程的调度</p>
<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<hr>
<h2><span id="什么是线程调度器和时间分片">什么是线程调度器和时间分片？</span></h2>
<p><strong>线程调度器(Thread Scheduler)</strong></p>
<ul>
<li>是操作系统内核中的一个组件，负责为就绪状态的线程分配并管理CPU时间，控制多线程程序的执行顺序</li>
<li>当有多个线程同时运行时，线程调度器会在这些线程之间进行切换，使得每个线程都有机会使用 CPU 资源，并实现任务的并发执行</li>
<li>线程调度并不受到 Java 虚拟机控制，因此需减少程序对线程优先级的依赖</li>
</ul>
<p><strong>时间分片（Time Slicing）</strong></p>
<ul>
<li>指将可用的 CPU 时间分配给可用的 Runnable 线程的过程</li>
<li>分配 CPU 时间可以基于线程优先级或者线程等待的时间，确保每个线程都能获得一定的运行时间，从而实现多任务并发执行</li>
</ul>
<hr>
<h2><span id="为什么-wait-要放在同步代码块中">为什么 wait() 要放在同步代码块中？</span></h2>
<p>同步方法就是在方法前加关键字 synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待；防止在 cpu 切换线程的时候，其它线程先执行了notify() ，后执行 wait() ，线程永远无法被唤醒， 所以要将wait() 放在同步代码块。</p>
<hr>
<h2><span id="说说-sleep-方法和-wait-方法区别和共同点">说说 sleep() 方法和 wait() 方法区别和共同点?</span></h2>
<p><strong>共同点</strong></p>
<ul>
<li>都是使当前线程进入休眠状态，即暂停线程的执行</li>
<li>都可以响应<strong>interrupt</strong>中断，也就是说在线程调用方法进入休眠状态后，如果收到中断信号，都可以进行响应并中断，且都可以抛出InterruptException 异常</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>所属类不同：sleep() 方法属于 Thread 类的静态方法，而 wait() 方法属于Object类。</li>
<li>唤醒方式不同：sleep() 方法必须传递一个超时时间的参数，过了这个时间后线程就会自动唤醒，进入就绪状态； 而 wait() 方法可以不传递参数，此时线程会进入永久休眠，直到另一个线程调用notify() 方法或者 notifyAll() 方法之后，休眠的线程才会被唤醒。也就是说sleep() 方法可以 主动唤醒，而不传参的wait() 方法只能被动唤醒</li>
<li>语法使用不同：</li>
<li>释放锁资源不同：在线程调用 wait() 方法时，线程会主动释放锁并进入等待状态； 而线程在调用sleep() 方法时，线程不会释放锁</li>
<li>线程进入状态不同：<br>
线程调用sleep() 方法会进入 TIMED_WAITING 有时限等待状态；而调用无参数的wait() 方法，线程会进入 WAITING 无时<br>
限等待状态</li>
<li>wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行</li>
</ul>
<hr>
<h2><span id="为什么-wait-定义在-object-里而不是-thread类里">为什么 wait() 定义在 object 里，而不是 Thread类里？</span></h2>
<p>Java 的锁是对象级别的锁，而不是线程级别，所以 wait()是 Object 的方法。 sleep() 是线程级别的，所以存在于Thread 类中</p>
<hr>
<h2><span id="为什么线程通信的方法-wait-notify和-notifyall被定义在-object-类里">为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</span></h2>
<p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法</p>
<p>因为这些方法的调用是依赖锁对象，而同步代码块的锁对象是任意。锁而Object代表任意的对象，所以定义在这里面。</p>
<hr>
<h2><span id="thread-类中的-yield-方法有什么作用">Thread 类中的 yield 方法有什么作用？</span></h2>
<ul>
<li>用于暂停当前线程（运行状态转为就绪状态），使得其他线程可以获得执行机会</li>
<li>在高并发场景下，为了平衡线程的负载和提高系统的整体性能（当前线程没有被调度器选择执行，而其他线程又没有占用 CPU 时）</li>
<li>但是也可能导致资源的浪费和系统的混乱。因为它可能让当前闲置的线程让出 CPU 资源给其他线程，但这些其他线程可能很快又变得不活跃，这可能导致 CPU 在不同线程之间频繁切换，反而降低了系统的整体性能。在使用时需要考虑到系统的整体负载和资源利用率</li>
</ul>
<hr>
<h2><span id="为什么-thread-类的-sleep和-yield-方法是静态的">为什么 Thread 类的 sleep()和 yield ()方法是静态的？</span></h2>
<p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行</p>
<p>所以在其他处于等待状态的线程上调用这些方法是没有意义的</p>
<p>这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法</p>
<hr>
<h2><span id="线程的-sleep方法和-yield方法有什么区别">线程的 sleep()方法和 yield()方法有什么区别？</span></h2>
<ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；而yield()方法只会给相同优先级或更高优先级的线程以运行的机会</li>
<li>线程执行sleep()方法后会转入阻塞状态，所以，执行sleep()方法后的线程在指定的时间内肯定不会呗执行，而yield（）方法只是使当前线程重新回到可执行状态，所以执行yield（）方法的线程可能在在进入到可执行状态后马上又被执行</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常</li>
<li>sleep()方法比yield()方法具有更好的可移植性</li>
</ul>
<hr>
<h2><span id="多线程的中断是什么">多线程的中断是什么？</span></h2>
<p>线程在运行过程中，有些时候可能需要中断一些阻塞的线程</p>
<p>类Thread中提供了几种中断线程的方法，其中Thread.suspend()和Thread.stop()方法已经过时了，因为这两个方法是不安全的</p>
<p>Thread.stop()，会直接终止该线程，并且会立即释放这个线程持有的所有锁，而这些锁恰恰是用来维持数据的一致性的</p>
<p>如果此时。写线程写入数据时写到一半，并强行终止，由于此时对象锁已经被释放，另一个等待该锁的读线程就会读到这个不一致的对象</p>
<p>hread.suspend()会导致死锁，Thread.resume()也不能使用。</p>
<hr>
<h2><span id="如何停止一个正在运行的线程">如何停止一个正在运行的线程？</span></h2>
<p>Java没有为停止线程提供 API</p>
<p>JDK 1.0 本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK 版本中他们被弃用了.</p>
<p>之后Java API 的设计者就没有提供一个兼容且线程安全的方法来停止一个线程</p>
<p>当run() 或者 call() 方法执行完的时候线程会自动结束, 如果要手动结束一个线程.你可以用volatile布尔变量来退出 run()方法的循环或者是取消任务来中断线程。</p>
<hr>
<h2><span id="java-中-interrupted-和-isinterrupted-方法的区别">Java 中 interrupted 和 isInterrupted 方法的区别？</span></h2>
<ul>
<li>interrupted：查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了</li>
<li>isInterrupted仅仅是查询当前线程的中断状态</li>
</ul>
<hr>
<h2><span id="notify-和-notifyall-有什么区别">notify() 和 notifyAll() 有什么区别？</span></h2>
<ul>
<li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li>
<li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；</li>
</ul>
<hr>
<h2><span id="你对线程优先级的理解是什么">你对线程优先级的理解是什么？</span></h2>
<ul>
<li>每一个线程都是有优先级的.</li>
<li>一般来说，高优先级的线程在运行时会具有优先权. 但这依赖于线程调度的实现.这个实现是和操作系统相关的</li>
<li>线程优先级是一个int 变量(从 1-10).1 代表最低优先级.10 代表最高优先级。</li>
</ul>
<hr>
<h2><span id="线程类的构造方法-静态块是被哪个线程调用的">线程类的构造方法、静态块是被哪个线程调用的</span></h2>
<ul>
<li>被new这个线程类所在的线程所调用的</li>
<li>而run方法里面的代码才是被线程自身所调用的</li>
<li>举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：<br>
(1)Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的；<br>
(2)Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的；</li>
</ul>
<hr>
<h2><span id="一个线程运行时发生异常会怎样">一个线程运行时发生异常会怎样？</span></h2>
<ul>
<li>如果异常没有被捕获该线程将会停止执行</li>
<li>Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM 会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler 并将线程和异常作为参数传递给handler 的uncaughtException()方法进行处理</li>
</ul>
<h2><span id="java-线程数过多会造成什么异常">Java 线程数过多会造成什么异常？</span></h2>
<ul>
<li>线程的生命周期开销非常高</li>
<li>消耗过多的CPU 资源<br>
如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU 资源时还将产生其他性能的开销。</li>
<li>降低稳定性<br>
JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</li>
</ul>
<hr>
<h2><span id="什么是-futuretask">什么是 FutureTask？</span></h2>
<p>FutureTask 表示一个异步运算的任务</p>
<p>FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作</p>
<p>由于 FutureTask<br>
也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中</p>
<hr>
<h2><span id="线程之间如何进行通讯的">线程之间如何进行通讯的？</span></h2>
<p>通常多个线程的运行是互不干扰的，但是CPU对线程的切换是随机的，若想让多个线程之间有规律的运行，就需要线程通讯</p>
<p>从而让多个线程按照我们预期的运行过程去执行</p>
<ul>
<li>wait()：当前线程释放锁并且进入就绪状态<br>
notify()：唤醒当前线程，唤醒调用wait()方法进入就绪状态后的线程<br>
notifyAll()：唤醒所有进入就绪状态的线程</li>
<li>join()方法：使A线程加入B线程中执行，B线程进入阻塞状态，只有当A线程运行结束后B线程才会继续执行</li>
<li>volatile关键字：实现线程变量之间真正共享，多个线程同时监控着共享变量，当变量发生变化时其它线程立即改变，具体实现与JMM内存模型有关</li>
</ul>
<hr>
<h2><span id="线程安全的概念">线程安全的概念？</span></h2>
<p>多个线程可以共享进程的堆和方法区资源，既多个线程共享类变量</p>
<p>多个线程共享一个进程的变量时，如果线程对这个变量只有读操作，没有更新操作则这个线程没有线程安全问题</p>
<p>如果线程需要对这个变量进行修改操作，则可能会因为数据更新不及时导致变量信息不准确而引发线程不安全</p>
<hr>
<h2><span id="线程安全如何保证">线程安全如何保证？</span></h2>
<p>当多个线程对同一个资源进行操作的时候就会有线程安全</p>
<p>解决线程安全的核心思想就是加锁</p>
<ul>
<li>JVM提供的锁，就是synchronized锁，即同步代码和同步代码块</li>
<li>jdk提供的各种锁，如lock</li>
</ul>
<hr>
<h2><span id="java中哪些集合是线程安全的">Java中哪些集合是线程安全的？</span></h2>
<ul>
<li>在JDK1.1版本中，所有的集合都是线程安全的</li>
<li>但是在1.2及以后的版本中就出现了一些线程不安全的集合</li>
<li>因为线程不安全的集合普遍比线程安全的集合效率高的多。在JDK源码中相同效果的集合线程安全的比线程不安全的仅仅多了一个同步机制，但是效率上却低了不少，而且对线程不安全的集合加锁以后也能达到安全的效果（但是效率会低，因为会有锁的获取以及等待）</li>
</ul>
<p>下面列举一些常用的线程安全的集合</p>
<ul>
<li>Vector：就比ArrayList多了个同步化机制</li>
<li>HashTable：就比HashMap多了个线程安全</li>
<li>ConcurrentHashMap：是一种高效但是线程安全的集合</li>
<li>Stack：栈，线程安全，继承与Vector</li>
</ul>
<hr>
<h2><span id="synchronized-关键字用法">synchronized 关键字用法？</span></h2>
<ul>
<li>
<p>修饰实例方法: 作用于当前<strong>对象实例</strong>加锁，进入同步代码前要获得当前对象实例的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰静态方法: 也就是给<strong>当前类</strong>加锁，会作用于类的所有对象实例</p>
<p>进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰代码块 ：指定加锁对象，对<strong>给定对象/类</strong>加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得当前 class 的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2><span id="构造方法可以使用-synchronized-关键字修饰么">构造方法可以使用 synchronized 关键字修饰么？</span></h2>
<ul>
<li>构造方法不能使用 synchronized 关键字修饰</li>
<li>构造方法本身就属于线程安全的，不存在同步的构造方法一说</li>
</ul>
<hr>
<h2><span id="synchronized使用双重校验锁实现对象单例线程安全">synchronized使用：双重校验锁实现对象单例(线程安全)。</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">	<span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 提供getInstance方法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="同步和异步的区别">同步和异步的区别？</span></h2>
<ul>
<li>同步：功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。这时程序是阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。因此，简单来说，同步就是必须一件一件做事，等前一件事做完了才能做完下一件事</li>
<li>异步：与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作，当这个调用完成后，一般通过状态或者回调来通知调用者</li>
</ul>
<hr>
<h2><span id="同步方法和同步块哪个是更好的选择">同步方法和同步块，哪个是更好的选择？</span></h2>
<ul>
<li>同步块，因为同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率（同步的范围越小越好）</li>
</ul>
<hr>
<h2><span id="为什么-wait-notify和-notifyall必须在同步方法或者同步块中被调用">为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</span></h2>
<p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁</p>
<p>接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法</p>
<p>当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁</p>
<p>由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用</p>
<hr>
<h2><span id="什么是线程同步和线程互斥">什么是线程同步和线程互斥？</span></h2>
<p><strong>线程同步</strong></p>
<ul>
<li>指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）</li>
<li>也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！</li>
</ul>
<p><strong>线程互斥</strong></p>
<ul>
<li>指对于共享的进程系统资源，在各单个线程访问时的排它性</li>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）</li>
</ul>
<hr>
<h2><span id="什么是线程池">什么是线程池？</span></h2>
<ul>
<li>提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务</li>
<li>由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能</li>
</ul>
<hr>
<h2><span id="为什么要用线程池">为什么要用线程池？</span></h2>
<ul>
<li>使用继承Thread或者实现Runnable接口的方式来创建及销毁线程会产生耗费资源、线程上下文切换问题</li>
<li>同时创建过多的线程也可能引发资源耗尽的风险</li>
<li>线程池方便线程任务的管理。java中涉及到线程池的相关类均在jdk1.5开始的java.util.concurrent包中，涉及到的几个核心类及接口包括：Executor、Executors、ExecutorService、ThreadPoolExecutor、FutureTask、Callable、Runnable等</li>
</ul>
<hr>
<h2><span id="线程池的优势">线程池的优势？</span></h2>
<ul>
<li>提供了一种限制和管理资源（包括执行一个任务）</li>
<li>每个线程池还维护一些基本统计信息，例如已完成任务的数量</li>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>
<hr>
<h2><span id="线程池的工作原理">线程池的工作原理？</span></h2>
<ul>
<li>线程提交到线程池</li>
<li>判断核心线程池是否已经达到设定的数量，如果没有达到，则直接创建线程执行任务</li>
<li>如果达到了，则放在队列中，等待执行</li>
<li>如果队列已经满了，则判断线程的数量是否已经达到设定的最大值，如果达到了，则直接执行拒绝策略</li>
<li>如果没有达到，则创建线程执行任务</li>
</ul>
<hr>
<h2><span id="线程池都有哪些状态">线程池都有哪些状态？</span></h2>
<ul>
<li>RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）</li>
<li>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态</li>
<li>TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态</li>
<li>TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做</li>
</ul>
<hr>
<h2><span id="什么是executors">什么是Executors？</span></h2>
<ul>
<li>Executor是一个线程池框架</li>
<li>Executor 位于java.util.concurrent.Executors，提供了用于创建工作线程的线程池的工厂方法。它包含一组用于有效管理工作线程的组件</li>
<li>Executor API 通过 Executors 将任务的执行与要执行的实际任务解耦</li>
</ul>
<hr>
<h2><span id="在-java-中-executor-和-executors-的区别">在 Java 中 Executor 和 Executors 的区别？</span></h2>
<p>Executor接口对象能执行我们的线程任务<br>
Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求<br>
ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法，我们能够获得任务执行的状态并且可以获取任务的返回值</p>
<hr>
<h2><span id="executors新建线程池类型">Executors新建线程池类型？</span></h2>
<ul>
<li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
<li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行</li>
</ul>
<hr>
<h2><span id="executors新建线程池的弊端">Executors新建线程池的弊端？</span></h2>
<ul>
<li>newFixedThreadPool和newSingleThreadExecutor：堆积的请求处理队列可能会耗费非常大的内存，甚至OOM</li>
<li>newCachedThreadPool和newScheduledThreadPool：线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM</li>
<li>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，规避资源耗尽的风险</li>
</ul>
<hr>
<h2><span id="什么是threadpoolexecutor">什么是ThreadPoolExecutor？</span></h2>
<p>ThreadPoolExecutor是线程池的核心实现类，在JDK1.5引入，位于java.util.concurrent包。</p>
<hr>
<h2><span id="通过threadpoolexecutor如何创建线程池">通过ThreadPoolExecutor如何创建线程池？</span></h2>
<p>通过下面的demo来了解ThreadPoolExecutor创建线程的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolSerialTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//超过 corePoolSize 线程数量的线程最大空闲时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//以秒为时间单位</span></span><br><span class="line">        <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">        <span class="comment">//创建工作队列，用于存放提交的等待执行任务</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建线程池</span></span><br><span class="line">            threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line">                    maximumPoolSize,</span><br><span class="line">                    keepAliveTime,</span><br><span class="line">                    unit,</span><br><span class="line">                    workQueue,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//循环提交任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//提交任务的索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (i + <span class="number">1</span>);</span><br><span class="line">                threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">//线程打印输出</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;大家好，我是线程：&quot;</span> + index);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//模拟线程执行时间，10s</span></span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//每个任务提交后休眠500ms再提交下一个任务，用于保证提交顺序</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个新任务被提交时：</p>
<ul>
<li>当前活跃线程数&lt;corePoolSize，则创建一个新线程执行新任务；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）未满时，则将新任务放入队列中；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）已满，且当前活跃线程数&lt;maximumPoolSize，则继续创建一个新线程执行新任务；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）已满，且当前活跃线程数=maximumPoolSize，则执行拒绝策略（handler）;</li>
</ul>
<p>当任务执行完成后：</p>
<ul>
<li>超出corePoolSize的空闲线程，在等待新任务时，如果超出了keepAliveTime，则线程会被销毁；</li>
<li>如果allowCoreThreadTimeOut被设置为true，那么corePoolSize以内的空闲线程，如果超出了keepAliveTime，则同样会被销毁。</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor线程池中的几种重要的参数">ThreadPoolExecutor线程池中的几种重要的参数？</span></h2>
<ul>
<li>corePoolSize：线程池中的核心线程数量，这几个核心线程在没有用的时候，也不会被回收</li>
<li>maximumPoolSize：线程池中可以容纳的最大线程的数量</li>
<li>keepAliveTime：除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清 除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间</li>
<li>util：计算这个时间的一个单位</li>
<li>workQueue：等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）</li>
<li>threadFactory：创建线程的线程工厂</li>
<li>handler：拒绝策略，我们可以在任务满了之后，拒绝执行某些任务</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor饱和拒绝策略是什么">ThreadPoolExecutor饱和(拒绝)策略是什么？</span></h2>
<ul>
<li>当线程充满了ThreadPool的有界队列时，饱和策略开始起作用</li>
<li>饱和策略可以理解为队列饱和后，处理后续无法入队的任务的策略</li>
<li>ThreadPoolExecutor可以通过调用setRejectedExecutionHandler来修改饱和策略</li>
</ul>
<hr>
<h2><span id="说说线程池的拒绝策略">说说线程池的拒绝策略？</span></h2>
<p>当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务</p>
<p>JDK默认提供的四种拒绝策略（在ThreadPoolExecutor中）</p>
<ul>
<li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li>
<li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</li>
<li>DiscardOleddestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理</li>
</ul>
<p>自定义拒绝策略</p>
<ul>
<li>RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor的execute方法和-submit方法的区别是什么呢">ThreadPoolExecutor的execute()方法和 submit()方法的区别是什么呢？</span></h2>
<ul>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</li>
<li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完</li>
</ul>
<hr>
<h2><span id="什么是线程组为什么在-java-中不推荐使用">什么是线程组，为什么在 Java 中不推荐使用？</span></h2>
<ul>
<li>线程组ThreadGroup对象中的stop，resume，suspend会导致安全问题，主要是死锁问题</li>
<li>线程组ThreadGroup不是线程安全的，在使用过程中不能及时获取安全的信息</li>
</ul>
<hr>
<h2><span id="线程池如何关闭">线程池如何关闭？</span></h2>
<ul>
<li>shutdownNow()：立即关闭线程池(暴力)，正在执行中的及队列中的任务会被中断，同时该方法会返回被中断的队列中的任务列表</li>
<li>shutdown()：平滑关闭线程池，正在执行中的及队列中的任务能执行完成，后续进来的任务会被执行拒绝策略</li>
<li>isTerminated()：当正在执行的任务及对列中的任务全部都执行（清空）完就会返回true</li>
</ul>
<hr>
<h2><span id="线程池的复用原理">线程池的复用原理？</span></h2>
<ul>
<li>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制</li>
<li>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来</li>
</ul>
<hr>
<h2><span id="线程池都有哪几种工作队列">线程池都有哪几种工作队列？</span></h2>
<ul>
<li>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序</li>
<li>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</li>
<li>SynchronousQueue 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool()使用了这个队列</li>
<li>PriorityBlockingQueue 一个具有优先级的无限阻塞队列</li>
</ul>
<hr>
<h2><span id="springboot如何整合线程池">SpringBoot如何整合线程池？</span></h2>
<p>首先是利用好SpringBoot的自动装配功能，配置好线程池的一些基本参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTaskConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 线程池名前缀</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">threadNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;Api-Async-&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean的名称， 默认为首字母小写的方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;taskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，</span></span><br><span class="line"><span class="comment">     * 当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</span></span><br><span class="line"><span class="comment">     * 当队列满了，就继续创建线程，当线程数量大于等于maxPoolSize后，开始使用拒绝策略拒绝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 核心线程数（默认线程数）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">//缓冲队列数</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">//允许线程空闲时间（单位是秒）</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveTime);</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        <span class="comment">//用来设置线程池关闭时候等待所有任务都完成再继续销毁其他的Bean</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//线程池对拒绝任务的处理策略，CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好线程池的基本参数时候，我们就可以使用线程池了， 只要在一个限定域为public的方法头部加上@Async注解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行任务&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="线程池的优化">线程池的优化？</span></h2>
<ul>
<li>
<p>分析任务的特性</p>
<p>任务的性质：CPU 密集型任务、IO 密集型任务和混合型任务。<br>
任务的优先级：高、中、低。<br>
任务的执行时间：长、中、短。<br>
任务的依赖性：是否依赖其他系统资源，如数据库连接</p>
</li>
<li>
<p>具体策略</p>
<ul>
<li>CPU 密集型任务配置尽可能小的线程，如配置N（CPU核心数）+1个线程的线程池。</li>
<li>IO 密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*N（CPU核心数）。</li>
<li>混合型任务如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务。只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率；如果这两个任务执行时间相差太大，则没必要进行分解。</li>
<li>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理，它可以让优先级高的任务先得到执行。但是，如果一直有高优先级的任务加入到阻塞队列中，那么低优先级的任务可能永远不能执行。</li>
<li>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</li>
<li>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，线程数应该设置得较大，这样才能更好的利用 CPU。</li>
<li>建议使用有界队列，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。使用无界队列，线程池的队列就会越来越大，有可能会撑满内存，导致整个系统不可用。</li>
</ul>
</li>
</ul>
<hr>
<h2><span id="什么是threadlocal">什么是ThreadLocal？</span></h2>
<p>从字面上理解ThreadLocal就是“线程局部变量”的意思</p>
<p>简单的说就是，一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的（每个线程都只能看到自己线程的值）</p>
<ul>
<li>
<p>set()：赋值操作</p>
</li>
<li>
<p>get()：获取变量中的值</p>
</li>
<li>
<p>remove()：删除当前这个变量的值</p>
<p>需要注意的是initialValue方法会在第一次调用时被触发，用于初始化当前变量值，例如在下列代码中我们需要创建一个ThreadLocal，用于创建一个与线程绑定的Connection对象：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadLocal</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(…);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>每个ThreadLocal实例内部都可以保存一个值（基本数据类型值或者引用类型的引用值），这个值是可以修改的</li>
<li>每一个ThreadLocal实例就类似于一个变量名，不同的ThreadLocal实例就是不同的变量名，它们内部会存有一个值（暂时这么理解）在后面的描述中所说的“ThreadLocal变量或者是线程变量”代表的就是ThreadLocal类的实例</li>
<li>通过重写initialValue方法指定ThreadLocal变量的初始值，默认情况下initialValue返回的是null</li>
</ul>
<hr>
<h2><span id="threadlocal的具体实现">ThreadLocal的具体实现?</span></h2>
<p>一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的（每个线程都只能看到自己线程的值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; num = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 重写这个方法，可以修改“线程变量”的初始值，默认是null</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一号线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 在一号线程中将ThreadLocal变量设置为1</span></span><br><span class="line">                num.set(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;一号线程中ThreadLocal变量中保存的值为：&quot;</span> + num.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建二号线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                num.set(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;二号线程中ThreadLocal变量中保存的值为：&quot;</span> + num.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//为了让一二号线程执行完毕，让主线程睡500ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中ThreadLocal变量中保存的值：&quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码中在类中创建了一个静态的“ThreadLocal变量”，在主线程中创建两个线程，在这两个线程中分别设置ThreadLocal变量为1和2。然后等待一号和二号线程执行完毕后，在主线程中查看ThreadLocal变量的值</li>
<li>程序结果重点看的是主线程输出的是0，如果是一个普通变量，在一号线程和二号线程中将普通变量设置为1和2，那么在一二号线程执行完毕后在打印这个变量，输出的值肯定是1或者2（到底输出哪一个由操作系统的线程调度逻辑有关）</li>
<li>但使用ThreadLocal变量通过两个线程赋值后，在主线程程中输出的却是初始值0。在这也就是为什么“一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的”，每个线程都只能看到自己线程的值，这也就是ThreadLocal的核心作用：实现线程范围的局部变量</li>
</ul>
<hr>
<h2><span id="threadlocal的原理分析">ThreadLocal的原理分析?</span></h2>
<p>每个Thread对象都有一个ThreadLocalMap</p>
<p>当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中</p>
<p>其中键就是ThreadLocal，值可以是任意类型</p>
<p>想要存入的ThreadLocal中的数据实际上并没有存到ThreadLocal对象中去，而是以这个ThreadLocal实例作为key存到了当前线程中的一个Map中去了</p>
<p>获取ThreadLocal的值时同样也是这个道理。这也就是为什么ThreadLocal可以实现线程之间隔离的原因了</p>
<ul>
<li>ThreadLocal的作用：实现线程范围内的局部变量，即ThreadLocal在一个线程中是共享的，在不同线程之间是隔离的。</li>
<li>ThreadLocal的原理：ThreadLocal存入值时使用当前ThreadLocal实例作为key，存入当前线程对象中的Map中去。最开始在看源码之前，我以为是以当前线程对象作为key将对象存入到ThreadLocal中的Map中去</li>
</ul>
<hr>
<h2><span id="threadlocal和synchonized区别">ThreadLocal和Synchonized区别？</span></h2>
<ul>
<li>两者都用于解决多线程并发访问</li>
<li>但是Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离</li>
<li>Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享</li>
<li>而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享</li>
</ul>
<hr>
<h2><span id="threadlocal内存泄漏以及解决方案">ThreadLocal内存泄漏以及解决方案？</span></h2>
<ul>
<li>如果ThreadLocal没有外部强引用，那么在发生垃圾回收的时候，ThreadLocal就必定会被回收</li>
<li>而ThreadLocal又作为Map中的key，ThreadLocal被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li>
<li>解决方案：每次使用完ThreadLocal都调用它的remove()方法清除数据，或者按照JDK建议将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>基本数据类型与包装类</title>
    <url>/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<p>赋值变量的过程中，不仅需要注意变量类型与数据类型是否一致，还需观察数据大小是否在数据类型的范围中。所以灵活使用数据类型能使我们更好的运用数据，根据数值大小将变量分配在合理的类型范围中，能有效减少存储空间。</p>
<p>针对八种基本数据类型定义相应的引用类型—包装类</p>
<p>首先,Java语言是一个面向对象的语言,但是Java中的基本数据类型却是不面向对象的，为了实现一 切皆对象,将每个基本数据类型设计一个对应的类进行代表，这种方式增强了Java面向对象的性质。</p>
<p>其次，如果仅仅有基本数据类型，那么在实际使用时将存在很多的不便，很多地方都需要使用对象。比如，在集合类中，我们是无法将int 、double等类型放进去的，因为集合的容器要求元素是Object类型。而包装类型的存在使得向集合中传入数值成为可能，包装类的存在弥补了基本数据类型的不足。</p>
<p>此外，包装类还为基本类型添加了属性和方法，丰富了基本类型的操作。如当我们想知道int取值 范围的最小值，我们需要通过运算，如下面所示，但是有了包装类，我们可以直接使Integer.MAX_VALUE即可。</p>
<p>注意:为什么要保留基本数据类型？Java种创建的对象都是存储在堆里的，使用的时候需要通过栈中的引用， 所以常用的基本数据类型，不需要使用new在堆上创建，而是直接在栈内存中存储不创建对象，就会比较高效。</p>
<span id="more"></span>
<h1><span id="基本数据类型">基本数据类型</span></h1>
<h4><span id="使用字面量">使用字面量</span></h4>
<ol>
<li>
<p>字面量类型必须与变量类型匹配或能自动转换成变量类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1L</span>;	<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字面量大小必须在自身类型表数范围内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> Long.MAX_VALUE;<span class="comment">//9223372036854775807</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">9223372036854775808L</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>特殊地，对于<strong>byte、short、char</strong>，虽然字面量类型不能自动转换成变量类型，但只需要字面量大小在变量类型的表述范围内则合法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>; 	<span class="comment">//字面量使用+运算符会在编译期间直接对值相加</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>为什么在变量赋值中将整数类型的变量赋值给byte、short、char会报错</strong>（变量在它们的表数范围内）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> i;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在编译过程中，如果赋值的是常数，JVM能直接判断是否在表数范围内，确定不会溢出数据后进行强行数据类型转换；</li>
<li>而变量在程序执行过程中可能发生变化，无法直接判断变量中的值是否在表数范围内，从而报错</li>
</ol>
<h2><span id="多种基本数据类型运算">多种基本数据类型运算</span></h2>
<ol>
<li>
<p>JVM会将所有数据类型转换成运算过程中表数范围最大的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">x4</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">x5</span> <span class="operator">=</span> <span class="number">1.0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x3 + x4 + x5 + x6;	<span class="comment">//x1、x2、x3、x4、x5相加，因此至少需要用float类型接收</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>byte、short、charr之间不会相互转换，他们三者在计算时首先转换为int类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">x7</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x7;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>乘除法同样符合上述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1.0</span>*x3;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>难点</strong>(byte、short、char)</p>
<ol>
<li>
<p><code>short s1 = 1;	</code></p>
<p>编译正确：int字面量若在short范围内,则可以再编译时强行转换成short</p>
</li>
<li>
<p><code>short s2 = s1 + 1;	</code></p>
<p>编译错误：即使等式右边结果在short范围内，由于有变量的存在（不确定），也无法在编译时强行转换成short</p>
</li>
<li>
<p><code>s1 = s1 + 1;</code></p>
<p>编译错误：可以将上述代码拆分成两步：</p>
<ol>
<li><code>short result = s + 1;</code></li>
<li><code>short s = result;</code></li>
</ol>
<p>由于赋值中存在变量，即使等式右边结果在short范围内，也无法在编译时强行转换成short，同2</p>
</li>
<li>
<p><code>s1 += 1;</code></p>
<p>编译正确：此时不不等于s1=s1+1，而等于s1=(short)(s1+1)，JVM会自动采用i2s指令，强行转换成short</p>
</li>
</ol>
<h2><span id="总结">总结</span></h2>
<h3><span id="字面量赋值">字面量赋值</span></h3>
<ol>
<li>先观察字面量<strong>类型</strong>，观察是否超过<strong>字面量类型表数范围</strong></li>
<li>字面量为常数且int类型时，被赋值变量类型为<strong>byte、short、char</strong>，字面量大小在byte、short、char的表数范围内，则可以直接赋值</li>
<li>表数范围小的类型可以赋值给表数范围大的类型（自动转换），反之报错</li>
</ol>
<h3><span id="多种类型变量运算">多种类型变量运算</span></h3>
<ol>
<li>byte、short、char三者在计算时首先转换为int类型</li>
<li>观察等号右边的最大表数范围的数据类型是否小于左边变量类型的表数范围</li>
<li>乘除法同样符合上述规则</li>
</ol>
<h1><span id="包装类">包装类</span></h1>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<h2><span id="装箱">装箱</span></h2>
<p>基本数据类型转换为包装类</p>
<ol>
<li>
<p>通过构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Byte</span>(<span class="string">&quot;123&quot;</span>); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过包装类的valueOf()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Interger</span> <span class="variable">t</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK5后出现自动装箱(推荐)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; 	</span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> i; <span class="comment">//Integer = 10;	底层还是通过包装类的valueof（）方法</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="拆箱">拆箱</span></h2>
<p>包装类转换为基本数据类型</p>
<ol>
<li>
<p>调用包装类实例对象的.xxxValue()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> obj.booleanValue(); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK5后出现自动拆箱(推荐)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer;	<span class="comment">//底层还是通过包装类实例的xxxValue（）方法</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="字符串转换成基本数据类型">字符串转换成基本数据类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;12&quot;</span>);<span class="comment">//通过包装类的构造器实现：</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.valueOf(<span class="string">&quot;123&quot;</span>);<span class="comment">//通过包装类的valueOf()实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(<span class="string">&quot;12.1&quot;</span>);<span class="comment">//通过包装类的parseXxx(String s)静态方法：</span></span><br></pre></td></tr></table></figure>
<h2><span id="基本数据类型转换成字符串">基本数据类型转换成字符串</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= String.valueOf(<span class="number">2.34f</span>);<span class="comment">//调用字符串重载的valueOf()方法：</span></span><br><span class="line"></span><br><span class="line">String str= <span class="number">5</span> + “”<span class="comment">//使用+做字符串连接</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类</th>
<th>字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本数据类型转换成</td>
<td>\</td>
<td>包装类构造器、包装类.valueOf(X)、自动</td>
<td>包装类.valueOf(X)、字符串拼接</td>
</tr>
<tr>
<td>包装类转换成</td>
<td>包装类实例对象.XXXValue()、自动</td>
<td>\</td>
<td>包装类.toString()</td>
</tr>
<tr>
<td>字符串转换成</td>
<td>包装类构造器、包装类.valueOf(X)、包装类.parseXxx(X)</td>
<td>包装类构造器、包装类.valueOf(X)</td>
<td>\</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63aaec6708b6830163fb2d26.png" alt></p>
<h2><span id="包装类中的缓存机制">包装类中的缓存机制</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//Integer num1 = 10;</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println((num1 == num2) +<span class="string">&quot;\t&quot;</span>+ num1.equals(num2));<span class="comment">//true	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line">System.out.println((num3 == num4) +<span class="string">&quot;\t&quot;</span>+ num3.equals(num4));<span class="comment">//false	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println((num5 == num6) +<span class="string">&quot;\t&quot;</span>+ num5.equals(num6));<span class="comment">//false	true</span></span><br></pre></td></tr></table></figure>
<p>Integer类第一次被使用时，Integer的静态内部类就被加载，加载的时候会创建-128到127的 Integer对象，同时创建一个数组cache来缓存这些对象。</p>
<ul>
<li>当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，不会再新建对象；</li>
<li>当使用new关键字或者使用valueOf()方法创建小于-128大于 127的值对象时，就会创建新对象。</li>
</ul>
<table>
<thead>
<tr>
<th>Character、Byte、Short、Integer、Long</th>
<th>Boolean</th>
<th>Float、Double</th>
</tr>
</thead>
<tbody>
<tr>
<td>有缓存区，且实现方式基本一样，都是-128到127的缓存范围（Character 0-127）</td>
<td>没有缓存区，但在成员变量中就创建了两个相应的对象true、false</td>
<td>没有缓存区，即使在0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</td>
</tr>
</tbody>
</table>
<p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p>
<h2><span id="基本数据类型与包装类区别">基本数据类型与包装类区别</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类（引用数据类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员</td>
<td>\</td>
<td>可调用各种属性及方法</td>
</tr>
<tr>
<td>实例化</td>
<td>不需要实例化</td>
<td>必须实例化后才能使用</td>
</tr>
<tr>
<td>存储方式</td>
<td>直接存储数据值</td>
<td>实际是对象的引用</td>
</tr>
<tr>
<td>默认值</td>
<td>有默认值</td>
<td>默认值是null</td>
</tr>
<tr>
<td>空指针异常</td>
<td>不会发生空指针异常</td>
<td>可能发生空指针异常</td>
</tr>
<tr>
<td>强制转换</td>
<td>可以强制转换为其他类型</td>
<td>不能强制转换为其他类型</td>
</tr>
</tbody>
</table>
<h1><span id="运算规则">运算规则</span></h1>
<ul>
<li>包装类和值类型一起运算，则包装类会拆箱成值类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//比较的是值</span></span><br><span class="line"><span class="comment">//两个值类型比较的是数值</span></span><br><span class="line"><span class="comment">//f1==f2，包装类和值类型进行运算，则包装类会拆箱</span></span><br><span class="line"><span class="type">int</span> g1=<span class="number">1000</span>;</span><br><span class="line">Integer g2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line">System.out.println(g1==g2);</span><br></pre></td></tr></table></figure>
<h1><span id="大数字处理">大数字处理</span></h1>
<p>大数字实际上是采用字符串存储</p>
<ol>
<li>
<p>BigInteger处理整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bigInteger=<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;10000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>);</span><br><span class="line">System.out.println(bigInteger.toString());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>BigDecimal处理小数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bigDecimal1=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000000000000000000000000000000000000000000000000000000000000000000.123&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(BigDecimal b)</td>
<td>加法</td>
</tr>
<tr>
<td>subtract(BigDecimal b)</td>
<td>减法</td>
</tr>
<tr>
<td>multiply(BigDecimal b)</td>
<td>乘法</td>
</tr>
<tr>
<td>divide(BigDecimal b)</td>
<td>除法</td>
</tr>
<tr>
<td>toString(BigDecimal b)</td>
<td>转换成字符串</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h1><span id="数字格式化">数字格式化</span></h1>
<p>DecimalFormat</p>
<ol>
<li>#:表示数字格式，如果有数字则显示，没有则不显示<br>
如果数字少了，则不处理，不会补“0”，也不会补“#”<br>
如果数字多了，就切掉，但只切小数的末尾，整数不能切<br>
同时被切掉的小数位会进行四舍五入处理</li>
<li>0:表示占位符，如果没有该数位则用0表示<br>
如果数字少了，就会补“0”，小数和整数都会补；<br>
如果数字多了，就切掉，但只切小数的末尾，整数不能切；<br>
同时被切掉的小数位会进行四舍五入处理。</li>
<li>.:表示小数点</li>
<li>,:表示钱个格式</li>
<li>其它字符：直接显示</li>
</ol>
<p><strong>格式化人民币</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;￥###,###.00&quot;</span>);</span><br><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> decimalFormat.format(a);</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(format);</span><br></pre></td></tr></table></figure>
<p><strong>格式化操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">123.1512134567</span>;</span><br><span class="line"><span class="comment">// 取整数部分</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi);</span><br><span class="line">System.out.println(<span class="string">&quot;取整数：&quot;</span> + s1);<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取小数点后1位,四舍五入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.0&quot;</span>).format(pi);</span><br><span class="line">System.out.println(s2);<span class="comment">//123.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取小数点后3位，不足部分取0</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.000&quot;</span>).format(pi);</span><br><span class="line">System.out.println(s3);<span class="comment">//123.150</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 百分比</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.0%&quot;</span>).format(pi);</span><br><span class="line">System.out.println(s4);<span class="comment">// 12315.0%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00E0&quot;</span>).format(pi);</span><br><span class="line"></span><br><span class="line">System.out.println(s5);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1234567</span>;</span><br><span class="line"><span class="comment">// 每三位以逗号分开</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,000&quot;</span>).format(d);</span><br><span class="line">System.out.println(s6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//小数点后3位，如果是0则不显示</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.###&quot;</span>).format(<span class="number">123.300</span>);</span><br><span class="line">System.out.println(s7);<span class="comment">//123.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数字也可以格式化</span></span><br><span class="line">BigDecimal bigDecimal1=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000000000000000000000000000000000000000000000000000000000000000000.123&quot;</span>);</span><br><span class="line">BigDecimal bigDecimal2=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">subtract</span> <span class="operator">=</span> bigDecimal1.subtract(bigDecimal2);</span><br><span class="line">System.out.println(subtract.toString());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;￥###,###.00&quot;</span>).format(subtract));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/post/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1><span id="第14章_数据结构与集合源码">第14章_数据结构与集合源码</span></h1>
<h2><span id="本章专题与脉络">本章专题与脉络</span></h2>
<p><img src="https://pic.imgdb.cn/item/666313ef5e6d1bfa05617cf9.png" alt></p>
<h2><span id="1-数据结构剖析">1. 数据结构剖析</span></h2>
<h3><span id="11-研究对象一数据的逻辑结构">1.1 研究对象一：数据的逻辑结构</span></h3>
<p>数据的逻辑结构指反映数据元素之间的逻辑关系，而与数据的存储无关，是独立于计算机的。</p>
<ul>
<li><strong>集合结构</strong>：数据结构中的元素之间除了“<code>同属一个集合</code>” 的相互关系外，别无其他关系。集合元素之间没有逻辑关系。</li>
<li><strong>线性结构</strong>：数据结构中的元素存在<code>一对一</code>的相互关系。比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、栈、队列</li>
<li><strong>树形结构</strong>：数据结构中的元素存在<code>一对多</code>的相互关系。比如：家谱、文件系统、组织架构</li>
<li><strong>图形结构</strong>：数据结构中的元素存在<code>多对多</code>的相互关系。比如：全国铁路网、地铁图</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6663143a5e6d1bfa0561cf16.png" alt></p>
<h3><span id="12-研究对象二数据的存储结构或物理结构">1.2 研究对象二：数据的存储结构（或物理结构）</span></h3>
<p>数据的物理结构/存储结构：包括<code>数据元素的表示</code>和<code>关系的表示</code>。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。</p>
<p><strong>结构1：顺序结构</strong></p>
<ul>
<li>
<p>顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素。</p>
</li>
<li>
<p>优点： 只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问。</p>
</li>
<li>
<p>缺点： 必须静态分配连续空间，内存空间的利用率比较低。插入或删除可能需要移动大量元素，效率比较低</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6663144e5e6d1bfa0561e4e0.png" alt></p>
<p><strong>结构2：链式结构</strong></p>
<ul>
<li>不使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点。节点中除了存放数据本身以外，还需要存放指向下一个节点的指针。</li>
<li>优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点。插入或删除元素时，不需要移动大量的元素。</li>
<li>缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6663146b5e6d1bfa0562048d.png" alt></p>
<p><strong>结构3：索引结构</strong></p>
<ul>
<li>除建立存储节点信息外，还建立附加的<code>索引表</code>来记录每个元素节点的地址。索引表由若干索引项组成。索引项的一般形式是：（关键字，地址）。</li>
<li>优点：用节点的索引号来确定结点存储地址，检索速度快。</li>
<li>缺点： 增加了附加的索引表，会占用较多的存储空间。在增加和删除数据时要修改索引表，因而会花费较多的时间。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6663147e5e6d1bfa056219eb.png" alt></p>
<p><strong>结构4：散列结构</strong></p>
<ul>
<li>根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。</li>
<li>优点：检索、增加和删除结点的操作都很快。</li>
<li>缺点：不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666314995e6d1bfa0562358b.png" alt></p>
<h3><span id="13-研究对象三运算结构">1.3 研究对象三：运算结构</span></h3>
<p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
<ul>
<li>分配资源，建立结构，释放资源</li>
<li>插入和删除</li>
<li>获取和遍历</li>
<li>修改和排序</li>
</ul>
<h3><span id="14-小结">1.4 小结</span></h3>
<p><img src="https://pic.imgdb.cn/item/666314aa5e6d1bfa05624885.png" alt></p>
<h2><span id="2-一维数组">2. 一维数组</span></h2>
<h3><span id="21-数组的特点">2.1 数组的特点</span></h3>
<ul>
<li>在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只声明了类型和长度</span></span><br><span class="line">数据类型[]  数组名称 = <span class="keyword">new</span> 数据类型[数组长度];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明了类型，初始化赋值，大小由元素个数决定</span></span><br><span class="line">数据类型[] 数组名称 = &#123;数组元素<span class="number">1</span>，数组元素<span class="number">2</span>，......&#125;</span><br></pre></td></tr></table></figure>
<p>例如：整型数组</p>
<p><img src="https://pic.imgdb.cn/item/666314bf5e6d1bfa0562609c.png" alt></p>
<p>例如：对象数组</p>
<p><img src="https://pic.imgdb.cn/item/666314cb5e6d1bfa05627247.png" alt></p>
<ul>
<li>物理结构特点：
<ul>
<li>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</li>
<li>不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢。</li>
<li>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</li>
</ul>
</li>
<li>具体的，如下图：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666314db5e6d1bfa05628527.png" alt></p>
<h3><span id="22-自定义数组">2.2 自定义数组</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu01.overview.array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Array</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;= elementData.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数组已满，不可添加&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size] = value;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询元素value在数组中的索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(elementData[i].equals(value))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前数组中移除首次出现的value元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> find(value);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; size - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            elementData[i] = elementData[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组中首次出现的oldValue替换为newValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Object oldValue,Object newValue)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> find(oldValue);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[index] = newValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历数组中所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == size - <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(elementData[i] + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(elementData[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Array</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        arr.add(<span class="number">123</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        arr.add(<span class="number">345</span>);</span><br><span class="line">        arr.add(<span class="number">345</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        arr.delete(<span class="number">345</span>);</span><br><span class="line"></span><br><span class="line">        arr.update(<span class="number">345</span>,<span class="number">444</span>);</span><br><span class="line"></span><br><span class="line">        arr.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="3-链表">3. 链表</span></h2>
<h3><span id="31-链表的特点">3.1 链表的特点</span></h3>
<ul>
<li>
<p>逻辑结构：线性结构</p>
</li>
<li>
<p>物理结构：不要求连续的存储空间</p>
</li>
<li>
<p>存储特点：链表由一系列结点node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的<code>数据域</code>，另一个是存储下一个结点地址的<code>指针域</code>。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666315195e6d1bfa0562c4a8.png" alt></p>
<ul>
<li>常见的链表结构有如下的形式：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666315265e6d1bfa0562d33d.png" alt></p>
<img src="https://pic.imgdb.cn/item/6663156b5e6d1bfa05632128.png" style="zoom:50%;">
<h3><span id="32-自定义链表">3.2 自定义链表</span></h3>
<h4><span id="321-自定义单向链表">3.2.1 自定义单向链表</span></h4>
<p><img src="https://pic.imgdb.cn/item/666315875e6d1bfa05633eaa.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单链表中的节点。</span></span><br><span class="line"><span class="comment">节点是单向链表中基本的单元。</span></span><br><span class="line"><span class="comment">每一个节点Node都有两个属性：</span></span><br><span class="line"><span class="comment">    一个属性：是存储的数据。</span></span><br><span class="line"><span class="comment">    另一个属性：是下一个节点的内存地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储的数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个节点的内存地址</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data, Node next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">链表类(单向链表)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Link</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node header;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向链表中添加元素的方法（向末尾添加）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E data)</span>&#123;</span><br><span class="line">    <span class="comment">//public void add(Object data)&#123;</span></span><br><span class="line">        <span class="comment">// 创建一个新的节点对象</span></span><br><span class="line">        <span class="comment">// 让之前单链表的末尾节点next指向新节点对象。</span></span><br><span class="line">        <span class="comment">// 有可能这个元素是第一个，也可能是第二个，也可能是第三个。</span></span><br><span class="line">        <span class="keyword">if</span>(header == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明还没有节点。</span></span><br><span class="line">            <span class="comment">// new一个新的节点对象，作为头节点对象。</span></span><br><span class="line">            <span class="comment">// 这个时候的头节点既是一个头节点，又是一个末尾节点。</span></span><br><span class="line">            header = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 说明头不是空！</span></span><br><span class="line">            <span class="comment">// 头节点已经存在了！</span></span><br><span class="line">            <span class="comment">// 找出当前末尾节点，让当前末尾节点的next是新节点。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">currentLastNode</span> <span class="operator">=</span> findLast(header);</span><br><span class="line">            currentLastNode.next = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 专门查找末尾节点的方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果一个节点的next是null</span></span><br><span class="line">            <span class="comment">// 说明这个节点就是末尾节点。</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够到这里说明：node不是末尾节点。</span></span><br><span class="line">        <span class="keyword">return</span> findLast(node.next); <span class="comment">// 递归算法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*// 删除链表中某个数据的方法</span></span><br><span class="line"><span class="comment">    public void remove(Object obj)&#123;</span></span><br><span class="line"><span class="comment">        //略</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 修改链表中某个数据的方法</span></span><br><span class="line"><span class="comment">    public void modify(Object newObj)&#123;</span></span><br><span class="line"><span class="comment">        //略</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 查找链表中某个元素的方法。</span></span><br><span class="line"><span class="comment">    public int find(Object obj)&#123;</span></span><br><span class="line"><span class="comment">        //略</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="322-自定义双向链表">3.2.2 自定义双向链表</span></h4>
<p><img src="https://pic.imgdb.cn/item/666315995e6d1bfa056351cc.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双向链表中的节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    Node prev;</span><br><span class="line">    E data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(Node prev, E data, Node next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表类(双向链表)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;  <span class="comment">//链表的首元素</span></span><br><span class="line">    <span class="keyword">private</span> Node last;   <span class="comment">//链表的尾元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(last, e, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>)&#123;</span><br><span class="line">            first = newNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        last = newNode;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">find</span> <span class="operator">=</span> findNode(obj);</span><br><span class="line">        <span class="keyword">if</span>(find != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find.prev != <span class="literal">null</span>)&#123;</span><br><span class="line">                find.prev.next = find.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                first = find.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(find.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                find.next.prev = find.prev;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last = find.prev;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            find.prev = <span class="literal">null</span>;</span><br><span class="line">            find.next = <span class="literal">null</span>;</span><br><span class="line">            find.data = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            total--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.data == <span class="literal">null</span>)&#123;</span><br><span class="line">                    find = node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">                    find = node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findNode(obj) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E old, E value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">find</span> <span class="operator">=</span> findNode(old);</span><br><span class="line">        <span class="keyword">if</span>(find != <span class="literal">null</span>)&#123;</span><br><span class="line">            find.data = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; node = first;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> node.data;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义双链表测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyLinkedList&lt;String&gt; my = <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>&lt;&gt;();</span><br><span class="line">        my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        my.add(<span class="literal">null</span>);</span><br><span class="line">        my.add(<span class="literal">null</span>);</span><br><span class="line">        my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;一共有：&quot;</span> + my.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : my) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查找java,null,haha的结果：&quot;</span>);</span><br><span class="line">        System.out.println(my.contains(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        System.out.println(my.contains(<span class="literal">null</span>));</span><br><span class="line">        System.out.println(my.contains(<span class="string">&quot;haha&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换java,null后：&quot;</span>);</span><br><span class="line">        my.update(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line">        my.update(<span class="literal">null</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;所有元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : my) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除hello，JAVA,null，atguigu后：&quot;</span>);</span><br><span class="line">        my.delete(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        my.delete(<span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line">        my.delete(<span class="literal">null</span>);</span><br><span class="line">        my.delete(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;所有元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : my) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="4-栈">4. 栈</span></h2>
<h3><span id="41-栈的特点">4.1 栈的特点</span></h3>
<ul>
<li>
<p>栈（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。</p>
</li>
<li>
<p>栈按照<code>先进后出(FILO,first in last out)</code>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。每次删除（退栈）的总是删除当前栈中最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。</p>
<p><img src="https://pic.imgdb.cn/item/666315b75e6d1bfa056371bc.png" alt></p>
</li>
<li>
<p>核心类库中的栈结构有Stack和LinkedList。</p>
<ul>
<li>Stack就是顺序栈，它是Vector的子类。</li>
<li>LinkedList是链式栈。</li>
</ul>
</li>
<li>
<p>体现栈结构的操作方法：</p>
<ul>
<li>peek()方法：查看栈顶元素，不弹出</li>
<li>pop()方法：弹出栈</li>
<li>push(E e)方法：压入栈</li>
</ul>
</li>
<li>
<p>时间复杂度:</p>
<ul>
<li>索引: <code>O(n)</code></li>
<li>搜索: <code>O(n)</code></li>
<li>插入: <code>O(1)</code></li>
<li>移除: <code>O(1)</code></li>
</ul>
</li>
<li>
<p>图示：</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666315c55e6d1bfa056381a4.png" alt></p>
<img src="https://pic.imgdb.cn/item/666315e05e6d1bfa05639dce.png" style="zoom:50%;">
<h3><span id="42-stack使用举例">4.2 Stack使用举例</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 15:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStack</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 测试Stack</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        list.push(<span class="number">1</span>);</span><br><span class="line">        list.push(<span class="number">2</span>);</span><br><span class="line">        list.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!list.empty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;list.pop() =&quot;</span> + list.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 测试LinkedList</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.push(<span class="number">1</span>);</span><br><span class="line">        list.push(<span class="number">2</span>);</span><br><span class="line">        list.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;list.pop() =&quot;</span> + list.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="43-自定义栈">4.3 自定义栈</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">// 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。</span></span><br><span class="line">    <span class="comment">// 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈帧，永远指向栈顶部元素</span></span><br><span class="line">    <span class="comment">// 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。</span></span><br><span class="line">    <span class="comment">//private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。</span></span><br><span class="line">    <span class="comment">//private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参数构造方法。默认初始化栈容量10.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 一维数组动态初始化</span></span><br><span class="line">        <span class="comment">// 默认初始化容量是10.</span></span><br><span class="line">        <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 给index初始化</span></span><br><span class="line">        <span class="built_in">this</span>.index = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压栈的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 被压入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= elements.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//方式1：</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;压栈失败，栈已满！&quot;);</span></span><br><span class="line">            <span class="comment">//return;</span></span><br><span class="line">            <span class="comment">//方式2：</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;压栈失败，栈已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够走到这里，说明栈没满</span></span><br><span class="line">        <span class="comment">// 向栈中加1个元素，栈帧向上移动一个位置。</span></span><br><span class="line">        index++;</span><br><span class="line">        elements[index] = obj;</span><br><span class="line">        System.out.println(<span class="string">&quot;压栈&quot;</span> + obj + <span class="string">&quot;元素成功，栈帧指向&quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//方式1：</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;弹栈失败，栈已空！&quot;);</span></span><br><span class="line">            <span class="comment">//return;</span></span><br><span class="line">            <span class="comment">//方式2：</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;弹栈失败，栈已空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够执行到此处说明栈没有空。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> elements[index];</span><br><span class="line">        System.out.print(<span class="string">&quot;弹栈&quot;</span> + obj + <span class="string">&quot;元素成功，&quot;</span>);</span><br><span class="line">        elements[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 栈帧向下移动一位。</span></span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。</span></span><br><span class="line">    <span class="comment">// 封装：第一步：属性私有化，第二步：对外提供set和get方法。</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getElements() &#123;</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setElements</span><span class="params">(Object[] elements)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="5-队列">5. 队列</span></h2>
<ul>
<li>
<p>队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表。</p>
</li>
<li>
<p>队列是逻辑结构，其物理结构可以是数组，也可以是链表。</p>
</li>
<li>
<p>队列的修改原则：队列的修改是依<code>先进先出（FIFO）的原则</code>进行的。新来的成员总是加入队尾（即不允许&quot;加塞&quot;），每次离开的成员总是队列头上的（不允许中途离队），即当前&quot;最老的&quot;成员离队。</p>
</li>
<li>
<p>图示：</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666315f85e6d1bfa0563b58d.png" alt></p>
<img src="https://pic.imgdb.cn/item/666316085e6d1bfa0563c6c9.png" style="zoom:50%;">
<h2><span id="6-树与二叉树">6. 树与二叉树</span></h2>
<h3><span id="61-树的理解">6.1 树的理解</span></h3>
<p><img src="https://pic.imgdb.cn/item/666316225e6d1bfa0563e576.png" alt></p>
<p><strong>专有名词解释：</strong></p>
<p><code>结点</code>：树中的数据元素都称之为结点</p>
<p><code>根节点</code>：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根</p>
<p><code>父节点</code>：结点的上层结点，如图中，结点K的父节点是E、结点L的父节点是G</p>
<p><code>子节点</code>：节点的下层结点，如图中，节点E的子节点是K节点、节点G的子节点是L节点</p>
<p><code>兄弟节点</code>：具有相同父节点的结点称为兄弟节点，图中F、G、H互为兄弟节点</p>
<p><code>结点的度数</code>：每个结点所拥有的子树的个数称之为结点的度，如结点B的度为3</p>
<p><code>树叶</code>：度数为0的结点，也叫作终端结点，图中D、K、F、L、H、I、J都是树叶</p>
<p><code>非终端节点（或分支节点）</code>：树叶以外的节点，或度数不为0的节点。图中根、A、B、C、E、G都是</p>
<p><code>树的深度（或高度）</code>：树中结点的最大层次数，图中树的深度为4</p>
<p><code>结点的层数</code>：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为1，其余结点的层数等于其父亲结点的层数+1</p>
<p><code>同代</code>：在同一棵树中具有相同层数的节点</p>
<h3><span id="62-二叉树的基本概念">6.2 二叉树的基本概念</span></h3>
<p>二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。许多实际问题抽象出来的数据结构往往是二叉树形式，二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。</p>
<p><img src="https://pic.imgdb.cn/item/6663163b5e6d1bfa05640612.png" alt></p>
<h3><span id="63-二叉树的遍历">6.3 二叉树的遍历</span></h3>
<ul>
<li>
<p><strong>前序遍历：中左右（根左右）</strong></p>
<p>即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。</p>
</li>
<li>
<p><strong>中序遍历：左中右（左根右）</strong></p>
<p>即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。</p>
</li>
<li>
<p><strong>后序遍历：左右中（左右根）</strong></p>
<p>即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6663164c5e6d1bfa05641996.png" alt></p>
<p>前序遍历：ABDHIECFG</p>
<p>中序遍历：HDIBEAFCG</p>
<p>后序遍历：HIDEBFGCA</p>
<h3><span id="64-经典二叉树">6.4 经典二叉树</span></h3>
<p><img src="https://pic.imgdb.cn/item/666316665e6d1bfa056437b3.png" alt></p>
<p>1、<code>满二叉树</code>： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，总的结点个数是2的n次方-1</p>
<p><img src="https://pic.imgdb.cn/item/666316755e6d1bfa0564462c.png" alt></p>
<p>2、<code>完全二叉树</code>： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。</p>
<p><img src="https://pic.imgdb.cn/item/6663168b5e6d1bfa05645dc4.png" alt></p>
<p>3、<code>二叉排序/查找/搜索树</code>：即为BST  (binary search/sort tree)。满足如下性质：<br>
（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值；<br>
（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>
（3）它的左、右子树也分别为二叉排序/查找/搜索树。</p>
<p><img src="https://pic.imgdb.cn/item/6663169a5e6d1bfa05646b63.png" alt></p>
<blockquote>
<p>对二叉查找树进行中序遍历，得到有序集合。便于检索。</p>
</blockquote>
<p>4、<code>平衡二叉树</code>：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：<br>
（1）它是一棵空树或它的左右两个子树的高度差的绝对值不超过1<br>
（2）并且左右两个子树也都是一棵平衡二叉树<br>
（3）不要求非叶节点都有两个子结点</p>
<blockquote>
<p>平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/666316a75e6d1bfa056477be.png" alt></p>
<p>6、<code>红黑树</code>：即Red-Black Tree。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p>红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它是在 1972 年由 Rudolf Bayer 发明的。红黑树是复杂的，但它的操作有着<code>良好的最坏情况运行时间</code>，并且在<code>实践中是高效的</code>：它可以在 O(log n)时间内做查找，插入和删除， 这里的 n 是树中元素的数目。</p>
<p>红黑树的特性：</p>
<ul>
<li>
<p>每个节点是红色或者黑色</p>
</li>
<li>
<p>根节点是黑色</p>
</li>
<li>
<p>每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点）</p>
</li>
<li>
<p>每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
</li>
<li>
<p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍）</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666316b95e6d1bfa05648dc1.png" alt></p>
<p>当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上5个要求，那么此时就需要进行处理，使得它继续满足以上的5个要求：</p>
<p>1、<code>recolor</code> ：将某个节点变红或变黑</p>
<p>2、<code>rotation</code> ：将红黑树某些结点分支进行旋转（左旋或右旋）</p>
<p><img src="https://pic.imgdb.cn/item/666317215e6d1bfa0565087a.png" alt></p>
<blockquote>
<p>红黑树可以通过红色节点和黑色节点尽可能的保证二叉树的平衡。主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。</p>
</blockquote>
<h3><span id="65-二叉树及其结点的表示">6.5 二叉树及其结点的表示</span></h3>
<p>普通二叉树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root; <span class="comment">//二叉树的根结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> total;<span class="comment">//结点总个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">        <span class="comment">//至少有以下几个部分</span></span><br><span class="line">        TreeNode parent;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        E data;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(TreeNode parent, TreeNode left, E data, TreeNode right)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap红黑树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Make a new cell with given key, value, and parent, and with</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@code</span> null&#125; child links, and BLACK color.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="7-list接口分析">7. List接口分析</span></h2>
<h3><span id="71-list接口特点">7.1 List接口特点</span></h3>
<ul>
<li>List集合所有的元素是以一种<code>线性方式</code>进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个元素<code>存取有序</code>的集合。即元素的存入顺序和取出顺序有保证。</li>
<li>它是一个<code>带有索引</code>的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有<code>重复</code>的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317345e6d1bfa05652424.png" alt></p>
<blockquote>
<p>注意：</p>
<p>List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。</p>
</blockquote>
<ul>
<li>List接口的主要实现类
<ul>
<li>ArrayList：动态数组</li>
<li>Vector：动态数组</li>
<li>LinkedList：双向链表</li>
<li>Stack：栈</li>
</ul>
</li>
</ul>
<h3><span id="72-动态数组arraylist与vector">7.2 动态数组ArrayList与Vector</span></h3>
<p>Java的List接口的实现类中有两个动态数组的实现：ArrayList 和 Vector。</p>
<h4><span id="721-arraylist与vector的区别">7.2.1 ArrayList与Vector的区别</span></h4>
<p>它们的底层物理结构都是数组，我们称为动态数组。</p>
<ul>
<li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li>
<li>动态数组的扩容机制不同，ArrayList默认扩容为原来的1.5倍，Vector默认扩容增加为原来的2倍。</li>
<li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK 6.0 及之前的版本也是10，JDK8.0 之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。原因：
<ul>
<li>用的时候，再创建数组，避免浪费。因为很多方法的返回值是ArrayList类型，需要返回一个ArrayList的对象，例如：后期从数据库查询对象的方法，返回值很多就是ArrayList。有可能你要查询的数据不存在，要么返回null，要么返回一个没有元素的ArrayList对象。</li>
</ul>
</li>
</ul>
<h4><span id="722-arraylist部分源码分析">7.2.2 ArrayList部分源码分析</span></h4>
<p><strong>JDK1.7.0_07中：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData; <span class="comment">//存储底层数组元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">//记录数组中存储的元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>); <span class="comment">//指定初始容量为10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">    elementData[size++] = e; <span class="comment">//将元素e添加到elementData数组中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果if条件满足，则进行数组的扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">//当前数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  <span class="comment">//判断旧数组的1.5倍是否够</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//判断旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//复制一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//判断index是否在有效的范围内</span></span><br><span class="line"></span><br><span class="line">    modCount++; <span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index); </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>; <span class="comment">//确定要移动的次数</span></span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size) <span class="comment">//index不合法的情况</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//返回指定位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：set()方法相关</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检验index是否合法</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：get()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index); <span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：indexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：lastIndexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>jdk1.8.0_271中：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  <span class="comment">//初始化为空数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法:add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;  <span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果需要的最小容量比当前数组的长度大，即当前数组不够存，就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">//当前数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">    <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//复制一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="723-arraylist相关方法图示">7.2.3 ArrayList相关方法图示</span></h4>
<ul>
<li><strong>ArrayList采用数组作为底层实现</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6663174a5e6d1bfa05653b63.png" alt></p>
<ul>
<li><strong>ArrayList自动扩容过程</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317575e6d1bfa05654ae4.png" alt></p>
<ul>
<li><strong>ArrayList的add(E e)方法</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317655e6d1bfa05655d8b.png" alt></p>
<ul>
<li><strong>ArrayList的add(int index,E e)方法</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317735e6d1bfa05657101.png" alt></p>
<h4><span id="724-vector部分源码分析">7.2.4 Vector部分源码分析</span></h4>
<p><strong>jdk1.8.0_271中：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(<span class="number">10</span>); <span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, <span class="number">0</span>); <span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：add()相关方法</span></span><br><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//看是否需要扩容</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity); <span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">//获取目前数组的长度</span></span><br><span class="line">    <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">    <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：indexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：removeElementAt()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="literal">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="73-链表linkedlist">7.3 链表LinkedList</span></h3>
<p>Java中有双链表的实现：LinkedList，它是List接口的实现类。</p>
<p>LinkedList是一个<code>双向链表</code>，如图所示：</p>
<p><img src="https://pic.imgdb.cn/item/666317815e6d1bfa056586b9.png" alt></p>
<h4><span id="731-链表与动态数组的区别">7.3.1 链表与动态数组的区别</span></h4>
<p>动态数组底层的物理结构是数组，因此根据索引访问的效率非常高。但是非末尾位置的插入和删除效率不高，因为涉及到移动元素。另外添加操作时涉及到扩容问题，就会增加时空消耗。</p>
<p>链表底层的物理结构是链表，因此根据索引访问的效率不高，即查找元素慢。但是插入和删除不需要移动元素，只需要修改前后元素的指向关系即可，所以插入、删除元素快。而且链表的添加不会涉及到扩容问题。</p>
<h4><span id="732-linkedlist源码分析">7.3.2 LinkedList源码分析</span></h4>
<p><strong>jdk1.8.0_271中：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//记录第一个结点的位置</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//记录当前链表的尾元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e); <span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last; <span class="comment">//用 l 记录原来的最后一个结点</span></span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，Node类定义如下</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item; <span class="comment">//元素数据</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">//下一个结点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法：获取get()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：插入add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//检查index范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//如果index==size，连接到当前链表的尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	index &lt; (size &gt;&gt; 1)采用二分思想，先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0</span></span><br><span class="line"><span class="comment">	往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部</span></span><br><span class="line"><span class="comment">	分不必要的遍历。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">//如果index&lt;size/2，就从前往后找目标结点</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则从后往前找目标结点</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把新结点插入到[index]位置的结点succ前面</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;<span class="comment">//succ是[index]位置对应的结点</span></span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev; <span class="comment">//[index]位置的前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新结点的prev是原来[index]位置的前一个结点</span></span><br><span class="line">    <span class="comment">//新结点的next是原来[index]位置的结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[index]位置对应的结点的prev指向新结点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果原来[index]位置对应的结点是第一个结点，那么现在新结点是第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//原来[index]位置的前一个结点的next指向新结点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//找到o对应的结点x</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到o对应的结点x</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">        <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">        <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">        x.next = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//元素个数减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//index是要删除元素的索引位置</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="733-linkedlist相关方法图示">7.3.3 LinkedList相关方法图示</span></h4>
<ul>
<li><strong>只有1个元素的LinkedList</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317935e6d1bfa05659d24.png" alt></p>
<ul>
<li><strong>包含4个元素的LinkedList</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317ac5e6d1bfa0565b952.png" alt></p>
<ul>
<li><strong>add(E e)方法</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317b95e6d1bfa0565c9be.png" alt></p>
<ul>
<li><strong>add(int index,E e)方法</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317c75e6d1bfa0565d8be.png" alt></p>
<ul>
<li><strong>remove(Object obj)方法</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317d25e6d1bfa0565e830.png" alt></p>
<ul>
<li><strong>remove(int index)方法</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/666317df5e6d1bfa0565f607.png" alt></p>
<h2><span id="8-map接口分析">8. Map接口分析</span></h2>
<h3><span id="81-哈希表的物理结构">8.1 哈希表的物理结构</span></h3>
<p>HashMap和Hashtable底层都是哈希表（也称散列表），其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个索引位置被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到某个table[index]桶中。</p>
<p>使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。</p>
<p><img src="https://pic.imgdb.cn/item/6663180b5e6d1bfa05662593.png" alt></p>
<h3><span id="82-hashmap中数据添加过程">8.2 HashMap中数据添加过程</span></h3>
<h4><span id="821-jdk7中过程分析">8.2.1 JDK7中过程分析</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在底层创建了长度为16的Entry[] table的数组</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(key1,value1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析过程如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">将(key1,value1)添加到当前hashmap的对象中。首先会调用key1所在类的hashCode()方法，计算key1的哈希值1，</span></span><br><span class="line"><span class="comment">此哈希值1再经过某种运算(hash())，得到哈希值2。此哈希值2再经过某种运算(indexFor())，确定在底层table数组中的索引位置i。</span></span><br><span class="line"><span class="comment">   （1）如果数组索引为i上的数据为空，则(key1,value1)直接添加成功   ------位置1</span></span><br><span class="line"><span class="comment">   （2）如果数组索引为i上的数据不为空，有(key2,value2)，则需要进一步判断：</span></span><br><span class="line"><span class="comment">       判断key1的哈希值2与key2的哈希值是否相同：</span></span><br><span class="line"><span class="comment">         （3） 如果哈希值不同，则(key1,value1)直接添加成功   ------位置2</span></span><br><span class="line"><span class="comment">              如果哈希值相同，则需要继续调用key1所在类的equals()方法，将key2放入equals()形参进行判断</span></span><br><span class="line"><span class="comment">                （4） equals方法返回false : 则(key1,value1)直接添加成功   ------位置3</span></span><br><span class="line"><span class="comment">                      equals方法返回true : 默认情况下，value1会覆盖value2。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">位置1：直接将(key1,value1)以Entry对象的方式存放到table数组索引i的位置。</span></span><br><span class="line"><span class="comment">位置2、位置3：(key1,value1) 与现有的元素以链表的方式存储在table数组索引i的位置，新添加的元素指向旧添加的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">在不断的添加的情况下，满足如下条件的情况下，会进行扩容:</span></span><br><span class="line"><span class="comment">if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) :</span></span><br><span class="line"><span class="comment">默认情况下，当要添加的元素个数超过12(即：数组的长度 * loadFactor得到的结果)时，就要考虑扩容。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">补充：jdk7源码中定义的：</span></span><br><span class="line"><span class="comment">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.get(key1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 计算key1的hash值，用这个方法hash(key1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">② 找index = table.length-1 &amp; hash;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(key1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 计算key1的hash值，用这个方法hash(key1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">② 找index = table.length-1 &amp; hash;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4><span id="822-jdk8中过程分析">8.2.2 JDK8中过程分析</span></h4>
<p>下面说明是JDK8相较于JDK7的不同之处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①</span></span><br><span class="line"><span class="comment">使用HashMap()的构造器创建对象时，并没有在底层初始化长度为16的table数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">②</span></span><br><span class="line"><span class="comment">jdk8中添加的key,value封装到了HashMap.Node类的对象中。而非jdk7中的HashMap.Entry。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">③</span></span><br><span class="line"><span class="comment">jdk8中新增的元素所在的索引位置如果有其他元素。在经过一系列判断后，如果能添加，则是旧的元素指向新的元素。而非jdk7中的新的元素指向旧的元素。“七上八下”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">④</span></span><br><span class="line"><span class="comment">jdk7时底层的数据结构是：数组+单向链表。 而jdk8时，底层的数据结构是：数组+单向链表+红黑树。</span></span><br><span class="line"><span class="comment">红黑树出现的时机：当某个索引位置i上的链表的长度达到8，且数组的长度超过64时，此索引位置上的元素要从单向链表改为红黑树。</span></span><br><span class="line"><span class="comment">如果索引i位置是红黑树的结构，当不断删除元素的情况下，当前索引i位置上的元素的个数低于6时，要从红黑树改为单向链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3><span id="83-hashmap源码剖析">8.3 HashMap源码剖析</span></h3>
<h4><span id="831-jdk170_07中源码">8.3.1 JDK1.7.0_07中源码</span></h4>
<p><img src="https://pic.imgdb.cn/item/6663181a5e6d1bfa056638db.png" alt></p>
<h5><span id="1-entry"><strong>1、Entry</strong></span></h5>
<p>key-value被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="2-属性"><strong>2、属性</strong></span></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//table数组的默认初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中key-value的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//临界值、阈值（扩容的临界值）</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"><span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<h5><span id="3-构造器"><strong>3、构造器</strong></span></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  	<span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="comment">//校验initialCapacity合法性 </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算得到table数组的长度（保证capacity是2的整次幂）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// threshold 初始为默认容量</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化table数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                                       (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="4-put方法"><strong>4、put()方法</strong></span></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//如果key是null，单独处理，存储到table[0]中，如果有另一个key为null，value覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      hashCode值        xxxxxxxxxx</span></span><br><span class="line"><span class="comment">      table.length-1    000001111</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">      hashCode值 xxxxxxxxxx  无符号右移几位和原来的hashCode值做^运算，使得hashCode高位二进制值参与计算，</span></span><br><span class="line"><span class="comment">                            也发挥作用，降低index冲突的概率。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">    <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//添加新的映射关系</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        h = hashSeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否需要库容</span></span><br><span class="line">    <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有key-value的存储位置</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length); </span><br><span class="line">        <span class="comment">//新的key-value的hash和index也会重新计算</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//存入table中</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//个数增加</span></span><br><span class="line">    size++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="832-jdk180_271中源码">8.3.2 JDK1.8.0_271中源码</span></h4>
<h5><span id="1-node"><strong>1、Node</strong></span></h5>
<p>key-value被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。</p>
<p>存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树。</p>
<p><img src="https://pic.imgdb.cn/item/666318345e6d1bfa056654b5.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Node类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其它结构：略</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//TreeNode类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="type">boolean</span> red; <span class="comment">//是红结点还是黑结点</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="2-属性"><strong>2、属性</strong></span></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认的初始容量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大容量  1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;  <span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">//默认树化阈值8，当链表的长度达到这个值后，要考虑树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//默认反树化阈值6，当树中结点的个数达到此阈值后，要考虑变为链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。</span></span><br><span class="line"><span class="comment">//当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>; <span class="comment">//最小树化容量64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;  <span class="comment">//记录有效映射关系的对数，也是Entry对象的个数</span></span><br><span class="line"><span class="type">int</span> threshold; <span class="comment">//阈值，当size达到阈值时，考虑扩容</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor; <span class="comment">//加载因子，影响扩容的频率</span></span><br></pre></td></tr></table></figure>
<h5><span id="3-构造器"><strong>3、构造器</strong></span></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted (其他字段都是默认值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="4-put方法"><strong>4、put()方法</strong></span></h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//如果key是null，hash是0</span></span><br><span class="line">	<span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line">	<span class="comment">//		即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">	如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">	这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">    Node&lt;K,V&gt; p;  <span class="comment">//一个结点</span></span><br><span class="line">    <span class="type">int</span> n, i; <span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tab和table等价</span></span><br><span class="line">	<span class="comment">//如果table是空的</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		tab = resize();</span></span><br><span class="line"><span class="comment">		n = tab.length;*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">		n = 16</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">	<span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line">	<span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line">		<span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123; <span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">            <span class="comment">//单独处理树结点</span></span><br><span class="line">            <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">            <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line">			<span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">//什么也没干</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">	<span class="comment">//size达到阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize(); <span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">//什么也没干</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">//oldTab原来的table</span></span><br><span class="line">    <span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//newCap，新容量</span></span><br><span class="line">	<span class="comment">//newThr：新阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//说明原来不是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//是否达到数组最大限制</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">			<span class="comment">//新容量：32,64，...</span></span><br><span class="line">			<span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line">			<span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">        <span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line">    <span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">//原来不是空数组</span></span><br><span class="line">        <span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>; <span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>) <span class="comment">//如果是最后一个结点</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果e是树结点</span></span><br><span class="line">                    <span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个新结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; </span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">    <span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();<span class="comment">//先扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">			do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<p><img src="https://pic.imgdb.cn/item/6663184d5e6d1bfa056677c5.png" alt></p>
<h3><span id="84-linkedhashmap源码剖析">8.4 LinkedHashMap源码剖析</span></h3>
<h4><span id="841-源码">8.4.1 源码</span></h4>
<p>内部定义的Entry如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">	Entry&lt;K,V&gt; before, after;</span><br><span class="line">	</span><br><span class="line">	Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">		<span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap重写了HashMap中的newNode()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="842-图示">8.4.2 图示</span></h4>
<p><img src="https://pic.imgdb.cn/item/6663185e5e6d1bfa05669143.png" alt></p>
<h2><span id="9-set接口分析">9. Set接口分析</span></h2>
<h3><span id="91-set集合与map集合的关系">9.1 Set集合与Map集合的关系</span></h3>
<p>Set的内部实现其实是一个Map，Set中的元素，存储在HashMap的key中。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。</p>
<h3><span id="92-源码剖析">9.2 源码剖析</span></h3>
<p><strong>HashSet源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个构造器是给子类LinkedHashSet调用的</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterator()方法：</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedHashSet源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);<span class="comment">//调用HashSet的某个构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);<span class="comment">//调用HashSet的某个构造器</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>TreeSet源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="built_in">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<h2><span id="10-拓展hashmap的相关问题">10. 【拓展】HashMap的相关问题</span></h2>
<h4><span id="1-说说你理解的哈希算法">1、说说你理解的哈希算法</span></h4>
<p>hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。</p>
<p><img src="https://pic.imgdb.cn/item/6663186f5e6d1bfa0566aa1b.png" alt></p>
<h4><span id="2-entry中的hash属性为什么不直接使用key的hashcode返回值呢">2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？</span></h4>
<p>不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p>
<p><img src="https://pic.imgdb.cn/item/6663187c5e6d1bfa0566b7fb.png" alt></p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。</p>
<p>为什么要hashCode值的二进制的高位参与到index计算呢？</p>
<p>因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</p>
<h4><span id="3-hashmap是如何决定某个key-value存在哪个桶的呢">3、HashMap是如何决定某个key-value存在哪个桶的呢？</span></h4>
<p>因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：</p>
<p>①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算效率没有位运算符&amp;高。</p>
<p>②hash 值 &amp; (table.length-1)，任何数 &amp; (table.length-1)的结果也一定在[0, table.length-1]范围。</p>
<p><img src="https://pic.imgdb.cn/item/6663188c5e6d1bfa0566ccf2.png" alt></p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">//此处h就是hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  <span class="comment">// i = (n - 1) &amp; hash</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//....省略大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="4-为什么要保持table数组一直是2的n次幂呢">4、为什么要保持table数组一直是2的n次幂呢？</span></h4>
<p>因为如果数组的长度为2的n次幂，那么table.length-1的二进制就是一个高位全是0，低位全是1的数字，这样才能保证每一个下标位置都有机会被用到。</p>
<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode值是   ？</span><br><span class="line">table.length是<span class="number">10</span></span><br><span class="line">table.length-<span class="number">1</span>是<span class="number">9</span></span><br><span class="line"></span><br><span class="line">？   ????????</span><br><span class="line"><span class="number">9</span>	 <span class="number">00001001</span></span><br><span class="line">&amp;_____________</span><br><span class="line">	 <span class="number">00000000</span>	[<span class="number">0</span>]</span><br><span class="line">	 <span class="number">00000001</span>	[<span class="number">1</span>]</span><br><span class="line">	 <span class="number">00001000</span>	[<span class="number">8</span>]</span><br><span class="line">	 <span class="number">00001001</span>	[<span class="number">9</span>]</span><br><span class="line">	 一定[<span class="number">0</span>]~[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode值是   ？</span><br><span class="line">table.length是<span class="number">16</span></span><br><span class="line">table.length-<span class="number">1</span>是<span class="number">15</span></span><br><span class="line"></span><br><span class="line">？   ????????</span><br><span class="line"><span class="number">15</span>	 <span class="number">00001111</span></span><br><span class="line">&amp;_____________</span><br><span class="line">	 <span class="number">00000000</span>	[<span class="number">0</span>]</span><br><span class="line">	 <span class="number">00000001</span>	[<span class="number">1</span>]</span><br><span class="line">	 <span class="number">00000010</span>	[<span class="number">2</span>]</span><br><span class="line">	 <span class="number">00000011</span>	[<span class="number">3</span>]</span><br><span class="line">	 ...</span><br><span class="line">	 <span class="number">00001111</span>    [<span class="number">15</span>]</span><br><span class="line">	 范围是[<span class="number">0</span>,<span class="number">15</span>]，一定在[<span class="number">0</span>,table.length-<span class="number">1</span>]范围内</span><br></pre></td></tr></table></figure>
<h4><span id="5-解决index冲突问题">5、解决[index]冲突问题</span></h4>
<p>虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p>
<p>JDK1.8之间使用：数组+链表的结构。</p>
<p><img src="https://pic.imgdb.cn/item/6663189e5e6d1bfa0566e5e1.png" alt></p>
<p>JDK1.8之后使用：数组+链表/红黑树的结构。</p>
<p><img src="https://pic.imgdb.cn/item/666318ad5e6d1bfa0566f62b.png" alt></p>
<p>即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p>
<h4><span id="6-为什么jdk18会出现红黑树和链表共存呢">6、为什么JDK1.8会出现红黑树和链表共存呢？</span></h4>
<p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。</p>
<p>但是二叉树的结构又过于复杂，占用内存也较多，如果结点个数比较少的时候，那么选择链表反而更简单。所以会出现红黑树和链表共存。</p>
<h4><span id="7-加载因子的值大小有什么关系">7、加载因子的值大小有什么关系？</span></h4>
<p>如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。</p>
<p>如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</p>
<h4><span id="8-什么时候树化什么时候反树化">8、什么时候树化？什么时候反树化？</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">//树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//反树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;<span class="comment">//最小树化容量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当某table[index]下的链表的结点个数达到8，并且table.length&gt;=64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。</p>
</li>
<li>
<p>当某table[index]下的红黑树结点个数少于6个，此时，</p>
<ul>
<li>当继续删除table[index]下的树结点，最后这个根结点的左右结点有null，或根结点的左结点的左结点为null，会反树化</li>
<li>当重新添加新的映射关系到map中，导致了map重新扩容了，这个时候如果table[index]下面还是小于等于6的个数，那么会反树化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyKey</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyKey</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            result = prime * result + num;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyKey</span> <span class="variable">other</span> <span class="operator">=</span> (MyKey) obj;</span><br><span class="line">        <span class="keyword">if</span> (num != other.num)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashMapMyKey</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里为了演示的效果，我们造一个特殊的类，这个类的hashCode（）方法返回固定值1</span></span><br><span class="line">        <span class="comment">//因为这样就可以造成冲突问题，使得它们都存到table[1]中</span></span><br><span class="line">        HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);<span class="comment">//树化演示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.remove(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i));<span class="comment">//反树化演示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">            map.remove(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i));</span><br><span class="line">        &#125;<span class="comment">//table[1]下剩余6个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">21</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);<span class="comment">//添加到扩容时，反树化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4><span id="9-key-value中的key是否可以修改">9、key-value中的key是否可以修改？</span></h4>
<p>key-value存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的key-value，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
<p>这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合。</p>
<h4><span id="10-jdk17中hashmap的循环链表是怎么回事如何解决">10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？</span></h4>
<p><img src="https://pic.imgdb.cn/item/666318c05e6d1bfa05670f55.png" alt></p>
<p>避免HashMap发生死循环的常用解决方案：</p>
<ul>
<li>多线程环境下，使用线程安全的ConcurrentHashMap替代HashMap，推荐</li>
<li>多线程环境下，使用synchronized或Lock加锁，但会影响性能，不推荐</li>
<li>多线程环境下，使用线程安全的Hashtable替代，性能低，不推荐</li>
</ul>
<p>HashMap死循环只会发生在JDK1.7版本中，主要原因：头插法+链表+多线程并发+扩容。</p>
<p>在JDK1.8中，HashMap改用尾插法，解决了链表死循环的问题。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/post/%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80api/</url>
    <content><![CDATA[<h2><span id="1-javalangstring不可变字符序列">1. java.lang.String（不可变字符序列）</span></h2>
<h3><span id="11-string的特性jdk8">1.1 String的特性（JDK8）</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[]; <span class="comment">//String对象的字符内容是存储在此数组中</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>String类被final关键字修饰，因而无法被继承</li>
<li>String类实现了可序列化接口、可比较接口，可以进行数据的传输、比较大小</li>
<li>String对象的字符内容存储在value字符数组中
<ul>
<li>final关键字：说明value一旦被初始化，其地址无法改变，因此修改String对象的字符内容时，会重新创建一个String对象并重新对value初始化</li>
<li>private关键字：String没有提供value的get和set方法，意味着外面无法直接获取字符数组</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储字符串数据的容器(JDK9开始)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; </span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JDK9开始value由原来的字符数组改成了byte数组</li>
<li>这是由于大多数String对象只存储Latin-1字符，这些字符只需要一个字节的存储空间，因此char类型的value数组中有一半空间未使用</li>
<li>为了有效利用value数组的空间，新的String类将自动根据字符串的内容存储对应的编码，如ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符</li>
</ul>
<h3><span id="12-字符串常量的存储位置">1.2 字符串常量的存储位置</span></h3>
<ul>
<li>
<p>字符串常量都存储在字符串常量池（StringTable）中</p>
</li>
<li>
<p>字符串常量池不允许存放两个相同的字符串常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.println.out(s1 == s2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/66542887d9c307b7e92e5584.png" style="zoom:50%;">
</li>
<li>
<p>在JDK不同版本中，字符串常量池存储在不同的位置</p>
<ul>
<li>
<p>JDK7之前字符串常量池存放在方法去</p>
<img src="https://pic.imgdb.cn/item/6652e3c0d9c307b7e9f7985e.png" style="zoom:67%;">
</li>
<li>
<p>JDK7及以后字符串常量池存放在堆空间中（利于及时的回收字符串常量）</p>
<img src="https://pic.imgdb.cn/item/6652e3d4d9c307b7e9f7ac5a.png" style="zoom: 67%;">
<img src="https://pic.imgdb.cn/item/6652e3f0d9c307b7e9f7cdf8.png" style="zoom:67%;">
</li>
</ul>
</li>
</ul>
<h3><span id="13-string的内存结构">1.3 String的内存结构</span></h3>
<p><img src="https://pic.imgdb.cn/item/66542821d9c307b7e92defe4.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;h1&quot;</span>;</span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/66542905d9c307b7e92ed4c8.png" style="zoom:50%;">
<p>当对字符串变量s2重新赋值时，首先会在字符串常量池中创建一个新的字符串常量</p>
<p>然后s2指向字符串常量池中新创建的字符串常量（“hi”），不会在原有位置上修改</p>
<img src="https://pic.imgdb.cn/item/6652e632d9c307b7e9fa342c.png" style="zoom: 50%;">
<p>当对字符串变量s2进行拼接操作时，需要重新开辟空间保存拼接以后的字符串，不能在原有位置上修改</p>
<img src="https://pic.imgdb.cn/item/6652e720d9c307b7e9fb27ad.png" style="zoom:50%;">
<p>当调用String类的replace()替换现有的某个字符时，需要重新开辟空间保存修改之后的字符串，不能在原有的位置上修改</p>
<h3><span id="14-string实例化的两种方式">1.4 String实例化的两种方式</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.println.out(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.println.out(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.println.out(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.println.out(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/6652e94dd9c307b7e9fd5c3b.png" style="zoom:50%;">
<img src="https://pic.imgdb.cn/item/6652f13ad9c307b7e907964f.png" style="zoom:50%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">//通过查看字节码文件，以下字符串含有变量的运算使用了StringBuilder进行拼接，并最后new String()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s5.intern();	<span class="comment">//返回字符串常量池中字面量的地址</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>String的连接操作：</p>
<ul>
<li>常量间的字符串连接：结果仍然存储在字符串常量池中（final修饰的字符串变量经过初始化也被看作是常量）</li>
<li>含有变量的字符串连接：通过new的方式建立字符串，再指向堆空间中该字符串对象的地址</li>
<li>调用字符串的intern()：返回字符串常量池中字面量的地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.concat(s2);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s4 == s5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>concat()：无论是字符串常量调用此方法，还是字符串变量调用此方法，且无论参数为常量还是变量，调用concat都会new一个字符串对象</p>
<h2><span id="2-string的常用方法">2. String的常用方法</span></h2>
<h3><span id="21-string构造器">2.1 String构造器</span></h3>
<table>
<thead>
<tr>
<th>String 构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String()</td>
<td>初始化创建表示空字符序列的String对象</td>
</tr>
<tr>
<td>String(String original)</td>
<td>初始化创建与参数相同字符序列的String对象</td>
</tr>
<tr>
<td>public String(char[] value)</td>
<td>通过参数的字符数组来构造新的String</td>
</tr>
<tr>
<td>public String(char[] value, int offset, int count)</td>
<td>通过指定的部分字符数组来构造新的String</td>
</tr>
<tr>
<td>public String(byte[] bytes)</td>
<td>通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String</td>
</tr>
<tr>
<td>public String(byte[] bytes, String charsetName)</td>
<td>通过使用指定的字符集解码当前参数中的字节数组来构造新的String</td>
</tr>
</tbody>
</table>
<h3><span id="22-string与char之间的转换">2.2 String与char[]之间的转换</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//String --&gt; char[]：调用String的toCharArray()</span></span><br><span class="line"><span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char[] --&gt; String：调用String的构造器</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">System.out.println(str1);<span class="comment">//hello</span></span><br></pre></td></tr></table></figure>
<h3><span id="23-string与byte之间的转换">2.3 String与byte[]之间的转换</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc中国&quot;</span>);</span><br><span class="line"><span class="comment">//（编码）String --&gt; byte[]：调用String的getBytes()</span></span><br><span class="line"><span class="type">byte</span>[] arr = str.getBytes();<span class="comment">//使用默认字符集(utf-8,汉字占3字节，字母占1字节)</span></span><br><span class="line"><span class="type">byte</span>[] arr1 = str.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//gbk字符集汉字占2字节，字母占1字节，gbk、utf-8都兼容ASCII码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（解码）byte[] --&gt; String 	解码必须使用与编码一致的字符集，否则会乱码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);<span class="comment">//使用默认字符集utf-8，</span></span><br><span class="line">System.out.println(str1);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr1,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用指定字符集gbk</span></span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>
<h3><span id="24string的常用方法">2.4String的常用方法</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean isEmpty()</td>
<td>字符串是否为空</td>
</tr>
<tr>
<td>int length()</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>String concat(XX)</td>
<td>拼接</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>比较字符串是否相等（区分大小写）</td>
</tr>
<tr>
<td>boolean equalsIgnoreCase(Object obj)</td>
<td>比较字符串是否相等（不区分大小写）</td>
</tr>
<tr>
<td>int compareTo(String othre)</td>
<td>比较字符串大小（区分大小写），根据Unicode编码值比较</td>
</tr>
<tr>
<td>int compareToIgnoreCase(String other)</td>
<td>比较字符串大小（不区分大小写）</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>将字符串中的大写字母转为小写</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>将字符串中的小写字母转为大写</td>
</tr>
<tr>
<td>String trim()</td>
<td>去掉字符串前后的空白符</td>
</tr>
<tr>
<td>public String intern()</td>
<td>结果在常量池中共享</td>
</tr>
<tr>
<td>boolean contains(XX)</td>
<td>查找是否包含</td>
</tr>
<tr>
<td>int indexOf(XX)</td>
<td>从前往后查找当前字符串中的XX，返回第一次出现的下标，不存在则返回-1</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>返回指定子字符串在此字符串中第一次出现的索引，从指定的索引开始</td>
</tr>
<tr>
<td>int lastIndexOf(XX)</td>
<td>从后往前查找当前字符串中的XX，返回最后一次出现的下标，不存在则返回-1</td>
</tr>
<tr>
<td>int lastIndexOf(String str, int fromIndex)</td>
<td>返回指定子字符串在此字符串中最后一次出现的索引，从指定的索引开始反向查找</td>
</tr>
<tr>
<td>String substring(int beginIndex)</td>
<td>返回从beginIndex开始截取到最后的一个子字符串</td>
</tr>
<tr>
<td>String substring(int beginIndex, int endIndex)</td>
<td>返回从beginIndex开始截取到endIndex的一个子字符串（左闭右开）</td>
</tr>
<tr>
<td>char charAt(int index)</td>
<td>返回index位置的字符</td>
</tr>
<tr>
<td>char[] toCharArray()</td>
<td>将字符串转换为一个字符数组并返回</td>
</tr>
<tr>
<td>static String valueOf(char[] data)</td>
<td>返回指定数组中表示该字符序列的String</td>
</tr>
<tr>
<td>static String valueOf(char[] data, int offset, int count )</td>
<td>返回指定数组中表示该字符序列的String</td>
</tr>
<tr>
<td>static String copyValueOf(char[] data)</td>
<td>返回指定数组中表示该字符序列的String</td>
</tr>
<tr>
<td>static String copyValueOf(char[] data, int offset, int count)</td>
<td>返回指定数组中表示该字符序列的String</td>
</tr>
<tr>
<td>boolean startsWith(XX)</td>
<td>是否以指定前缀开始</td>
</tr>
<tr>
<td>boolean startsWith(String prefix, int offset)</td>
<td>从指定索引开始检测是否已指定前缀开始</td>
</tr>
<tr>
<td>boolean endsWith(XX)</td>
<td>是否以指定后缀结束</td>
</tr>
<tr>
<td>String replace(char oldChar, char newChar)</td>
<td>返回一个新的字符串，通过用newChar替换所有oldChar得到（不支持正则）</td>
</tr>
<tr>
<td>String replace(CharSequence target, CharSequence replacement)</td>
<td>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</td>
</tr>
<tr>
<td>String replaceAll(String regex, String replacement)</td>
<td>使用给定的replacement替换此字符串中所有匹配给定的正则表达式的子字符串</td>
</tr>
<tr>
<td>String replaceFirst(String regex, String replacement)</td>
<td>使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String <span class="title function_">valueOf</span><span class="params">(new <span class="type">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;)</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String <span class="title function_">copyValueOf</span><span class="params">(new <span class="type">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;)</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3><span id="25-string-stringbuffer-stringbuilder三者对比">2.5 String、StringBuffer、StringBuilder三者对比</span></h3>
<p>三者在JDK8及之前都使用Char[]，JDK9及以后使用byte[]</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody>
<tr>
<td>value是否可变</td>
<td>不可变（final）</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td>是否线程安全</td>
<td>线程安全</td>
<td>线程安全（加同步锁）</td>
<td>不是线程安全</td>
</tr>
<tr>
<td>运行效率</td>
<td>最低</td>
<td>中等</td>
<td>最高</td>
</tr>
</tbody>
</table>
<p>StringBuffer和StringBuilder都是实现AbstractStringBuilder接口，定义的属性如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] value;<span class="comment">//存储字符序列</span></span><br><span class="line"><span class="type">int</span> count;<span class="comment">//存储字符的实际个数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sBuilder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">//char[] value = new char[16];	无参构造初始化容量为16</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sBuilder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[16 + &quot;abc&quot;.length]</span></span><br><span class="line">sBuilder1.append(<span class="string">&quot;ac&quot;</span>);<span class="comment">//value[0] = &#x27;a&#x27;; value[1] = &#x27;c&#x27;;</span></span><br><span class="line">sBuilder1.append(<span class="string">&quot;b&quot;</span>);<span class="comment">//value[2] = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment">//当添加后的总元素个数(count)大于此时数组的长度时，需要扩容（默认扩容为原有容量的2倍 + 2），并将原有数组中的数据赋值到新的数组中</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>若开发中需要频繁的针对于字符串的添加、修改、删除等操作，建议使用StringBuffer、StringBuilder（String效率太低）</li>
<li>若开发中使用单线程或不涉及线程安全的问题，建议使用StringBuilder替换StringBuffer（StringBuffer线程安全，有同步锁导致效率低）</li>
<li>若开发中大致确定要操作字符的个数，建议使用带参数（int capacity）的构造器，避免初始化的容量不够引起的多次扩容</li>
</ul>
<h3><span id="26-stringbuffer-stringbuilder的常用方法">2.6 StringBuffer、StringBuilder的常用方法</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringBuffer append(XX)</td>
<td>用于进行字符串追加方式的拼接</td>
</tr>
<tr>
<td>StringBuffer insert(int index, XX)</td>
<td>在index位置上插入XX</td>
</tr>
<tr>
<td>StringBuffer delete(int start, int end)</td>
<td>删除[start,end)之间的字符</td>
</tr>
<tr>
<td>StringBuffer deleteCharAt(int index)</td>
<td>删除index位置的字符</td>
</tr>
<tr>
<td>StringBuffer replace(int start, int end, String str)</td>
<td>替换[start,end)之间的字符为str</td>
</tr>
<tr>
<td>void setCharAt(int index, char c)</td>
<td>替换index位置的字符为c</td>
</tr>
<tr>
<td>StringBuffer reverse()</td>
<td>反转</td>
</tr>
<tr>
<td>char charAt(int index)</td>
<td>查找index位置的字符</td>
</tr>
<tr>
<td>int length()</td>
<td>返回存储的字符数据的长度</td>
</tr>
<tr>
<td>int indexOf(String  str)</td>
<td>在当前字符序列中查询str第一次出现的下标</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>在当前字符序列中从fromIndex位置开始查找str第一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>在当前字符序列中查询str最后一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str, int fromIndex)</td>
<td>在当前字符序列中从fromIndex位置开始查找str最后一次出现的下标</td>
</tr>
<tr>
<td>String substring(int start)</td>
<td>从start位置开始截取当前字符序列</td>
</tr>
<tr>
<td>String substring(int start, int end)</td>
<td>[start, end)截取当前字符序列</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回此序列中的字符串表示形式</td>
</tr>
<tr>
<td>void setLength(int newLength)</td>
<td>设置当前字符序列的长度为newLength（本质上修改count）</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">sBuilder.setLength(<span class="number">2</span>);</span><br><span class="line">System.out.println(sBuilder);<span class="comment">//he</span></span><br><span class="line">sBuilder.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(sBuilder);<span class="comment">//hec</span></span><br><span class="line">sBuilder.setLength(<span class="number">10</span>);</span><br><span class="line">System.out.println(sBuilder);<span class="comment">//hec0000000</span></span><br><span class="line">System.out.println(sBuilder.charAt(<span class="number">6</span>) == <span class="number">0</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2><span id="3-jdk8之前日期时间api">3. JDK8之前：日期时间API</span></h2>
<h3><span id="31-javalangsystem类的方法">3.1 java.lang.System类的方法</span></h3>
<p>public static long currentTimeMillis()：用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(time);<span class="comment">//1559806982971</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>常用于计算执行的时间差</p>
</li>
<li>
<p>计算世界时间的主要标准有：</p>
<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
<blockquote>
<p>在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。这里，UTC与GMT含义完全相同。</p>
</blockquote>
</li>
</ul>
<h3><span id="32-javautildate">3.2 java.util.Date</span></h3>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date()</td>
<td>使用无参构造器创建的对象可以获取本地当前时间</td>
</tr>
<tr>
<td>Date(long 毫秒数)</td>
<td>把该毫秒值换算成日期时间对象</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">1559807047979L</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getTime()</td>
<td>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数</td>
</tr>
<tr>
<td>toString()</td>
<td>把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">System.out.println(time);<span class="comment">//1559807047979</span></span><br></pre></td></tr></table></figure>
<h3><span id="33-javatextsimpledateformat">3.3 java.text.SimpleDateFormat</span></h3>
<p>不与语言环境有关的方式来格式化和解析日期的具体类</p>
<p>格式化：日期 --&gt; 文本</p>
<p>解析：文本 --&gt; 日期</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SimpleDateFormat()</td>
<td>默认的模式和语言环境创建对象</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>该构造方法可以用参数pattern指定的格式创建一个对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String format(Date date)</td>
<td>方法格式化时间对象date</td>
</tr>
<tr>
<td>public Date parse(String source)</td>
<td>从给定字符串的开始解析文本，以生成一个日期</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/6654601fd9c307b7e96ea284.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line"><span class="comment">//把Date日期转成字符串，按照指定的格式转</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sf.format(d);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2022年06月06日 16时03分14秒 545毫秒  星期四 +0800&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sf.parse(str);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>
<h3><span id="34-javautilcalendar日历">3.4 java.util.Calendar(日历)</span></h3>
<ul>
<li>
<p>Date类的API大部分被废弃了，替换为Calendar</p>
</li>
<li>
<p><code>Calendar</code> 类是一个抽象类，主用用于完成日期字段之间相互操作的功能</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static calendar getInstance()</td>
<td>使用默认时区和默认语言环境获取一个日历</td>
</tr>
<tr>
<td>static calendar getInstance(Locale aLocale)</td>
<td>使用默认时区和指定语言环境获取一个日历</td>
</tr>
<tr>
<td>static calendar getInstance(TimeZone zone)</td>
<td>使用指定时区和默认语言环境获取一个日历</td>
</tr>
<tr>
<td>static calendar getInstance(TimeZone zone, Locale aLocale)</td>
<td>使用指定时区和指定语言环境获取一个日历</td>
</tr>
</tbody>
</table>
<ul>
<li>获取实例也可以调用它的子类GregorianCalendar（公历）的构造器</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public int get(int field)</td>
<td>返回给定日历字段的值</td>
</tr>
<tr>
<td>public void set(int field,int value)</td>
<td>将给定的日历字段设置为指定的值</td>
</tr>
<tr>
<td>public void add(int field,int amount)</td>
<td>根据日历的规则，为给定的日历字段添加或者减去指定的时间量</td>
</tr>
<tr>
<td>public final Date getTime()</td>
<td>将Calendar转成Date对象</td>
</tr>
<tr>
<td>public final void setTime(Date date)</td>
<td>使用指定的Date对象重置Calendar的时间</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>日历常用字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以加1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12h制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24h制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody>
</table>
<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2 ， 。。。。周六是7</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> c.get(Calendar.DATE);</span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> c.get(Calendar.MINUTE);</span><br><span class="line">System.out.println(year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day + <span class="string">&quot; &quot;</span> + hour + <span class="string">&quot;:&quot;</span> + minute);</span><br><span class="line"></span><br><span class="line"><span class="type">TimeZone</span> <span class="variable">t</span> <span class="operator">=</span> TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>);</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(t);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> c.get(Calendar.DATE);</span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> c.get(Calendar.MINUTE);</span><br><span class="line">System.out.println(year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day + <span class="string">&quot; &quot;</span> + hour + <span class="string">&quot;:&quot;</span> + minute);</span><br><span class="line"></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">// 从一个 Calendar 对象中获取 Date 对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用给定的 Date 设置此 Calendar 的时间</span></span><br><span class="line">date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">234234235235L</span>);</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间日设置为8后,时间是:&quot;</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.HOUR, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间加2小时后,时间是:&quot;</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前日期减2个月后,时间是:&quot;</span> + calendar.getTime());  </span><br></pre></td></tr></table></figure>
<h2><span id="4-jdk8新的日期时间api">4. JDK8：新的日期时间API</span></h2>
<ul>
<li>
<p>JDK在1.1时引入Calendar类，JDK 1.0中的java.util.Date类的大多数方法随之被弃用了</p>
</li>
<li>
<p>Calendar也有着如下缺陷：</p>
<ul>
<li>
<p>可变性：像日期和时间这样的类应该是不可变的。</p>
</li>
<li>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p>
</li>
<li>
<p>格式化：格式化只对Date有用，Calendar则不行。</p>
</li>
<li>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
<blockquote>
<p>闰秒，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1秒的调整。由于地球自转的不均匀性和长期变慢性（主要由潮汐摩擦引起的），会使世界时（民用时）和原子时之间相差超过到±0.9秒时，就把协调世界时向前拨1秒（负闰秒，最后一分钟为59秒）或向后拨1秒（正闰秒，最后一分钟为61秒）； 闰秒一般加在公历年末或公历六月末。</p>
<p>目前，全球已经进行了27次闰秒，均为正闰秒。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>Java 8中引入的java.time API 已经纠正了过去的缺陷，新的日期时间API包含：</p>
<ul>
<li><code>java.time</code> – 包含值对象的基础包</li>
<li><code>java.time.chrono</code> – 提供对不同的日历系统的访问。</li>
<li><code>java.time.format</code> – 格式化和解析时间和日期</li>
<li><code>java.time.temporal</code> – 包括底层框架和扩展特性</li>
<li><code>java.time.zone</code> – 包含时区支持的类</li>
</ul>
<p>说明：新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类</p>
<p>尽管有68个新的公开类型，但是大多数开发者只会用到基础包和format包，大概占总数的三分之一</p>
<h3><span id="41-本地日期时间localdate-localtime-localdatetime">4.1 本地日期时间：LocalDate、LocalTime、LocalDateTime</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>now() </code>/ now(ZoneId zone)</td>
<td>静态方法，根据当前时间创建对象/指定时区的对象</td>
</tr>
<tr>
<td><code>of(xx,xx,xx,xx,xx,xxx)</code></td>
<td>静态方法，根据指定日期/时间创建对象</td>
</tr>
<tr>
<td>getDayOfMonth()/getDayOfYear()</td>
<td>获得月份天数(1-31) /获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份, 返回一个 Month 枚举值</td>
</tr>
<tr>
<td>getMonthValue() / getYear()</td>
<td>获得月份(1-12) /获得年份</td>
</tr>
<tr>
<td>getHours()/getMinute()/getSecond()</td>
<td>获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td>with(TemporalAdjuster  t)</td>
<td>将当前日期时间设置为校对器指定的日期时间</td>
</tr>
<tr>
<td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td>
<td>向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td>
<td>从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
<tr>
<td>plus(TemporalAmount t)/minus(TemporalAmount t)</td>
<td>添加或减少一个 Duration 或 Period</td>
</tr>
<tr>
<td>isBefore()/isAfter()</td>
<td>比较两个 LocalDate</td>
</tr>
<tr>
<td>isLeapYear()</td>
<td>判断是否是闰年（在LocalDate类中声明）</td>
</tr>
<tr>
<td>format(DateTimeFormatter  t)</td>
<td>格式化本地日期、时间，返回一个字符串</td>
</tr>
<tr>
<td>parse(Charsequence text)</td>
<td>将指定格式的字符串解析为日期、时间</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lai</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">System.out.println(lai);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lai</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">System.out.println(lai.getDayOfYear());</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lai</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">go</span> <span class="operator">=</span> lai.plusDays(<span class="number">160</span>);</span><br><span class="line">System.out.println(go);<span class="comment">//2019-10-20</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">before</span> <span class="operator">=</span> now.minusDays(<span class="number">100</span>);</span><br><span class="line">System.out.println(before);<span class="comment">//2019-02-26</span></span><br></pre></td></tr></table></figure>
<h3><span id="42-瞬时instant">4.2 瞬时：Instant</span></h3>
<ul>
<li>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳
<ul>
<li>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数</li>
</ul>
</li>
<li><code>java.time.Instant</code>表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，<code>它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数</code></li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>now()</code></td>
<td>静态方法，返回默认UTC时区的Instant类的对象</td>
</tr>
<tr>
<td><code>ofEpochMilli(long epochMilli)</code></td>
<td>静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>结合即时的偏移来创建一个 OffsetDateTime</td>
</tr>
<tr>
<td><code>toEpochMilli()</code></td>
<td>返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</td>
</tr>
</tbody>
</table>
<blockquote>
<p>中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。</p>
<p>instant.atOffset(ZoneOffset.ofHours(8));</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/665464cbd9c307b7e9734e98.png" alt></p>
<blockquote>
<p>整个地球分为二十四时区，每个时区都有自己的本地时间。北京时区是东八区，领先UTC八个小时，在电子邮件信头的Date域记为+0800。如果在电子邮件的信头中有这么一行：</p>
<p>Date: Fri, 08 Nov 2002 09:42:22 +0800</p>
<p>说明信件的发送地的地方时间是二○○二年十一月八号，星期五，早上九点四十二分（二十二秒），这个地方的本地时领先UTC八个小时(+0800， 就是东八区时间)。电子邮件信头的Date域使用二十四小时的时钟，而不使用AM和PM来标记上下午。</p>
</blockquote>
<h3><span id="43-日期时间格式化datetimeformatter">4.3 日期时间格式化：DateTimeFormatter</span></h3>
<p>该类提供了三种格式化方法：</p>
<ul>
<li>
<p>(了解)预定义的标准格式。如：ISO_LOCAL_DATE_TIME、ISO_LOCAL_DATE、ISO_LOCAL_TIME</p>
</li>
<li>
<p>(了解)本地化相关的格式。如：ofLocalizedDate(FormatStyle.LONG)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line"><span class="comment">// FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">				</span><br><span class="line"><span class="comment">// 本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line"><span class="comment">// FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方</strong>   <strong>法</strong></th>
<th><strong>描</strong>   <strong>述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ofPattern(String</strong>  <strong>pattern)</strong></td>
<td>静态方法，返回一个指定字符串格式的DateTimeFormatter</td>
</tr>
<tr>
<td><strong>format(TemporalAccessor</strong> <strong>t)</strong></td>
<td>格式化一个日期、时间，返回字符串</td>
</tr>
<tr>
<td><strong>parse(CharSequence</strong>  <strong>text)</strong></td>
<td>将指定格式的字符序列解析为一个日期、时间</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line"><span class="comment">// 格式化:日期--&gt;字符串</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(str1);<span class="comment">//2022-12-04T21:02:14.808</span></span><br><span class="line"><span class="comment">// 解析：字符串 --&gt;日期</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2022-12-04T21:02:14.808&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.from(parse);</span><br><span class="line">System.out.println(dateTime);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="comment">// 本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line"><span class="comment">// FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">System.out.println(str2);<span class="comment">// 2022年12月4日 下午09时03分55秒</span></span><br><span class="line"><span class="comment">// 本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line"><span class="comment">// FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter2.format(LocalDate.now());</span><br><span class="line">System.out.println(str3);<span class="comment">// 2022年12月4日 星期日</span></span><br><span class="line"><span class="comment">//方式三：自定义的方式（关注、重点）</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strDateTime</span> <span class="operator">=</span> dateTimeFormatter.format(LocalDateTime.now());</span><br><span class="line">System.out.println(strDateTime); <span class="comment">//2022/12/04 21:05:42</span></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> dateTimeFormatter.parse(<span class="string">&quot;2022/12/04 21:05:42&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.from(accessor);</span><br><span class="line">System.out.println(localDateTime); <span class="comment">//2022-12-04T21:05:42</span></span><br></pre></td></tr></table></figure>
<h3><span id="44-其它api">4.4 其它API</span></h3>
<p><strong>1、指定时区日期时间：ZondId和ZonedDateTime</strong></p>
<ul>
<li>
<p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p>
</li>
<li>
<p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</p>
<ul>
<li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等</li>
</ul>
</li>
<li>
<p>常见时区ID：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Asia/Shanghai</span><br><span class="line">UTC</span><br><span class="line">America/New_York</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过ZondId获取所有可用的时区ID：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要知道一些时区的id</span></span><br><span class="line"><span class="comment">//Set&lt;String&gt;是一个集合，容器</span></span><br><span class="line">Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line"><span class="comment">//快捷模板iter</span></span><br><span class="line"><span class="keyword">for</span> (String availableZoneId : availableZoneIds) &#123;</span><br><span class="line">    System.out.println(availableZoneId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">t1</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">System.out.println(t1);</span><br><span class="line"></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">t2</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">System.out.println(t2);</span><br></pre></td></tr></table></figure>
<p><strong>2、持续日期/时间：Period和Duration</strong></p>
<ul>
<li>持续时间：Duration，用于计算两个“时间”间隔</li>
<li>日期间隔：Period，用于计算两个“日期”间隔</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="type">LocalDate</span> <span class="variable">t1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">      <span class="type">LocalDate</span> <span class="variable">t2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">      <span class="type">Period</span> <span class="variable">between</span> <span class="operator">=</span> Period.between(t1, t2);</span><br><span class="line">      System.out.println(between);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;相差的年数：&quot;</span>+between.getYears());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的月数：&quot;</span>+between.getMonths());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的天数：&quot;</span>+between.getDays());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的总数：&quot;</span>+between.toTotalMonths());</span><br><span class="line"> </span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">t1</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">t2</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="type">Duration</span> <span class="variable">between</span> <span class="operator">=</span> Duration.between(t1, t2);</span><br><span class="line">      System.out.println(between);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;相差的总天数：&quot;</span>+between.toDays());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的总小时数：&quot;</span>+between.toHours());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的总分钟数：&quot;</span>+between.toMinutes());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的总秒数：&quot;</span>+between.getSeconds());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的总毫秒数：&quot;</span>+between.toMillis());</span><br><span class="line">      System.out.println(<span class="string">&quot;相差的总纳秒数：&quot;</span>+between.toNanos());</span><br><span class="line">      System.out.println(<span class="string">&quot;不够一秒的纳秒数：&quot;</span>+between.getNano());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">System.out.println(duration);</span><br><span class="line"></span><br><span class="line">System.out.println(duration.getSeconds());</span><br><span class="line">System.out.println(duration.getNano());</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">System.out.println(duration1.toDays());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Period:用于计算两个“日期”间隔，以年、月、日衡量</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate, localDate1);</span><br><span class="line">System.out.println(period);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getYears());</span><br><span class="line">System.out.println(period.getMonths());</span><br><span class="line">System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> period.withYears(<span class="number">2</span>);</span><br><span class="line">System.out.println(period1);</span><br></pre></td></tr></table></figure>
<p>3、Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</p>
<p>4、TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。<br>
TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// TemporalAdjuster:时间校正器</span></span><br><span class="line"><span class="comment">// 获取当前日期的下一个周日是哪天？</span></span><br><span class="line"><span class="type">TemporalAdjuster</span> <span class="variable">temporalAdjuster</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"><span class="comment">// 获取下一个工作日是哪天？</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now().with(<span class="keyword">new</span> <span class="title class_">TemporalAdjuster</span>() &#123;</span><br><span class="line">  	 	<span class="meta">@Override</span></span><br><span class="line">  	 	<span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal temporal)</span> &#123;</span><br><span class="line">       	<span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> (LocalDate) temporal;</span><br><span class="line">    	  	<span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) &#123;</span><br><span class="line">          		<span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">       	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) &#123;</span><br><span class="line">           	<span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">       	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           	<span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">       	&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br></pre></td></tr></table></figure>
<h3><span id="45-与传统日期处理的转换">4.5 与传统日期处理的转换</span></h3>
<table>
<thead>
<tr>
<th><strong>类</strong></th>
<th><strong>To</strong> <strong>遗留类</strong></th>
<th><strong>From</strong> <strong>遗留类</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>java.time.Instant与java.util.Date</strong></td>
<td>Date.from(instant)</td>
<td>date.toInstant()</td>
</tr>
<tr>
<td><strong>java.time.Instant与java.sql.Timestamp</strong></td>
<td>Timestamp.from(instant)</td>
<td>timestamp.toInstant()</td>
</tr>
<tr>
<td><strong>java.time.ZonedDateTime与java.util.GregorianCalendar</strong></td>
<td>GregorianCalendar.from(zonedDateTime)</td>
<td>cal.toZonedDateTime()</td>
</tr>
<tr>
<td><strong>java.time.LocalDate与java.sql.Time</strong></td>
<td>Date.valueOf(localDate)</td>
<td>date.toLocalDate()</td>
</tr>
<tr>
<td><strong>java.time.LocalTime与java.sql.Time</strong></td>
<td>Date.valueOf(localDate)</td>
<td>date.toLocalTime()</td>
</tr>
<tr>
<td><strong>java.time.LocalDateTime与java.sql.Timestamp</strong></td>
<td>Timestamp.valueOf(localDateTime)</td>
<td>timestamp.toLocalDateTime()</td>
</tr>
<tr>
<td><strong>java.time.ZoneId与java.util.TimeZone</strong></td>
<td>Timezone.getTimeZone(id)</td>
<td>timeZone.toZoneId()</td>
</tr>
<tr>
<td><strong>java.time.format.DateTimeFormatter与java.text.DateFormat</strong></td>
<td>formatter.toFormat()</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2><span id="5-java比较器">5. Java比较器</span></h2>
<p>为了解决引用数据类型不能直接使用比较运算符来比较大小，Java实现对象排序的方式有两种：</p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.util.Comparator</li>
</ul>
<h3><span id="51-自然排序javalangcomparable">5.1 自然排序：java.lang.Comparable</span></h3>
<p>Comparable接口强行对实现它的每个类的对象进行整体排序</p>
<ul>
<li>实现 Comparable 的类必须实现 <code>compareTo(Object obj) </code>方法</li>
<li>对象即通过 compareTo(Object obj) 方法的返回值来比较大小</li>
<li>如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器</p>
</li>
<li>
<p>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与 e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）<code>最好使自然排序与 equals 一致</code></p>
</li>
<li>
<p>Comparable 的典型实现：(<code>默认都是从小到大排列的</code>)</p>
<ul>
<li>String：按照字符串中字符的Unicode值进行比较</li>
<li>Character：按照字符的Unicode值来进行比较</li>
<li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li>
<li>Date、Time等：后面的日期时间比前面的日期时间大</li>
</ul>
</li>
<li>
<p>代码示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> score, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//这些需要强制，将o对象向下转型为Student类型的变量，才能调用Student类中的属性</span></span><br><span class="line">        <span class="comment">//默认按照学号比较大小</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id - stu.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] arr = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">90</span>,<span class="number">23</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;熊大&quot;</span>,<span class="number">100</span>,<span class="number">22</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>,<span class="string">&quot;王五&quot;</span>,<span class="number">75</span>,<span class="number">25</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">85</span>,<span class="number">24</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>,<span class="string">&quot;熊二&quot;</span>,<span class="number">85</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单独比较两个对象</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]));</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>].compareTo(arr[<span class="number">2</span>]));</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>].compareTo(arr[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有学生：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;按照学号排序：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j].compareTo(arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score - ((Student)o).score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">	Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">	students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">96</span>);</span><br><span class="line">	students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">85</span>);</span><br><span class="line">	students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">98</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(Arrays.toString(students));</span><br><span class="line">	Arrays.sort(students);</span><br><span class="line">	System.out.println(Arrays.toString(students));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">other</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparableTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">        all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《红楼梦》&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《西游记》&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《三国演义》&quot;</span>, <span class="number">140</span>);</span><br><span class="line">        all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《水浒传》&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(all);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(all));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="52-定制排序javautilcomparator">5.2 定制排序：java.util.Comparator</span></h3>
<ul>
<li>
<p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码（例如：一些第三方的类，你只有.class文件，没有源文件）</p>
</li>
<li>
<p>即使实现了Comparable接口也指定了两个对象的比较大小的规则，但是期望使用临时自定义的方法比较大小</p>
</li>
<li>
<p>JDK在设计类库之初，也考虑到这种情况，所以又增加了一个java.util.Comparator接口。强行对多个对象进行整体排序的比较</p>
<ul>
<li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1,Object o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">//定义定制比较器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentScoreComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) o1;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) o2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> s1.getScore() - s2.getScore();</span><br><span class="line">        <span class="keyword">return</span> result != <span class="number">0</span> ? result : s1.getId() - s2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] arr = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">90</span>, <span class="number">23</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;熊大&quot;</span>, <span class="number">100</span>, <span class="number">22</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">85</span>, <span class="number">24</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;熊二&quot;</span>, <span class="number">85</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有学生：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;按照成绩排序&quot;</span>);</span><br><span class="line">        <span class="type">StudentScoreComparator</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentScoreComparator</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc.compare(arr[j], arr[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">    students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">90</span>, <span class="number">23</span>);</span><br><span class="line">    students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;熊大&quot;</span>, <span class="number">100</span>, <span class="number">22</span>);</span><br><span class="line">    students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">    students[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">85</span>, <span class="number">24</span>);</span><br><span class="line">    students[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;熊二&quot;</span>, <span class="number">85</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(students));</span><br><span class="line">    <span class="comment">//定制排序</span></span><br><span class="line">    <span class="type">StudentScoreComparator</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentScoreComparator</span>();</span><br><span class="line">    Arrays.sort(students, sc);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序之后：&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(students));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;War and Peace&quot;</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Childhood&quot;</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Scarlet and Black&quot;</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Notre Dame de Paris&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(all));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="53-定制排序与自然排序的对比">5.3 定制排序与自然排序的对比</span></h3>
<table>
<thead>
<tr>
<th>对比</th>
<th>自然排序</th>
<th>定制排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现接口和方法</td>
<td>comparable的compareTo(Object obj)</td>
<td>comparator的compre(Object o1, Object o2)</td>
</tr>
<tr>
<td>特点</td>
<td>唯一的</td>
<td>灵活的、多样的，每次排序都可以自定义</td>
</tr>
<tr>
<td>有效期限</td>
<td>实现后可以一直使用</td>
<td>常用于临时排序</td>
</tr>
</tbody>
</table>
<h2><span id="6-系统相关类">6. 系统相关类</span></h2>
<h3><span id="61-javalangsystem类">6.1 java.lang.System类</span></h3>
<ul>
<li>
<p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于<code>java.lang包</code>。</p>
</li>
<li>
<p>由于该类的构造器是private的，所以无法创建该类的对象。其内部的成员变量和成员方法都是<code>static的</code>，所以也可以很方便的进行调用。</p>
</li>
<li>
<p>成员变量   Scanner scan = new Scanner(<a href="http://System.in">System.in</a>);</p>
<ul>
<li>System类内部包含<code>in</code>、<code>out</code>和<code>err</code>三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
</li>
<li>
<p>成员方法</p>
<ul>
<li>
<p><code>native long currentTimeMillis()</code>：<br>
该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
</li>
<li>
<p><code>void exit(int status)</code>：<br>
该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</li>
<li>
<p><code>void gc()</code>：<br>
该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
</li>
<li>
<p><code>String getProperty(String key)</code>：<br>
该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
<p><img src="C:/Users/Administrator/Downloads/images/image-20220406003340258.png" alt="image-20220406003340258"></p>
</li>
</ul>
</li>
<li>
<p>举例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSystem</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的系统时间距离1970年1月1日凌晨：&quot;</span> + time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);<span class="comment">//不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i &lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="type">MyDemo</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>(i);</span><br><span class="line">            <span class="comment">//每一次循环my就会指向新的对象，那么上次的对象就没有变量引用它了，就成垃圾对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了看到垃圾回收器工作，我要加下面的代码，让main方法不那么快结束，因为main结束就会导致JVM退出，GC也会跟着结束。</span></span><br><span class="line">        System.gc();<span class="comment">//如果不调用这句代码，GC可能不工作，因为当前内存很充足，GC就觉得不着急回收垃圾对象。</span></span><br><span class="line">        			<span class="comment">//调用这句代码，会让GC尽快来工作。</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDemo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDemo</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyDemo&#123;&quot;</span> + <span class="string">&quot;value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写finalize方法，让大家看一下它的调用效果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//        正常重写，这里是编写清理系统内存的代码</span></span><br><span class="line"><span class="comment">//        这里写输出语句是为了看到finalize()方法被调用的效果</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>+ <span class="string">&quot;轻轻的我走了，不带走一段代码....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：</p>
<p>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。常用于数组的插入和删除</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSystemArrayCopy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.arraycopy(arr1,<span class="number">0</span>,arr2,<span class="number">3</span>,arr1.length);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,arr,<span class="number">1</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.arraycopy(arr,<span class="number">1</span>,arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="62-javalangruntime类">6.2 java.lang.Runtime类</span></h3>
<p>每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。</p>
<p><code>public static Runtime getRuntime()</code>： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。</p>
<p><code>public long totalMemory()</code>：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的1/64。</p>
<p><code>public long maxMemory()</code>：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的1/4。</p>
<p><code>public long freeMemory()</code>：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRuntime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> runtime.totalMemory(); <span class="comment">//获取虚拟机初始化时堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> runtime.maxMemory(); <span class="comment">//获取虚拟机最大堆内存总量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//模拟占用内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            str += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">freeMemory</span> <span class="operator">=</span> runtime.freeMemory(); <span class="comment">//获取空闲堆内存总量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;总内存：&quot;</span> + initialMemory / <span class="number">1024</span> / <span class="number">1024</span> * <span class="number">64</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总内存：&quot;</span> + maxMemory / <span class="number">1024</span> / <span class="number">1024</span> * <span class="number">4</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;空闲内存：&quot;</span> + freeMemory / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;已用内存：&quot;</span> + (initialMemory-freeMemory) / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="7-和数学相关的类">7. 和数学相关的类</span></h2>
<h3><span id="71-javalangmath">7.1 java.lang.Math</span></h3>
<p><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p>
<ul>
<li><code>public static double abs(double a) </code> ：返回 double 值的绝对值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.abs(-<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.ceil(-<span class="number">3.3</span>); <span class="comment">//d2的值为 -3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>public static double floor(double a) </code> ：返回小于等于参数最大的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.floor(-<span class="number">3.3</span>); <span class="comment">//d2的值为-4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">d1</span> <span class="operator">=</span> Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d2</span> <span class="operator">=</span> Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d3</span> <span class="operator">=</span> Math.round(-<span class="number">3.3</span>); <span class="comment">//d3的值为-3</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d4</span> <span class="operator">=</span> Math.round(-<span class="number">3.8</span>); <span class="comment">//d4的值为-4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>public static double pow(double a,double b)：返回a的b幂次方法</li>
<li>public static double sqrt(double a)：返回a的平方根</li>
<li><code>public static double random()</code>：返回[0,1)的随机值</li>
<li>public static final double PI：返回圆周率</li>
<li>public static double max(double x, double y)：返回x,y中的最大值</li>
<li>public static double min(double x, double y)：返回x,y中的最小值</li>
<li>其它：acos,asin,atan,cos,sin,tan 三角函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sqrt</span> <span class="operator">=</span> Math.sqrt(<span class="number">256</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">rand</span> <span class="operator">=</span> Math.random();</span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br></pre></td></tr></table></figure>
<h3><span id="72-javamath包">7.2 java.math包</span></h3>
<h4><span id="721-biginteger">7.2.1 BigInteger</span></h4>
<ul>
<li>
<p>Integer类作为int的包装类，能存储的最大整型值为2<sup>31-1，Long类也是有限的，最大为2</sup>63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p>
</li>
<li>
<p>java.math包的BigInteger可以表示<code>不可变的任意精度的整数</code>。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
</li>
<li>
<p>构造器</p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li>
<p>方法</p>
<ul>
<li>public BigInteger <code>abs</code>()：返回此 BigInteger 的绝对值的 BigInteger。</li>
<li>BigInteger <code>add</code>(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li>
<li>BigInteger <code>subtract</code>(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li>
<li>BigInteger <code>multiply</code>(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li>
<li>BigInteger <code>divide</code>(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li>
<li>BigInteger <code>remainder</code>(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li>
<li>BigInteger[] <code>divideAndRemainder</code>(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</li>
<li>BigInteger <code>pow</code>(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//long bigNum = 123456789123456789123456789L;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678912345678912345678&quot;</span>);</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;78923456789123456789123456789&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(&quot;和：&quot; + (b1+b2));//错误的，无法直接使用+进行求和</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;和：&quot;</span> + b1.add(b2));</span><br><span class="line">    System.out.println(<span class="string">&quot;减：&quot;</span> + b1.subtract(b2));</span><br><span class="line">    System.out.println(<span class="string">&quot;乘：&quot;</span> + b1.multiply(b2));</span><br><span class="line">    System.out.println(<span class="string">&quot;除：&quot;</span> + b2.divide(b1));</span><br><span class="line">    System.out.println(<span class="string">&quot;余：&quot;</span> + b2.remainder(b1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="722-bigdecimal">7.2.2 BigDecimal</span></h4>
<ul>
<li>
<p>一般的Float类和Double类可以用来做科学计算或工程计算，但在<strong>商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</strong></p>
</li>
<li>
<p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
</li>
<li>
<p>构造器</p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val) --&gt; 推荐</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>public BigDecimal <code>add</code>(BigDecimal augend)</li>
<li>public BigDecimal <code>subtract</code>(BigDecimal subtrahend)</li>
<li>public BigDecimal <code>multiply</code>(BigDecimal multiplicand)</li>
<li>public BigDecimal <code>divide</code>(BigDecimal divisor, int scale, int roundingMode)：divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入）</li>
</ul>
</li>
<li>
<p>举例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12433241123&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">// System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="73-javautilrandom">7.3 java.util.Random</span></h3>
<p>用于产生随机数</p>
<ul>
<li>
<p><code>boolean nextBoolean()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。</p>
</li>
<li>
<p><code>void nextBytes(byte[] bytes)</code>:生成随机字节并将其置于用户提供的 byte 数组中。</p>
</li>
<li>
<p><code>double nextDouble()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。</p>
</li>
<li>
<p><code>float nextFloat()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。</p>
</li>
<li>
<p><code>double nextGaussian()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。</p>
</li>
<li>
<p><code>int nextInt()</code>:返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。</p>
</li>
<li>
<p><code>int nextInt(int n)</code>:返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。</p>
</li>
<li>
<p><code>long nextLong()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;随机整数：&quot;</span> + r.nextInt());</span><br><span class="line">    System.out.println(<span class="string">&quot;随机小数：&quot;</span> + r.nextDouble());</span><br><span class="line">    System.out.println(<span class="string">&quot;随机布尔值：&quot;</span> + r.nextBoolean());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1><span id="并发编程面试题">并发编程面试题</span></h1>
<hr>
<h2><span id="为什么要使用并发编程">为什么要使用并发编程?</span></h2>
<p>为了能提高程序的执行效率提高程序运行速度，充分的利用多核CPU资源</p>
<p>线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程</p>
<p>多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销</p>
<p>多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能</p>
<hr>
<h2><span id="说说并发与并行的区别">说说并发与并行的区别?</span></h2>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。  （不一定是同时的）<br>
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行</p>
<ul>
<li>并发的关键是你有处理多个任务的能力，不一定要同时</li>
<li>并行的关键是你有同时处理多个任务的能力</li>
</ul>
<hr>
<h2><span id="并发编程的缺点">并发编程的缺点？</span></h2>
<ul>
<li>频繁的创建线程、销毁线程和线程间的切换，消耗较多的内存和时间</li>
<li>可能产生线程安全问题。如线程的可见性、有序性、原子性问题，会导致程序出现的结果与预期结果不一致</li>
<li>多线程容易造成死锁、活锁、线程饥饿等问题。此类问题往往只能通过手动停止线程、甚至是进程才能解决</li>
</ul>
<hr>
<h2><span id="并发编程的三要素">并发编程的三要素？</span></h2>
<ul>
<li>原子性：在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行</li>
<li>可见性：一个线程对共享变量的修改,其他线程能够立刻看到。（synchronized,volatile）</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行。（指令重排：处理器为了提高程序运行效率，处理器根据指令之间的数据依赖性，可能会对指令进行重排序，单线程下可以保证程序最终执行结果和代码顺序执行的结果是一致的，但是多线程下有可能出现问题）</li>
</ul>
<hr>
<h2><span id="可见性怎么理解">可见性怎么理解？</span></h2>
<p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>
<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。这就是可见性问题</p>
<p><strong>volatile关键字</strong></p>
<p>保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>
另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<hr>
<h2><span id="有序性怎么理解">有序性怎么理解？</span></h2>
<p>即程序执行的顺序按照代码的先后顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;              </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>
<p>从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序<br>
<strong>指令重排序（Instruction Reorder）</strong></p>
<ul>
<li>处理器为了提高程序运行效率，可能会对输入代码进行优化</li>
<li>会考虑指令之间的数据依赖性。它会保证程序最终执行结果和代码顺序执行的结果是一致的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="literal">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">    sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<ul>
<li>由于语句1和语句2没有数据依赖性，因此可能会被重排序</li>
<li>假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错</li>
<li>从上面可以看出，在Java内存模型中，允许编译器和处理器对指令进行重排序</li>
<li>重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</li>
</ul>
<hr>
<h2><span id="juc具体是什么">JUC具体是什么?</span></h2>
<p>java.util.concurrent(简称JUC)包</p>
<ul>
<li>从Java5.0引入</li>
<li>提供并发编程中常用的工具类，</li>
<li>定义自定义子系统，包括线程池、异步IO和轻量级任务框架</li>
<li>提供可调的、灵活的线程池</li>
<li>提供了设计用于多线程上下文的Collection实现等</li>
</ul>
<hr>
<h2><span id="什么是java内存模型jmm">什么是Java内存模型(JMM)？</span></h2>
<ul>
<li>与JVM不同，不是真是存在，是一个抽象的规范</li>
<li>由于不同的硬件或操作系统对内存的访问逻辑不同，导致同一代码在不同硬件或操作系统下运行的结果不同</li>
<li>通过JMM的规范，保证Java程序在各种平台下对内存的访问都能得到一致的效果</li>
</ul>
<hr>
<h2><span id="什么是cpu和缓存一致性">什么是CPU和缓存一致性？</span></h2>
<p>CPU运算速度远远快于内存读取速度，导致CPU需要耗费很多时间等待内存读取</p>
<p>通过在CPU和物理内存上新增高速缓存，这样程序在运行过程中，会将运算所需要的数据从主内存复制一份到CPU的高速缓存中，当CPU进行计算时就可以直接从高速缓存中读数据和写数据了，当运算结束再将数据刷新到主内存</p>
<p>多核CPU每个核都有一套自己的缓存</p>
<p>在多线程程序中，多线程通过不同CPU核心访问进程的共享内存，每个核心在各自的缓存相互独立，各自的数据可能不同</p>
<hr>
<h2><span id="什么是重排序">什么是重排序？</span></h2>
<p>从源代码到最终执行指令的过程中，编译器和处理器会对指令进行重排的一种行为（用于提高性能）</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220901/1662002742@46a9651c19c368751b8cafb425d4d525.png" alt="img"></p>
<ul>
<li>编译器优化的重排序：编译器在不改变单线程程序语义（as-if-serial）的的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序：现在处理器采用指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序：由于处理器使用了存储和读写缓冲区，这使得加载和存储操作看上去乱序执行</li>
</ul>
<hr>
<h2><span id="重排序实际执行的指令步骤">重排序实际执行的指令步骤？</span></h2>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220901/1662003010@4ea192eb55d4edfef511d8ae85c03850.png" alt="img"></p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
<li>这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。</li>
</ul>
<hr>
<h2><span id="重排序遵守的规则">重排序遵守的规则？</span></h2>
<ul>
<li>数据依赖性:编译器和处理器在重排序时针对单个处理器中执行的指令序列和单个线程中执行的操作会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</li>
<li>遵守as-if-serial 语义:不管编译器和处理器为了提高并行度怎么重排序，（单线程）程序的执行结果不能被改变</li>
</ul>
<hr>
<h2><span id="as-if-serial规则和happens-before规则的区别">as-if-serial规则和happens-before规则的区别？</span></h2>
<p>二者的作用都是在不改变程序执行结果的前提下，提高程序执行的并行度</p>
<p>happens-before关系保证了同步的多线程程序的执行结果不被改变，as-if-serial保证了单线程内程序的执行结果不被改变</p>
<ul>
<li>as-if-serial定义：无论编译器和处理器如何进行重排序，单线程程序的执行结果不会改变</li>
<li>happens-before定义：一个操作happens-before另一个操作，表示第一个的操作结果对第二个操作可见，并且第一个操作的执行顺序也在第二个操作之前。但这并不意味着Java虚拟机必须按照这个顺序来执行程序。如果重排序的后的执行结果与按happens-before关系执行的结果一致，Java虚拟机也会允许重排序的发生。</li>
</ul>
<hr>
<h2><span id="final不可变对象它对写并发应用有什么帮助">final不可变对象，它对写并发应用有什么帮助？</span></h2>
<ul>
<li>不可变对象一旦被创建,它的状态(对象属性值)就不能改变</li>
<li>不可变对象的类即为不可变类。如 String、基本类型的包装类、BigInteger 和 BigDecimal 等</li>
<li>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率</li>
</ul>
<hr>
<h2><span id="volatile-关键字的作用">volatile 关键字的作用？</span></h2>
<ul>
<li>保证变量写操作的可见性</li>
<li>保证变量前后代码的执行顺序</li>
</ul>
<hr>
<h2><span id="volatile能保证线程安全吗">volatile能保证线程安全吗？</span></h2>
<p>不能。volatile不能保证原子性，只能保证线程可见性</p>
<p>可见性表现在当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>
<hr>
<h2><span id="volatile的底层原理">volatile的底层原理？</span></h2>
<p>被volatile修饰的变量被修改时，会将修改后的变量直接写入主存中，并且将其他线程中该变量的缓存置为无效，从而让其它线程对该变量的引用直接从主存中获取数据，这样就保证了变量的可见性。<br>
但是volatile修饰的变量在自增时由于该操作分为读写两个步骤，所以当一个线程的读操作被阻塞时，另一个线程同时也进行了自增操作，此时由于第一个线程的写操作没有进行所以主存中仍旧是之前的原数据，所以当两个线程自增完成后，该变量可能只加了1。因而volatile是无法保证对变量的任何操作都是原子性的。</p>
<hr>
<h2><span id="volatile-数组在java中能创建吗">volatile 数组在Java中能创建吗？</span></h2>
<p>能，Java 中可以创建 volatile 类型数组，但如果多个线程改变引用指向的数组，将会受到 volatile 的保护，如果多个线程改变数组的元素内容，volatile 标示符就不能起到之前的保护作用了。</p>
<hr>
<h2><span id="volatile-变量和-atomic-变量有什么不同">volatile 变量和 atomic 变量有什么不同？</span></h2>
<p>volatile变量可以确保先行关系,即写操作会发生在后续的读操作之前,但它并不能保证原子性。例如用volatile修饰count变量那么count++操作就不是原子性的。<br>
而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement( )方法会原子性的进行增量操作把当前值加- ,其它数据类型和引用变量也可以进行相似操作。</p>
<hr>
<h2><span id="什么是原子类">什么是原子类？</span></h2>
<p>原子操作</p>
<ul>
<li>不会被线程调度机制打断的操作（可以是一个或多个步骤）</li>
<li>一旦开始，就一直运行到结束，中间不会有任何线程上下文切换</li>
<li>顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体</li>
</ul>
<p>原子类、</p>
<ul>
<li>具有原子性的类</li>
<li>如 java.util.concurrent.atomic 下的类，可以原子性地执行添加、递增、递减等操作。比如之前多线程下的线程不安全的 i++ 问题，到了原子类这里，就可以用功能相同且线程安全的 getAndIncrement 方法来优雅地解决</li>
</ul>
<hr>
<h2><span id="原子类的作用">原子类的作用？</span></h2>
<p>与锁类似，都是为了保证并发情况下线程安全；但相比于锁，有一定的优势</p>
<ul>
<li>粒度更细：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。</li>
<li>效率更高：除了高度竞争的情况之外，使用原子类的效率通常会比使用同步互斥锁的效率更高，因为原子类底层利用了 CAS 操作，不会阻塞线程</li>
</ul>
<hr>
<h2><span id="原子类的常用类">原子类的常用类？</span></h2>
<ul>
<li>AtomicInteger与AtomicLong：它们的底层实现使用了CAS锁</li>
<li>不同点在于AtomicInteger包装了一个Integer型变量，而AtomicLong包装了一个Long型变量</li>
<li>LongAdder：它的底层实现是分段锁+CAS锁</li>
</ul>
<hr>
<h2><span id="说一下-atomic的原理">说一下 Atomic的原理？</span></h2>
<ul>
<li>atomic代表的是concurrent包下Atomic开头的类，如AtomicBoolean、AtomicInteger、AtomicLong等</li>
<li>都是用原子的方式来实现指定类型的值的更新，它的底层通过CAS原理解决并发情况下原子性的问题，在jdk中CAS是Unsafe类中的api来实现的</li>
</ul>
<hr>
<h2><span id="什么是cas">什么是CAS?</span></h2>
<p>全称为Compare and Swap，即比较-替换,实现并发算法时常用到的一种技术</p>
<p>假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false</p>
<p>CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功</p>
<hr>
<h2><span id="cas的具体实现">CAS的具体实现?</span></h2>
<p>以AtomicInteger为例,说明CAS的使用与原理</p>
<p>首先atomicIngeter初始化为5</p>
<p>调用对象的compareAndSet方法来对比当前值与内存中的值，是否相等，相等则更新为2019，不相等则不会更新，compareAndSet方法返回的是boolean类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">2019</span>)+<span class="string">&quot; \t current  &quot;</span>+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">2014</span>)+<span class="string">&quot; \t current  &quot;</span>+atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次调用，内存中的值是5，通过对比相等更新为2019，输出  true  current  2019</p>
<p>第二次调用时，内存重点的值已经更新为2019，不相等不更新内存中的值,输出  false  current  2019</p>
<hr>
<h2><span id="cas缺点">CAS缺点？</span></h2>
<p>CAS存在ABA问题</p>
<p>如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性</p>
<p>只能保证一个共享变量的原子性</p>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以使用锁来保证原子性。</p>
<hr>
<h2><span id="java中有哪些锁">java中有哪些锁？</span></h2>
<p>为了解决多线程访问共享资源时的因竞争导致的数据错乱，在访问共享资源之前加锁。不同种类有不同的成本开销，不同的锁适用于不同的场景</p>
<ul>
<li>从资源已被锁定，线程是否阻塞可以分为 自旋锁（spinlock）和互斥锁（mutexlock）</li>
<li>从线程是否需要对资源加锁可以分为 悲观锁 和 乐观锁</li>
<li>从多个线程并发访问资源，也就是 Synchronized 可以分为 无锁、偏向锁、 轻量级锁 和 重量级锁</li>
<li>从锁的公平性进行区分，可以分为公平锁 和 非公平锁</li>
<li>从根据锁是否重复获取可以分为可重入锁（自己获得锁以后，自己还可以进入锁之中） 和 不可重入锁</li>
<li>从那个多个线程能否获取同一把锁分为共享锁和 排他锁</li>
</ul>
<hr>
<h2><span id="互斥锁与自旋锁怎么理解">互斥锁与自旋锁怎么理解？</span></h2>
<p><strong>互斥锁</strong></p>
<ul>
<li>在访问共享资源之前对其进行加锁操作，在访问完成之后进行解锁操作</li>
<li>加锁后，任何其它试图再次加锁的线程都会被阻塞，直到当前线程解锁。在这种方式下，只有一个线程能够访问被互斥锁保护的资源</li>
<li>如synchronized/Lock 这些方式都是互斥锁，不同线程不能同时进入 synchronized Lock 设定锁的范围</li>
</ul>
<p><strong>自旋锁</strong></p>
<ul>
<li>一种特殊的互斥锁</li>
<li>当资源被加锁后，其它线程想要再次加锁，此时该线程不会被阻塞睡眠而是陷入循环等待状态(CPU不能做其它事情)，循环检查资源持有者是否已经释放了资源</li>
<li>减少了线程从睡眠到唤醒的资源消耗，但会一直占用CPU的资源。</li>
</ul>
<p>互斥锁的起始开销要高于自旋锁，但是基本上是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长</p>
<hr>
<h2><span id="读写锁是什么">读写锁是什么？</span></h2>
<ul>
<li>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁</li>
<li>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁</li>
<li>读写锁也叫共享锁。其共享是在读数据的时候，可以让多个线程同时进行读操作的。在写的时候具有排他性，其他读或者写操作都要被阻塞</li>
</ul>
<hr>
<h2><span id="多线程中乐观锁和悲观锁区别">多线程中乐观锁和悲观锁区别？</span></h2>
<p>悲观锁</p>
<ul>
<li>线程对一个共享变量进行访问，它就自动加锁，所以只能有一个线程访问它</li>
<li>适合写操作多的场景，先加锁可以保证写操作时数据正确</li>
<li>只有一个线程对它操作时，没有必要加锁，造成了性能浪费</li>
</ul>
<p>乐观锁</p>
<ul>
<li>线程访问共享变量时不加锁，当执行完后，同步值到内存时，使用旧值和内存中的值进行判断，如果相同，那么写入，如果不相同，重新使用新值执行</li>
<li>适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</li>
<li>缺点：值相同的情况，可能被其他线程执行过；操作变量频繁时，重新执行次数多，造成性能浪费；完成比较后，写入前，被其他线程修改了值，导致不同步问题</li>
</ul>
<hr>
<h2><span id="讲一下-synchronized-关键字的底层原理jvm层面">讲一下 synchronized 关键字的底层原理(JVM层面)。</span></h2>
<p><strong>synchronized 同步语句块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息</p>
<p>首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件</p>
<p>然后执行javap -c -s -v -l SynchronizedDemo.class。</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220830/1661829462@8bb56c18a22eca0d0031e8122ca1b0d1.jpg" alt="img"></p>
<p>从上面我们可以看出：synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置</p>
<p>当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权</p>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 ObjectMonitor对象。另外，wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因</p>
<p>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1</p>
<p>在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</p>
<p><strong>synchronized 修饰方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：</p>
<p>首先切换到类的对应目录执行 javac SynchronizedDemo2.java 命令生成编译后的 .class 文件</p>
<p>然后执行javap -c -s -v -l SynchronizedDemo2.class。</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220830/1661829493@1077db68d74d61efbc235b2f889fdb90.jpg" alt="img"></p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识</p>
<p>该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</p>
<h2><span id="volatile修饰的双重校验锁实现对象单例线程安全">volatile修饰的双重校验锁实现对象单例（线程安全)</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="comment">// 这里为什么需要加上volatile 后面会讲解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">	<span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 提供getInstance方法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中uniqueInstance 变量采用 volatile 关键字修饰，分析如下：<br>
uniqueInstance = new Singleton();</p>
<ul>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
<li>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</li>
</ul>
<hr>
<h2><span id="synchronized可重入的原理">synchronized可重入的原理?</span></h2>
<p>可重入原理即加锁次数计数器。一个线程拿到锁之后，可以继续地持有锁，如果想再次进入由这把锁控制的方法，那么它可以直接进入。它的原理是利用加锁次数计数器来实现的</p>
<ul>
<li>每重入一次，计数器+1<br>
每个对象自动含有一把锁，JVM负责跟踪对象被加锁的次数<br>
线程第一次给对象加锁的时候，计数器=0+1=1，每当这个相同的线程在此对象上再次获得锁时，计数器再+1。只有首先获取这把锁的线程，才能继续在这个对象上多次地获取这把锁</li>
<li>计数器-1<br>
每当任务结束离开时，计数递减，当计数器减为0，锁被完全释放<br>
利用这个计数器可以得知这把锁是被当前多次持有，还是如果=0的话就是完全释放了。</li>
</ul>
<hr>
<h2><span id="当一个线程进入一个对象的-synchronized-方法-a-之后其它线程是否可进入此对象的-synchronized-方法-b">当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</span></h2>
<p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<hr>
<h2><span id="synchronized-和-lock-有什么区别">synchronized 和 Lock 有什么区别？</span></h2>
<ul>
<li>lock是一个接口；而synchronized是java的一个关键字。</li>
<li>synchronized在发生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常时，不会主动释放占有的锁，必须手动来释放锁，可能引起死锁的发生。</li>
</ul>
<hr>
<h2><span id="synchronized和reentrantlock的区别">synchronized和ReentrantLock的区别？</span></h2>
<ul>
<li>synchronized是和if、else、for、while一样的关键字；ReentrantLock是类，这是二者的本质区别</li>
<li>既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</li>
<li>ReentrantLock比synchronized的扩展性体现在几点上：
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ul>
</li>
<li>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</li>
</ul>
<hr>
<h2><span id="synchronized-和-volatile的区别是什么">synchronized 和 volatile的区别是什么？</span></h2>
<ul>
<li>synchronized保证内存可见性和操作的原子性；volatile只能保证内存可见性</li>
<li>volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</li>
<li>volatile标记的变量不会被编译器优化；而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）</li>
<li>volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符</li>
<li>volatile本质是在告诉JVM当前变量在寄存器中的值是不确定的，使用前，需要先从主存中读取，因此可以实现可见性。而对n=n+1,n++等操作时，volatile关键字将失效，不能起到像synchronized一样的线程同步（原子性）的效果</li>
</ul>
<hr>
<h2><span id="线程-b-怎么知道线程-a-修改了变量">线程 B 怎么知道线程 A 修改了变量 ?</span></h2>
<ul>
<li>volatile 修饰变量</li>
<li>synchronized 修饰修改变量的方法</li>
<li>wait/notify</li>
<li>轮询</li>
</ul>
<hr>
<h2><span id="在监视器monitor内部是如何做线程同步的程序应该做哪种级别的同步">在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</span></h2>
<p>监视器和锁在Java虚拟机中是一块使用的</p>
<p>监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码</p>
<p>在 java 虚拟机中, 每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联, 为了实现监视器的互斥功能, 每个对象都关联着一把锁.一旦方法或者代码块被 synchronized 修饰, 那么这个部分就放入了监视器的监视区域, 确保一次只能有一个线程执行该部分的代码, 线程在获取锁之前不允许执行该部分的代码。另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p>
<hr>
<h2><span id="线程死锁概念以及发生的必要条件">线程死锁概念以及发生的必要条件？</span></h2>
<p>死锁</p>
<p>指多个线程在运行过程中因争夺资源而造成的一种僵局</p>
<p>比如有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁</p>
<p>死锁发生的必要条件</p>
<ul>
<li>互斥，同一时刻只能有一个线程访问。</li>
<li>持有且等待，当线程持有资源A时，再去竞争资源B并不会释放资源A。</li>
<li>不可抢占，线程T1占有资源A，其他线程不能强制抢占。</li>
<li>循环等待，线程T1占有资源A，再去抢占资源B如果没有抢占到会一直等待下去。</li>
</ul>
<hr>
<h2><span id="如何避免线程死锁">如何避免线程死锁？</span></h2>
<p>避免线程死锁上诉条件只要不满足一个即可，那么分析如下</p>
<ul>
<li>互斥条件，不可破坏，如果破坏那么并发安全就不存在了。</li>
<li>持有且等待，可以破坏，可以一次性申请所有的资源。</li>
<li>不可抢占，当线程T1持有资源A再次获取资源B时，发现资源B被占用那么主动释放资源A。</li>
<li>循环等待，可以将资源排序，可以按照排序顺序的资源申请，这样就不会存在环形资源申请了。</li>
</ul>
<hr>
<h2><span id="什么是活锁">什么是活锁？</span></h2>
<p>活锁</p>
<p>是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<p>就类似马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去</p>
<hr>
<h2><span id="什么是饥饿">什么是饥饿？</span></h2>
<p>饥饿</p>
<p>是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求…，T2可能永远等待</p>
<p>类似有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的确没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过</p>
<hr>
<h2><span id="死锁与活锁的区别">死锁与活锁的区别？</span></h2>
<ul>
<li>处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊</li>
<li>简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</li>
</ul>
<hr>
<h2><span id="死锁与饥饿的区别">死锁与饥饿的区别？</span></h2>
<p>都是由于竞争资源而引起的，但又有明显差别</p>
<ul>
<li>从进程状态考虑，死锁进程都处于等待状态，忙式等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死；</li>
<li>死锁进程等待永远不会被释放的资源，饿死进程等待会被释放但却不会分配给自己的资源，表现为等待时限没有上界(排队等待或忙式等待)；</li>
<li>死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死；</li>
<li>死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。饥饿和饿死与资源分配策略有关，因而防止饥饿与饿死可从公平性考虑，确保所有进程不被忽视，如FCFS分配算法。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>排序与查找</title>
    <url>/post/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1><span id="排序">排序</span></h1>
<h2><span id="冒泡排序">冒泡排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>依次比较相邻两个元素的大小，将大的元素放在后面</li>
<li>两两都比较过为一轮排序，每轮排序都会确定一个最大元素的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;		<span class="comment">//n-1趟可决定n-1个元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<ol>
<li>
<p>每轮排序都将确定一个最大元素的位置（最后），在下轮排序中无需再比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>-i; j++) &#123;	<span class="comment">//每执行一轮排序，内层循环可以少执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在一轮排序中，若没有元素交换，则说明元素序列已经有序，可提前结束排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">//检查每轮是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>-i; j++) &#123;	<span class="comment">//每执行一轮排序，内层循环可以少执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!swapped)&#123;		<span class="comment">//没有元素交换，可提前结束排序</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后一次交换索引的右侧都是确定最终位置的元素，下轮排序中无需比较；当最后一次交换索引的位置为0，说明没有交换元素，综合上述进一步优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble1</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                last = j;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="选择排序">选择排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>
<p>将数组分为有序与无序的两个子集，每轮排序中从无序中选择最小的元素放入有序子集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;	<span class="comment">//最小元素插入的位置，最后的位置不用处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;	<span class="comment">//从无序子序列中找到最小的元素</span></span><br><span class="line">            min = a[min] &lt; a[j] ? min : j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>稳定性</strong></p>
</li>
</ol>
<img src="https://pic.imgdb.cn/item/63d72bf9face21e9ef3198f3.jpg" style="zoom:80%;">
<h2><span id="插入排序">插入排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>将数组分为有序与无序两个子集，每轮排序从无序数组中取出第一个元素插入有序子集中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;    <span class="comment">//无序子序列要插入的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;  <span class="comment">//有序子序列最右边的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];  <span class="comment">//要插入元素的值</span></span><br><span class="line">        <span class="keyword">for</span> (;j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= a[j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>大部分情况下，插入都略优于选择</p>
</li>
<li>
<p>有序集合插入的时间复杂度为 $O(n)$</p>
</li>
</ol>
<h2><span id="希尔排序">希尔排序</span></h2>
<p>插入排序适合小数据量，可以先将数组分割，再使用插入排序</p>
<p><strong>算法描述</strong></p>
<ol>
<li>
<p>首先选取一个间隙序列，如 (n/2，n/4 … 1)，n 为数组长度</p>
</li>
<li>
<p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p>
<p>① 少量元素插入排序速度很快</p>
<p>② 让组内值较大的元素更快地移动到后方</p>
</li>
<li>
<p>当间隙逐渐减少，直至为 1 时，即可完成排序</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;	<span class="comment">//设置间隙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gap; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + gap; j &lt; a.length; j += gap) &#123;		<span class="comment">//要插入的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> j - gap;  <span class="comment">//要插入元素下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[j];   <span class="comment">//要插入元素值</span></span><br><span class="line">                <span class="keyword">for</span> (; m &gt;= <span class="number">0</span>; m -= index) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value &gt;= a[m]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        a[m + index] = a[m];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[m + gap] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<ol>
<li>上述代码先将数组按照等间隙分为多个子序列进行排序，因此在不同间隙下分为多个子序列分别进行插入排序</li>
<li>实际上我们可以只关心数组中要插入的单个结点，通过不断减去间隙来计算要插入的有序子序列，而不用先求得多个子序列，再找插入元素以及子序列中的有序部分</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;	<span class="comment">//设置间隙</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; a.length; i++) &#123;<span class="comment">//要插入元素下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];   <span class="comment">//要插入元素的值</span></span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value &gt;= a[j]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        a[j + gap] = a[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + gap] = value;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="快速排序">快速排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>每一轮排序选择一个基准点（pivot）进行分区
<ol>
<li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li>
<li>当分区完成时，基准点元素的位置就是其最终位置</li>
</ol>
</li>
<li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li>
<li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li>
</ol>
<p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p>
<ol>
<li>
<p>选择最右元素作为基准点元素</p>
<blockquote>
<p>为了不对数组进行删除修改操作，将交换元素调整数组，使基准点左侧均小于基准点，右侧均大于基准点</p>
</blockquote>
</li>
<li>
<p>从左往右遍历元素，逐步确定基准点的最终位置</p>
<blockquote>
<p>最终位置需要和大于基准点的第一个元素交换</p>
</blockquote>
</li>
<li>
<p>当前结点前不存在大于基准点的结点时：</p>
<ol>
<li>
<p>若小于基准点，则最终位置右移，继续向右查找</p>
</li>
<li>
<p>若大于基准点，则暂定最终位置为此处，余下结点前出现了大于基准点的结点</p>
</li>
</ol>
</li>
<li>
<p>当前结点前为大于基准点的结点时：</p>
<ol>
<li>
<p>若大于基准点，则不改变最终位置（大于基准点的第一个元素）</p>
</li>
<li>
<p>若小于基准点，将当前结点与最终位置的结点交换，交换后最终位置右移，重新调整为最终位置左侧均小，右侧均大</p>
</li>
</ol>
</li>
<li>
<p>当遍历到最后的基准点时，与最终位置的结点交换</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partion(a, low, high);  <span class="comment">//获取索引，并调整索引位置</span></span><br><span class="line">    Quick(a, <span class="number">0</span>, index - <span class="number">1</span>);</span><br><span class="line">    Quick(a, index + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">//最右元素作为基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt;= high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= a[high]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">            a[j] = a[index];</span><br><span class="line">            a[index] = temp;</span><br><span class="line">            <span class="keyword">if</span> (j != high) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p>
<ol>
<li>
<p>选择最左元素作为基准点元素</p>
<blockquote>
<p>最终位置为小于基准点的最后一个元素，先j后i</p>
</blockquote>
</li>
<li>
<p>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</p>
</li>
<li>
<p>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</p>
<blockquote>
<p>对于递增有序序列的快排，基准点最终位置在最左不变，i从最左开始</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[low];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> low + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> high;</span><br><span class="line">    <span class="keyword">while</span> (index != j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; index != j &amp;&amp; j &gt; low + <span class="number">1</span>; j--) &#123;    <span class="comment">//最终位置为小于基准点的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; index != j &amp;&amp; index &lt; high; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[index] &gt;= pivot) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">            a[index] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[index] &lt; pivot) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[low];</span><br><span class="line">        a[low] = a[index];</span><br><span class="line">        a[index] = temp;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;     <span class="comment">//当右侧均大时，最终位置即最左</span></span><br><span class="line">        <span class="keyword">return</span> --index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partion2</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[low];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> high;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; index) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; index &amp;&amp; a[j] &gt; pivot) &#123;       <span class="comment">//最终位置为小于基准点的最后一个元素</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; index &amp;&amp; a[index] &lt;= pivot) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">        a[index] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[low];</span><br><span class="line">    a[low] = a[index];</span><br><span class="line">    a[index] = temp;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快排效率</strong></p>
<ol>
<li>
<p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$，平均空间复杂度为$O(log_2⁡n )$，最坏空间复杂度为$O(n)$</p>
<blockquote>
<p>时间复杂度= $O(n*递归层数)$ ：	快排中递归调用Quick方法，每次Quick方法的时间复杂度为$O(n)$</p>
<p>若将每次划分确定最终位置的结点作为根节点，再递归划分他的左右子序列，数组最终会被组织成一颗二叉树</p>
<ol>
<li>二叉树的层数即递归调用的层数</li>
<li>n个结点的二叉树的最小高度为$logn（向下取整） + 1$，最大高度为$n$</li>
</ol>
</blockquote>
</li>
<li>
<p>最好情况与最坏情况</p>
<blockquote>
<p>最坏情况：数组序列为有序递增序列，二叉树所有结点集中在其中一侧，此时二叉树的层数即结点个数</p>
<img src="https://pic.imgdb.cn/item/63d9075be90d1c00980a5c6a.jpg" style="zoom:67%;">
<p>最好情况：数组序列基准点将待排序列均匀划分为左右两个序列，二叉树平衡性最高，递归深度最小</p>
<img src="https://pic.imgdb.cn/item/63d90ae1e90d1c00981351ff.jpg" style="zoom:67%;">
<p>优化思路：选择值大小适中的元素作为基准点</p>
<ol>
<li>随机选取</li>
<li>从头中尾三个位置中选择适中大小的结点</li>
</ol>
</blockquote>
</li>
<li>
<p>不稳定</p>
<p><img src="https://pic.imgdb.cn/item/63d8fff3e90d1c0098f92473.jpg" alt></p>
</li>
</ol>
<p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p>
<ul>
<li>霍尔的移动次数平均来讲比洛穆托少3倍</li>
<li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li>
</ul>
<blockquote>
<p><em><strong>补充代码说明</strong></em></p>
<ul>
<li>day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少</li>
<li>day01.sort.QuickSortHoare 演示了霍尔分区的实现</li>
<li>day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较</li>
</ul>
</blockquote>
<h2><span id="归并排序">归并排序</span></h2>
<h2><span id="基数排序">基数排序</span></h2>
<h2><span id="堆排序">堆排序</span></h2>
<p><strong>稳定排序与不稳定排序</strong></p>
<p>稳定排序：排序后不改变同值元素的顺序</p>
<table>
<thead>
<tr>
<th></th>
<th>冒泡排序</th>
<th>选择排序</th>
<th>插入排序</th>
<th>希尔排序</th>
<th>快速排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>取决于间隙</td>
<td>$O(nlog_2⁡n )$</td>
</tr>
<tr>
<td>适用</td>
<td>有序时交换次数少</td>
<td>无序时交换次数少</td>
<td>小数据量</td>
<td>数组</td>
<td>数据量较大</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定</td>
<td>不稳定</td>
<td>稳定</td>
<td>不稳定</td>
<td>不稳定</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>$O(log_2n)$</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/post/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2><span id="安装mysql">安装MySql</span></h2>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/e74255282ff5da9b.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/ef5b33c7ad593eff.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/64e39bddd1a902aa.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/472607774d81bf74.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/1a137450e9c0ec6e.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/821c5a4b337ed56f.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/c846391409d30e41.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/909df66f9bf3c443.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/268f40b1c611ce87.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/2045461d92bf6f9c.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/5fc1dbf469fd495b.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/0e42147cc13e9916.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/d090c84b4339c86e.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/8fc3f1b80630ac98.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/eec7ce722143c841.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/a2dc187199daff4b.png" alt></p>
<p><img src="https://pic.imgdb.cn/item/63e0f2cf4757feff3388143a.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63e0f2da4757feff33882809.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63e0f2e64757feff33883a24.jpg" alt></p>
<h2><span id="概述">概述</span></h2>
<p>数据查询语言<strong>DQL</strong>，数据操纵语言<strong>DML</strong>，数据定义语言<strong>DDL</strong>，数据控制语言<strong>DCL</strong>。</p>
<blockquote>
<p>DQL：数据库查询语言。关键字：SELECT … FROM … WHERE。</p>
<p><a href="https://baike.baidu.com/item/DDL/21997?fromModule=lemma_inlink">DDL</a> ：数据库模式定义语言。关键字：CREATE，DROP，ALTER。</p>
<p><a href="https://baike.baidu.com/item/DML/10035808?fromModule=lemma_inlink">DML</a>：数据操纵语言。关键字：INSERT、UPDATE、DELETE。</p>
<p><a href="https://baike.baidu.com/item/DCL/6524388?fromModule=lemma_inlink">DCL</a>：数据控制语言 。关键字：GRANT、REVOKE。</p>
<p>TCL：事务控制语言。关键字：COMMIT、ROLLBACK、SAVEPOINT。</p>
<p>DDL,DML,DCL,DQL,TCL共同组成数据库的完整语言。</p>
</blockquote>
<h2><span id="关系数据库">关系数据库</span></h2>
<p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">class_id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">gender</th>
<th style="text-align:left">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">M</td>
<td style="text-align:left">90</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">F</td>
<td style="text-align:left">95</td>
</tr>
</tbody>
</table>
<p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p>
<h3><span id="主键">主键</span></h3>
<p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p>
<blockquote>
<p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。</p>
</blockquote>
<ol>
<li>记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</li>
<li>不使用任何业务相关的字段作为主键。</li>
</ol>
<blockquote>
<p>如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p>
<p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p>
</blockquote>
<p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p>
<ol>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li>
<li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li>
</ol>
<p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p>
<blockquote>
<p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p>
</blockquote>
<h3><span id="联合主键">联合主键</span></h3>
<p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p>
<p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id_num</th>
<th style="text-align:left">id_type</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">A</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">A</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">B</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p>
<p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p>
<h3><span id="小结">小结</span></h3>
<p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p>
<p>可以使用多个列作为联合主键，但联合主键并不常用</p>
<h3><span id="外键">外键</span></h3>
<p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">一班</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">二班</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p>
<p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p>
<p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">class_id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2</td>
<td style="text-align:left">小白</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p>
<p>例如：</p>
<ul>
<li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li>
</ul>
<p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p>
<p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure>
<p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p>
<p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p>
<p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p>
<p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_class_id;</span><br></pre></td></tr></table></figure>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p>
<h3><span id="多对多">多对多</span></h3>
<p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p>
<p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p>
<p><code>teachers</code>表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">张老师</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">王老师</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">李老师</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">赵老师</td>
</tr>
</tbody>
</table>
<p><code>classes</code>表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">一班</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">二班</td>
</tr>
</tbody>
</table>
<p>中间表<code>teacher_class</code>关联两个一对多关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">teacher_id</th>
<th style="text-align:left">class_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">4</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p>
<ul>
<li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li>
<li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li>
<li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li>
<li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li>
</ul>
<p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p>
<ul>
<li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li>
<li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li>
</ul>
<p>因此，通过中间表，我们就定义了一个“多对多”关系。</p>
<h3><span id="一对一">一对一</span></h3>
<p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p>
<p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">student_id</th>
<th style="text-align:left">mobile</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">135xxxx6300</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
<td style="text-align:left">138xxxx2209</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">5</td>
<td style="text-align:left">139xxxx8086</td>
</tr>
</tbody>
</table>
<p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p>
<p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p>
<p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p>
<h3><span id="小结">小结</span></h3>
<p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p>
<h3><span id="索引">索引</span></h3>
<ol>
<li>
<p>查询成千上万条记录时，使用索引可以提高查询速度</p>
<blockquote>
<p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度</p>
</blockquote>
</li>
<li>
<p>索引的效率与索引列的值是否散列有关</p>
<blockquote>
<p>该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p>
<p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p>
</blockquote>
</li>
<li>
<p>索引对于用户和应用程序来说都是透明的</p>
<blockquote>
<p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p>
</blockquote>
</li>
<li>
<p>可以对一张表创建多个索引</p>
</li>
<li>
<p>在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢</p>
</li>
</ol>
<p><strong>唯一索引</strong></p>
<ol>
<li>
<p>可以保证某一列的值具有唯一性</p>
</li>
<li>
<p>具有业务含义的列适合唯一索引</p>
<blockquote>
<p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p>
<p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。</p>
</blockquote>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);		<span class="comment">-- 唯一索引</span></span><br></pre></td></tr></table></figure>
<p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);		<span class="comment">-- 唯一约束，此时name列没有索引，但仍具有唯一性保证</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>需要在examination_info表创建以下索引，在duration列创建普通索引idx_duration、在exam_id列创建唯一性索引uniq_idx_exam_id、在tag列创建全文索引full_idx_tag。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_duration <span class="keyword">ON</span> examination_info (duration);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uniq_idx_exam_id <span class="keyword">ON</span> examination_info (exam_id); </span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX full_idx_tag <span class="keyword">ON</span> examination_info (tag);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>创建索引</strong></p>
<ol>
<li>
<p>CREATE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="comment">-- 唯一索引</span></span><br><span class="line"><span class="operator">|</span> FULLTEXT <span class="comment">-- 全文索引</span></span><br><span class="line">] INDEX index_name <span class="keyword">ON</span> table_name <span class="comment">-- 不指定唯一或全文时默认普通索引</span></span><br><span class="line">(column1[(length) [<span class="keyword">DESC</span><span class="operator">|</span><span class="keyword">ASC</span>]] [,column2,...]) <span class="comment">-- 可以对多列建立组合索引 </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ALTER</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name </span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT] [INDEX] index_content (column1)	[,column2,...])<span class="comment">-- index_content索引名 content索引列</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>删除索引</strong></p>
<ol>
<li>
<p>DROP</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ALTER</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p>删除examination_info表上的唯一索引uniq_idx_exam_id和全文索引full_idx_tag。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX uniq_idx_exam_id <span class="keyword">ON</span> examination_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX full_idx_tag <span class="keyword">ON</span> examination_info;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用</p>
<ol>
<li>索引使用时满足最左前缀匹配原则，即对于组合索引(col1, col2)，在不考虑引擎优化时，条件必须是col1在前col2在后，或者只使用col1，索引才会生效；</li>
<li>索引不包含有NULL值的列</li>
<li>一个查询只使用一次索引，where中如果使用了索引，order by就不会使用</li>
<li>like做字段比较时只有前缀确定时才会使用索引</li>
<li>在列上进行运算后不会使用索引，如year(start_time)&lt;2020不会使用start_time上的索引</li>
</ol>
<h2><span id="dql数据查询">DQL数据查询</span></h2>
<h3><span id="书写顺序">书写顺序</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	[<span class="keyword">distinct</span>]<span class="operator">|</span>[<span class="keyword">ALL</span>] 列<span class="number">1</span>[, 列<span class="number">2</span>, 列<span class="number">3</span>] 		</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	<span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">JOIN</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	<span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>	</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	<span class="operator">&lt;</span>包含聚合函数的条件表达式<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">	子句 <span class="keyword">asc</span>（默认）<span class="operator">|</span><span class="keyword">desc</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span>N<span class="operator">&gt;</span> <span class="keyword">OFFSET</span> <span class="operator">&lt;</span>M<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="基本查询">基本查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb01c07d5ca72068acda0.jpg" alt></p>
<p>可以没有<code>FROM</code>子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">+</span><span class="number">200</span></span><br><span class="line"><span class="comment">-- 计算出表达式的结果，但不常用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- 用来判断当前到数据库的连接是否有效</span></span><br></pre></td></tr></table></figure>
<h3><span id="投影查询">投影查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>[, 列<span class="number">2</span>, 列<span class="number">3</span>] <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> </span><br><span class="line"><span class="comment">-- 如果列名或者表名与关键字冲突，需要使用撇号包裹</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从`students`表中返回`id`、`score`和`name`这三列：</span></span><br><span class="line"><span class="keyword">SELECT</span> id, score, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb20a07d5ca72068f76d9.jpg" alt></p>
<p><strong>AS</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span> (<span class="keyword">AS</span>) 别名<span class="number">1</span>, 列<span class="number">2</span> (<span class="keyword">AS</span>) 别名<span class="number">2</span>, 列<span class="number">3</span> (<span class="keyword">AS</span>) 别名<span class="number">3</span> <span class="keyword">FROM</span> ...</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，可以设置结果集显示的列名</li>
<li>AS可以省略</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用投影查询，并将列名重命名：</span></span><br><span class="line"><span class="keyword">SELECT</span> id, score points, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb23a07d5ca72069010ea.jpg" alt></p>
<p><strong>DISTINCT</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>]<span class="operator">|</span>[<span class="keyword">ALL</span>] 列<span class="number">1</span>[，列<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DISTINCT用来查询修饰字段不重复记录的条数,它将每个不同(唯一)值返回的行数限制为一个任意行。</p>
<p>如果未指定<code>DISTINCT</code>子句，则默认情况下显示满足选择条件的所有行。与指定ALL子句相同</p>
</blockquote>
<ol>
<li>为修饰字段的每个不重复组合返回一行。可以指定一个或多个修饰字段</li>
<li>在SELECT语句中使用DISTINCT，必须放在第一个要查询字段的开头</li>
<li>不能在DML语句（ INSERT, DELETE, UPDATE） 中使用</li>
<li>聚合函数也可以使用DISTINCT，COUNT(DISTINCT 列1，列2)可以实现查询不重复分组后每组的行数</li>
</ol>
<h3><span id="条件查询">条件查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="operator">|</span>列 <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>条件表达式</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">条件</th>
<th>符号</th>
<th style="text-align:left">表达式举例1</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">判断相等</td>
<td>=</td>
<td style="text-align:left">score = 80</td>
<td style="text-align:left">字符串需要用单引号括起来</td>
</tr>
<tr>
<td style="text-align:left">判断大于</td>
<td>&gt;</td>
<td style="text-align:left">score &gt; 80</td>
<td style="text-align:left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr>
<td style="text-align:left">判断大于或相等</td>
<td>&gt;=</td>
<td style="text-align:left">score &gt;= 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断小于</td>
<td>&lt;</td>
<td style="text-align:left">score &lt; 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断小于或相等</td>
<td>&lt;=</td>
<td style="text-align:left">score &lt;= 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断不相等</td>
<td>&lt;&gt;</td>
<td style="text-align:left">score &lt;&gt; 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断包含于</td>
<td>IN</td>
<td style="text-align:left">score in(60,70,80,90)</td>
<td style="text-align:left">score = 60 OR score = 70 OR score = 80 OR score = 90</td>
</tr>
<tr>
<td style="text-align:left">判断在-之间</td>
<td>BETWEEN</td>
<td style="text-align:left">score between 60 and 100</td>
<td style="text-align:left">score &gt;= 60 AND score &lt;= 100</td>
</tr>
<tr>
<td style="text-align:left">判断空</td>
<td>IS NULL</td>
<td style="text-align:left">score IS NULL</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断非空</td>
<td>IS NOT NULL</td>
<td style="text-align:left">score IS NOT NULL</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断相似</td>
<td>LIKE</td>
<td style="text-align:left">name LIKE ‘ab%’</td>
<td style="text-align:left">%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td>
</tr>
<tr>
<td style="text-align:left">判断正则表达式</td>
<td>RLIKE</td>
<td style="text-align:left">name RLIKE ‘<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>+$’</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断存在</td>
<td>EXISTS</td>
<td style="text-align:left">EXISTS 查询子句</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><strong>LIKE</strong></p>
<ol>
<li>% 通配多个任意字符或者没有任意字符</li>
<li>_ 通配必须有一个任意字符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询姓刘的同学</span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span> stu</span><br><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;刘%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓刘的同学,且必须三个字</span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span> stu</span><br><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;刘__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名含有H的同学</span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span> stu</span><br><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;%H%&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>RLIKE</strong></p>
<blockquote>
<p>后接正则表达式 （<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>+$）</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>表示匹配的字符必须在最前边</td>
<td>^A不匹配“an A”中的‘A’，但匹配“An A”中最前面的‘A’</td>
</tr>
<tr>
<td>$</td>
<td>与^类似，匹配最末的字符</td>
<td>t$不匹配“eater”中的‘t’，但匹配“eat”中的‘t’</td>
</tr>
<tr>
<td>[0-9]</td>
<td>字符列表，匹配列出中的任一个字符。你可以通过连字符-指出字符范围</td>
<td>[abc]跟[a-c]一样。它们匹配“brisket”中的‘b’和“ache”中的‘c’</td>
</tr>
<tr>
<td>+</td>
<td>匹配+号前面的字符1次及以上。等价于{1,}</td>
<td>a+匹配“candy”中的‘a’和“caaaaaaandy”中的所有‘a’</td>
</tr>
</tbody>
</table>
<p>来源:<a href="https://www.yulucn.com/question/4866556442">https://www.yulucn.com/question/4866556442</a></p>
<p><strong>EXISTS</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXISTS</span> (查询子句)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False</p>
</blockquote>
<ul>
<li>UNION搭配EXISTS可以实现复杂的条件查询</li>
</ul>
<p><strong>AND</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>条件<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span>条件<span class="number">2</span><span class="operator">&gt;</span>					<span class="comment">-- 表达满足条件1并且满足条件2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,gender,score <span class="keyword">FROM</span> students  <span class="comment">-- 查找及格的男同学</span></span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">AND</span> gender <span class="operator">=</span> &quot;M&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb7e707d5ca72069a274a.jpg" alt></p>
<p><strong>OR</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>条件<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">OR</span> <span class="operator">&lt;</span>条件<span class="number">2</span><span class="operator">&gt;</span>					<span class="comment">-- 表达满足条件1、条件2其中一个</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,gender,score <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">2</span>				<span class="comment">-- 查询学号是1和2的同学</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb8af07d5ca72069bca88.jpg" alt></p>
<p><strong>NOT</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">NOT</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>						<span class="comment">-- 表示“不符合该条件”的记录</span></span><br></pre></td></tr></table></figure>
<h3><span id="排序">排序</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句 <span class="keyword">asc</span>（默认）<span class="operator">|</span><span class="keyword">desc</span> 		<span class="comment">-- 默认按照子句的从低到高排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照成绩排序（降序）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">-- 按照年龄降序排序，同岁的学生按照分数降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">year</span>(age) <span class="keyword">desc</span> ,score <span class="keyword">desc</span> </span><br></pre></td></tr></table></figure>
<h3><span id="分页查询">分页查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT <span class="operator">&lt;</span>N<span class="operator">&gt;</span> <span class="keyword">OFFSET</span> <span class="operator">&lt;</span>M<span class="operator">&gt;</span>				<span class="comment">-- 从结果集中的第M号记录开始取出N条记录</span></span><br><span class="line"><span class="comment">-- N：每页的数量	M：当前页数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>					<span class="comment">-- 第1页从0号记录开始,OFFSET 0 可以省略</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>					<span class="comment">-- 第2页从3号记录开始</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">6</span>					<span class="comment">-- 第3页从6号记录开始</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">9</span>					<span class="comment">-- 第4页从9号记录开始</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/a1ffbb51822fa121.png" alt></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">20</span>					<span class="comment">-- 超过记录，得到一个空的结果集</span></span><br></pre></td></tr></table></figure>
<h3><span id="聚合查询">聚合查询</span></h3>
<ul>
<li>多行数据变成一个数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">聚合函数([<span class="keyword">DISTINCT</span>]列名<span class="operator">|</span>表达式)		 				<span class="comment">-- 列名可以为 * 表示所有列</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>聚合函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT</td>
<td>计算某一列的总数</td>
</tr>
<tr>
<td>AVG</td>
<td>计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td>SUM</td>
<td>计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td>MAX</td>
<td>计算某一列的最大值，对于字符型字符类型返回排序最后的字符</td>
</tr>
<tr>
<td>MIN</td>
<td>计算某一列的最小值，对于字符型字符类型返回排序最前的字符</td>
</tr>
</tbody>
</table>
<p>如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code></p>
<p><strong>分组聚合</strong></p>
<ul>
<li>按照指定列拆分，列数据相同的数据被合并，最终多行数据分为若干行</li>
<li>分组指定的列能与聚合函数一起显示，而显示非聚合的列也非分组的列没有实际意义</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>					<span class="comment">-- 可以是单列，也可以是多列</span></span><br></pre></td></tr></table></figure>
<p><strong>如何对聚合函数的列进行条件查询</strong></p>
<ul>
<li>
<p>WHERE子句不能使用聚合函数，一般在分组后使用HAVING关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>包含聚合函数的条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以根据聚合函数列排序（order by 子句能使用聚合函数）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询男同学和女同学的平均年龄,且只显示平均年龄大于23岁的</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	gender,</span><br><span class="line">	<span class="built_in">avg</span>(age)</span><br><span class="line"><span class="keyword">from</span>  </span><br><span class="line">	user_profile</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">	gender </span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line">	<span class="built_in">avg</span>(age)<span class="operator">&gt;</span><span class="number">23</span></span><br></pre></td></tr></table></figure>
<p>聚合查询应用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    tag,</span><br><span class="line">    difficulty,</span><br><span class="line">    ROUND((<span class="built_in">SUM</span>(score) <span class="operator">-</span> <span class="built_in">MAX</span>(score) <span class="operator">-</span> <span class="built_in">MIN</span>(score)) <span class="operator">/</span> (<span class="built_in">COUNT</span>(score) <span class="number">-2</span>),<span class="number">1</span>) clip_avg_score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    exam_record er,</span><br><span class="line">    examination_info ei</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    ei.exam_id <span class="operator">=</span> er.exam_id</span><br><span class="line">    <span class="keyword">AND</span> submit_time <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">    <span class="keyword">AND</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br></pre></td></tr></table></figure>
<h3><span id="多表查询">多表查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>别名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>表名<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>别名<span class="number">2</span><span class="operator">&gt;</span>	</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>返回结果为表1和表2的“乘积”</p>
<blockquote>
<p>即表1的每一行与表2的每一行都两两拼在一起返回</p>
<p>结果集的列数是表1和表2的列数之和</p>
<p>行数是表1和表2的行数之积</p>
</blockquote>
</li>
<li>
<p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p>
</li>
</ul>
<h3><span id="连接查询">连接查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INNER</span><span class="operator">|</span><span class="keyword">LEFT</span> <span class="keyword">OUTER</span><span class="operator">|</span><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>连接条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>内连接</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/f893d48c7c951a76.png" alt></p>
<p>只返回同时存在于两张表的行数据</p>
<p><code>students</code>表的<code>class_id</code>包含1，2，3，<code>classes</code>表的<code>id</code>包含1，2，3，4</p>
<p>INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/ffe3367a85280dab.png" alt></p>
<p><strong>左外连接</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/fb563ac69a54d9d9.png" alt></p>
<p>LEFT OUTER JOIN则返回左表都存在的行</p>
<p>如果给students表增加一行，并添加class_id=5，classes表并不存在id=5的行</p>
<p>LEFT OUTER JOIN的结果会增加一行，对应的<code>class_name</code>是<code>NULL</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/481c20f1e19c820f.png" alt></p>
<p><strong>右外连接</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/5ebf76c465113c6d.png" alt></p>
<p>RIGHT OUTER JOIN返回右表都存在的行</p>
<p>如果某一行仅在右表存在，那么结果集就会以<code>NULL</code>填充剩下的字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/47439395f20cd95e.png" alt></p>
<p><strong>USING</strong></p>
<blockquote>
<p>sql/92标准可以使用using关键字来简化连接查询，但是只是在查询满足以下条件时<br>
1.查询必须是等值连接<br>
2.等值连接中的列必须具有相同的名称和数据类型</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">USING</span> (列<span class="number">1</span>，列<span class="number">2</span>，...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a (<span class="keyword">AS</span> 别名a) <span class="keyword">JOIN</span> (b 别名b) <span class="keyword">ON</span> 别名a.列<span class="number">1</span> <span class="operator">=</span> 别名b.列<span class="number">1</span></span><br><span class="line">	<span class="keyword">AND</span> 别名a.列<span class="number">2</span> <span class="operator">=</span> 别名b.列<span class="number">2</span> </span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<ul>
<li>可以一次指定多个相同名称、数据类型的列</li>
<li>不能指定表的别名</li>
<li>不能 AND 附加别的连接限制条件</li>
</ul>
<h3><span id="日期函数">日期函数</span></h3>
<p><strong>数据类型</strong></p>
<ul>
<li>DATE - 格式 YYYY-MM-DD</li>
<li>DATETIME - 格式: YYYY-MM-DD HH:MM:SS</li>
<li>TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS</li>
<li>YEAR - 格式 YYYY 或 YY</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的学生，且需要查看其实际年龄（多少岁）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,(<span class="keyword">year</span>(curdate())<span class="operator">-</span><span class="keyword">year</span>(age)) <span class="keyword">as</span> 岁数 <span class="keyword">from</span> stu</span><br></pre></td></tr></table></figure>
<p><strong>日期格式化</strong></p>
<p>DATE_FORMAT(date,format)</p>
<blockquote>
<p>用format 格式化date，format 为格式化字符串</p>
<p>‘%Y-%m-%d %H:%i:%s’  2021-08-17 14:42:31</p>
<p>‘%Y%m’	202108</p>
</blockquote>
<table>
<thead>
<tr>
<th>格式化标识符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Y</td>
<td>年，4位</td>
</tr>
<tr>
<td>%y</td>
<td>年，2位</td>
</tr>
<tr>
<td>%M</td>
<td>月，月名称，如January</td>
</tr>
<tr>
<td>%m</td>
<td>月，2位（01-12）</td>
</tr>
<tr>
<td>%D</td>
<td>日，如1st，2nd</td>
</tr>
<tr>
<td>%d</td>
<td>日，2位（01-31）</td>
</tr>
<tr>
<td>%H</td>
<td>时，2位，24小时制</td>
</tr>
<tr>
<td>%h</td>
<td>时，12小时制</td>
</tr>
<tr>
<td>%i</td>
<td>分，2位（00-59）</td>
</tr>
<tr>
<td>%S或%s</td>
<td>秒，2位（00-59）</td>
</tr>
<tr>
<td>%p</td>
<td>PM 或AM</td>
</tr>
<tr>
<td>%r</td>
<td>HH:mm:ss PM形式时间</td>
</tr>
<tr>
<td>%W</td>
<td>周，周名，如Tuesday</td>
</tr>
<tr>
<td>%w</td>
<td>周，0-6，0为周日</td>
</tr>
<tr>
<td>%j</td>
<td>当前日期所在一年中的天数，3位（001-366）</td>
</tr>
</tbody>
</table>
<p><strong>距离</strong></p>
<ol>
<li>
<p>TIMESTAMPDIFF(interval, time_start, time_end)</p>
<blockquote>
<p>可计算time_start、time_end的时间差，单位以指定的interval为准，常用可选：</p>
<ul>
<li>SECOND 秒</li>
<li>MINUTE 分钟（返回秒数差除以60的整数部分）</li>
<li>HOUR 小时（返回秒数差除以3600的整数部分）</li>
<li>DAY 天数（返回秒数差除以3600*24的整数部分）</li>
<li>MONTH 月数</li>
<li>YEAR 年数</li>
</ul>
</blockquote>
</li>
<li>
<p>DATEDIFF(time_end,time_start)</p>
<blockquote>
<p>计算time_start、time_end之间的天数</p>
</blockquote>
</li>
</ol>
<p><strong>运算</strong></p>
<p>DATE_ADD(date,	INTERVAL expr unit)</p>
<blockquote>
<p>日期加上指定单位的时间，第二参数interval 后支持负数，date_add既可以加也可以减</p>
</blockquote>
<table>
<thead>
<tr>
<th>interval</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>interval 1 day</td>
<td>1天</td>
</tr>
<tr>
<td>interval 1 hour</td>
<td>1小时</td>
</tr>
<tr>
<td>interval 1 minute</td>
<td>1分钟</td>
</tr>
<tr>
<td>interval 1 second</td>
<td>1秒</td>
</tr>
<tr>
<td>interval 1 microsecond</td>
<td>1毫秒</td>
</tr>
<tr>
<td>interval 1 week</td>
<td>1周</td>
</tr>
<tr>
<td>interval 1 month</td>
<td>1月</td>
</tr>
<tr>
<td>interval 1 quarter</td>
<td>1季</td>
</tr>
<tr>
<td>interval 1 year</td>
<td>1年</td>
</tr>
</tbody>
</table>
<p><strong>计算某个月的天数</strong></p>
<ol>
<li>
<pre><code class="language-sql">DATEDIFF(DATE_ADD(time,INTERVAL 1 MONTH),time)		-- 距离下个月同天的天数
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ~~~sql</span><br><span class="line">   day(last_day(time))						   		-- 获取本月最后一天</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<p><strong>MySQL Date 函数</strong></p>
<p>涉及时分秒一般为DATETIME的函数</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_now.asp">NOW()</a></td>
<td style="text-align:left">返回当前的日期和时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR(列名)</td>
<td style="text-align:left">返回当前的时间的年</td>
</tr>
<tr>
<td style="text-align:left">MONTH(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的月</td>
</tr>
<tr>
<td style="text-align:left">DAY(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的天</td>
</tr>
<tr>
<td style="text-align:left">HOUR(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的小时</td>
</tr>
<tr>
<td style="text-align:left">MINUTE(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的分钟</td>
</tr>
<tr>
<td style="text-align:left">SECOND(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的秒</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_curdate.asp">CURDATE()</a></td>
<td style="text-align:left">返回当前的日期</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_curtime.asp">CURTIME()</a></td>
<td style="text-align:left">返回当前的时间</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date.asp">DATE()</a></td>
<td style="text-align:left">提取日期或日期/时间表达式的日期部分</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_extract.asp">EXTRACT()</a></td>
<td style="text-align:left">返回日期/时间按的单独部分</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date_add.asp">DATE_ADD()</a></td>
<td style="text-align:left">给日期添加指定的时间间隔</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date_sub.asp">DATE_SUB()</a></td>
<td style="text-align:left">从日期减去指定的时间间隔</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_datediff_mysql.asp">DATEDIFF()</a></td>
<td style="text-align:left">返回两个日期之间的天数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date_format.asp">DATE_FORMAT()</a></td>
<td style="text-align:left">用不同的格式显示日期/时间</td>
</tr>
</tbody>
</table>
<p><strong>时间戳-日期格式转化</strong></p>
<ol>
<li>from_unixtime(列名,字符串格式)：将时间戳转换成日期</li>
<li>unix_timestamp():将日期转换回时间戳</li>
</ol>
<h3><span id="条件函数">条件函数</span></h3>
<p><strong>IF 条件函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if(x<span class="operator">=</span>n,a,b)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x=n代表判断条件，如果x=n时，那么结果返回a，否则返回b</p>
</blockquote>
<p><strong>Case when 条件函数</strong></p>
<p>按照多个条件更换列中的内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> 测试表达式							<span class="comment">-- 测试表达式可省略，此时为搜索CASE函数</span></span><br><span class="line"><span class="keyword">WHEN</span> 简单表达式<span class="number">1</span> <span class="keyword">THEN</span> 结果表达式<span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> 简单表达式<span class="number">2</span> <span class="keyword">THEN</span> 结果表达式<span class="number">2</span> …</span><br><span class="line"><span class="keyword">WHEN</span> 简单表达式n <span class="keyword">THEN</span> 结果表达式n</span><br><span class="line">[ <span class="keyword">ELSE</span> 结果表达式n<span class="operator">+</span><span class="number">1</span> ]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>若没有测试表达式</p>
<ol>
<li>从上到下判断WHEN子句的简单表达式的值</li>
<li>若简单表达式的值为TRUE，则返回WHEN子句所对应的结果表达式的值</li>
<li>如果所有简单表达式的值为FALSE
<ol>
<li>若指定了ELSE子句,则返回ELSE子句中指定的结果表达式的值</li>
<li>若没有指定ELSE子句，则返回NULL</li>
</ol>
</li>
</ol>
<p>若有测试表达式</p>
<blockquote>
<ol>
<li>从上到下判断测试表达式的值与每个WHEN子句的简单表达式是否相等</li>
<li>如果某个简单表达式的值与测试表达式的值相等，则返回第一个与之匹配的WHEN子句所对应的结果表达式的值</li>
<li>如果所有简单表达式的值与测试表达式的值都不相等</li>
<li>若指定了ELSE子句,则返回ELSE子句中指定的结果表达式的值</li>
<li>若没有指定ELSE子句，则返回NULL</li>
</ol>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    device_id,</span><br><span class="line">    gender,</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">25</span> <span class="keyword">then</span> <span class="string">&#x27;25岁及以上&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;20-24岁&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age<span class="operator">&lt;</span><span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;20岁以下&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="string">&#x27;其他&#x27;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">as</span> age_cut</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="文本函数">文本函数</span></h3>
<p><strong>CONCAT函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> CONCAT(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>,<span class="string">&#x27;ff&#x27;</span>)	<span class="comment">-- 返回结果为 ‘abcbcdff&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CONCAT函数用于将两个或多个字符串连接起来，形成一个单一的字符串</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GROUP_CONCAT([<span class="keyword">DISTINCT</span>] 要连接的字段 [<span class="keyword">Order</span> <span class="keyword">BY</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span> 排序字段] [Separator <span class="string">&#x27;分隔符&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><strong>SUBSTRING_INDEX</strong></p>
<p>将字符串依据某个指定分隔符进行切分，并返回指定位置分隔符前的字符。(字段分割符,位置）</p>
<p>从 ‘180,78kg,male’ 分别取出身高体重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(<span class="string">&#x27;180,78kg,male&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;1&#x27;</span>) <span class="keyword">as</span> height	<span class="comment">-- 返回身高: &#x27;180&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(<span class="string">&#x27;180,78kg,male&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;2&#x27;</span>) <span class="keyword">as</span> height	<span class="comment">-- 返回&#x27;180,78kg&#x27;	多取出身高的信息</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在上述的基础上嵌套一层查询，负数位置代表从后向前取，-1代表最后一位，相当于取出’180,78kg&#x27;的最后一个逗号后的字符</span></span><br><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(SUBSTRING_INDEX(<span class="string">&#x27;180,78kg,male&#x27;</span>,<span class="string">&#x27;,’,&#x27;</span><span class="number">2</span>’),’,’,<span class="number">-1</span>) <span class="keyword">as</span> height</span><br></pre></td></tr></table></figure>
<p><strong>INSTR函数</strong></p>
<ul>
<li>instr(substr,str)：返回substr字符串在str里第一次出现的位置，从1开始，没有返回0</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;bacd&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) 	<span class="comment">-- 从bacd字符串中寻找字符a首次出现的位置，输出值为2</span></span><br></pre></td></tr></table></figure>
<p><strong>substring函数</strong></p>
<ul>
<li>
<p>substr（string A，int start，int len）,返回字符串A从下标start位置开始，长度为len的字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(‘bacda’,<span class="number">2</span>,<span class="number">2</span>)	<span class="comment">-- 输出：’ac’，代码表示返回从第2个字符起后2个字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>substring（string A，int start）,在不指定返回字符串长度的情况下，返回字符串A从下标start位置到结尾的字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(‘bacda’,<span class="number">2</span>)		<span class="comment">-- 输出：’acda’，代码表示返回从第2个字符起到末尾所有的字符串</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>大小写转换</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UPPER(str)</td>
<td>将参数转换为大写</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将参数转换为小写</td>
</tr>
<tr>
<td>LENGTH(str)</td>
<td>返回文本字段中值的长度</td>
</tr>
<tr>
<td>CHAR_LENGTH(str)</td>
<td>返回文本字段中字符的长度</td>
</tr>
<tr>
<td>CONCAT(str1,str2,…)</td>
<td>将多个字符串连接成一个字符串</td>
</tr>
<tr>
<td>SUBSTRING_INDEX(str,分隔符,index)</td>
<td>字符串依据某个分隔符进行切分，第index个分隔符前的字符</td>
</tr>
<tr>
<td>INSTR(substr,str)</td>
<td>返回substr字符串在str里第一次出现的位置，从1开始，没有返回0</td>
</tr>
<tr>
<td>SUBSTRING(str,int start,int len)</td>
<td>返回字符串从下标start位置开始，长度为len的字符串，从1开始，没有返回0</td>
</tr>
<tr>
<td>SUBSTRING(str,int start)</td>
<td>返回字符串从下标start位置到结尾的字符串</td>
</tr>
</tbody>
</table>
<h3><span id="窗口函数">窗口函数</span></h3>
<p><strong>使用场景</strong></p>
<ol>
<li>排名问题：每个部门按业绩来排名</li>
<li>topN问题：找出每个部门排名前N的员工进行奖励</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>用于分组的列名<span class="operator">&gt;</span>					       <span class="comment">-- 窗口函数可以是专用窗口函数或聚合函数</span></span><br><span class="line">                 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>用于排序的列名<span class="operator">&gt;</span> <span class="keyword">RANGE</span><span class="operator">|</span><span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> 边界规则<span class="number">1</span> <span class="keyword">AND</span> 边界规则<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>窗口函数与GROUP BY</strong></p>
<table>
<thead>
<tr>
<th>窗口函数</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody>
<tr>
<td>同时分组和排序</td>
<td>分组</td>
</tr>
<tr>
<td>不减少原表的行数（特殊DENSE_RANK）</td>
<td>汇总后改变了表的行数，一行只有一个类别</td>
</tr>
<tr>
<td>在where或者group by子句处理后的结果上操作，原则上只能写在select子句中</td>
<td>指定的书写位置</td>
</tr>
<tr>
<td>Mysql从8.0版本才开始支持窗口函数</td>
<td></td>
</tr>
<tr>
<td>对于每行数据都有新的标记（与使用的窗口函数有关）</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>窗口函数中的ORDER BY</strong></p>
<p><a href="https://www.cnblogs.com/lihaoyang/p/6756956.html">SQL开窗函数 - 我俩绝配 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>用于排序的列名<span class="operator">&gt;</span> [<span class="keyword">RANGE</span><span class="operator">|</span><span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> 边界规则<span class="number">1</span> <span class="keyword">AND</span> 边界规则<span class="number">2</span>] <span class="comment">-- 定位计算范围，这个子句又被称为定位框架</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>RANGE表示按照值的范围进行范围的定义</p>
<p>ROWS表示按照行的范围进行范围的定义</p>
</blockquote>
<table>
<thead>
<tr>
<th>边界规则</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CURRENT ROW</td>
<td>当前行</td>
</tr>
<tr>
<td>N PRECEDING</td>
<td>前N行</td>
</tr>
<tr>
<td>UNBOUNDED PRECEDING</td>
<td>一直到第一条记录</td>
</tr>
<tr>
<td>N FOLLOWING</td>
<td>后N行</td>
</tr>
<tr>
<td>UNBOUNDED FOLLOWING</td>
<td>一直到最后一条记录</td>
</tr>
</tbody>
</table>
<p>查询从第一行到当前行为一组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(fsalary) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> fsalary [<span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>]）	<span class="comment">-- 可以省略定位框架声明部分</span></span><br></pre></td></tr></table></figure>
<p>row换成range，按照值范围进行定位</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(fsalary) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> fsalary <span class="keyword">range</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) 到当前行工资求和</span><br></pre></td></tr></table></figure>
<p><img src="https://images2015.cnblogs.com/blog/702434/201704/702434-20170424155347381-935401731.png" alt="img"></p>
<p>处理并列排序的情况：Lily、Swing、Bill这三个人的工资都是2000元</p>
<ol>
<li>“ROWS”进行行的范围定位，则计算从第一条到当前行的累积和</li>
<li>“RANGE”进行值的范围定位，则计算从第一个值1000到当前值的累计和，由于等于2000元的工资有三个人，所以对 Lily、Swing、Bill这三个人进行开窗函数聚合计算的时候得到的都是7000（ “ 1000+2000+2000+2000 ”）</li>
</ol>
<p>查询前两行和后两行为一组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(FSalary) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> FSalary <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> PRECEDING <span class="keyword">AND</span> <span class="number">2</span> FOLLOWING)  <span class="comment">-- 前二后二和</span></span><br></pre></td></tr></table></figure>
<p><img src="https://images2015.cnblogs.com/blog/702434/201704/702434-20170424155602225-1292657393.png" alt="img"></p>
<ol>
<li>按照FSalary进行排序，然后计算从当前行前两行（2 PRECEDING）到当前行后两行（2 FOLLOWING）的工资和</li>
<li>第一、第二条的“前两行”不存在，最后两行数据的“后两行”也不存在，因此计算时候按照前两行不存在进行计算，结果为空值NULL而非0</li>
</ol>
<p><strong>分类</strong></p>
<ol>
<li>专用窗口函数</li>
<li>聚合函数</li>
</ol>
<p><strong>专用窗口函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score,RANK<span class="operator">|</span>DENSE_RANK<span class="operator">|</span><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>([<span class="keyword">PARTITION</span> <span class="keyword">BY</span>] <span class="keyword">ORDER</span> <span class="keyword">BY</span> score)rank</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e49a844757feff3306d93f.jpg" alt></p>
<ul>
<li>RANK、DENSE_RANK、ROW_NUMBER使用时遇到重复字段的标号规则不同</li>
</ul>
<p><strong>特殊窗口函数</strong></p>
<p><strong>PERCENT_RANK</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score,<span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span>([<span class="keyword">PARTITION</span> <span class="keyword">BY</span>] <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>)percent_ranking</span><br><span class="line"><span class="keyword">FROM</span> practice_record</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e49c5a4757feff330b7e27.jpg" alt></p>
<ul>
<li>PERCENT_RANK会将排序后的标号均匀分布在[0,1]上</li>
<li>常用于查询有序下的前百分之几的数据</li>
</ul>
<p><strong>LEAD</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lead</span>(列名, 行数, 默认值) <span class="keyword">over</span> (		<span class="comment">-- 行数可省略，默认为1，默认值也可省略，默认为null</span></span><br><span class="line">    <span class="keyword">partition</span> <span class="keyword">by</span> 分组指定列</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> 排序指定列</span><br><span class="line">) 新列名 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先按照指定列分组，在每组内取<strong>该列</strong>该行下的<strong>第几行</strong>数据 作为新列在本行的数据，<strong>无法获取行下数据时再补充默认值</strong></p>
<p>和表的连接一样新增列</p>
<p>使用与查找与每一列都相关的数据，如第二天的相关数据</p>
</blockquote>
<p><strong>聚合函数作为窗口函数</strong></p>
<p>聚合函数后面括号不能为空，需要指定聚合的列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    score,</span><br><span class="line">    <span class="built_in">sum</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_sum,</span><br><span class="line">    <span class="built_in">avg</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_avg,</span><br><span class="line">    <span class="built_in">count</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_count,</span><br><span class="line">    <span class="built_in">max</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_max,</span><br><span class="line">    <span class="built_in">min</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_min</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	practice_record</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e4ad154757feff332cefa9.jpg" alt></p>
<ul>
<li>每组中，都是在自身数据及上方的数据范围使用聚合函数</li>
<li>可以看到截止本行数据，对于本行及以上的数据范围内的变化过程</li>
<li>使用聚合函数的显著特点就是分组排序后不改变列的行数</li>
</ul>
<h3><span id="暂存表">暂存表</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> 暂存表名 <span class="keyword">as</span>(</span><br><span class="line">	</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>无需重复书写 查找相同表的代码</li>
</ul>
<h3><span id="保留位数">保留位数</span></h3>
<p>小数点和保留位数</p>
<p><strong>ROUND</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ROUND(被操作数，保留小数点后几位数字)</span><br></pre></td></tr></table></figure>
<ol>
<li>四舍五入</li>
<li>保留位数</li>
</ol>
<p><strong>NUMERIC</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">numeric</span> (数据长度，小数点后位数)</span><br></pre></td></tr></table></figure>
<ol>
<li>与Decimal类似</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;12.56&#x27;</span> <span class="keyword">AS</span> <span class="type">NUMERIC</span>(<span class="number">10</span>,<span class="number">8</span>))<span class="comment">--==&gt;12.56000000 -- 小数点后位数最大为8</span></span><br></pre></td></tr></table></figure>
<p><strong>CAST</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CAST</span>(被操作数 <span class="keyword">AS</span> <span class="type">Decimal</span><span class="operator">|</span><span class="type">NUMERIC</span>(数据长度，小数点后位数))</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="string">&#x27;12.362222&#x27;</span> <span class="keyword">as</span>  <span class="type">decimal</span>(<span class="number">32</span>,<span class="number">3</span>))	<span class="comment">-- 》12.362 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;12&#x27;</span> <span class="keyword">AS</span> <span class="type">int</span>)<span class="comment">--&gt;12</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;12.0&#x27;</span> <span class="keyword">AS</span> <span class="type">int</span>)<span class="comment">--&gt;报错,double类型的字符串不能转成int</span></span><br></pre></td></tr></table></figure>
<p><strong>FLOOR</strong></p>
<p>FLOOR（x）返回小于等于x的最大整数（向下取整）</p>
<p><strong>CEILING</strong></p>
<p>CEILING（x）返回大于等于x的最小整数（向上取整）</p>
<h3><span id="其他">其他</span></h3>
<p><strong>UNION与UNION ALL</strong></p>
<p><strong>数据汇总</strong></p>
<p>COALESCE(expression_1, expression_2, …,expression_n)</p>
<ul>
<li>增加列，可用于数据汇总</li>
</ul>
<blockquote>
<p>依次参考各参数表达式，遇到非null值即停止并返回该值。</p>
<p>表达式为NULL时继续往下查询，不为NULL返回当前表达式的值</p>
</blockquote>
<p>WITH ROLLUP</p>
<ul>
<li>增加列，可用于数据汇总</li>
</ul>
<blockquote>
<p>定义在group by之后</p>
<p>对于聚合列相当于在分组前聚合，对于非聚合列相当于取最后一行的值，对于分组列设为NULL</p>
</blockquote>
<p>注意：低版本下使用WITH ROLLUP与COALESCE</p>
<p>若GROUP BY子句中不为数据库表中的列，而是经过运算存储在内存中的列</p>
<p>WITH ROLLUP会覆盖COALESCE中运算暂存列本来为NULL的值，导致COALESCE判断该表达式永远为非NULL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">COALESCE</span>(<span class="keyword">month</span>(submit_time))</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	practice_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	<span class="keyword">month</span>(submit_time) <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span> </span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e1c8b74757feff33b7067c.jpg" alt></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">COALESCE</span>(submit_month,<span class="string">&#x27;2021汇总&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		<span class="keyword">month</span>(submit_time) submit_month</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">			practice_record</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">			<span class="keyword">month</span>(submit_time) <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span> </span><br><span class="line">) a</span><br><span class="line"><span class="comment">-- 可以通过子查询解决WITHROLLUP覆盖COALESCE表达式NULL</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e1c9924757feff33b847fe.jpg" alt></p>
<h4><span id="mysql高版本">MySQL高版本</span></h4>
<p><strong>解决最新的SQL版本中ONLY_FULL_GROUP_BY报错</strong></p>
<blockquote>
<p>ONLY_FULL_GROUP_BY的语义就是确定select 中的所有列的值要么是来自于聚合函数（sum、avg、max等）的结果，</p>
<p>要么是来自于group by 子句中的表达式。</p>
<p>MySQL提供了any_value()函数来抑制ONLY_FULL_GROUP_BY值被拒绝。</p>
</blockquote>
<p>所以只需要在非group by的列上加any_value()就可以了</p>
<h2><span id="dml数据操作">DML数据操作</span></h2>
<h3><span id="添加数据">添加数据</span></h3>
<ol>
<li>
<p>普通插入（全字段）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>普通插入（限定字段）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1, value2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多条一次性插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从另一个表导入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name2 [<span class="keyword">WHERE</span> key<span class="operator">=</span><span class="keyword">value</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>带更新的插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (value1, value2, ...) </span><br><span class="line"><span class="comment">-- 注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>新表exam_record_before_2021用来备份2021年之前的试题作答记录，结构和exam_record表一致，请将2021年之前的已完成了的试题作答纪录导入到该表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span></span><br><span class="line">    exam_record_before_2021</span><br><span class="line">    (uid,exam_id,start_time,submit_time,score)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    uid,exam_id,start_time,submit_time,score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    exam_record</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    <span class="keyword">year</span>(submit_time) <span class="operator">&lt;</span> <span class="number">2021</span></span><br></pre></td></tr></table></figure>
<p>现在有一套ID为9003的高难度SQL试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表examination_info（其表结构如下图），不管该ID试卷是否存在，都要插入成功，请尝试插入它。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> </span><br><span class="line">    examination_info(exam_id,tag,difficulty,duration,release_time) <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">9003</span>, &quot;SQL&quot;, &quot;hard&quot;, <span class="number">90</span>, &quot;2021-01-01 00:00:00&quot;);</span><br></pre></td></tr></table></figure>
<h3><span id="修改数据">修改数据</span></h3>
<ol>
<li>
<p>设置为新值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column_name<span class="operator">=</span>new_value [, column_name2<span class="operator">=</span>new_value2] [<span class="keyword">WHERE</span> column_name3<span class="operator">=</span>value3]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据已有值替换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> key1<span class="operator">=</span>replace(key1, <span class="string">&#x27;查找内容&#x27;</span>, <span class="string">&#x27;替换成内容&#x27;</span>) [<span class="keyword">WHERE</span> column_name3<span class="operator">=</span>value3]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info</span><br><span class="line"><span class="keyword">set</span> tag <span class="operator">=</span> REPLACE(tag,<span class="string">&#x27;PYTHON&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info</span><br><span class="line"><span class="keyword">set</span> tag <span class="operator">=</span> REPLACE(tag,<span class="string">&#x27;PYTHON&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="删除数据">删除数据</span></h3>
<ol>
<li>
<p>根据条件删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> options] [ [ <span class="keyword">ORDER</span> <span class="keyword">BY</span> fields ] LIMIT n ]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>全部删除（表清空，包含自增计数器重置）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> table_name</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span></span><br><span class="line">    exam_record</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span></span><br><span class="line">    TIMESTAMPDIFF(<span class="keyword">MINUTE</span>,start_time,submit_time) <span class="operator">&lt;</span> <span class="number">5</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time</span><br><span class="line">LIMIT <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2><span id="ddl数据定义">DDL数据定义</span></h2>
<h3><span id="创建数据库">创建数据库</span></h3>
<h3><span id="创建数据库表格">创建数据库表格</span></h3>
<ol>
<li>直接创建表</li>
</ol>
   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">[IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] tb_name <span class="comment">-- 不存在才创建，存在就跳过</span></span><br><span class="line">(column_name1 data_type1 <span class="comment">-- 列名和类型必选</span></span><br><span class="line">    [ <span class="keyword">PRIMARY</span> KEY <span class="comment">-- 可选的约束，主键</span></span><br><span class="line">     <span class="operator">|</span><span class="keyword">FOREIGN</span> KEY <span class="comment">-- 外键，引用其他表的键值</span></span><br><span class="line">     <span class="operator">|</span>AUTO_INCREMENT <span class="comment">-- 自增ID</span></span><br><span class="line">     COMMENT comment <span class="comment">-- 列注释（评论）</span></span><br><span class="line">     <span class="keyword">DEFAULT</span> default_value <span class="comment">-- 默认值</span></span><br><span class="line">     <span class="keyword">UNIQUE</span> <span class="comment">-- 唯一性约束，不允许两条记录该列值相同</span></span><br><span class="line">     <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="comment">-- 该列非空</span></span><br><span class="line">    ], ...</span><br><span class="line">) [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset] <span class="comment">-- 字符集编码</span></span><br><span class="line">[<span class="keyword">COLLATE</span> collate_value] <span class="comment">-- 列排序和比较时的规则（是否区分大小写等）</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>从另一张表复制表结构创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">LIKE</span> tb_name_old</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从另一张表的查询结果创建表</p>
</li>
</ol>
   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_name_old <span class="keyword">WHERE</span> options</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> user_info_vip (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;自增ID&#x27;</span>,</span><br><span class="line">    uid <span class="type">int</span> <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    nick_name <span class="type">varchar</span>(<span class="number">64</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">    achievement <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;成就值&#x27;</span>,</span><br><span class="line">    `level` <span class="type">int</span> COMMENT <span class="string">&#x27;用户等级&#x27;</span>,</span><br><span class="line">    job <span class="type">varchar</span>(<span class="number">32</span>) COMMENT <span class="string">&#x27;职业方向&#x27;</span>,</span><br><span class="line">    register_time datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span></span><br><span class="line">) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
<h3><span id="修改数据库表格">修改数据库表格</span></h3>
<p><code>ALTER TABLE 表名 修改选项</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&#123; <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span> after <span class="operator">&lt;</span>位置<span class="operator">&gt;</span> <span class="comment">-- 增加列</span></span><br><span class="line"><span class="operator">|</span> CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>旧列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列类型<span class="operator">&gt;</span> <span class="comment">-- 修改列名或类型，直接替换为新列，以下均为修改某个属性</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> &#123; <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span> &#125; <span class="comment">-- 修改/删除 列的默认值</span></span><br><span class="line"><span class="operator">|</span> MODIFY <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span> <span class="comment">-- 修改列类型</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="comment">-- 删除列</span></span><br><span class="line"><span class="operator">|</span> RENAME <span class="keyword">TO</span> <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span> <span class="comment">-- 修改表名</span></span><br><span class="line"><span class="operator">|</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span> <span class="comment">-- 修改字符集</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span> &#125; <span class="comment">-- 修改校对规则（比较和排序时用到）</span></span><br></pre></td></tr></table></figure>
<h3><span id="删除数据库表格">删除数据库表格</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名<span class="number">1</span> [ ,表名<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3><span id="创建查询命令">创建查询命令</span></h3>
<h3><span id="修改查询命令">修改查询命令</span></h3>
<h3><span id="删除查询命令">删除查询命令</span></h3>
<h3><span id="删除数据表内容">删除数据表内容</span></h3>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>0-9 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>0-9 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1><span id="数据库面试题">数据库面试题</span></h1>
<hr>
<h2><span id="数据-数据库-数据库管理系统和数据库系统概念">数据、数据库、数据库管理系统和数据库系统概念?</span></h2>
<p><strong>数据</strong></p>
<ul>
<li>是数据库中存储的基本对象</li>
<li>在计算机中的概念是广义的，描述事物的符号记录称为数据</li>
<li>比如你手机里的音乐、文档和图形都是数据</li>
</ul>
<p><strong>数据库</strong></p>
<p>长期存储在计算机内，有组织、可共享的大量数据集合</p>
<p><strong>数据库管理系统</strong></p>
<p>位于用户与操作系统之间的一层数据管理软件，用来定义数据，管理数据</p>
<p><strong>数据库系统</strong></p>
<p>由数据、数据库、数据库管理系统（及其开发应用工具）、应用程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统</p>
<p>通常把它简称为数据库</p>
<hr>
<h2><span id="数据模型的分类有哪些">数据模型的分类有哪些？</span></h2>
<ul>
<li>物理模型：是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存储方法，是面向计算机系统的</li>
<li>概念模型：是现实世界到机器世界的一个中间层次，用于信息世界的建模，是现实世界到信息世界的第一层抽象</li>
<li>逻辑模型：按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。常用的逻辑模型主要有层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型和半结构化数据模型</li>
</ul>
<hr>
<h2><span id="概念模型中有一些基本术语">概念模型中有一些基本术语</span></h2>
<ul>
<li>实体：客观存在且可以相互区别的事物</li>
<li>属性：实体所具有的某一种特性</li>
<li>码：唯一表示实体的属性集</li>
<li>实体型：实体名及其属性名集合抽象成的同类实体</li>
<li>实体集：同一类型的实体集合</li>
<li>联系：事物之间和事物内部都具有联系（一对一、一对多、多对多）</li>
</ul>
<hr>
<h2><span id="简述关系型与非关系型数据库的区别">简述关系型与非关系型数据库的区别？</span></h2>
<p><strong>关系型数据库</strong></p>
<ul>
<li>依据关系模型来创建的数据库</li>
<li>关系模型就是“一对一”、“一对多”、“对多对”等</li>
<li>常见的关系型数据库有Oracle、MySQL、SQL Server等</li>
</ul>
<p><strong>非关系型数据库</strong></p>
<ul>
<li>基于“非关系型模型”</li>
<li>非关系型模型有：列模型、键值对模型、文档类模型。比如redis属于键值对模型</li>
</ul>
<hr>
<h2><span id="关系型数据库的优点和缺点">关系型数据库的优点和缺点？</span></h2>
<p><strong>优点</strong></p>
<ul>
<li>易于维护：都是使用表结构，格式一致。</li>
<li>使用方便：SQL语言通用，可用于复杂查询。</li>
<li>复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>读写性能比较差，尤其是海量数据的高效率读写。</li>
<li>固定的表结构，灵活度稍欠。</li>
<li>高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</li>
</ul>
<hr>
<h2><span id="非关系型数据库的优点和缺点">非关系型数据库的优点和缺点？</span></h2>
<p><strong>优点</strong></p>
<ul>
<li>格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</li>
<li>速度快：nosql可使用硬盘或者随机存储器作为载体，关系型数据库只能使用硬盘。</li>
<li>高拓展性</li>
<li>成本低：nosql数据库部署简单，基本都是开源软件。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不提供sql支持，学习和使用成本较高。</li>
<li>无事务处理</li>
<li>数据结构相对复杂，复杂查询方面稍欠。</li>
</ul>
<hr>
<h2><span id="e-r模型是什么">E-R模型是什么？</span></h2>
<p>使用E-R图来描述现实世界的概念模型，是描述概念模型的有力工具</p>
<hr>
<h2><span id="两个实体之间的关系">两个实体之间的关系？</span></h2>
<ul>
<li>1对1（1:1），比如一个客户只有一个会员卡，一个会员卡属于一个客户</li>
<li>1对多（1:n），比如一个系有多个班级，一个班级属于一个系</li>
<li>多对多（n:m） ，比如一个学生可以选修多门课程，一门课程可以支持多名同学参加</li>
</ul>
<hr>
<h2><span id="数据库设计三范式">数据库设计三范式？</span></h2>
<p>为了减少数据的冗余。但在实际的开发中，我们以满足客户的需求为目的，有的时候也会拿冗余来换取速度</p>
<ul>
<li>
<p>第一范式：每个表都应该有<strong>主键</strong>，并且<strong>每个字段要求原子性</strong>不可再分<br>
以下表存在可再分项（高级职称），所以不满足第一范式</p>
<p><img src="https://pic.imgdb.cn/item/663b87f00ea9cb1403db8c89.png" alt></p>
</li>
<li>
<p>第二范式：建立在第一范式基础之上，所有<strong>非主键字段必须完全依赖主键，不能产生部分依赖</strong><br>
举例如关系模型（职工号，姓名，职称，项目号，项目名称）中，职工号-&gt;姓名，职工号-&gt;职称，而项目号-&gt;项目名称。显然依赖关系不满足第二范式</p>
<p>常用的解决办法是差分表格，比如拆分为职工信息表和项目信息表</p>
</li>
<li>
<p>第三范式：建立在第二范式基础之上，所有<strong>非主键字段必须直接依赖主键，不能产生传递依赖</strong><br>
比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 --&gt; (院校地址，院校电话)。我们应该拆开来，如下：(学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p>
</li>
</ul>
<hr>
<h2><span id="mysql和oracle的区别">MySQL和Oracle的区别？</span></h2>
<ul>
<li>MySQL是一个轻量级的关系型数据库（开源），Oracle是一个重量级的关系型数据库（收费）</li>
<li>MySQL支持自增主键（auto increment），而Oracle支持序列</li>
<li>MySQL占内存小，Oracle占内存大</li>
<li>MySQL字符串用双引号，Oracle用单引号</li>
<li>MySQL分页用limit，Oacle使用rownum表名位置，而且只能用小于</li>
<li>MySQL用0、1判断真假，Oracle用true、false</li>
<li>MySQL的事务级别是repeatable read，oracle的事务隔离性是read committed</li>
</ul>
<hr>
<h2><span id="左连接-右连接-笛卡尔积-全连接和内连接的区别">左连接、右连接、笛卡尔积、全连接和内连接的区别?</span></h2>
<ul>
<li>左连接（左外连接）：以左表作为基准进行查询，左表数据会全部显示出来，右表如果和左表数据不匹配则显示为null。</li>
<li>右连接（右外连接）：以右表作为基准进行查询，右表数据会全部显示出来，左表如果和右表的数据不匹配则显示为null。</li>
<li>全连接：先以左表进行左外连接，再以右表进行右外连接。</li>
<li>内连接：显示表之间有连接匹配的所有行。</li>
<li>笛卡尔积也叫交叉连接</li>
</ul>
<hr>
<h2><span id="sql语言包括哪些类型">SQL语言包括哪些类型？</span></h2>
<ul>
<li>数据定义：Create Table,Alter Table,Drop/Truncate Table, Create/Drop Index</li>
<li>数据操纵：Select ,Insert,Update,Delete</li>
<li>数据控制：Grant,Revoke</li>
</ul>
<hr>
<h2><span id="sql-约束有哪几种">SQL 约束有哪几种？</span></h2>
<ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<hr>
<h2><span id="事务的概念">事务的概念？</span></h2>
<ul>
<li>事务是逻辑上的一组操作，要么都执行，要么都不执行</li>
<li>事务最经典的例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加</li>
</ul>
<hr>
<h2><span id="事务的特征">事务的特征？</span></h2>
<p>数据库事务transanction正确执行的四个基本要素ACID</p>
<ul>
<li>原子性(Atomicity)：事务是最小的执行单位，不允许分割。整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节</li>
<li>一致性(Correspondence)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏</li>
<li>隔离性(Isolation)：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</li>
<li>持久性(Durability)：在事务完成以后，该事务对数据库中数据的改变是持久的。即使数据库发生故障也不应该对其有任何影响</li>
</ul>
<hr>
<h2><span id="事务的隔离级别">事务的隔离级别？</span></h2>
<ul>
<li>数据库的隔离级别越高，并发性就越差，性能就越低</li>
<li>oracle的隔离级别默认是READ COMMITED；mysql的隔离级别默认是REPEATABLE READ，mysql下的事务默认是自动提交的</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>解决脏写</th>
<th>解决脏读</th>
<th>解决不可重复读</th>
<th>解决幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交 READ COMMITTED</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>读已提交 READ COMMITTED</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>可重复度 REPEATABLE READ</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>串行化 SERIALIZABLE</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<ul>
<li>读未提交：事务A在事务B未提交前读取数据，如果事务B撤销了修改，那么A会读取到脏数据。因为事务B提交前的数据在缓存中</li>
<li>读已提交：事务A分别在事务B提交前和提交后读取数据，出现不可重复读。因为事务B提交前的数据在缓存，事务B提交后的数据在硬盘，而事务A一直读取的都是硬盘的数据从而导致不能够重复读的问题</li>
<li>可重复读：事务A在事务B添加一条数据提交后，事务A读取记录数的时候不一致出现幻读。不可重复读的重点在于Update和Delete，而幻读在于Insert</li>
</ul>
<hr>
<h2><span id="并发事务带来的问题">并发事务带来的问题？</span></h2>
<p>在典型的应用程序中，如果多个事务并发运行可能会导致以下的问题</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动事务，查询得到值1</td>
<td>启动事务</td>
</tr>
<tr>
<td></td>
<td>查询得到值1</td>
</tr>
<tr>
<td></td>
<td>将1改成2</td>
</tr>
<tr>
<td>查询得到值v1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>提交事务B</td>
</tr>
<tr>
<td>查询得到值v2</td>
<td></td>
</tr>
<tr>
<td>提交事务A</td>
<td></td>
</tr>
<tr>
<td>查询得到值V3</td>
<td></td>
</tr>
</tbody>
</table>
<p>在不同的隔离级别下，V值分别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>读未提交</th>
<th>读已提交</th>
<th>可重复读</th>
<th>串行化</th>
</tr>
</thead>
<tbody>
<tr>
<td>V1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>V2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>V3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>与标准的SQL隔离级别不同的是，InnoDB在可重复读级别下，利用Next-Key Lock解决了幻读问题，能够完全保证事务的隔离性，达到了串行化级别</p>
<hr>
<h2><span id="索引的优缺点什么时候使用索引什么时候不能使用索引">索引的优缺点，什么时候使用索引，什么时候不能使用索引</span></h2>
<ul>
<li>索引最大的好处是提高查询速度</li>
<li>缺点是更新数据时效率低，因为要同时更新索引</li>
<li>对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引</li>
</ul>
<hr>
<h2><span id="简述什么是聚簇索引与非聚簇索引">简述什么是聚簇索引与非聚簇索引？</span></h2>
<ul>
<li>**聚簇索引：**将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>**非聚簇索引：**将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，MyISAM通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<hr>
<h2><span id="主键索引是聚集索引还是非聚集索引">主键索引是聚集索引还是非聚集索引？</span></h2>
<ul>
<li>聚集索引决定了数据库的物理存储结构，而主键只是确定表格逻辑组织方式。这两者不可混淆！</li>
<li>在InnoDB下主键索引是聚集索引，在MyISAM下主键索引是非聚集索引。</li>
</ul>
<hr>
<h2><span id="存储过程和函数的区别">存储过程和函数的区别？</span></h2>
<ul>
<li>存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程</li>
<li>而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表</li>
</ul>
<hr>
<h2><span id="什么是存储过程有哪些优缺点">什么是存储过程？有哪些优缺点？</span></h2>
<ul>
<li>用户定义的一系列sql语句的集合（给语句块定义一个名字，使用时调用即可）</li>
<li>优点：存储过程是一个预编译的代码块，执行效率比较高；存储过程在服务器端运行，减少客户端的压力；允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用；一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率；可以一定程度上确保数据安全</li>
<li>缺点：调试麻烦、可移植性不灵活、重新编译问题</li>
</ul>
<hr>
<h2><span id="什么是触发器触发器的使用场景有哪些">什么是触发器？触发器的使用场景有哪些？</span></h2>
<ul>
<li>触发器，指一段代码，当触发某个事件时，自动执行这些代码</li>
<li>使用场景：可以通过数据库中的相关表实现级联更改；实时监控某张表中的某个字段的更改而需要做出相应的处理</li>
</ul>
<hr>
<h2><span id="什么叫视图">什么叫视图？</span></h2>
<ul>
<li>视图是一种虚拟的表，具有和物理表相同的功能</li>
<li>可以对视图进行增，改，查，操作</li>
<li>视图通常是有一个表或者多个表的行或列的子集</li>
<li>对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询</li>
</ul>
<hr>
<h2><span id="什么是游标">什么是游标？</span></h2>
<ul>
<li>是对查询出来的结果集作为一个单元来有效的处理</li>
<li>游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改</li>
<li>需要逐条处理数据的时使用游标</li>
</ul>
<hr>
<h2><span id="视图的作用以及视图可以更新数据吗">视图的作用？以及视图可以更新数据吗？</span></h2>
<ul>
<li>使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据</li>
<li>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖</li>
<li>对于某些视图，例如，未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</li>
</ul>
<hr>
<h2><span id="什么是数据库连接池为什么需要数据库连接池呢">什么是数据库连接池?为什么需要数据库连接池呢?</span></h2>
<ul>
<li>数据库连接是一种关键的有限的昂贵的资源，对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序 的性能指标</li>
<li>数据库连接池正是针对这个问题提出来的，能明显提高对数据库操作的性能</li>
<li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</li>
<li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li>
<li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了 这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/post/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>一、Collectors.toList()<br>
  现在有个集合：</p>
<p>List<user> users = getUserList();<br>
1<br>
  现在需要将这些user的id提取出来。这个很简单，for循环嘛，谁不会啊（不会吧不会吧，不会有人还不会用for循环的吧）。</user></p>
<p>List<long> idList = new ArrayList<long>();</long></long></p>
<p>for(int i = 0; i &lt; users.size(); i++){</p>
<p>idList.add(users.get(i).getId());</p>
<p>}</p>
<p>然而Java8有个更简便的方法，一行代码搞定：</p>
<p>List<long> idList = users.stream().map(User::getId).collect(Collectors.toList());<br>
1<br>
其中有个User::getId，这个其实就是调用User类的getId()方法。</long></p>
<p>再举个例子，将集合里的元素由小写变大写：</p>
<p>List<string> list = Arrays.asList(“a”, “b”, “c”, “d”);</string></p>
<p>List<string> results = list.stream().map(String::toUpperCase).collect(Collectors.toList());</string></p>
<p>System.out.println(results); //{A, B, C, D}</p>
<p>二、Collectors.toMap()<br>
  Collectors.toMap()，一般用于将一个List转换为Map。常见用法：</p>
<p>list.stream().collect(Collectors.toMap(Function keyMapper, Function valueMapper))</p>
<p>可以接收2个、3个、4个参数，但是我一般只用2个的或者3个的就已经足够了。这里我也就只讲一个前两个用法，也就是2个参数的和3个参数的用法。</p>
<p>第一个参数，用于指定key的Function。<br>
  第二个参数，用于指定value的Function。<br>
  第三个参数，若在转换中，出现多个相同的key，如何进行合并的Function。</p>
<ol>
<li>两个参数的用法<br>
  现在有个User对象：</li>
</ol>
<p>@Getter<br>
@Setter<br>
public class User{<br>
private Long id;<br>
private String name;<br>
private Integer age;</p>
<pre><code>public User(Long id, String name, Integer age) &#123;
    this.id = id;
    this.name = name;
    this.age = age;
&#125;
</code></pre>
<p>}</p>
<p>然后进行以下操作：</p>
<p>List<user> userList = new ArrayList&lt;&gt;();<br>
userList.add(new User(1, “张三”, 18));<br>
userList.add(new User(2, “李四”, 19));<br>
userList.add(new User(3, “王五”, 18));<br>
//将userList转化为key为id，value为User对象的map<br>
Map&lt;Long, User&gt; map = userList.stream().collect(Collectors.toMap(User::getId, p -&gt; p));</user></p>
<p>Map&lt;Long, User&gt; map = userList.stream().collect(Collectors.toMap(User::getId, p -&gt; p));这一步就是将userList 转换为key为id，value为User对象的map。</p>
<p>User::getId ===》 User对象的getId方法<br>
p -&gt; p ===》就是进来的是什么，最终就是什么，这里就是进来的是User对象，出去的也就是User对象</p>
<p>而这时map里的（模拟）值是：</p>
<p>{<br>
1: User(1, “张三”, 18)<br>
2: User(2, “李四”, 19)<br>
3: User(3, “王五”, 18)<br>
}</p>
<p>还可以换一下：</p>
<p>Map&lt;Long, String&gt; map = userList.stream().collect(Collectors.toMap(User::getId, User::getName));<br>
1<br>
  这个获取的就是key为id，value为name的map了。</p>
<ol start="2">
<li>三个参数的用法<br>
  还是沿用上面那个例子，如果这个时候你想获取key是age，value是name的map呢？如果你还是沿用上面的方法，就会出问题了，因为有两个age是 18 的数据，也就是存在重复的key，会直接报错，想不报错的话，就可以利用第三个参数了。</li>
</ol>
<p>Map&lt;Integer, String&gt; map = userList.stream().collect(Collectors.toMap(User::getAge, User::getName, (a, b) -&gt; b));<br>
1<br>
  (a, b) -&gt; b的意思就是，如果存在重复的，永远取后面一个</p>
<p>这时，map里的值就是：</p>
<p>{<br>
18: “王五”<br>
19: “李四”<br>
}</p>
<p>三、Collectors.groupingBy()<br>
  还是沿用上面那个例子。当你想获取key是age的map，又不想覆盖掉重复项数据，这个时候就可以用 Collectors.groupingBy 了。</p>
<p>Map&lt;Integer, List<user>&gt; map = userList.stream().collect(Collectors.groupingBy(User::getAge));<br>
1<br>
  可以看到，这次的返回值变成了 Map&lt;Integer, List&gt; 了，也就是说，变成了key是age，value是User对象的集合了。这时，map里的值就变成了：</user></p>
<p>{<br>
18: [User(1, “张三”, 18), User(3, “王五”, 18)]<br>
19: [User(2, “李四”, 19)]<br>
}</p>
]]></content>
  </entry>
  <entry>
    <title>树</title>
    <url>/post/%E6%A0%91/</url>
    <content><![CDATA[<h1><span id="二叉排序树">二叉排序树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>也称二叉查找树，一棵空树，或者是具有下列特性的二叉树:</p>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值</li>
<li>左、右子树也分别是一棵二叉排序树</li>
</ol>
<p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值</p>
<p>对二叉排序树进行中序遍历可以得到一个递增的有序序列</p>
<h2><span id="操作">操作</span></h2>
<h3><span id="二叉树的结构">二叉树的结构</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="查找操作">查找操作</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="comment">//如果递归过程中T为空，则查找结果返回NULL；或者查找成功，返回指向该关键字的指针</span></span><br><span class="line">	<span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; T-&gt;data != key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data) T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBSTNode</span><span class="params">(BSTreee T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBSTNode(T-&gt;lchild,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBSTNode(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="插入操作">插入操作</span></h3>
<p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data == key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &gt; key) T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &lt; key) T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTree b = (BSTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BSTree));</span><br><span class="line">    b-&gt;data = key;</span><br><span class="line">    b-&gt;rchild = b-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T = b;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BSTree T,KeyType key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        BiTree b = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Bitree));</span><br><span class="line">        b-&gt;data = key;</span><br><span class="line">        b-&gt;lchild = b-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = b;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> InsertBST(T-&gt;lchild,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InsertBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="构建操作">构建操作</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    InsertBST(T,a[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3><span id="删除操作">删除操作</span></h3>
<ol>
<li>叶子结点：删除该结点不需要做其他操作；</li>
<li>仅有左或右子树的结点：删除后让被删除结点的直接后继接替它的位置；</li>
<li>左右子树都有的结点：遍历得到被删除结点的直接前驱或者直接后继来接替它的位置，然后再删除</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/63be79c8be43e0d30ec4aff5.jpg" alt></p>
<p>删除Z结点：</p>
<ol>
<li>用左孩子结点代替被删除结点，若该左孩子结点有右子树，则无法满足二叉排序树定义，没有右子树则直接替换，删除该元素</li>
<li>用左孩子的右孩子代替被删除的结点，若该节点有右子树，则无法满足二叉排序树定义</li>
<li>用左孩子的右孩子的右孩子的…右孩子的结点代替删除的结点，该节点没有右子树，代替可满足二叉排序树定义</li>
<li>且该节点有左子树或是叶子结点，删除同上述，由此得到直接前驱的概念</li>
</ol>
<ul>
<li>直接前驱：Z结点左孩子的右孩子的右孩子的…右孩子的结点，直到该节点没有右子树，即左子树中最右下的结点</li>
<li>直接后继：同理，是Z结点右子树中最坐下的结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> *<span class="title function_">DeleteBST</span><span class="params">(BSTNode *p)</span>&#123;</span><br><span class="line">    BSTree q,s;</span><br><span class="line">    <span class="keyword">if</span>(*p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; (*p)-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;   </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;    </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        q = *p;							<span class="comment">//递归更加直观</span></span><br><span class="line">        s = (*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q != *p)&#123;</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="comment">/*s = (*p)-&gt;lchild;</span></span><br><span class="line"><span class="comment">        while(s-&gt;rchild != NULL)&#123;</span></span><br><span class="line"><span class="comment">            s = s-&gt;rchild;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        (*p)-&gt;data = s-&gt;data;</span></span><br><span class="line"><span class="comment">        DeleteBST(s);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="查找效率">查找效率</span></h2>
<p>平均查找长度ASL（Average Search Length）：需要对比关键字的次数</p>
<ol>
<li>
<p>查找成功的ASL</p>
<img src="https://pic.imgdb.cn/item/63be996bbe43e0d30e01cf1e.jpg" style="zoom:50%;">
</li>
<li>
<p>查找失败的ASL</p>
<img src="https://pic.imgdb.cn/item/63be99b9be43e0d30e0272f7.jpg" style="zoom:50%;">
</li>
</ol>
<h2><span id="引申出平衡二叉树">引申出平衡二叉树</span></h2>
<p>二叉排序树的优点明显，插入删除的时间性能比较好。</p>
<p>而对于二叉排序树的查找，其比较次数等于给定值的结点在二叉排序树的层数，即树的高</p>
<p>最好情况：n个结点的二叉树最小高度为 log<sub>2</sub>n（向下取整）+1</p>
<p>最坏情况：每个结点1个分支，树高=节点数=n</p>
<p>也就是说，我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，那么查找的时间复杂也就为O(logn)，近似于折半查找</p>
<h1><span id="平衡二叉树">平衡二叉树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>平衡二叉树(AVL)是一种二叉排序树，其中每一个节点的左子树和右子树的高度差不超过1</p>
<p>结点的平衡因子：二叉树上结点的左子树深度减去右子树深度的值称为平衡因子</p>
<p>平衡二叉树上所有结点的平衡因子只能是-1、0和1</p>
<p>假设n<sub>h</sub>为深度为h的平衡树中含有的最少结点数，n<sub>0</sub>=0，n<sub>1</sub>=1，n<sub>2</sub>= 2 ，平衡二叉树中有n<sub>h</sub> = n<sub>h-1</sub> + n<sub>h-2</sub> +1可证明最大深度和平均查找长度O(long<sub>2</sub>n)</p>
<h2><span id="操作">操作</span></h2>
<h3><span id="平衡二叉树的结构">平衡二叉树的结构</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">rchild</span>, *<span class="title">lchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure>
<h3><span id="查找操作">查找操作</span></h3>
<h3><span id="插入操作">插入操作</span></h3>
<p>当我们在二叉排序树中插入(或删除)一个结点时，可能导致其插入路径上的结点不平衡（平衡因子绝对值大于1）</p>
<p>若导致了不平衡，须将最小不平衡子树调整平衡，则其他结点都会恢复平衡</p>
<p>最小不平衡子树：从插入结点王辉找到第一个不平衡结点，以该结点为根的子树</p>
<h4><span id="ll平衡旋转右单旋转">LL平衡旋转(右单旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea349be43e0d30e12a52e.jpg" alt></p>
<p>在结点A的左孩子(L)的左子树(L)上插入了新结点</p>
<p>将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树</p>
<h4><span id="rr平衡旋转左单旋转">RR平衡旋转(左单旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bf666ebe43e0d30e2ce419.jpg" alt="image-20230111195440307"></p>
<p>在结点A的右孩子®的右子树®上插入了新结点</p>
<p>将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树</p>
<h4><span id="lr平衡旋转先左后右双旋转">LR平衡旋转(先左后右双旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea837be43e0d30e1d7d44.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63bea87abe43e0d30e1ddaf3.jpg" alt></p>
<p>在A的左孩子(L)的右子树®上插入新结点</p>
<p>先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置,即进行一次RR平衡旋转(左单旋转），然后再把该C结点向右上旋转提升到A结点的位置,即进行一次LL平衡旋转(右单旋转)</p>
<h4><span id="rl平衡旋转先右后左双旋转">RL平衡旋转(先右后左双旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea8b2be43e0d30e1e2b37.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63bea8ddbe43e0d30e1e681a.jpg" alt></p>
<p>在A的右孩子®的左子树(L)上插入新结点</p>
<p>先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置,即进行一次LL平衡旋转(右单旋转)，然后再把该C结点向左上旋转提升到A结点的位置,即进行一次RR平衡旋转(左单旋转)</p>
<p>新结点插入C的左子树还是插入C的右子树不影响旋转过程</p>
<p><img src="https://pic.imgdb.cn/item/63beaaafbe43e0d30e2182c7.jpg" alt></p>
<ul>
<li>插入操作导致的最小不平衡子树（此时插入前平衡）：高度加1，经过调整后最小不平衡子树的高度恢复，从而其祖先结点也恢复</li>
</ul>
<h2><span id="查找效率">查找效率</span></h2>
<ul>
<li>若树高为h，最坏情况下，查找一个关键字最多需要比较h次，即查找操作的时间复杂度不可能超过O(h)</li>
</ul>
<h1><span id="红黑树">红黑树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>红黑树也是二叉排序树，与普通BST相比：左根右，根叶黑 ，不红红，黑路同，左子孙结点值小于根节点值小于右子孙结点值</p>
<ol>
<li>每个结点或是红色，或是黑色的</li>
<li>根节点是黑色的</li>
<li>叶结点（外部结点、NULL结点、失败结点）均是黑色的</li>
<li>不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</li>
<li>对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</li>
</ol>
<ul>
<li>平衡二叉树 AVL：插入/删除 很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不 平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行 LL/RR/LR/RL 调整</li>
<li>红黑树 RBT：插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一 般都可以在常数级时间内完成 平衡二叉树：适用于以查为主、很少插入/删除的场景 红黑树：适用于频繁插入、删除的场景，实用性更强 性能逐渐优秀</li>
</ul>
<h2><span id="红黑树的结构">红黑树的结构</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    RBNode* parent;</span><br><span class="line">    RBNode* lchild;</span><br><span class="line">    RBNode* rchild;</span><br><span class="line">    <span class="type">int</span> color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="性质">性质</span></h2>
<ol>
<li>结点的黑高（bh）：从某结点出发（<strong>不含该节点</strong>）到达任一<strong>空叶结点</strong>的<strong>路径上黑结点总数</strong></li>
<li>从根节点到叶结点的最长路径不大于最短路径的2倍</li>
<li>有n个内部节点的红黑树高度 h ≤ 2log<sub>2</sub>(n+1)</li>
<li>查找效率与AVL 树同等数量级 红黑树查找操作时间复杂度 = O(log<sub>2</sub>n)</li>
</ol>
<h2><span id="操作">操作</span></h2>
<h3><span id="插入操作java">插入操作（java）</span></h3>
<ol>
<li>
<p>先查找，确定插入位置（原理同二叉排序树），插入新结点</p>
</li>
<li>
<p>新结点是根——染为黑色</p>
<img src="https://pic.imgdb.cn/item/63d4df2dface21e9efde7f4d.jpg" style="zoom:67%;">
</li>
<li>
<p>新结点非根——染为红色</p>
<img src="https://pic.imgdb.cn/item/63d4df0aface21e9efde2e14.jpg" style="zoom:67%;">
</li>
<li>
<p>若插入新结点后依然满足红黑树定义，则插入结束，若不满足红黑树定义，则通过叔叔结点的颜色调整</p>
<ol>
<li>
<p>黑叔：旋转+染色</p>
<ol>
<li>
<p>LL型：右单旋，父换爷+染色</p>
<p><img src="https://pic.imgdb.cn/item/63d4df9fface21e9efdf9503.jpg" alt></p>
</li>
<li>
<p>RR型：左单旋，父换爷+染色</p>
</li>
<li>
<p>LR型：左、右双旋，儿换爷+染色</p>
<p><img src="https://pic.imgdb.cn/item/63d4df60face21e9efdeef6c.jpg" alt></p>
</li>
<li>
<p>RL型：右、左双旋，儿换爷+染色</p>
</li>
</ol>
</li>
<li>
<p>红叔：染色+变新</p>
<ol>
<li>
<p>叔父爷染色，爷变为新结点</p>
<p><img src="https://pic.imgdb.cn/item/63d4deedface21e9efdde5f1.jpg" alt></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;	<span class="comment">//获取根结点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;	<span class="comment">//遍历树结点</span></span><br><span class="line">        <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)	<span class="comment">//插入左子树</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)	<span class="comment">//插入右子树</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))	<span class="comment">//键key相等</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));	<span class="comment">//插入平衡</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="构建操作java">构建操作（java）</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;		<span class="comment">//构建红黑树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;	<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;	<span class="comment">//遍历结点数组</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;	<span class="comment">//将结点转换成树结点</span></span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;	<span class="comment">//初始化根节点</span></span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;	<span class="comment">//遍历红黑树，找到结点要插入的位置</span></span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)		<span class="comment">//当前结点的哈希小于树节点的哈希，往左子树中查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)		<span class="comment">//当前结点的哈希大于树节点的哈希，往右子树中查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;		<span class="comment">//当前结点与树结点的哈希相等</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;	<span class="comment">//插入当前结点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);	<span class="comment">//插入后的平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.red = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//xp：父节点	 xpp：爷结点	xppl：爷结点的左孩子	xppr：爷结点的右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;	<span class="comment">//根节点</span></span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)	<span class="comment">//父节点为黑或爷结点为空</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;	<span class="comment">//父节点为左孩子</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;	<span class="comment">//爷结点的右孩子不为空且为红色（叔为红）</span></span><br><span class="line">                xppr.red = <span class="literal">false</span>;	<span class="comment">//叔父爷染色，爷结点作为新结点</span></span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;					<span class="comment">//爷结点的右孩子为空或黑色（叔为黑）</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;	<span class="comment">//lr类型</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);	<span class="comment">//左旋</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;		<span class="comment">//ll</span></span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);	<span class="comment">//右旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;							<span class="comment">//父节点为右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;		<span class="comment">//爷结点的左孩子不为空且为红色（叔为红）</span></span><br><span class="line">                xppl.red = <span class="literal">false</span>;	<span class="comment">//叔父爷染色，爷结点作为新结点</span></span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;				<span class="comment">//爷结点的左孩子为空或黑色（叔为黑）</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/63d5054aface21e9ef34ef9e.jpg" style="zoom:67%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="comment">//r：p的右结点	rl：p的右结点的左结点</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)	<span class="comment">//处理r的左孩子</span></span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)	<span class="comment">//将p左旋</span></span><br><span class="line">            (root = r).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/63d506efface21e9ef38ae81.jpg" style="zoom:67%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            (root = l).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除操作java">删除操作（java）</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment"> * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment"> * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment"> * successor that is pinned by &quot;next&quot; pointers that are accessible</span></span><br><span class="line"><span class="comment"> * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment"> * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment"> * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment"> * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="literal">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="literal">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.right == <span class="literal">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="literal">null</span> || rl.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="literal">null</span> &amp;&amp; pr != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="literal">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="literal">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="literal">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="literal">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="literal">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="literal">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="literal">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多</p>
<p><img src="https://pic.imgdb.cn/item/63bf6956be43e0d30e315a52.jpg" alt="不严格平衡的红黑树"></p>
<p>​    <strong>Answer 1：</strong></p>
<ol>
<li>
<p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p>
</li>
<li>
<p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p>
</li>
<li>
<p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p>
</li>
<li>
<p>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多</p>
</li>
<li>
<p>功能、性能、空间开销的折中结果。<br>
AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。<br>
红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。</p>
<p><strong>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</strong></p>
</li>
</ol>
<p>​    <strong>1 好处 及 用途</strong></p>
<p>​    红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。</p>
<p>​    红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。当然，还有一些更好的，但实现起来更复杂的<a href="http://lib.csdn.net/base/datastructure">数据结构</a> 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的<a href="http://lib.csdn.net/base/datastructure">算法</a>时间复杂度和AVL相同，但统计性能比AVL树更高。</p>
<p>​    当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>​     在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。</p>
<p>​     典型的用途是实现关联数组</p>
<p>​    <strong>2. AVL树是最先发明的自平衡二叉查找树。</strong></p>
<p>​    在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。引入二叉树的目的是为了提高二叉树的搜索的效率, 减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度.</p>
<p>​    AVL树的定义:<br>
​    一棵AVL树满足以下的条件:<br>
​    1&gt;它的左子树和右子树都是AVL树<br>
​    2&gt;左子树和右子树的高度差不能超过1<br>
​    从条件1可能看出是个递归定义,如GNU一样.</p>
<p>​    性质:<br>
​    1&gt;一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1)<br>
​    2&gt;一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)).<br>
​    3&gt;一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).</p>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>校验注解</title>
    <url>/post/%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2><span id="导入依赖">导入依赖</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bval<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bval-jsr<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringBoot依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--继承父模块中的依赖：数据校验--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用以下注解时，必须在控制层的参数加上@Valid才能生效</p>
<h2><span id="notnull">@NotNull</span></h2>
<ul>
<li>不能为 null，但可以为 empty</li>
<li>一般用在 Integer 类型的基本数据类型的非空校验上，而且被其标注的字段可以使用 @size、@Max、@Min 对字段数值进行大小的控制</li>
<li>一个 BigDecimal 的字段使用字段校验标签应该为 @NotNull</li>
</ul>
<h2><span id="notempty">@NotEmpty</span></h2>
<ul>
<li>不能为 null，且长度必须大于 0</li>
<li>一般用在集合类上或者数组上</li>
</ul>
<h2><span id="notblank">@NotBlank</span></h2>
<ul>
<li>只能作用在接收的 String 类型上，不能为 null，而且调用 trim() 后，长度必须大于 0即：必须有实际字符</li>
</ul>
<h2><span id="size">@Size</span></h2>
<p>一般用在 String 类型上可对字段数值进行最大长度限制的控制</p>
<h2><span id="max-min">@Max @Min</span></h2>
<p>一般用在 Integer 类型上可对字段数值进行大小范围的控制</p>
<table>
<thead>
<tr>
<th></th>
<th>@NotNull</th>
<th>@NotEmpty</th>
<th>@NotBlank</th>
</tr>
</thead>
<tbody>
<tr>
<td>String name = null;</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>String name = “”;</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>String name = &quot; &quot;;</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String name = “Hello World！”;</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
<h2><span id="常用的校验注解">常用的校验注解</span></h2>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>限制只能为null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>限制必须不能为null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>限制必须为true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>限制必须为false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被限制的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被限制的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max,min)</td>
<td>限制字符长度必须在min到max的指定范围内</td>
</tr>
<tr>
<td>@Digits(integer,fraction)</td>
<td>限制必须为一个小数，且整数部分的位数不能超过integer、小数部分的位数不能超过fraction的在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被限制的元素(日期类型)必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被限制的元素(日期类型)必须是一个将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>限制必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Email</td>
<td>被限制的元素值为是电子邮件地址，也可以通过正则表达式和flag指定自定义的email</td>
</tr>
<tr>
<td>@Length</td>
<td>被限制的字符串的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被限制的字符串必须非空(不为null且不为空)</td>
</tr>
<tr>
<td>@Range</td>
<td>被限制的元素必须在合适的范围内</td>
</tr>
<tr>
<td>@JsonFormat</td>
<td>使用 @JsonFormat 注解时，查到的时间可能会比数据库中的时间少八个小时，这是由于时区差引起的，JsonFormat 默认的时区是 Greenwich Time， 默认的是格林威治时间，而我们是在东八区上，所以时间会比实际我们想得到的时间少八个小时。需要在后面加上一个时区:@JsonFormat(pattern=“yyyy-MM-dd”,timezone=“GMT+8”) private Date date;</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>类加载的初始化顺序</title>
    <url>/post/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2><span id="静态代码块">静态代码块</span></h2>
<ul>
<li>
<p>随着类的加载而运行，只执行一次</p>
</li>
<li>
<p>当出现多个静态代码块(包括静态属性赋值）时，按顺序执行</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(Order.i);		<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="构造代码块">构造代码块</span></h2>
<ul>
<li>随着对象的创建而运行，且先于构造函数的执行</li>
<li>有多个构造代码块时，也按顺序执行</li>
</ul>
<h2><span id="构造器">构造器</span></h2>
<ul>
<li>与类名同名的，通过new运算符来新建一个类的实例的函数。可以同时拥有多个不同参数类型顺序的构造器</li>
<li>当未定义任何构造器时，编译器会默认提供一个无参的构造器</li>
</ul>
<span id="more"></span>
<h2><span id="执行顺序">执行顺序</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Order();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">静态代码块</span><br><span class="line">构造代码块</span><br><span class="line">构造器</span><br><span class="line">===============</span><br><span class="line">构造代码块</span><br><span class="line">构造器</span><br></pre></td></tr></table></figure>
<p>可以看出</p>
<ol>
<li>静态代码块&gt;&gt;构造代码块&gt;&gt;构造器</li>
<li>不管new几次对象，静态代码块都只执行一次，而构造代码块和构造器每次创建对象时都会执行</li>
</ol>
<h2><span id="继承的情况">继承的情况</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Inheritance</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> GrandChild();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> GrandChild();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Child</span> <span class="title">extends</span> <span class="title">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GrandChild</span> <span class="title">extends</span> <span class="title">Child</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GrandChild()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">父类的静态代码块</span><br><span class="line">子类的静态代码块</span><br><span class="line">孙子类的静态代码块</span><br><span class="line">父类的构造代码块</span><br><span class="line">父类的构造器</span><br><span class="line">子类的构造代码块</span><br><span class="line">子类的构造器</span><br><span class="line">孙子类的构造代码块</span><br><span class="line">孙子类的构造器</span><br><span class="line">===============</span><br><span class="line">父类的构造代码块</span><br><span class="line">父类的构造器</span><br><span class="line">子类的构造代码块</span><br><span class="line">子类的构造器</span><br><span class="line">孙子类的构造代码块</span><br><span class="line">孙子类的构造器</span><br></pre></td></tr></table></figure>
<h3><span id="子类对象实例化过程">子类对象实例化过程</span></h3>
<ol>
<li>
<p>首先不断向上查找直至到达顶层父类Object，然后不断向下依次调用父类的构造器进行父特征的初始化</p>
</li>
<li>
<p>然后向下依次执行静态代码块（静态代码块随着类的加载执行且执行一次，再次创建对象无需加载类）</p>
</li>
<li>
<p>接着依次创建对象，依次执行构造代码块、构造器</p>
</li>
<li>
<p>直到创建完所有子类对象</p>
<p><a href="../super/#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">若父类定义了有参构造器而没定义无参构造器，此时子类的构造器会报错</a></p>
</li>
</ol>
<h2><span id="静态内部类">静态内部类</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticInnerClass</span>&#123;</span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的构造器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的静态代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的构造代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span>()</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">class</span> <span class="title">InnerClass</span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;实例内部类的构造器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*static void testMethod()&#123;					//编译报错</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;实例内部类静态方法&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        static&#123;									   //编译报错</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;实例内部类静态代码块&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;实例内部类的构造代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="外部类执行顺序">外部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类构造代码块</span><br><span class="line">外部类构造器</span><br></pre></td></tr></table></figure>
<h3><span id="外部类静态方法执行顺序">外部类静态方法执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.testMethod();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类静态方法</span><br></pre></td></tr></table></figure>
<ul>
<li>执行静态方法时，先加载类和静态代码块</li>
<li>不创建类实例对象，直接访问静态方法</li>
</ul>
<h3><span id="静态内部类执行顺序">静态内部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticInnerClass();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">静态内部类的静态代码块</span><br><span class="line">静态内部类的构造代码块</span><br><span class="line">静态内部类的构造器</span><br></pre></td></tr></table></figure>
<ul>
<li>首先加载外部类以及外部类静态代码块，但没有创建外部类实例对象</li>
<li>接着顺序执行构造静态内部类实例对象</li>
</ul>
<h3><span id="静态内部类静态方法执行顺序">静态内部类静态方法执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.StaticInnerClass.testMethod();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">静态内部类的静态代码块</span><br><span class="line">静态内部类的静态方法</span><br></pre></td></tr></table></figure>
<ul>
<li>同样加载了外部类及外部类静态代码块，但没有创建外部类实例对象</li>
<li>加载了当前内部类及静态代码块，但没有创建内部类实例对象</li>
</ul>
<h3><span id="实例内部类执行顺序">实例内部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类构造代码块</span><br><span class="line">外部类构造器</span><br><span class="line">实例内部类的构造代码块</span><br><span class="line">实例内部类的构造器</span><br></pre></td></tr></table></figure>
<ul>
<li>先后创建了外部类、内部类的实例对象</li>
</ul>
<p><strong>结论</strong>：<br>
静态内部类并不会随着外部类的初始化而被初始化，而是当静态内部类的方法被调用时，静态内部类才被初始化。反之，静态内部类被调用时，仅加载了外部类及外部类静态代码块，并没有创建外部类实例对象</p>
<table>
<thead>
<tr>
<th></th>
<th>类的执行顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>不含继承关系、不含内部类</td>
<td>静态代码块&gt;&gt;构造代码块&gt;&gt;构造器，静态代码块随类的加载只执行一次</td>
</tr>
<tr>
<td>含继承关系</td>
<td>访问子类对象时，从上向下依次加载类和静态代码块，再依次创建对象（构造代码块&gt;&gt;构造器）</td>
</tr>
<tr>
<td>含内部类</td>
<td>访问内部类对象时，无论静态或非静态，都先加载外部类及外部类静态代码块，不创建外部实例对象，然后创建内部类对象</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot统一异常处理与信息返回</title>
    <url>/post/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E8%BF%94%E5%9B%9E/</url>
    <content><![CDATA[<h2><span id="异常处理">异常处理</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(value = &#123;Exception.class&#125;)</span><span class="comment">//value=&#123;&#125;可省略</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Resp&lt;T&gt; <span class="title function_">exceptionHandler</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//这里先判断拦截到的Exception是不是我们自定义的异常类型</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> AppException)&#123;</span><br><span class="line">            <span class="type">AppException</span> <span class="variable">appException</span> <span class="operator">=</span> (AppException)e;</span><br><span class="line">            <span class="keyword">return</span> Resp.error(appException.getCode(),appException.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果拦截的异常不是我们自定义的异常(例如：数据库主键冲突)</span></span><br><span class="line">        <span class="keyword">return</span> Resp.error(<span class="number">500</span>,<span class="string">&quot;服务器端异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Resp&lt;String&gt; <span class="title function_">demo1</span><span class="params">(String name)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;ok&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> Resp.success(<span class="string">&quot;succ&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;err&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="comment">//抛业务相关的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(AppExceptionCodeMsg.USERNAME_NOT_EXISTS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;errcode&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(AppExceptionCodeMsg.INVALID_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;0&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查用户积分是否足够，如果不够，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;notenough&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(AppExceptionCodeMsg.USER_CREDIT_NOT_ENOUTH);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Resp.success(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Resp&lt;List&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Resp.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="信息返回">信息返回</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resp</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端返回的错误码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//服务端返回的错误信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="comment">//我们服务端返回的数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Resp</span><span class="params">(<span class="type">int</span> code,String msg,T data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">success</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(<span class="number">200</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">success</span><span class="params">(String msg,T data)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(<span class="number">200</span>,msg, data);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">error</span><span class="params">(AppExceptionCodeMsg appExceptionCodeMsg)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(appExceptionCodeMsg.getCode(), appExceptionCodeMsg.getMsg(), <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">error</span><span class="params">(<span class="type">int</span> code,String msg)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(code,msg, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="枚举">枚举</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个枚举类中定义的都是跟业务有关的异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AppExceptionCodeMsg</span> &#123;</span><br><span class="line"></span><br><span class="line">    INVALID_CODE(<span class="number">10000</span>,<span class="string">&quot;验证码无效&quot;</span>),</span><br><span class="line">    USERNAME_NOT_EXISTS(<span class="number">10001</span>,<span class="string">&quot;用户名不存在&quot;</span>),</span><br><span class="line">    USER_CREDIT_NOT_ENOUTH(<span class="number">10002</span>,<span class="string">&quot;用户积分不足&quot;</span>);</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code ;</span><br><span class="line">    <span class="keyword">private</span> String msg ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    AppExceptionCodeMsg(<span class="type">int</span> code, String msg)&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="自定义异常类">自定义异常类</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;服务器异常&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(AppExceptionCodeMsg appExceptionCodeMsg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.code = appExceptionCodeMsg.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = appExceptionCodeMsg.getMsg();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(<span class="type">int</span> code,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id></span></h2>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>编码与数制</title>
    <url>/post/%E7%BC%96%E7%A0%81%E4%B8%8E%E6%95%B0%E5%88%B6/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>1、2、3、4……，我们从小便学习这么计数，并使用到现在。但是这样的计数方式从何而来呢？又如何发展成如今计算机的计数方式？</p>
<span id="more"></span>
<p>罗马人从使用手指计数到在羊皮上画出Ⅰ、Ⅱ、Ⅲ来代替手指的字符，他们定义出了能够表示不同个数的符号，并随后引出了X(十)、C(百)、(M)千等等符号。随着要表示的数量越来越多，他们不得不引出更多的符号。</p>
<p>印度人发明了如今成为国际通用的阿拉伯数字，与罗马人的计数方式相比，阿拉伯数字不需要不断引出新的符号，而是用数字的位置来表示，高位在左，低位在右，传入欧洲后，加上逢十进一，演变成如今人们使用的数字计数，即十进制计数法（D)。</p>
<h1><span id="进位计数法">进位计数法</span></h1>
<h2><span id="r进制计数法">r进制计数法</span></h2>
<p>r进制计数法是从十进制计数法中抽象出来的概念，r可以表示任何整数，逢r进一</p>
<p>相比于传统计数方法，r进制计数法</p>
<ul>
<li>
<p>利用了数字位置的信息</p>
<p>每个数位表示不同的常数，第0位表示r<sup>0</sup>,第1位表示r<sup>1</sup>……</p>
<p>（从0开始）第i位表示r<sup>i</sup>，r<sup>i</sup>就是第i位的<strong>位权</strong></p>
</li>
<li>
<p>每个数位使用r种不同数码</p>
<p>r就是<strong>基数</strong></p>
<p>真实的数字 = 累加 （每个数位的数字	乘以	该位的位权）</p>
<blockquote>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
</li>
</ul>
<h2><span id="二进制计数法">二进制计数法</span></h2>
<p>在计算机中使用高电平和低电平两种稳定状态的电子器件，因而使用二进制来表示计算机中的数据</p>
<p>二进制中的1、0对应了逻辑中的真、假，为逻辑运算提供便利条件</p>
<p>常用的还有<strong>八进制计数法（O）、十六进制计数法（H）</strong></p>
<h1><span id="不同进制间的转换">不同进制间的转换</span></h1>
<p>为了深入了解不同进制表示的数据，还需分析不同进制间的转换</p>
<h2><span id="任意进制-gt-十进制">任意进制 -&gt; 十进制</span></h2>
<h3><span id="按权展开相加法">按权展开相加法</span></h3>
<p>累加 （每个数位的数字	乘以	该位的位权）</p>
<h2><span id="二进制-gt-八进制-十六进制">二进制 -&gt; 八进制 、十六进制</span></h2>
<ul>
<li>二进制的3个数位最多能表示8个数字</li>
<li>二进制的4个数位最多能表示16个数字</li>
</ul>
<p>二进制 -&gt; 八进制 ：</p>
<ol>
<li>小数点左边：3位1组-&gt;最左边补0凑3位</li>
<li>小数点右边：3位1组-&gt;最右边补0凑3位</li>
<li>每组转化成八进制数</li>
</ol>
<p>二进制 -&gt; 十六进制：</p>
<ol>
<li>小数点左边：4位1组-&gt;最左边补0凑4位</li>
<li>小数点右边：4位1组-&gt;最右边补0凑4位</li>
<li>每组转化成十六进制数</li>
</ol>
<h2><span id="八进制-十六进制-gt-二进制">八进制 、十六进制 -&gt; 二进制</span></h2>
<p>八进制 -&gt; 二进制 ：1位 -&gt; 3位二进制数</p>
<p>十六进制 -&gt; 二进制：1位 -&gt; 4位二进制数</p>
<p>最后去掉最高位最小位的0</p>
<h2><span id="八进制-gt-十六进制">八进制 -&gt; 十六进制</span></h2>
<p>以二进制为桥梁  八进制-&gt;二进制-&gt;十六进制</p>
<h2><span id="十进制-gt-二进制">十进制 -&gt; 二进制</span></h2>
<h3><span id="基数乘除法">基数乘除法</span></h3>
<p>进位计数法有效利用了数码的位置信息，如何借助数字位置信息实现进制转换呢？</p>
<blockquote>
<p>对于一个r进制数：K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
<p>乘以基数r</p>
<blockquote>
<p>r*(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)</p>
<p>=r*(K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)</p>
<p>=K<sub>n</sub>*r<sup>n+1</sup>+K<sub>n-1</sub>*r<sup>n</sup>+…+K<sub>2</sub>*r<sup>3</sup>+K<sub>1</sub>*r<sup>2</sup>+K<sub>0</sub>*r<sup>1</sup>+K<sub>-1</sub>*r<sup>0</sup>+K<sub>-2</sub>*r<sup>-1</sup>+…+K<sub>-m</sub>*r<sup>-m+1</sup>+0*r<sup>m</sup></p>
<p>=K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>0</p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生左移，并在最右边一位补0</p>
<p>除以基数r</p>
<blockquote>
<p>(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)\r</p>
<p>= (K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)\r</p>
<p>=0*r<sup>n</sup>+K<sub>n</sub>*r<sup>n-1</sup>+K<sub>n-1</sub>*r<sup>n</sup>-2+…+K<sub>2</sub>*r<sup>1</sup>+K<sub>1</sub>*r<sup>0</sup>+K<sub>0</sub>*r<sup>-1</sup>+K<sub>-1</sub>*r<sup>-2</sup>+K<sub>-2</sub>*r<sup>-3</sup>+…+K<sub>-m</sub>*r<sup>-m-1</sup></p>
<p>=0K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生右移，并在最左边一位补0</p>
<table>
<thead>
<tr>
<th></th>
<th>第n+1位</th>
<th>第n位</th>
<th>第n-1位</th>
<th>…</th>
<th>第2位</th>
<th>第1位</th>
<th>第0位</th>
<th>第-1位</th>
<th>…</th>
<th>第-(m-1)</th>
<th>第-m位</th>
<th>第-(m+1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>原数</td>
<td></td>
<td>Kn</td>
<td>Kn-1</td>
<td>…</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>…</td>
<td>K-(m-1)</td>
<td>K-m</td>
<td></td>
</tr>
<tr>
<td>乘以基数r</td>
<td>Kn</td>
<td>Kn-1</td>
<td>Kn-2</td>
<td>…</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>K-2</td>
<td>…</td>
<td>K-m</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>除以基数r</td>
<td></td>
<td>0</td>
<td>Kn</td>
<td>…</td>
<td>K3</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>…</td>
<td>K-(m-2)</td>
<td>K-(m-1)</td>
<td>K-m</td>
</tr>
</tbody>
</table>
<h4><span id="对于整数除基取余法">对于整数：除基取余法</span></h4>
<p>将数字除以基数，相当于右移了数字，小数点右边的为余数，先除得的余数为低位，即二进制的最低位</p>
<p>继续将商除以基数，继续右移，直到商为0，后除得的余数为高位</p>
<p><strong>除基取余，先余为低，后余为高，商0结束</strong></p>
<h4><span id="对于小数乘基取整法">对于小数：乘基取整法</span></h4>
<p>将数字乘以基数，相当于左移了数字，小数点左边的为高位</p>
<p>此时乘积的结构为： 高位数码（整数部分） + 剩余数  (**.**K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)*r =  K<sub>-1</sub> <strong>.</strong> K<sub>-2</sub>…K<sub>-m</sub></p>
<p>乘积减去高位数码得到剩余数，再将剩余数继续乘基数，重复以上步骤，直到高位数码为0</p>
<p><strong>乘基取整，先整为高，后整为低，整0结束</strong></p>
<p>注意：不是每个小数都能用二进制表示</p>
<h3><span id="拼凑法">拼凑法</span></h3>
<p>在十进制转换为二进制中，大小适中的数字，可以通过位权凑出数字</p>
<table>
<thead>
<tr>
<th style="text-align:left">2<sup>-4</sup></th>
<th style="text-align:left">2<sup>-3</sup></th>
<th style="text-align:left">2<sup>-2</sup></th>
<th style="text-align:left">2<sup>-1</sup></th>
<th style="text-align:left">2<sup>0</sup></th>
<th style="text-align:left">2<sup>1</sup></th>
<th style="text-align:left">2<sup>2</sup></th>
<th style="text-align:left">2<sup>3</sup></th>
<th style="text-align:left">2<sup>4</sup></th>
<th style="text-align:left">2<sup>5</sup></th>
<th style="text-align:left">2<sup>6</sup></th>
<th style="text-align:left">2<sup>7</sup></th>
<th style="text-align:left">2<sup>8</sup></th>
<th style="text-align:left">2<sup>9</sup></th>
<th style="text-align:left">2<sup>10</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0.0625</td>
<td style="text-align:left">0.125</td>
<td style="text-align:left">0.25</td>
<td style="text-align:left">0.5</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">4</td>
<td style="text-align:left">8</td>
<td style="text-align:left">16</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64</td>
<td style="text-align:left">128</td>
<td style="text-align:left">256</td>
<td style="text-align:left">512</td>
<td style="text-align:left">1024</td>
</tr>
</tbody>
</table>
<p>75.325D = 64 + 8 + 2 + 1 + 0.25 + 0.125 = 2<sup>6</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> + 2<sup>-2</sup> + 2<sup>-3</sup> = 1001011.011B</p>
<p>在了解了计算机的进位计数法及不同进制的转换后，便可以学习如何将生活中的数存入计算机</p>
<h1><span id="整数的表示">整数的表示</span></h1>
<p>在日常生活中带正负号的数，我们通常称为 <strong>真值</strong></p>
<p>将数据<strong>符号数字化</strong>后并能够存储到计算机中的数称为 <strong>机器数</strong>。</p>
<p>先看简化的无符号整数（以下都是二进制计数）</p>
<h2><span id="无符号整数">无符号整数</span></h2>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub></p>
<ul>
<li>没有符号位，默认为正号</li>
<li>最大值为：2<sup>n+1</sup>-1，最小值为0</li>
</ul>
<h3><span id="加法运算">加法运算</span></h3>
<blockquote>
<p>1+1 = 0001 + 0001 = 0010B = 2D</p>
</blockquote>
<h3><span id="减法运算">减法运算</span></h3>
<p>减法只考虑正数减正数：</p>
<ol>
<li>正数减负数、负数减正数本质上是加法，</li>
<li>负数减负数其实也就是正数减正数</li>
</ol>
<blockquote>
<p>2-1 = 0010 - 0001 = 0001 =1D</p>
</blockquote>
<p>实际上，早期的计算机中设有关于减法的相关电路，复杂的电路伴随着高昂的成本，因此如今的计算机逻辑运算单元中，只有加法器进行加法的运算，减法的运算也是通过加法器实现。那么如何通过加法运算实现减法呢？</p>
<h3><span id="钟表时针">钟表时针</span></h3>
<p>类似于钟表的时针：如果说现在时针现在停在10点钟，那么什么时候时针会停在8点钟呢？</p>
<p>时针倒拨2小时，或是正拨10小时，超过12小时后，时针将走第二圈，并最终停在8点钟</p>
<blockquote>
<p>10 - 2 = 8，10 + 10 = 20 = 12 + 8</p>
<p>即 (10 - 2) mod 12 = 8</p>
<p>​	(10 + 10) mod 12 = 8</p>
</blockquote>
<ul>
<li>
<p>mod就是<strong>取模运算</strong>，它们除以整数12，并计算最后的余数</p>
</li>
<li>
<p>8和20对于模12<strong>同余</strong>(有着相同的余数)，它们将共同停在余数8点钟</p>
</li>
</ul>
<h3><span id="取模运算">取模运算</span></h3>
<p>对整数a、b，取模运算就是a除以b，并计算余数（模余），记作</p>
<blockquote>
<p>a Mod b = a - [a/b]*b，[a/b]为向下取整</p>
</blockquote>
<p>如：20 Mod 12 = 20 - [20/12]*12 = 20 - 1*12 = 8</p>
<h3><span id="同余">同余</span></h3>
<p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余,记作</p>
<blockquote>
<p>a Mod r =  b Mod r =&gt; a ≡ b (mod m)</p>
<p>性质：<strong>a、b满足a-b为r的整数倍</strong></p>
</blockquote>
<h3><span id="思考">思考</span></h3>
<p>与钟表时针相比，计算机计数也有相似的地方：</p>
<table>
<thead>
<tr>
<th style="text-align:left">钟表时针</th>
<th style="text-align:left">计算机计数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">钟表时针取值只有[0-11]，超过12后会从0重新开始</td>
<td style="text-align:left">计算机作二进制表示的数位有限，超过一定数值也会重新开始计数</td>
</tr>
<tr>
<td style="text-align:left">将时针倒拨可以通过正拨等价实现</td>
<td style="text-align:left">计算机减法也可以使用加法等价实现</td>
</tr>
<tr>
<td style="text-align:left">(10-2) mod 12 = (10+10) mod 12</td>
<td style="text-align:left">(x - a) Mod r = (x + b) Mod r</td>
</tr>
<tr>
<td style="text-align:left">(10-2) ≡ (10+10) (mod 12)</td>
<td style="text-align:left">(x-a) ≡ (x+ b) (mod r)</td>
</tr>
</tbody>
</table>
<ul>
<li>x - a与x + b同余</li>
<li>根据<a href="#%E5%90%8C%E4%BD%99">同余的性质</a>，(x+ b) - (x-a) = r*Z，化简得 b = r*Z - a	（Z为整数、r为模）</li>
</ul>
<p>为了方便计算，可以只找离模最近的数，取Z = 1，即 b = r - a</p>
<p>也就是说，减法中减去a与加上 <strong>r - a</strong>等价，但r - a中仍存在减法，</p>
<p>这时需要利用计算机中的取反操作：</p>
<blockquote>
<p><strong>r  = a + ~a +1</strong>	（~为取反符号）</p>
</blockquote>
<p>二进制中任何一个数与它取反后的数相加，都会得到每个位为1的数，此时加上1就能得到该位下的模</p>
<blockquote>
<p>b = r - a = ~a +1</p>
</blockquote>
<p>x减去a 可以等价成 x 加上取反后的a加1，即</p>
<blockquote>
<p><strong>x - a = x + b =  x + ~a + 1</strong></p>
</blockquote>
<p>至此，减法运算可以仅通过加法、取反来实现</p>
<h2><span id="带符号整数">带符号整数</span></h2>
<h3><span id="原码">原码</span></h3>
<p>接着引入符号位的概念，最高位为符号位，正数为0，负数为1</p>
<p>符号位与真值的绝对值构成了原码</p>
<blockquote>
<p>[1]<sub>原</sub> = 0001	[-1]<sub>原</sub> = 1001</p>
</blockquote>
<p>8位的原码表示范围为：</p>
<blockquote>
<p>​	1111 1111 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4><span id="原码的运算">原码的运算</span></h4>
<ul>
<li>原码中的符号位仅用来表示数的正、负，不参加运算，只有数值部分参与运算</li>
<li>原码运算时，先比较两个数的符号，若两个数的符号相同，则将两个数的相加，最后加上符号</li>
<li>若两数的符号不同，则需比较两数的数值大小，然后将数值较大的数减去数值较小的数，并将数值较大的数的符号作为最后结果的符号。</li>
</ul>
<h3><span id="补码">补码</span></h3>
<p>回顾<a href="#%E6%80%9D%E8%80%83">无符号整数的减法运算</a>，x减去a 可以等价成 x 加上取反后的a加1</p>
<h4><span id="补码引言">补码引言</span></h4>
<p>无符号4位2进制的模为2<sup>4</sup></p>
<blockquote>
<ol>
<li>被减数-减数 = 0：1 - 1 = 0001 + 1111 = 1)0000B = 0D</li>
<li>被减数-减数 &gt; 0：2 - 1 = 0010 + 1111 = 1)0001B = 1D</li>
<li>被减数-减数 &lt; 0：1 - 2 = 0001 + 1110 = 1111B = 15D(16 - 1)</li>
</ol>
</blockquote>
<p>结果都比原来多了2<sup>4</sup>,都多加了一个模</p>
<ol>
<li>对于被减数 - 减数 &gt;= 0，忽视溢出位，数值位等于实际值</li>
<li>对于被减数 - 减数 &lt; 0，还需减去一个模，a - r = a - (a + ~a + 1) = -(~a + 1)，数值位才等于实际值</li>
</ol>
<p>我们继续整合符号位，当符号位中0表示负号，1表示正号时，符号位参与运算后为1</p>
<ul>
<li>对于被减数 - 减数 &gt;= 0，溢出位参与符号位的运算恰好使得结果的符号为正</li>
<li>对于被减数 - 减数&lt; 0，符号位不变表示结果小于0，恰好表示了 -(~a + 1)中的负号</li>
<li>对于减数，将x - a = x+ b 看作 x -a = x + [-a]<sub>新的形式</sub>，- a = [-a]<sub>新的形式</sub></li>
</ul>
<h4><span id="小结">小结</span></h4>
<p>加上符号位的减法运算，我们可以总结出：</p>
<ol>
<li>减法变加法，减数看成负数，数值位为按位取反后加1，符号位为1</li>
<li>符号位应为数值位高一位，参与加法运算</li>
<li>结果如果符号位为0则不变，如果符号为1，符号位不变，作 取反加1 的变换</li>
</ol>
<p>至此，补码的定义逐渐清晰起来</p>
<h4><span id="定义">定义</span></h4>
<ul>
<li>补码的符号位为数值位高一位，0表示负，1表示正</li>
<li>正数的补码与原码一致，负数的补码符号位不变，数值位作 取反加1</li>
</ul>
<p>8位的补码表示范围为：</p>
<p>​	1111 1111 ~ 0111 1111，补码没有-0的结果，补码中的1000 0000表示-128</p>
<p>(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub> + [1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub> = -128D</p>
<p>表示范围：-128 ~ 127</p>
<h4><span id="补码的加法">补码的加法</span></h4>
<p>最低位开始，按位相加，并往高位进位（符号位参与运算）</p>
<h4><span id="补码的减法">补码的减法</span></h4>
<p>减法变加法，减数看成负数，被减数的补码加上减数的负数的补码，，减数符号位为1不变，数值位为按位取反后加1</p>
<p>有符号5位2进制的模为2<sup>5</sup>，第5位为符号位</p>
<blockquote>
<p><strong>[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></strong></p>
</blockquote>
<ol>
<li>被减数-减数 = 0	[1]<sub>补</sub> - [1]<sub>补</sub> = [1]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0000]<sub>补</sub> = 0D</li>
<li>被减数-减数 &gt; 0	[2]<sub>补</sub> - [1]<sub>补</sub> = [2]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0010 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0001]<sub>补</sub> = 1D</li>
<li>被减数-减数 &lt; 0	[1]<sub>补</sub> - [2]<sub>补</sub> = [1]<sub>补</sub> + [-2]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1110]<sub>补</sub> = [<u>1</u>1111]<sub>补</sub>= -1D</li>
</ol>
<p>结果还是补码，计算机内，所有带符号整数的加减法都先转换为补码</p>
<h4><span id="补码lt-gt原码">补码&lt;-&gt;原码</span></h4>
<ol>
<li>
<p>在补码减法运算中，[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub>；根据原码、补码定义，[b]<sub>补</sub> = [b]<sub>原</sub>，-[b]<sub>原</sub> = [-b]<sub>原</sub>，</p>
<blockquote>
<p>[a]<sub>原</sub> + [-b]<sub>原</sub> = [a]<sub>原</sub> - [b]<sub>原</sub> =  [a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></p>
</blockquote>
</li>
</ol>
<p>也就是 [-b]<sub>原</sub>到 [-b]<sub>补</sub>的转换，[-b]<sub>原</sub>的符号位为1不变，数值位按位取反后加1</p>
<ol start="2">
<li>而被减数-减数 &lt; 0，结果为补码，要转换成原码，符号位为1不变，还需将数值位按位取反后加1</li>
</ol>
<p>总结：补码与原码之间的转换相同，正数不变，负数符号位为1不变，数值位按位取反后加1</p>
<h3><span id="反码">反码</span></h3>
<p>在使用补码作减法运算中，对于正数用不到按位取反的操作，而多次将负数的数值位按位取反再加一，将数值位按位取反也定义成新的形式，这个新的形式就是反码</p>
<h4><span id="定义">定义</span></h4>
<ul>
<li>反码的最高位为符号位，符号位为1为负数，符号位为0则为负数</li>
<li>正数的反码与原码相同，负数的反码符号位为1不变，数值位按位取反</li>
</ul>
<p>8位的反码表示范围为：</p>
<blockquote>
<p>​	1000 0000 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4><span id="反码-gt-补码">反码 -&gt; 补码</span></h4>
<p>[X]<sub>补</sub> = [X]<sub>反</sub> + 1</p>
<h3><span id="移码">移码</span></h3>
<p>移码的符号位用“1”表示正数，用“0”表示负数，数值部分与补码相同。</p>
<p>常用于表示浮点数的阶码</p>
<h2><span id="总结">总结</span></h2>
<table>
<thead>
<tr>
<th>n + 1 bit</th>
<th>无符号整数</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
<th>移码</th>
</tr>
</thead>
<tbody>
<tr>
<td>表示范围</td>
<td>0 ~ 2<sup>n+1</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最大值</td>
<td>11…11=2<sup>n+1</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11=2<sup>n</sup>-1</td>
<td>1,11…11=2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最小值</td>
<td>00…00 = 0</td>
<td>1,11…11 = -(2<sup>n</sup>-1)</td>
<td>1,00…00 = -(2<sup>n</sup>-1)</td>
<td>1,00…00=-(2<sup>n</sup>)</td>
<td>0,00…00=-(2<sup>n</sup>)</td>
</tr>
<tr>
<td>0的表示</td>
<td>00…00</td>
<td>[+0]<sub>原</sub>=0,00…00,[-0]<sub>原</sub>=1,00…00</td>
<td>[+0]<sub>反</sub>=0,00…00[-0]<sub>反</sub>=1,11…11</td>
<td>[0]<sub>补</sub>=0,00…00</td>
<td>[0]<sub>移</sub>=1,00…00</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63993b6ab1fccdcd36b1b146.png" alt="相互转换"></p>
<h1><span id="定点数的表示">定点数的表示</span></h1>
<p>定点数约定小数点的位置不变，定点纯整数约定了小数点在数值位的最后。定点纯小数约定了数值位的最高位在小数点后面。</p>
<h2><span id="定点小数的原码-反码表示">定点小数的原码、反码表示</span></h2>
<p>​	整数符号位后接，号，小数符号位接.号</p>
<h2><span id="定点小数的补码">定点小数的补码</span></h2>
<p>​	定点小数的补码加减法运算同带符号整数的补码加减法运算</p>
<h2><span id="位数扩展">位数扩展</span></h2>
<p>定点小数与定点整数做时，扩展位置不同</p>
<ul>
<li>定点小数右边扩展</li>
<li>定点整数在符号位后一位扩展</li>
</ul>
<h1><span id="浮点数的表示">浮点数的表示</span></h1>
<p>浮点数是与定点数相对的概念，定点数约定小数点的位置不变。</p>
<p>使用定点数表示时，当定点数占用的字长多而有效数字少时，就会造成存储空间的浪费；使用浮点数表示，合理改变小数点的位置，仅存储有效数字和2次幂信息，在位数有限的情况下，既扩大了数的表示范围，又保留了数的有效精度</p>
<h2><span id="浮点数的形式">浮点数的形式</span></h2>
<p>浮点数由尾数M和阶码E构成。基数为2的数F的浮点数表示为：</p>
<blockquote>
<p>F = M*2<sup>E</sup></p>
</blockquote>
<ul>
<li>尾数M存储有效数字，尾数反映数字的精度</li>
<li>阶码E存储2次幂信息，阶码反映表示范围，以及小数点的位置</li>
</ul>
<h3><span id="浮点数编码规则">浮点数编码规则</span></h3>
<table>
<thead>
<tr>
<th>阶符</th>
<th>阶码</th>
<th>数符</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>k位</td>
<td>1位</td>
<td>n位</td>
</tr>
<tr>
<td>阶码的正负</td>
<td>数值大小</td>
<td>浮点数的正负</td>
<td>数值精度</td>
</tr>
</tbody>
</table>
<ul>
<li>尾数M必须为<strong>小数</strong>，用n+1位有符号定点小数表示，可采用的原码，补码。</li>
<li>阶码E必须为<strong>整数</strong>，用k+1位有符号定点整数表示，可采用原码，补码，移码。</li>
<li>浮点数编码的位数m=(n+1)+(k+1)</li>
</ul>
<h2><span id="非规格化浮点数">非规格化浮点数</span></h2>
<p>当对尾数M只要求是小数而无其他限制时，此时的浮点数被称为非规格化浮点数。</p>
<p>假设阶码和尾数都用原码表示，则非规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th>阶码和尾数</th>
<th>数值</th>
<th>阶码和尾数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶码最小值</td>
<td>- (2<sup>k</sup>-1)</td>
<td>阶码最大值</td>
<td>2<sup>k</sup>-1</td>
</tr>
<tr>
<td>尾数最小负值</td>
<td>-(1- 2<sup>-n</sup>)</td>
<td>尾数最大负值</td>
<td>-2<sup>-n</sup></td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>2<sup>-n</sup></td>
<td>尾数最大正值</td>
<td>1-2<sup>-n</sup></td>
</tr>
</tbody>
</table>
<p>以8位数值位，一位符号位的阶码为例子： 由于用原码表示，</p>
<p>阶码的最小值：1 11111111 即 -(2^8 - 1) = -255</p>
<p>阶码的最大值：0 0000000 即   2^8 - 1  =  255</p>
<p>尾数也是8位数值位，1为符号位原码的形式：</p>
<p>由于我们限定了浮点数的尾数只能是小数，所以我们当成定点纯小数的形式进行分析：</p>
<p>尾数的最小负值：1.11111111	即-(1- 2<sup>-8</sup>)</p>
<p>尾数的最大负值：1.0000001	即-2<sup>8</sup></p>
<p>尾数的最大正值：0.11111111	即1- 2<sup>-8</sup></p>
<p>尾数的最小正值	0.0000001	即2<sup>8</sup></p>
<h2><span id="规格化浮点数">规格化浮点数</span></h2>
<p>假如一个尾数M用原码表示为0.00000001，那么这8位尾数的前7位都是0，这7个0实际上是无效数值位，我们完全可以改写成：</p>
<blockquote>
<p>0.1XXXXXXX×2<sup>-7</sup></p>
</blockquote>
<p>当1左移到最高位时，尾数后面多出来了7位可以多表示7个有效位来提高精度</p>
<p>规格化浮点数，就是调整一个非规格化浮点数的位数和阶码的大小，使非零的浮点数在尾数的最高位上保证是一个有效值</p>
<p>规格化浮点数使尾数存储空间能表示更多的有效数位</p>
<h3><span id="规范">规范</span></h3>
<p>若尾数M用原码表示，</p>
<ul>
<li>
<p>当M ≥0时，[M]<sub>原</sub> = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M]<sub>原</sub> = 1.1XXXXXXX</p>
<p>若尾数M用补码表示，</p>
</li>
<li>
<p>当M ≥0时，[M] 补 = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M] 补 = 1.0XXXXXXX</p>
</li>
</ul>
<h3><span id="表示范围">表示范围</span></h3>
<p>尾数用原码表示，则规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>数值</th>
<th></th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>尾数最小负值</td>
<td>-(1-2<sup>n</sup>)</td>
<td>尾数最大负值</td>
<td>-1/2</td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>1/2</td>
<td>尾数最大正值</td>
<td>1-2<sup>n</sup></td>
</tr>
</tbody>
</table>
<p>因此规格化浮点数将尾数M的绝对值限定在规定的数值范围之内，即</p>
<blockquote>
<p>1/2 ≤ ∣ M ∣ &lt; 1 （原码）</p>
</blockquote>
<p>要使尾数的绝对值在此范围内，通过改变小数点的位置（相应地改变阶码）就可以做到。</p>
<h3><span id="操作">操作</span></h3>
<table>
<thead>
<tr>
<th>非规格化浮点数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>当运算结果最高位不是有效位时</td>
<td>尾数每左移一位，阶码减一</td>
</tr>
<tr>
<td>当运算结果的尾数的有效位进到小数点前面时</td>
<td>尾数每右移一位，阶码加一</td>
</tr>
</tbody>
</table>
<ul>
<li>判断浮点数是否规格化：尾数最高位是否是有效位</li>
<li>正数补码（原码）而言，有效位都为1；而对于负数补码而言，有效位为0，对于负数原码，有效位为1</li>
<li>特别地，补码表示中，-1/2（1.100000000）不是规格化形式，-1（1.00000000）是规格化形式；，注意不要与原码规格化判定的绝对值范围混淆</li>
</ul>
<h2><span id="ieee-754标准浮点数">IEEE 754标准浮点数</span></h2>
<h3><span id="单精度浮点数">单精度浮点数</span></h3>
<p>IEEE 754规定单精度浮点数的真值N一般表示为：</p>
<blockquote>
<p>N = (-1)<sup>S</sup> * 2<sup>e-127</sup> * 1.f</p>
</blockquote>
<table>
<thead>
<tr>
<th>数符S</th>
<th>阶码e</th>
<th>尾数f</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>8位</td>
<td>23位</td>
</tr>
<tr>
<td>浮点数的正负</td>
<td>含1位阶符，采用移码表示，偏移量127</td>
<td>浮点数的精度，采用原码表示</td>
</tr>
</tbody>
</table>
<ul>
<li>IEEE 754中的阶码采用移码来表示，但对于单精度浮点数来说，移码的偏移量不是2<sup>7</sup>而是2<sup>7</sup> − 1 = 127 ,这是因为IEEE 754将移码编码的全0和全1作为了特殊标识。</li>
<li>IEEE 754浮点数是规格化浮点数，为了能够更多地表示尾数的有效数位，规定尾数真值的整数部分必须为1，尾数编码时整数1隐去，小数部分f用原码表示。</li>
</ul>
<table>
<thead>
<tr>
<th>真值D</th>
<th>补码</th>
<th>移码</th>
<th>阶码真值</th>
</tr>
</thead>
<tbody>
<tr>
<td>-128</td>
<td>1000 0000</td>
<td>0000 0000</td>
<td>/</td>
</tr>
<tr>
<td>-127</td>
<td>1000 0001</td>
<td>0000 0001</td>
<td>1111 1110</td>
</tr>
<tr>
<td>-126</td>
<td>1000 0010</td>
<td>0000 0010</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>-1</td>
<td>1111 1111</td>
<td>0111 1111</td>
<td>0000 0000</td>
</tr>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>1000 0000</td>
<td>0000 0001</td>
</tr>
<tr>
<td>1</td>
<td>0000 0001</td>
<td>1000 0001</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>125</td>
<td>0111 1101</td>
<td>1111 1101</td>
<td></td>
</tr>
<tr>
<td>126</td>
<td>0111 1110</td>
<td>1111 1110</td>
<td></td>
</tr>
<tr>
<td>127</td>
<td>0111 1111</td>
<td>1111 1111</td>
<td></td>
</tr>
</tbody>
</table>
<h4><span id="阶码e全0和全1时的特殊含义">阶码e全0和全1时的特殊含义</span></h4>
<ol>
<li>当阶码全0，且尾数f不全0时，表示该浮点数不是规格化浮点数，尾数实际为：0.XXXXXXXX 次正规数,而不是规定形式的：1.XXXXXXXX</li>
<li>当阶码e全1，且尾数f全为0时，则该浮点数表示正无穷大或负无穷大，当数符s为1时，表示负无穷大，当数符s为0时，表示正无穷大。</li>
<li>当阶码e全1，且尾数f不全为0时，则该浮点数表示非数值数据（NaN）。</li>
</ol>
<h4><span id="为什么ieee-754使用移码表示阶码e">为什么IEEE 754使用移码表示阶码e</span></h4>
<h5><span id="保证浮点数的机器零的阶码为全0">保证浮点数的机器零的阶码为全0</span></h5>
<p>机器零：机器数表示0的形式</p>
<p>​	IEEE 754标准下，浮点数尾数真值的整数部分隐藏了真值1，因此无法通过尾数全0来表示机器0；使用阶符表示机器0时，当阶码的真值趋向负无穷时，即指数趋于负无穷，此时浮点真值也趋于0，因此规定使用阶码中真值为负数且最小的数来表示机器0；假设使用8位补码来表示阶码，此时机器0表示为1000 0000B（-127D)，若使用8位移码，则使用 0000 0000 ；使用移码更直观，因此规定<strong>尾数、阶码同时全为0来表示机器0</strong>。（阶码全0，尾数不全0时，表示浮点数非规格化）</p>
<h5><span id="移码全部位于正轴上随真值增大而增大">移码全部位于正轴上，随真值增大而增大</span></h5>
<p>​	移码是对于某一个系列或集合的数使它们都映射到正数轴上去，即在数轴上把数都统一往右移动n位，使得所有的数都不为负数。IEEE 754标准下，移码E=e+偏移量，因此对于所有的E都有E大于等于0。由于移码都是从0开始的正数，所以即使是二进制的表示形式，也能直接<strong>比较阶码对应数值的大小</strong>(而补码之间的比较要观察符号位，同时转换成原码对数值位进行比较)。</p>
<h5><span id="移码也能减法变加法">移码也能减法变加法</span></h5>
<p>移码相对于补码仅符号位取反，进行减法运算时，也能加法变减法，只是符号位代表的含义不同，0表示负数，1表示正数，使用移码减法运算和补码减法运算得到的结果真值相同。</p>
<h5><span id="总结">总结</span></h5>
<p>对于单精度浮点数：<br>
(1)阶码的真值E=e-127，并且0&lt;e&lt;255，-126&lt;E&lt;127。</p>
<p>(2)当e=0或255时，在IEEE 754中表示特殊的数。</p>
<p>(3)所能表示的范围为：</p>
<ul>
<li>正数为：+2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到+2 <sup>−126</sup> ×(1+0)</li>
<li>负数为：−2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到−2 <sup>−126</sup> ×(1+0)</li>
</ul>
<h3><span id="双精度浮点数">双精度浮点数</span></h3>
<p>简要说明双精度浮点数（与单精度浮点数相类似）：</p>
<p>（1)阶码的真值E的取值范围为：-1022 ~ +1023,偏移量为+1023,阶码移码编码e为：<br>
+1 ~ + 2046</p>
<p>（2）双精度浮点数的规格化数表示为：N=(−1) s ×2 e−1023 ×1.f</p>
<p>（3）所能表示的规格化数范围：<br>
正数为：+2 +1023 ×(1+1−2 −52 )到+2 −1022 ×(1+0)</p>
<p>负数为：−2 +1023 ×(1+1−2 −52 )到−2 −1022 ×(1+0)</p>
<p>（4）当e=0或e=2047时，在IEEE 754标准中表示特殊的数</p>
<h3><span id="舍入模式">舍入模式</span></h3>
<p>我们在进行对阶或者右规格化的时候，阶数较小的操作数在进行右移的时候，会造成尾数部分的低位丢失，从而会造成误差。因此我们才需要根据需求，采取四种舍入模式中的一种对尾数进行舍入操作以减少误差。</p>
<p>二、IEEE754标准中的4种舍入模式<br>
1、就近舍入：</p>
<p>即十进制下的四舍五入。但是也会出现以下几种情况：</p>
<p>多余数字是1001，它大于0.5，故最低位进1。<br>
多余数字是0111，它小于0.5，则直接舍掉多余数字。<br>
多余数字是1000，正好是等于0.5的特殊情况；那么此时最低位为0则舍掉多余位，最低位为1则进位1。<br>
注意这里说明的数位都是指二进制数。因为这是尾数，所以在计算这些二进制和0.5的关系的时候，也即转为10进制的时候，我们用每一位的权重乘以2^(-i)然后求和即可。</p>
<p>2、朝0舍入：即朝数轴零点方向舍入，所以我们直接截尾即可。</p>
<p>3、朝正无穷舍入：对正数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；负数的话不管多余位是多少直接截尾即可。</p>
<p>4、朝负无穷舍入：对负数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；正数的话不管多余位是多少直接截尾即可。</p>
]]></content>
      <categories>
        <category>计算机组成与原理</category>
      </categories>
  </entry>
  <entry>
    <title>高并发</title>
    <url>/post/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1><span id="高并发面试题">高并发面试题</span></h1>
<hr>
<h2><span id="什么是高并发">什么是高并发？</span></h2>
<p><strong>高并发（High Concurrency）</strong></p>
<ul>
<li>系统运行时，短时间内接收大量请求的情况（WEB系统突然收到大量请求，如抢票、双十一）</li>
<li>导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。</li>
<li>通过设计保证系统能够同时并行处理很多请求</li>
</ul>
<hr>
<h2><span id="2-高并发的处理指标">2. 高并发的处理指标？</span></h2>
<ul>
<li>响应时间（Response Time）：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间</li>
<li>吞吐量（Throughput）：单位时间内处理的请求数量</li>
<li>每秒查询率QPS（Query Per Second）：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显</li>
<li>并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数</li>
</ul>
<hr>
<h2><span id="3-高并发和多线程的关系和区别">3. 高并发和多线程的关系和区别？</span></h2>
<p>高并发 ≠ 多线程</p>
<p><strong>多线程</strong></p>
<ul>
<li>java的特性，因为现在cpu都是多核多线程的，可以同时执行几个任务，为了提高jvm的执行效率，java提供了这种多线程的机制，以增强数据处理效率。多线程对应的是cpu，高并发对应的是访问请求，可以用单线程处理所有访问请求，也可以用多线程同时处理访问请求</li>
<li>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行</li>
<li>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序</li>
<li>总之，多线程即可以这么理解：多线程是处理高并发的一种编程方法，即并发需要用多线程实现</li>
</ul>
<p><strong>高并发</strong></p>
<ul>
<li>高并发不是JAVA的专有的东西，是语言无关的广义的，为提供更好互联网服务而提出的概念</li>
<li>典型的场景，例如：12306抢火车票，天猫双十一秒杀活动等。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。<br>
如果要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等……而多线程只是其中解决方法之一</li>
</ul>
<hr>
<h2><span id="4-如何提升系统的并发能力">4. 如何提升系统的并发能力？</span></h2>
<p>方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）</p>
<p><strong>垂直扩展</strong></p>
<p>提升单机处理能力。垂直扩展的方式又有两种：</p>
<ul>
<li>增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；</li>
<li>提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；</li>
</ul>
<p><strong>水平扩展</strong></p>
<p>只要增加服务器数量，就能线性扩充系统性能</p>
<p>在互联网业务发展迅猛的早期，采用“增强单机硬件性能”的方式提升系统并发能力，发展业务抢时间</p>
<p>但是单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展</p>
<hr>
<h2><span id="5-高并发系统设计的宏观目标">5. 高并发系统设计的宏观目标？</span></h2>
<ul>
<li>高性能：性能体现了系统的并行处理能力，在有限的硬件投入下，提高性能意味着节省成本。同时，性能也反映了用户体验，响应时间分别是100毫秒和1秒,给用户的感受是完全不同的</li>
<li>高可用：表示系统可以正常服务的时间。一个全年不停机、无故障；另一个隔三差五出线上事故、宕机，用户肯定选择前者。另外，如果系统只能做到90%可用，也会大大拖累业务</li>
<li>高扩展：表示系统的扩展能力，流量高峰时能否在短时间内完成扩容，更平稳地承接峰值流量，比如双11活动、明星离婚等热点事件</li>
</ul>
<p>这3个目标是需要通盘考虑的，因为它们互相关联、相互影响</p>
<hr>
<h2><span id="高性能的指标有哪些">高性能的指标有哪些？</span></h2>
<ul>
<li>平均响应时间：最常用，但是缺陷很明显，对于慢请求不敏感。比如1万次请求，其中9900次是1ms，100次是100ms，则平均响应时间为1.99ms，虽然平均耗时仅增加了0.99ms，但是1%请求的响应时间已经增加了100倍</li>
<li>TP90、TP99等分位值：将响应时间按照从小到大排序，TP90表示排在第90分位的响应时间， 分位值越大，对慢请求越敏感</li>
<li>吞吐量：和响应时间呈反比，比如响应时间是1ms，则吞吐量为每秒1000次</li>
</ul>
<hr>
<h2><span id="高可用性的指标有哪些">高可用性的指标有哪些？</span></h2>
<ul>
<li>高可用性是指系统具有较高的无故障运行能力</li>
<li>可用性 = 正常运行时间 / 系统总运行时间，一般使用几个9来描述系统的可用性</li>
<li>对于高并发系统来说，最基本的要求是：保证3个9或者4个9。原因很简单，如果你只能做到2个9，意味着有1%的故障时间，像一些大公司每年动辄千亿以上的GMV或者收入，1%就是10亿级别的业务影响</li>
</ul>
<hr>
<h2><span id="高可扩展性的指标有哪些">高可扩展性的指标有哪些？</span></h2>
<ul>
<li>面对突发流量，不可能临时改造架构，最快的方式就是增加机器来线性提高系统的处理能力</li>
<li>对于业务集群或者基础组件来说，扩展性 = 性能提升比例 / 机器增加比例，理想的扩展能力是：资源增加几倍，性能提升几倍</li>
<li>通常来说，扩展能力要维持在70%以上。但是从高并发系统的整体架构角度来看，扩展的目标不仅仅是把服务设计成无状态就行了，因为当流量增加10倍，业务服务可以快速扩容10倍，但是数据库可能就成为了新的瓶颈。像MySQL这种有状态的存储服务通常是扩展的技术难点，如果架构上没提前做好规划（垂直和水平拆分），就会涉及到大量数据的迁移。因此，高扩展性需要考虑：服务集群、数据库、缓存和消息队列等中间件、负载均衡、带宽、依赖的第三方等，当并发达到某一个量级后，上述每个因素都可能成为扩展的瓶颈点</li>
</ul>
<hr>
<h2><span id="高并发技术方案">高并发技术方案?</span></h2>
<ul>
<li>分布式缓存：redis、memcached等，结合CDN来解决图片文件等访问</li>
<li>消息队列中间件：activeMQ等，解决大量消息的异步处理能力</li>
<li>应用拆分:一个工程被拆分为多个工程部署，利用dubbo解决多工程之间的通信</li>
<li>数据库垂直拆分和水平拆分(分库分表)等</li>
<li>数据库读写分离，解决大数据的查询问题</li>
<li>还可以利用nosql ，例如mongoDB配合mysql组合使用</li>
<li>还需要建立大数据访问情况下的服务降级以及限流机制等</li>
</ul>
]]></content>
  </entry>
</search>
