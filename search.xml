<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOS常用命令</title>
    <url>/post/DOS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="dos命令的基础使用">DOS命令的基础使用：</span></h2>
<h3><span id="dir"><code>dir</code></span></h3>
<ul>
<li>查看当前目录，其中dir指directory</li>
</ul>
<h3><span id="mkdirmd"><code>mkdir</code>(md)</span></h3>
<ul>
<li>创建文件夹</li>
</ul>
<span id="more"></span>
<h3><span id="rmdirrd"><code>rmdir</code>(rd)</span></h3>
<ul>
<li>删除文件夹，若要删除非空的文件夹，需要<code>-s</code>来强行删除该文件夹下的所有子文件夹与文件，再加上<code>-q</code>则无需确认（安静模式）</li>
</ul>
<h3><span id="cd"><code>cd</code></span></h3>
<ul>
<li>
<p>可以跳转至当前目录的所有子孙目录，但无法进行跨盘符跳转；若要进行跨盘符跳转，则使用“盘符”+“:”，例如<code>c:</code>,<code>d:</code>,<code>e:</code></p>
</li>
<li>
<p>特别地，<code>cd .\</code>表示当前目录<code>cd ..</code> 表示返回上一级目录,<code>cd \</code> 表示返回根目录</p>
</li>
</ul>
<h3><span id="echo回声"><code>echo</code>(回声)</span></h3>
<ul>
<li><code>echo 123</code>只使用echo + 字符串，则表示打印该字符串</li>
<li><code>echo 123 &gt; d:\hello.txt </code>加上大于号，表示将打印的字符串重定向到指定位置，此时对同一个文件多次echo将会覆盖上次写的内容</li>
<li><code>echo 123 &gt;&gt; d:\hello.txt</code> 两个大于号可对上次写下的内容进行叠加</li>
</ul>
<h3><span id="del"><code>del</code></span></h3>
<ul>
<li>删除文件</li>
<li><code>del *.txt</code> 通配符删除，意为将当前目录下所有后缀为txt的文·件删除</li>
</ul>
<h3><span id="type"><code>type</code></span></h3>
<ul>
<li>仅能查看文本文件内容</li>
</ul>
<h3><span id="cls"><code>cls</code></span></h3>
<ul>
<li>clean sreen 清空屏幕</li>
</ul>
<h3><span id="tree"><code>tree</code></span></h3>
<ul>
<li>以树形显示该目录下的所有文件夹</li>
<li>加上<code>-f</code> 可同时显示该目录下的所有文件</li>
</ul>
<h2><span id="绝对路径与相对路径">绝对路径与相对路径：</span></h2>
<ul>
<li>
<p>绝对路径：从盘符开始的路径</p>
</li>
<li>
<p>相对路径：从当前目录开始的路径</p>
</li>
</ul>
<h2><span id="网络命令">网络命令</span></h2>
<ul>
<li>
<p><code>ping</code> 检查是否可以和其他主机通信</p>
<p><code>-t</code> 不间断发送数据包</p>
</li>
<li>
<p><code>ipconfig</code> 查看网卡信息</p>
<p><code>/all</code> 查看详细的网卡信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
      <tags>
        <tag>Dos</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/post/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行运行</td>
<td>Shift + F10</td>
<td>万能解错/生成返回值</td>
<td>Alt + Enter</td>
</tr>
<tr>
<td>提示补全</td>
<td>Ctrl +空格(改成 Alt+/)</td>
<td>返回上次查看代码的位置</td>
<td>Ctrl + Alt + 左右箭头</td>
</tr>
<tr>
<td>单行注释</td>
<td>Ctrl + /</td>
<td>查看继承关系</td>
<td>Ctrl + H</td>
</tr>
<tr>
<td>多行注释</td>
<td>Ctrl + Shift + /</td>
<td>格式化代码</td>
<td><strong>Ctrl + Alt + L</strong></td>
</tr>
<tr>
<td>向下复制一行</td>
<td>Ctrl + D</td>
<td>提示方法参数类型</td>
<td>Ctrl + P</td>
</tr>
<tr>
<td>删除一行或多行</td>
<td>Ctrl + Y</td>
<td>复制</td>
<td>Ctrl + C</td>
</tr>
<tr>
<td>向上/下移动一行</td>
<td><strong>Alt+Shift+上或下箭头</strong></td>
<td>撤销</td>
<td>Ctrl + Z</td>
</tr>
<tr>
<td>向下开始新的一行</td>
<td>Shift + Enter</td>
<td>剪切</td>
<td>Ctrl + X</td>
</tr>
<tr>
<td>向上开始新的一行</td>
<td>Ctrl + Alt + Enter</td>
<td>粘贴</td>
<td>Ctrl + V</td>
</tr>
<tr>
<td>查看源码</td>
<td>Ctrl + 鼠标左键</td>
<td>保存</td>
<td>Ctrl + S</td>
</tr>
<tr>
<td>搜索类</td>
<td>Ctrl + N</td>
<td>全选</td>
<td>Ctrl + A</td>
</tr>
<tr>
<td>整体向后移动</td>
<td>Tab</td>
<td>全局查找</td>
<td>Ctrl + Shift+R</td>
</tr>
<tr>
<td>整体向前移动</td>
<td>Shift + Tab</td>
<td>查找任何东西</td>
<td>Shift+Shift</td>
</tr>
<tr>
<td>查看类的结构</td>
<td>Ctrl + F12</td>
<td>查看类的继承结构图</td>
<td>Ctrl + Alt + U</td>
</tr>
<tr>
<td>重构方法变量名</td>
<td>Shift + F6</td>
<td>抽取方法</td>
<td>Ctrl + Alt + M</td>
</tr>
<tr>
<td>大小写转换</td>
<td>Ctrl +Shift + U</td>
<td>最近修改的文件</td>
<td>Ctrl + E</td>
</tr>
<tr>
<td>生成get/set/toString</td>
<td>Alt + Insert</td>
<td>选择粘贴内容</td>
<td>Ctrl + Shift + V</td>
</tr>
<tr>
<td>查看文档说明</td>
<td>Ctrl + Q</td>
<td>优化导入的类</td>
<td>Ctrl + Alt + O</td>
</tr>
<tr>
<td>收起/展开所有方法</td>
<td>Ctrl + Shift + “+/-”</td>
<td>寻找方法被调用的地方</td>
<td>Alt + Alt + F7</td>
</tr>
<tr>
<td>生成surround with</td>
<td>Ctrl + Alt+T</td>
<td>跳到文件尾部</td>
<td>Ctrl + End</td>
</tr>
<tr>
<td>查找</td>
<td>Ctrl + F</td>
<td>跳到文件头部</td>
<td>Ctrl + Home</td>
</tr>
<tr>
<td>查找替换</td>
<td>Ctrl + R</td>
<td>实现/重写方法</td>
<td>Ctrl + O/</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>常用模板</title>
    <url>/post/IDEA%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>模板</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>psvm</strong></td>
<td>可生成 main 方法</td>
</tr>
<tr>
<td><strong>sout</strong></td>
<td>System.out.println() 快捷输出</td>
</tr>
<tr>
<td><strong>soutp</strong></td>
<td>System.out.println(&quot;方法形参名 = &quot; +  形参名);</td>
</tr>
<tr>
<td><strong>soutv</strong></td>
<td>System.out.println(&quot;变量名 = &quot; + 变 量);</td>
</tr>
<tr>
<td><strong>soutm</strong></td>
<td>System.out.println(“当前类名.当前方 法”);</td>
</tr>
<tr>
<td><strong>“abc”.sout</strong></td>
<td>System.out.println(“abc”);</td>
</tr>
<tr>
<td><strong>fori</strong></td>
<td>可生成 for 循环</td>
</tr>
<tr>
<td>iter</td>
<td>可生成增强 for 循环</td>
</tr>
<tr>
<td>itar</td>
<td>可生成普通 for 循环</td>
</tr>
<tr>
<td>list.for</td>
<td>可生成集合 list 的 for 循环 ,for(String s:list){}</td>
</tr>
<tr>
<td><strong>ifn</strong></td>
<td>可生成 if(xxx = null)</td>
</tr>
<tr>
<td><strong>inn</strong></td>
<td>可生成 if(xxx != null)或xxx.nn或 xxx.null</td>
</tr>
<tr>
<td>prsf</td>
<td>可生成 private static final</td>
</tr>
<tr>
<td>psf</td>
<td>可生成 public static final</td>
</tr>
<tr>
<td>psfi</td>
<td>可生成 public static final int</td>
</tr>
<tr>
<td>psfs</td>
<td>可生成 public static final String</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>JDK的安装及环境变量的配置</title>
    <url>/post/JDK%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>JDK是Java开发的重要工具，安装JDK是学好Java的第一步</p>
<span id="more"></span>
<h1><span id="jdk-的安装">JDK 的安装</span></h1>
<h2><span id="下载">下载</span></h2>
<p>首先通过甲骨文官方下载JDK所需的安装包</p>
<p><a href="https://www.oracle.com/java/technologies/downloads/archive/">Java Archive | Oracle</a></p>
<p>选择需要的JDK版本，通常使用的是JDK8</p>
<img src="https://pic.imgdb.cn/item/6391d5c8b1fccdcd362211e2.png" style="zoom:50%;">
<p>往下找到适配自己系统的JDK，这里演示的是windows64字节</p>
<img src="https://pic.imgdb.cn/item/6391d6b8b1fccdcd362376b7.png" style="zoom: 33%;">
<p>点击下载链接，勾选接受协议，将会跳转至Oracle登录界面，没有Oracle账号还需注册，登录成功即可开始下载</p>
<h2><span id="安装">安装</span></h2>
<ul>
<li>
<p>作为开发人员安装JDK，<strong>设置公共JRE公共功能不可用</strong>，因JDK本身即包含了JRE，无需再次安装，关于JDK： <a href="../Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0">Java语言概述</a></p>
</li>
<li>
<p>其次，安装的路径下<strong>不得存在中文</strong>，</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391d82cb1fccdcd3625d862.png" style="zoom: 80%;">
<h1><span id="环境变量的配置">环境变量的配置</span></h1>
<h2><span id="查看环境变量">查看环境变量</span></h2>
<p>鼠标右击此电脑点击属性，对于win11的系统，点击设备规格下的高级系统设置，点击环境变量</p>
<img src="https://pic.imgdb.cn/item/6391de65b1fccdcd362eea05.png" style="zoom: 80%;">
<h2><span id="java_home">JAVA_HOME</span></h2>
<p>点击系统变量中的新建，添加一个名为JAVA_HOME的变量，变量值为JDK的安装路径</p>
<img src="https://pic.imgdb.cn/item/6391de3db1fccdcd362eb8e5.png" style="zoom: 80%;">
<h2><span id="path">Path</span></h2>
<p>点击系统变量中的编辑，点击新建，输入<code>%JAVA_HOME%\bin</code></p>
<img src="https://pic.imgdb.cn/item/6392fd2db1fccdcd36c029a3.png" style="zoom:80%;">
<h2><span id="classpath">CLASSPATH</span></h2>
<p>同理添加一个名为CLASSPATH的变量，变量值为</p>
<p><code> .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></p>
<p>这里需注意：</p>
<ul>
<li>CLASSPATH变量中的字符必须是英文字符</li>
<li>此处的%JAVA_HOME%意为对上一个JAVA_HOME的引用，即JDK的安装路径</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391e15eb1fccdcd3633b5d5.png" style="zoom: 80%;">
<p>随后一路确定，即配置完成</p>
<h1><span id="测试">测试</span></h1>
<p>win+r查看cmd，输入<code>java -version</code>查看JDK版本信息</p>
<img src="https://pic.imgdb.cn/item/6391e1f1b1fccdcd36358bae.png" style="zoom: 80%;">
<h1><span id="总结">总结</span></h1>
<h2><span id="为什么要配置环境变量">为什么要配置环境变量?</span></h2>
<h3><span id="path">path</span></h3>
<p>首次安装JDK后，当我们想去编译某个.java源代码，需要执行JDK的bin目录下的某个可执行文件(.exe)；在执行DOS命令行中，windows首先在当前目录下查找是否存在所指的可执行文件，若没有找到，将到path环境变量指定的目录中查找，若扔未找到，则报错。</p>
<p>对此，我们只能在DOS命令行中写下要执行文件的绝对路径，这使操作变得复杂。</p>
<p>根据windows系统查找可执行文件的原理，我们可以将常执行的文件的目录配置到环境变量中，如此，我们便可以不写文件的绝对路径仍能执行文件。</p>
<h3><span id="java_home">JAVA_HOME</span></h3>
<p>在配置了path的基础上，可能会出现多个环境变量需要配置JDK路径的情况，如果想更改使用JDK的版本号，需要找到每个JDK路径并修改他们，这将是个麻烦的过程。</p>
<p>因此，将JDK路径配置到JAVA_HOME下将方便我们对JDK版本的切换。</p>
<p>部分第三方软件约定使用JAVA_HOME来指定JDK路径（Tomcat）。</p>
<h3><span id="classpath一般不需配置">CLASSPATH（一般不需配置）</span></h3>
<p>编译源代码生成的字节码文件，交给JVM运行处理，在没有配置classpath的情况下，在DOS命令行中输入运行指令，首先，JVM中的类加载器从当前目录下查找是否存在字节码文件，若找不到字节码文件则报错。因此，配置ClassPath环境变量是为了使类加载器从配置的路径中找到字节码文件。<a href="../Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">Java加载及执行原理</a></p>
<p>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</p>
<p>变量中包含了多条路径，它们分别由<code>;</code>隔开，其中 <code>.</code>指的是当前路径；其余两条路径分别为<code> %JAVA_HOME%\lib\dt.jar</code>、<code>%JAVA_HOME%\lib\tools.jar</code>。</p>
<p>一般情况下要想运行.class文件会切换至.class文件所在的目录，也就是当前路径，因此，CLASSPATH一般不需要配置</p>
<ul>
<li>问题：当两个类被分别放在不同目录下，但两个类之间存在调用另一个类的方法，如何使两个类正常运行？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test1</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args&#123;</span></span><br><span class="line"><span class="params">		System.out.println(<span class="string">&quot;222222222&quot;</span>)</span>;</span><br><span class="line">     	test1.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test2类调用了test1类的方法，经过测试我们无法直接编译test2.Java源文件</p>
<p><img src="https://pic.imgdb.cn/item/639318d0b1fccdcd36f02e1e.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -classpath &quot;另一个类所处目录路径&quot; test2.java</span><br></pre></td></tr></table></figure>
<p>通过Java命令-classpath修改CLASSPATH路径，实现对test2的编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -classpath .;&quot;另一个类所处目录路径&quot; test2</span><br></pre></td></tr></table></figure>
<p>执行.class文件时，仅配置了另一个类所处目录的路径会找不到当前要执行的test2.class，因此加上当前目录，即可运行</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>JVM内存结构</title>
    <url>/post/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/101495810">JVM内存模型（详解） - 知乎 (zhihu.com)</a></p>
<p><img src="https://pic.imgdb.cn/item/63ae5b6208b6830163cf8eca.png" alt="JVM内存模型"></p>
<h3><span id="程序计数器program-counter-register">程序计数器（Program Counter Register）</span></h3>
<p>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令：分支、跳转、循环、异常处理、线程恢复等基础操作都会依赖这个计数器来完成。每个线程都有独立的程序计数器，用来在线程切换后能恢复到正确的执行位置，各条线程之间的计数器互不影响，独立存储。所以它是一个“线程私有”的内存区域。</p>
<h3><span id="本地方法栈-native-method-stack">本地方法栈（ Native Method Stack）</span></h3>
<p>本地方法栈和虚拟机栈所发挥的作用是很相似的，它们之间的区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法（由其它语言实现）服务。</p>
<span id="more"></span>
<h3><span id="虚拟机栈vm-stack">虚拟机栈（VM Stack）</span></h3>
<p>JVM栈是线程私有的内存区域。主要存放方法执行数据</p>
<ol>
<li>每个方法执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息</li>
<li>局部变量表存放各种基本数据类型、对象引用（reference类型，指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一跳字节码指令的地址）</li>
<li>动态连接（Dynamic Linking）通过每个栈帧都包含一个指向该栈帧所属方法（常量池）的引用，在<strong>运行期间</strong>将指向该方法的<a href="../Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/#%E8%A7%A3%E6%9E%90">符号引用</a>转化为直接引用
<ol>
<li>静态解析：在类加载的解析阶段或者第一次使用时将指向该方法的符号引用转化为直接引用，</li>
</ol>
</li>
</ol>
<h3><span id="堆heap">堆（Heap）</span></h3>
<p>通常情况下，它占用的空间是所有内存区域中最大的</p>
<ol>
<li>存储实例对象、数组、成员变量</li>
<li>堆由垃圾收集器自动回收，堆区由各子线程共享使用</li>
<li>堆的内存空间既可以固定大小，也可运行时动态地调整</li>
</ol>
<h3><span id="方法区method-area">方法区（Method Area）</span></h3>
<p>线程共享的内存区域</p>
<ol>
<li>存储字节码文件，包含所有的class文件和static变量(静态域)、常量(常量池)、即时编译后的代码等数据</li>
<li>静态域：存放类中以static声明的静态成员变量</li>
<li>常量池：在编译期间就将一部分数据存放于该区域，包含以final修饰的基本数据类型的常量值、String字符串。（在java6时它是方法区的一部分；1.7又把他放到了堆内存中；1.8之后出现了元空间，它又回到了方法区）</li>
</ol>
<h3><span id="类成员存储">类成员存储</span></h3>
<h3><span id="前提">前提</span></h3>
<p><a href="../%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">类加载及执行原理</a></p>
<h3><span id="属性存储">属性存储</span></h3>
<p>属性根据声明位置不同分为成员变量和局部变量</p>
<ol>
<li>局部变量声明在方法体中，在程序执行过程中随着方法被调用一起入栈，存储在栈的栈帧的局部变量表中</li>
<li>成员变量分为静态变量和实例变量
<ol>
<li>静态变量在类加载的准备阶段分配在方法体的静态域中，并设置初始值</li>
<li>实例变量则在程序执行中和对象实例一起存放在堆中</li>
</ol>
</li>
</ol>
<h3><span id="方法存储">方法存储</span></h3>
<p>方法根据是否用static修饰可以分为静态方法和实例方法</p>
<ol>
<li>实例方法：创建对象实例时，对象实例和该对象中的实例方法被存放在堆中，通过实例对象的引用调用实例方法</li>
<li>静态方法：随着类加载而加载到方法区中，但不会自动执行，可通过类名.方法名访问</li>
</ol>
<h4><span id="实例方法调用过程">实例方法调用过程</span></h4>
<ol>
<li>在JVM中的一个进程中，每个线程都会拥有一个<strong>方法调用栈</strong>，用于跟踪线程运行中一系列的方法调用过程</li>
<li>当线程调用一个方法时就会向方法栈中压入一个新栈帧。<strong>栈帧</strong>是用于支持虚拟机进行方法调用和方法执行的数据结构，也是虚拟机运行时数据区中的虚拟机栈的栈元素。</li>
<li>每个<strong>方法从调用开始至执行结束的过程</strong>，都对应着一个栈帧在虚拟机栈里面从<strong>入栈到出栈的过程</strong></li>
<li>当方法执行完成时，该栈帧就会<strong>弹出栈帧的元素作为这个方法的返回值</strong>（参数传递），并且清除这个栈帧</li>
<li><strong>栈顶</strong>的栈帧就是当前正在执行的方法</li>
<li>每个栈帧都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>();  <span class="comment">//function是对象引用存在栈中，new Funciotn()的实例放在堆中（包含方法区中的类型信息(方法信息等)引用等）。</span></span><br><span class="line">        function.out2();  <span class="comment">//调用out2方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Function</span>&#123; <span class="comment">//运行时把加载之后的Function的信息存入方法区（类型信息、常量、静态变量、方法信息等）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了out1方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out2</span><span class="params">()</span>&#123;</span><br><span class="line">        out1();   <span class="comment">//这块调用out1主要是为了展示栈帧和栈帧中的动态链接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行了out2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>启动Java虚拟机进程，通过<a href="../%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">类加载机制</a>加载编译后的.class文件</p>
</li>
<li>
<p>JVM定位到方法区中静态方法Main()的字节码，将main方法转换为栈帧压入方法调用栈，并开始顺序执行它的指令：</p>
<blockquote>
<p>Function function = new Function();<br>
function.out2();</p>
</blockquote>
</li>
<li>
<p>Function function = new Function():</p>
<ol>
<li>加载Function类。 把Function类的相关信息存放在了方法区中</li>
<li>JVM在堆中为一个新的Function类的实例分配内存。该实例有着指向方法区的Function类的类型信息的引用（内存地址）</li>
<li>使function变量指向堆区中的Function实例。即function变量有指向Function类的实例的引用。变量function为局部变量，因此它会被JVM存放到执行main()方法的方法调用栈中</li>
</ol>
</li>
<li>
<p>function.out2():</p>
<ol>
<li>
<p>将根据局部变量function的引用，定位到堆中的Function类的实例，再根据Function类的实例的引用，定位到方法区中Function类的类型信息（包括类，静态变量，静态方法，常量和成员方法），从而获取out2()方法的字节码</p>
</li>
<li>
<p>将out2()方法压入方法调用栈，并顺序执行out2()方法中的指令</p>
<blockquote>
<p>out1();<br>
System.out.println(“我是Yi_ding的方法”);</p>
</blockquote>
<ol>
<li>out2()方法调用out1()方法。根据动态链接（在运行时期将常量池中指向方法的符号引用转换为直接引用）来获取out1()方法的直接引用，并将out1()方法压入方法调用栈，并顺序执行out1()方法中的指令</li>
<li>输出&quot;执行了out1方法&quot;</li>
<li>out1()方法执行完成，out1()方法出栈</li>
</ol>
</li>
<li>
<p>输出&quot;执行了out2方法&quot;</p>
</li>
<li>
<p>out2()方法执行完成，out2()方法出栈</p>
</li>
</ol>
</li>
<li>
<p>main()方法执行完成，main()方法出栈，程序执行结束</p>
</li>
</ol>
<img src="https://pic.imgdb.cn/item/63b2fb02be43e0d30e96d7da.jpg" style="zoom:150%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java文档注释</title>
    <url>/post/Java%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<ul>
<li>
<p>注释可以提高代码的可读性，清晰完整的注释便于程序调试的过程</p>
</li>
<li>
<p>于编程者而言，书写注释是编程路上必须具有的良好习惯</p>
</li>
<li>
<p>对代码的解释说明,就像产品的说明书一样,良好的注释会减少团队的沟通成本</p>
</li>
</ul>
<span id="more"></span>
<ul>
<li>单行注释	/注释文字/</li>
<li>多行注释    /<em>注释文字</em>/     多行注释中不能有多行注释嵌套</li>
</ul>
<h1><span id="文档注释">文档注释</span></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span>	指定java程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 自从哪个版本号开始就存在了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的程序的说明文档。</p>
<p>操作方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc –d mydoc –author –version FileName.java</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown 入门使用</title>
    <url>/post/Markdown%20%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2><span id="介绍">介绍</span></h2>
<p>Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。</p>
<span id="more"></span>
<h2><span id="标题">标题</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h1><span id="标题1">标题1</span></h1>
<h2><span id="标题2">标题2</span></h2>
<h3><span id="标题3">标题3</span></h3>
<h4><span id="标题4">标题4</span></h4>
<h5><span id="标题5">标题5</span></h5>
<h6><span id="标题6">标题6</span></h6>
</blockquote>
<h2><span id="列表">列表</span></h2>
<h3><span id="有序列表">有序列表</span></h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">把大象放进冰箱：</span><br><span class="line"><span class="bullet">1.</span> 打开冰箱</span><br><span class="line"><span class="bullet">2.</span> 把大象放进冰箱</span><br><span class="line"><span class="bullet">3.</span> 关上冰箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把大象放进冰箱:</p>
<ol>
<li>打开冰箱</li>
<li>把大象放进冰箱</li>
<li>关上冰箱</li>
</ol>
</blockquote>
<h3><span id="无序列表">无序列表</span></h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">无序列表：</span><br><span class="line"><span class="bullet">-</span> 所爱扥就</span><br><span class="line"><span class="bullet">-</span> 撒欧丹发腮</span><br><span class="line"><span class="bullet">-</span> 哦啊赛季反扒</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无序列表：</p>
<ul>
<li>所爱扥就</li>
<li>撒欧丹发腮</li>
<li>哦啊赛季反扒</li>
</ul>
</blockquote>
<h2><span id="任务列表">任务列表</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">明天要做的事：	</span><br><span class="line"><span class="bullet">-</span> [ ] 吃饭	//每个字符之间由空格隔开	</span><br><span class="line"><span class="bullet">-</span> [ ] 睡觉</span><br><span class="line"><span class="bullet">-</span> [ ] 打豆豆</span><br></pre></td></tr></table></figure>
<blockquote>
<p>明天要做的事：</p>
<ul>
<li>[ ] 吃饭</li>
<li>[ ] 睡觉</li>
<li>[ ] 打豆豆</li>
</ul>
</blockquote>
<h2><span id="代码块">代码块</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">``` c      //选择语言</span></span><br><span class="line"><span class="code">int main()&#123;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="数学公式">数学公式：</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;\partial f&#125;&#123;\partial x&#125; = 2\sqrt&#123;a&#125;x</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$$<br>
\frac{\partial f}{\partial x} = 2\sqrt{a}x<br>
$$</p>
</blockquote>
<h2><span id="表格">表格</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|姓名|年龄|成绩|</span><br><span class="line">|:--|--:|:-----:| </span><br><span class="line"><span class="code">			//冒号靠左为左对齐，靠右为右对齐，两边都有冒号为居中对齐</span></span><br><span class="line"><span class="code">|张三|18|90|</span></span><br><span class="line"><span class="code">|李四|20|89|</span></span><br></pre></td></tr></table></figure>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:right">年龄</th>
<th style="text-align:center">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">张三</td>
<td style="text-align:right">18</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:left">李四</td>
<td style="text-align:right">20</td>
<td style="text-align:center">89</td>
</tr>
</tbody>
</table>
</blockquote>
<h2><span id="脚注">脚注</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一条注释[^注释]</span><br><span class="line">[<span class="symbol">^注释</span>]:<span class="link">这是注释的注释。</span></span><br><span class="line"> ---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一条注释<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<hr>
</blockquote>
<h2><span id="超链接">超链接</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span>)</span><br><span class="line">[<span class="string">百度</span>][<span class="symbol">id</span>]</span><br><span class="line">[<span class="symbol">id</span>]:<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span></span><br><span class="line"></span><br><span class="line">请参考[<span class="string">标题1</span>](<span class="link">#标题</span>)</span><br><span class="line"></span><br><span class="line">URL：</span><br><span class="line">http://www.baidu.com</span><br><span class="line"></span><br><span class="line">![<span class="string">百度</span>](<span class="link">https://imgse.com/i/z2p2JH&quot;百度搜索&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.baidu.com" title="一个搜索引擎">百度</a><br>
<a href="http://www.baidu.com" title="一个搜索引擎">百度</a></p>
<p>请参考<a href="#%E6%A0%87%E9%A2%98">标题1</a></p>
<p>URL：<br>
<a href="http://www.baidu.com">http://www.baidu.com</a></p>
<p><img src="https://pic.imgdb.cn/item/63914551b1fccdcd36559921.png%22%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%22" alt="百度"></p>
</blockquote>
<h2><span id="字体变化">字体变化</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="code">`行内代码printf()`</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">:smile:</span><br><span class="line">$\theta=x^2$</span><br><span class="line">H~2~O,x^2^</span><br><span class="line">==这是一段高亮文字==</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>斜体</em><br>
<strong>加粗</strong><br>
<code>行内代码printf()</code><br>
<u>下划线</u><br>
😄<br>
$\theta=x^2$<br>
H<sub>2</sub>O,x<sup>2</sup><br>
==这是一段高亮文字==</p>
</blockquote>
<h2><span id="参考视频">参考视频</span></h2>
<iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这是注释的注释。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Java语言概述</title>
    <url>/post/Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1><span id="介绍">介绍</span></h1>
<p>Java 是一种<strong>高级的、面向对象的、健壮的、多线程的、可跨平台的</strong>程序设计语言</p>
<span id="more"></span>
<h1><span id="java语言的特点">Java语言的特点</span></h1>
<h2><span id="简单">简单</span></h2>
<p>Java相较于C语言<strong>少了复杂的指针，仅支持单继承</strong></p>
<h2><span id="面向对象封装-继承-多态">面向对象（封装、继承、多态）</span></h2>
<h2><span id="健壮">健壮</span></h2>
<p>Java相较于C语言，<strong>无需开发人员对内存进行管理</strong>，Java本身预留一条线程监测内存并自动申请或释放（GC机制）</p>
<h2><span id="多线程">多线程</span></h2>
<p>Java支持<strong>多条线程并发进行</strong></p>
<h2><span id="跨平台">跨平台</span></h2>
<p>通过Java语言编写的应用程序可以在<strong>不同系统环境下运行</strong>（JVM）</p>
<h1><span id="java技术体系平台">Java技术体系平台</span></h1>
<h2><span id="javase">JavaSE</span></h2>
<p>Java标准版，主要面向<strong>桌面级应用程序</strong>的开发，为JavaEE、JavaME提供基础</p>
<h2><span id="javaee">JavaEE</span></h2>
<p>Java企业版，主要用于<strong>企业应用的、部署在服务器端的Java应用程序</strong>的开发</p>
<h2><span id="javame">JavaME</span></h2>
<p>Java微型版，支持Java在<strong>嵌入式等移动终端</strong>上运行</p>
<h2><span id="三者之间的关系">三者之间的关系</span></h2>
<p>JavaEE和JavaME都包含了JavaSE，因此学习JavaSE是学习JavaEE、JavaME的基础</p>
<img src="https://pic.imgdb.cn/item/6391cce1b1fccdcd36138138.png" alt="三者之间关系" style="zoom: 50%;">
<h1><span id="jvm-jre-jdk三者关系">JVM、JRE、JDK三者关系</span></h1>
<h2><span id="jvmjava-virtual-machine">JVM（Java Virtual Machine）</span></h2>
<p>Java虚拟机，Java源代码经过编译后生成的字节码需要通过Java虚拟机才能在不同的操作系统环境下运行。Java虚拟机是Java实现跨平台运行的关键。</p>
<p>JVM如何实现Java跨平台运行？</p>
<ul>
<li>对于不同的系统环境，提供了相对应的Java虚拟机</li>
<li>JVM接收源代码变异后的字节码，屏蔽了操作系统下的底层运行原理</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391d2a8b1fccdcd361c1520.png" alt="JVM实现原理" style="zoom: 50%;">
<h2><span id="jrejava-runtime-environment">JRE（Java Runtime Environment）</span></h2>
<p>Java运行环境，JRE包括JVM以及一些Java基本类库，JRE可满足运行Java应用程序的需求。</p>
<h2><span id="jdkjava-development-kit">JDK（Java Development Kit）</span></h2>
<p>Java开发工具包，JDK包括JRE以及Java开发工具，提供给开发人员使用</p>
<img src="https://pic.imgdb.cn/item/6391e28cb1fccdcd363743c4.png" style="zoom:50%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java加载及执行原理</title>
    <url>/post/Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1><span id="java程序执行原理">Java程序执行原理</span></h1>
<p>编程人员编写.Java源文件，经过编译器编译(javac)成.class字节码文件，字节码文件通过JVM的类加载器加载至执行引擎，执行引擎执行(java)字节码文件并与操作系统交互。</p>
<span id="more"></span>
<p><img src="https://pic.imgdb.cn/item/6393113db1fccdcd36e17411.png" alt="执行过程"></p>
<h1><span id="类加载的过程">类加载的过程</span></h1>
<p>加载、验证、准备、解析和初始化5个阶段</p>
<h2><span id="加载">加载</span></h2>
<ol>
<li>通过类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h2><span id="验证">验证</span></h2>
<p>目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</p>
<h2><span id="准备">准备</span></h2>
<p>正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值</p>
<ul>
<li>
<p>从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但方法区本身是一个逻辑上的区域（在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了）</p>
</li>
<li>
<p>内存分配只包括类变量，而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li>
<p>初始值通常指数据类型的零值。赋值指令是程序被编译后，存放于类构造器()方法之中，所以赋值动作要到类的初始化阶段才会被执行。</p>
</li>
</ul>
<h2><span id="解析">解析</span></h2>
<p>所有目标方法都是通过符号引用（在Class文件的常量池中）来调用。在类加载的解析阶段，会将部分<strong>符号引用</strong>转化为<strong>直接引用</strong>。这些符号引用所属的方法在程序运行前就有一个可确定的调用版本，且在运行期不可改变（编译期可知，运行期不可变）。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。</p>
<p>主要指静态方法和私有方法，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</p>
<blockquote>
<p>符号引用：以一组符号来描述所引用的目标。符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</p>
<p>直接引用：直接引用是可以直接指向目标的指针。相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
</blockquote>
<ul>
<li>
<p>虚拟机实现时可以自行判断，是在类被加载器加载时，还是等到符号引用将被使用时，对常量池中的符号引用进行解析</p>
</li>
<li>
<p>解析阶段中对它们的可访问性（public、protected、 private、）进行检查</p>
</li>
</ul>
<h2><span id="初始化">初始化</span></h2>
<p>Java虚拟机真正开始执行类中编写的Java程序代码</p>
<ul>
<li>
<p>准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序代码来初始化类变量和其他资源</p>
</li>
<li>
<p>初始化阶段是执行类构造器&lt;clint&gt;()方法的过程。</p>
</li>
</ul>
<h3><span id="ltclintgt方法">&lt;clint&gt;()方法</span></h3>
<ol>
<li>
<p>&lt;clint&gt;()不是代码中程序员直接编写的方法，它是Javac编译器的自动生成物</p>
</li>
<li>
<p>&lt;clint&gt;()方法由编译器自动收集并合并类中的所有类变量的赋值动作和静态代码块中的语句，收集的顺序与语句在源文件中出现的顺序一致</p>
</li>
<li>
<p>JVM会保证在子类的&lt;clint&gt;()方法执行前，父类的&lt;clint&gt;()方法已经执行完毕。&lt;clint&gt;()方法与类的实例构造函数不同，它不需要显式地调用父类构造器，父类的&lt;clint&gt;()方法会优先先执行，也就意味着父类的静态语句块要优先于子类的变量赋值操作，具体查看<a href="../%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">类加载的初始化顺序</a></p>
</li>
<li>
<p>如果类中没有静态语句块、对变量的赋值操作，编译器可以不为这个类生成&lt;clint&gt;()方法</p>
</li>
<li>
<p>即使接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clint&gt;()方法。但接口与类不同的是，父接口的&lt;clint&gt;()方法不需要先于子接口的&lt;clint&gt;()方法执行，接口的实现类在初始化时也不会先执行接口的&lt;clint&gt;()方法。因为只有当父接口中定义的变量被使用时，父接口才会被初始化。</p>
</li>
</ol>
<h1><span id="源文件-类-字节码文件">源文件、类、字节码文件</span></h1>
<ul>
<li>源文件中可包含一个或多个类</li>
<li>源文件中至多有一个类被public修饰，当源文件中有public修饰类，原文件名必须与public修饰类名一致，当源文件中没有public修饰类，则源文件名与类名没有关系</li>
<li>在编译的过程中，对应每个类会生成相应的.class字节码文件，也就是说，当源文件中存在多个类时，编译完成后，会生成多个与类名一致的.class字节码文件</li>
<li>执行过程中，只需要指定字节码文件运行</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>super</title>
    <url>/post/super/</url>
    <content><![CDATA[<p>super	超类的</p>
<span id="more"></span>
<h2><span id="子类对象实例化过程">子类对象实例化过程</span></h2>
<ul>
<li>
<p>不断向上查找直至到达顶层父类Object，然后不断向下依次调用父类的构造器进行父特征的初始化</p>
</li>
<li>
<p>整个过程只产生了一个对象</p>
</li>
</ul>
<p>super代表的就是父特征</p>
<h2><span id="使用">使用</span></h2>
<blockquote>
<p>super()</p>
</blockquote>
<p>继承体系中,一定会调用<strong>父类的构造器</strong>初始化父特征，super()是子类构造器默认的第一行</p>
<blockquote>
<p>super.成员</p>
</blockquote>
<p>调用<strong>父类的属性和方法</strong></p>
<h3><span id="调用父类的构造器">调用父类的构造器</span></h3>
<ol>
<li>子类中所有的构造器默认都会访问父类中无参数的构造器（默认有super()）</li>
<li>若父类中没有无参数的构造器，子类构造器必须调用本类或者父类中相应的构造器。即通过this(参数列表)或者super(参数列表)语句，且必须放在构造器的首行</li>
<li>若父类中没有无参数的构造器，且子类构造器中既未显式调用父类或本类的构造器，则编译出错</li>
</ol>
<h3><span id="super大多情况可省略">super（大多情况可省略）</span></h3>
<ul>
<li>当<strong>父类和子类的属性名称相同</strong>，必须使用super.属性指定父类的属性</li>
<li>当<strong>方法重写需要调用父类的同名属性或者方法</strong>的时候,super不能省略</li>
</ul>
<h3><span id="this和super">this和super</span></h3>
<table>
<thead>
<tr>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>static、final关键字、代码块</title>
    <url>/post/static%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<h1><span id="static">static</span></h1>
<h2><span id="修饰属性">修饰属性</span></h2>
<p>static修饰的属性称为：静态变量、全局变量、静态属性、全局属性、类变量、类属性，非static修饰的属性可称为实例变量</p>
<span id="more"></span>
<ul>
<li>静态属性随类的加载而加载，先于对象存在</li>
<li>静态属性仅存放JVM方法区的静态域中，所有对象共享</li>
</ul>
<p>静态属性常用于所有对象属性值唯一的属性，即属性值与对象无关</p>
<p><img src="https://pic.imgdb.cn/item/63a97c1608b6830163f144a1.png" alt></p>
<h2><span id="修饰方法">修饰方法</span></h2>
<p>static修饰的方法称为：静态方法，非static修饰的方法可称为实例方法</p>
<ul>
<li>静态方法随着类的加载而加载，先于对象存在</li>
<li>静态方法常通过 类名.方法名 调用</li>
<li>静态方法无法访问非静态属性、非静态方法，他们需要实例才可以访问</li>
<li>实例方法既可以访问静态属性、静态方法，也可以访问非静态属性、非静态方法</li>
</ul>
<p>静态方法常用于</p>
<p>1.工具类（直接使用  类名.方法名 调用，Math.random() ）</p>
<p>2.处理静态属性的方法</p>
<p><strong>main()方法</strong>也是静态方法，在main()方法中不能直接访问该类中的非静态成员，需要创建实例对象，通过实例对象访问该类中的非静态成员</p>
<p>main()方法中的关键字</p>
<ul>
<li>Java虚拟机需要访问main()方法，访问权限使用public</li>
<li>main()方法无需创建实例对象，使用static</li>
<li>接收个String类型的数组参数，可通过java指令传参   <strong>java 类名  “XXX” “XXX” “XXX”</strong></li>
</ul>
<h2><span id="修饰代码块">修饰代码块</span></h2>
<p>static修饰的代码块，当类被载入时，静态代码块被执行，且只被执行一次，常用于初始化静态属性</p>
<ul>
<li>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">    System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="静态代码块-静态方法区别">静态代码块 静态方法区别</span></h3>
<table>
<thead>
<tr>
<th>静态代码块</th>
<th>静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>在类加载时自动执行，且只执行一次</td>
<td>在类加载时加载到方法区,其他程序来调用时,无需创建对象,通过类名.方法名执行</td>
</tr>
</tbody>
</table>
<h2><span id="修饰内部类">修饰内部类</span></h2>
<h3><span id="为什么静态方法无法直接访问非静态成员">为什么静态方法无法直接访问非静态成员</span></h3>
<ol>
<li>静态方法在类加载的解析阶段实现了符号引用转换成直接引用，在类加载后就能通过类名.方法名访问</li>
<li>而非静态成员要等到符号引用被使用时（即类加载后的初始化阶段），才会对常量池中指向非静态成员的符号引用进行解析，因为非静态成员可能在运行期间发生改变（变量赋值、方法重写）</li>
<li>在静态方法解析完成时，非静态成员可能仍未开始解析，因此静态方法获取不了非静态成员的直接引用，即无法访问非静态成员</li>
<li>在静态方法中定义非静态成员所属类的实例对象，通过对象可以访问类的非静态成员</li>
</ol>
<h3><span id="为什么非静态成员为什么无法容纳静态成员">为什么非静态成员为什么无法容纳静态成员</span></h3>
<h4><span id="实例方法无法定义静态属性">实例方法无法定义静态属性</span></h4>
<ol>
<li>静态属性是属于类的，在类加载阶段就加载到方法区的静态域中</li>
<li>实例方法等到它被调用时，它的符号引用才被解析，然后被JVM压入方法调用栈</li>
<li>如果实例方法中定义了静态属性，实例方法被调用时才被解析，无法满足其静态变量在类加载阶段就被解析；</li>
<li>而且实例方法中的属性会随着方法压入栈中，而静态变量唯一存放在方法区的静态域中</li>
</ol>
<h4><span id="实例内部类无法访问静态成员属性-静态方法-静态代码块">实例内部类无法访问静态成员（属性、静态方法、静态代码块）</span></h4>
<p>假设实例内部类中定义了静态成员，在类加载时，静态成员就应被初始化，定义了静态成员的实例内部类作为外部类的成员之一，还需要通过外部类实例对象被调用才会被初始化，因此无法实现在类加载时实现实例内部类的静态初始化。(JDK16以后可以)</p>
<p>但是实例内部类中可以定义static、final常量，常量在编译期就是确定的，加载常量不需要加载它所属的实例内部类</p>
<h1><span id="代码块">代码块</span></h1>
<p>代码块只能有static关键字来修饰，其中static修饰的称为静态代码块，否则称为实例代码块，代码块是为了对Java类或对象进行初始化</p>
<table>
<thead>
<tr>
<th>静态代码块</th>
<th>非静态代码块</th>
</tr>
</thead>
<tbody>
<tr>
<td>随着类的加载而加载，仅执行一次</td>
<td>每次创建对象都执行一次，先于构造器执行</td>
</tr>
<tr>
<td>静态代码块先于非静态代码块执行</td>
<td></td>
</tr>
<tr>
<td>静态代码块间顺序执行</td>
<td>非静态代码块间顺序执行</td>
</tr>
<tr>
<td>不可以调用非静态的属性和方法。</td>
<td>既能调用非静态成员，还能调用静态成员</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Order&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    	orderId = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    	orderId = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;<span class="comment">//同级别顺序执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">        System.out.print(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();      <span class="comment">//BCEF</span></span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();      <span class="comment">//BCEF</span></span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Father</span>();   <span class="comment">//BC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ADG************************</span><br><span class="line">BCEF************************</span><br><span class="line">BCEF************************</span><br><span class="line">BC</span><br></pre></td></tr></table></figure>
<h1><span id="final">final</span></h1>
<ol>
<li>使用final修饰的类不能被继承</li>
<li>使用final修饰的方法不能被重写</li>
<li>使用final标记的变量称为常量。名称大写，且只能被赋值一次。</li>
</ol>
<p>final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</p>
<ul>
<li>final修饰基本数据类型的变量，值不能改变</li>
<li>修饰引用型数据类型的变量时，地址不能改变</li>
</ul>
<p>final、static同时修饰的属性为：全局唯一常量</p>
<h1><span id="单例模式">单例模式</span></h1>
<p>保证整个系统中一个类只有一个对象的实例，实现这种功能的方式就叫单例模式</p>
<ol>
<li>构造私有: 如果要保证一个类不能多次被实例化，那么我肯定要阻止对象被new 出来，所以需要把 类的所有构造方法私有化。</li>
<li>以静态方法返回实例。 因为外界就不能通过new来获得对象，所以我们要通过提供类的方法来让外界获取对象实例。</li>
<li>确保对象实例只有一个。 只对类进行一次实例化，以后都直接获取第一次实例化的对象。</li>
</ol>
<h2><span id="懒汉模式">懒汉模式</span></h2>
<p>先不创建类的对象实例，等你需要的时候我再创建，线程不安全 节省资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstence</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="饿汉模式">饿汉模式</span></h2>
<p>我先把对象（面包）创建好，等我要用（吃）的直接直接来拿就行了，浪费资源  线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Object类</title>
    <url>/post/Object%E7%B1%BB/</url>
    <content><![CDATA[<p>Object类是所有类的根类,如果一个类没有显示的继承其他类,默认继承Object</p>
<p>Object的类型变量可以指向任意类型的子类对象</p>
<span id="more"></span>
<h2><span id="int-hashcode">int hashCode()</span></h2>
<p>返回该对象的哈希码值 ，可以类似的看做虚拟内存地址</p>
<p>hashCode作用是用于散列表（hash算法）中的一个参数（寻找到一个数组下标位）【用于HashSet集合去重重复的关键参数之一】</p>
<ul>
<li>引用类型（注意是没有重写过hashCode）Object计算hashCode是以对象的地址为基本数据，进行二进制换算</li>
<li>String对象的字符序列一样，则hashCode一样</li>
<li>值类型的数值一旦一样，则hashCode一样</li>
<li>布尔的哈希值true=1231,false=1237</li>
</ul>
<h2><span id="classltgt-getclass">Class&lt;?&gt; getClass()</span></h2>
<p>返回此对象的运行时类。看创建对象是哪个类</p>
<table>
<thead>
<tr>
<th>getClass()</th>
<th>getClass().getName()</th>
<th>getClass().getSimpleName()</th>
</tr>
</thead>
<tbody>
<tr>
<td>class  包名.类名</td>
<td>包名.类名</td>
<td>类名</td>
</tr>
</tbody>
</table>
<h2><span id="string-tostring">String toString()</span></h2>
<p>返回该对象的字符串表示。</p>
<ul>
<li>
<p>默认实现 类的全限定名@hashcode的十六进制</p>
</li>
<li>
<p>自定义类如果不想按照上面的格式输出 需要重写toString()</p>
</li>
</ul>
<h2><span id="protected-void-finalize">protected void finalize()</span></h2>
<p>当对象不再被程序使用时，垃圾回收器将会将其回收</p>
<p>垃圾回收是在后台运行的，我们无法命令垃圾回收器马上回收资源，但是我们可 以告诉他，尽快回收资源（<strong>System.gc</strong> 和 Runtime.getRuntime().gc()）</p>
<p>垃圾回收器在回收某个对象的时候，首先会调用该对象的 finalize 方法</p>
<p>GC 主要针对堆内存 当垃圾收集器将要收集某个垃圾对象时将会调用 finalize，建议不要使用此方法，因为此方法的运行时间不确定，如果执行此方法出现错误，程序不会报告，仍然继续运行</p>
<h2><span id="boolean-equalsobject-obj">boolean equals(Object obj)</span></h2>
<p>指示其他某个对象是否与此对象“相等”。</p>
<h2><span id="和-equals-区别">== 和 equals 区别?</span></h2>
<table>
<thead>
<tr>
<th>== 比较运算符</th>
<th>equals是object中的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>既可以比较基本数据类型 也可以比较引用数据类型</td>
<td>只能比较引用数据类型</td>
</tr>
<tr>
<td>对于引用数据类型，比较的是地址</td>
<td>默认情况下equals方法底层使用==实现, 和 equals比较结果是一样</td>
</tr>
<tr>
<td></td>
<td>可重写成比较属性是否相等</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//存储在方法区同一地址下</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3.equals(str4));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>比较引用数据类型，使用equals更好</p>
<p>对于File、String、Date及包装类来说，是比较类型及内容而不考虑引用的是否是同一个对象；</p>
<p>原因：在这些类中重写了Object类的 equals()方法</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/post/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>当一个事物的内部，有一个完整、复杂部分不能简单使用属性或者方法来描述时，且该结构只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</p>
<p>在Java中，允许一个类的定义位于另一个类的内部，该类称为内部类，被定义的类称为外部类</p>
<p>内部类一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</p>
<p>内部类的名字不能与包含它的外部类类名相同；</p>
<p>内部类按照声明位置又分为成员内部类和局部内部类</p>
<span id="more"></span>
<h2><span id="成员内部类">成员内部类</span></h2>
<p>成员内部类声明在外部类的成员位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">TestPojo</span> <span class="keyword">implements</span> <span class="title class_">TestInterface</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我正在跑！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testf</span><span class="params">()</span> &#123;<span class="comment">//重写的接口方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;实现接口！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法里面调用内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.testf(); <span class="comment">// 掉用重写接口方法</span></span><br><span class="line">        b.run(); 　<span class="comment">// 调用自己的方法</span></span><br><span class="line">        b.testpojo(); <span class="comment">// 调用继承父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// main 方法测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() ;</span><br><span class="line">        a.test() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义了一个接口 ，方法为testf()</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TestInterface</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testf</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义了一个普通类 方法testpojo()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestPojo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testpojo</span><span class="params">()</span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;我是简单的pojo类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 调用内部类里面的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Textone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>().<span class="keyword">new</span> <span class="title class_">B</span>() ; <span class="comment">//调用类A里面的内部类B</span></span><br><span class="line">        <span class="comment">/** 等同于 下面代码</span></span><br><span class="line"><span class="comment">        * A a = new A() ;</span></span><br><span class="line"><span class="comment">        * A.B b = a.new B() ;</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        b.testf() ; <span class="comment">// 掉用重写接口方法</span></span><br><span class="line">        b.run() ; <span class="comment">// 调用自己的方法</span></span><br><span class="line">        b.testpojo() ; <span class="comment">// 调用继承父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="特点">特点</span></h3>
<h4><span id="作为类的成员">作为类的成员</span></h4>
<table>
<thead>
<tr>
<th>类的成员</th>
<th>成员内部类</th>
</tr>
</thead>
<tbody>
<tr>
<td>可被static、final修饰，abstract可修饰方法</td>
<td>可被static、abstract、final修饰</td>
</tr>
<tr>
<td>可被4种访问权限修饰符修饰</td>
<td>可被(public default protected private) 访问权限修饰符修饰，，类一般只能被public、default修饰</td>
</tr>
<tr>
<td>方法可直接访问类的其他成员(包括private成员)</td>
<td>实例内部类可直接访问外部类的所有成员(包括private成员)；静态内部类只能访问外部类的静态成员(类似静态方法只能访问静态成员)</td>
</tr>
<tr>
<td>存在同名成员则编译报错</td>
<td>实例内部类和外部类有同名成员，可使用<code>外部类名.this.成员名</code> 访问外部类成员；静态内部类和外部静态成员同名，使用<code>类名.静态成员名</code>访问</td>
</tr>
</tbody>
</table>
<h4><span id="作为类">作为类</span></h4>
<table>
<thead>
<tr>
<th>类</th>
<th>成员内部类</th>
</tr>
</thead>
<tbody>
<tr>
<td>类的成员</td>
<td>可定义类的所有成员（属性、方法、构造器、代码块、内部类）</td>
</tr>
<tr>
<td>创建实例对象</td>
<td>构建内部类对象（静态内部类、实例内部类构建方式不同）</td>
</tr>
<tr>
<td>编译生成字节码文件</td>
<td>编译后生成独立字节码文件(<code>外部类名$内部类名.class</code>)（也适用于局部内部类）</td>
</tr>
</tbody>
</table>
<h4><span id="静态内部类和实例内部类">静态内部类和实例内部类</span></h4>
<table>
<thead>
<tr>
<th></th>
<th>静态内部类(有static修饰)</th>
<th>实例内部类(没有static修饰)</th>
</tr>
</thead>
<tbody>
<tr>
<td>构建内部类对象</td>
<td><code>new 外部类名.内部类名()</code></td>
<td><code>new 外部类名().new 内部类名()) </code></td>
</tr>
<tr>
<td>外部类访问内部类成员</td>
<td>静态成员:<code>静态内部类完整类名.静态成员</code>实例成员：先创建静态内部类对象<code>静态内部类对象.实例成员</code></td>
<td>先创建实例内部类对象<code>实例内部类对象.成员</code></td>
</tr>
<tr>
<td>内部类访问外部来成员</td>
<td>只能访问外部类的静态成员(类似静态方法只能访问静态成员)</td>
<td>可直接访问外部类的所有成员(包括private成员)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>实例内部类中不能声明静态成员，只有在外部类或静态内部类中 才可声明static成员</td>
</tr>
</tbody>
</table>
<h4><span id="为什么实例内部类不能声明静态成员">为什么实例内部类不能声明静态成员？</span></h4>
<p>在类加载的时候，static变量就会被初始化，内部类对象在没有外部类这个对象时便生成了，这样这个成员内部类就脱离了外部类的掌控，不需要外部类的对象就可以生成内部类的对象，这与成员内部类的定义就相驳了，因为我们知道成员内部类的对象必须是现有外部类的对象才能创建</p>
<h2><span id="局部内部类">局部内部类</span></h2>
<p>局部内部类声明在外部类的方法内，类似于局部变量，有效范围在方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">// 定义一个方法</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Ne</span>&#123; <span class="comment">// 定义一个方法内部类</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fle</span><span class="params">()</span>&#123; <span class="comment">// 定义方法内部类的方法</span></span><br><span class="line">            	System.out.println(<span class="string">&quot;我正在飞翔！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     	&#125; ;</span><br><span class="line">     	<span class="keyword">new</span> <span class="title class_">Ne</span>().fle() ; <span class="comment">//调用内部类的方法</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PerTest</span>().test() ; <span class="comment">//测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>权限修饰符修饰：不能使用static abstract</p>
</li>
<li>
<p>字节码名称:外部类名$标号内部类名.class</p>
</li>
<li>
<p>局部内部类使用的外部局部变量会自动将该变量识别为final的</p>
</li>
</ul>
<ol>
<li>方法内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化</li>
</ol>
<h4><span id="方法内部类对象不能使用该内部类所在方法的非final局部变量">方法内部类对象不能使用该内部类所在方法的非final局部变量。</span></h4>
<p>因为方法的局部变量位于栈上，只存在于该方法的生命期内。当一个方法结束，其栈结构被删除，局部变量成为历史。但是该方法结束之后，在方法内创建的内部类对象可能仍然存在于堆中！例如，如果对它的引用被传递到其他某些代码，并存储在一个成员变量内。正因为不能保证局部变量的存活期和方法内部类对象的一样长，所以内部类对象不能使用它们。</p>
<h3><span id="匿名内部类匿名抽象类-匿名实现类">匿名内部类(匿名抽象类 匿名实现类)</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)、抽象匿名内部类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">//方法为test</span></span><br><span class="line">        <span class="type">TestA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestA</span>()&#123; <span class="comment">//实现抽象类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//实现抽象类的方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;我正在使用抽象匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        a.run() ; <span class="comment">//调用内部类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbstractClass</span>().test() ; <span class="comment">//测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个抽象类 TestA 抽象方法为run()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestA</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>)、接口匿名内部类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnonymous</span> &#123;</span><br><span class="line">    <span class="type">MyInterface</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>()&#123; <span class="comment">//实现接口</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">//重写MyInterface 接口方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;我正在吃饭！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; ;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ss</span><span class="params">()</span>&#123; <span class="comment">//方法ss</span></span><br><span class="line">        m.eat() ; <span class="comment">//调用重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">TestAnonymous</span>().ss() ; <span class="comment">//测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个接口 方法为 eat</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：匿名内部类可以定义在方法内也可以定义在类的成员中，不管是那种匿名内部类都不能被外部类直接调用</p>
<h3><span id="内部类的作用">内部类的作用</span></h3>
<p>每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。</p>
<h4><span id="内部类如何实现多继承">内部类如何实现多继承</span></h4>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>变量</title>
    <url>/post/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>由于变量能够把程序中准备使用的每一段数据都赋给一个简短、易于记忆的名字，因此它们十分有用。变量可以保存程序运行时用户输入的数据、特定运算的结果以及要在窗体上显示的一段数据等。简而言之，变量是用于跟踪几乎所有类型信息的简单工具。</p>
<span id="more"></span>
<h1><span id="数据">数据</span></h1>
<p>字面量即数据</p>
<h2><span id="数据类型">数据类型</span></h2>
<h1><span id="变量">变量</span></h1>
<h2><span id="变量使用">变量使用</span></h2>
<h3><span id="声明变量">声明变量</span></h3>
<p>int var;</p>
<h3><span id="变量的赋值">变量的赋值</span></h3>
<p>var = 10;</p>
<h3><span id="声明和赋值变量">声明和赋值变量</span></h3>
<p>int var = 10; （数据类型，存储范围）</p>
<ul>
<li>Java可以在一行声明多个变量,例如: int a,b,c; long a,b,c=100</li>
<li>局部变量声明后必须赋值才能使用</li>
</ul>
<h3><span id="变量的作用域局部变量">变量的作用域（局部变量）</span></h3>
<p>变量的作用域在前后花括号{}之间，作用域外相当于没有声明过该变量</p>
<p>作用域内只能有一个同名变量</p>
<h2><span id="变量分类">变量分类</span></h2>
<p>变量可按照声明位置、数据类型分类</p>
<h3><span id="按声明位置">按声明位置</span></h3>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量。</li>
<li>二者都有生命周期，但局部变量除形参外，需初始化。</li>
</ul>
<h3><span id="按数据类型">按数据类型</span></h3>
<p>变量的类型必须与数据的类型一致</p>
<img src="https://pic.imgdb.cn/item/639332ffb1fccdcd36247b54.png" alt="数据类型" style="zoom: 67%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>包装类的使用</title>
    <url>/post/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>针对八种基本数据类型定义相应的引用类型—包装类</p>
<p>首先,Java语言是一个面向对象的语言,但是Java中的基本数据类型却是不面向对象的，为了实现一 切皆对象,将每个基本数据类型设计一个对应的类进行代表，这种方式增强了Java面向对象的性质。</p>
<p>其次，如果仅仅有基本数据类型，那么在实际使用时将存在很多的不便，很多地方都需要使用对象。比如，在集合类中，我们是无法将int 、double等类型放进去的，因为集合的容器要求元素是Object类型。而包装类型的存在使得向集合中传入数值成为可能，包装类的存在弥补了基本数据类型的不足。</p>
<p>此外，包装类还为基本类型添加了属性和方法，丰富了基本类型的操作。如当我们想知道int取值 范围的最小值，我们需要通过运算，如下面所示，但是有了包装类，我们可以直接使Integer.MAX_VALUE即可。</p>
<p>注意:为什么要保留基本数据类型？Java种创建的对象都是存储在堆里的，使用的时候需要通过栈中的引用， 所以常用的基本数据类型，不需要使用new在堆上创建，而是直接在栈内存中存储不创建对象，就会比较高效。</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<h2><span id="装箱和拆箱">装箱和拆箱</span></h2>
<h3><span id="基本数据类型转换为包装类装箱">基本数据类型转换为包装类(装箱)</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Byte</span>(<span class="number">123</span>); 	<span class="comment">//通过构造器 </span></span><br><span class="line"><span class="type">Short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Short</span>(<span class="string">&quot;123&quot;</span>);<span class="comment">//NumberFormatException </span></span><br><span class="line"></span><br><span class="line"><span class="type">Interger</span> <span class="variable">t</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>); <span class="comment">//通过包装类的valueOf()方法 </span></span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> Long.valueOf(<span class="string">&quot;123&quot;</span>) <span class="comment">//NumberFormatException </span></span><br></pre></td></tr></table></figure>
<h3><span id="包装类转换为基本数据类型拆箱">包装类转换为基本数据类型(拆箱)</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> obj.booleanValue(); <span class="comment">//调用包装类的.xxxValue()方法</span></span><br></pre></td></tr></table></figure>
<h3><span id="自动拆装箱">自动拆装箱</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; </span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> i; </span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t<span class="comment">// jdk5之后出现自动拆装箱 </span></span><br></pre></td></tr></table></figure>
<h2><span id="基本类型和字符串">基本类型和字符串</span></h2>
<h3><span id="字符串转换成基本数据类型">字符串转换成基本数据类型</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;12&quot;</span>);<span class="comment">//通过包装类的构造器实现：</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.valueOf(<span class="string">&quot;123&quot;</span>);<span class="comment">//通过包装类的valueOf()实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(<span class="string">&quot;12.1&quot;</span>);<span class="comment">//通过包装类的parseXxx(String s)静态方法：</span></span><br></pre></td></tr></table></figure>
<h3><span id="基本数据类型转换成字符串">基本数据类型转换成字符串</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= String.valueOf(<span class="number">2.34f</span>);<span class="comment">//调用字符串重载的valueOf()方法：</span></span><br><span class="line"></span><br><span class="line">String str= <span class="number">5</span> + “”<span class="comment">//使用+做字符串连接</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类</th>
<th>字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本数据类型转换成</td>
<td>\</td>
<td>包装类构造器、包装类.valueOf(X)、自动</td>
<td>包装类.valueOf(X)、字符串拼接</td>
</tr>
<tr>
<td>包装类转换成</td>
<td>包装类实例对象.XXXValue()、自动</td>
<td>\</td>
<td>包装类.toString()</td>
</tr>
<tr>
<td>字符串转换成</td>
<td>包装类构造器、包装类.valueOf(X)、包装类.parseXxx(X)</td>
<td>包装类构造器、包装类.valueOf(X)</td>
<td>\</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63aaec6708b6830163fb2d26.png" alt></p>
<h2><span id="包装类中的缓存机制">包装类中的缓存机制</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//Integer num1 = 10;</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println((num1 == num2) +<span class="string">&quot;\t&quot;</span>+ num1.equals(num2));<span class="comment">//true	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line">System.out.println((num3 == num4) +<span class="string">&quot;\t&quot;</span>+ num3.equals(num4));<span class="comment">//false	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println((num5 == num6) +<span class="string">&quot;\t&quot;</span>+ num5.equals(num6));<span class="comment">//false	true</span></span><br></pre></td></tr></table></figure>
<p>Integer类第一次被使用时，Integer的静态内部类就被加载，加载的时候会创建-128到127的 Integer对象，同时创建一个数组cache来缓存这些对象。</p>
<ul>
<li>当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，不会再新建对象；</li>
<li>当使用new关键字或者使用valueOf()方法创建小于-128大于 127的值对象时，就会创建新对象。</li>
</ul>
<table>
<thead>
<tr>
<th>Character、Byte、Short、Integer、Long</th>
<th>Boolean</th>
<th>Float、Double</th>
</tr>
</thead>
<tbody>
<tr>
<td>有缓存区，且实现方式基本一样，都是-128到127的缓存范围。</td>
<td>没有缓存区，但在成员变量中就创建了两个相应的对象true、false</td>
<td>没有缓存区，即使在0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</td>
</tr>
</tbody>
</table>
<p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p>
<h2><span id="基本数据类型与包装类区别">基本数据类型与包装类区别</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类（引用数据类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员</td>
<td>\</td>
<td>可调用各种属性及方法</td>
</tr>
<tr>
<td>实例化</td>
<td>不需要实例化</td>
<td>必须实例化后才能使用</td>
</tr>
<tr>
<td>存储方式</td>
<td>直接存储数据值</td>
<td>实际是对象的引用</td>
</tr>
<tr>
<td>默认值</td>
<td>有默认值</td>
<td>默认值是null</td>
</tr>
<tr>
<td>空指针异常</td>
<td>不会发生空指针异常</td>
<td>可能发生空指针异常</td>
</tr>
<tr>
<td>强制转换</td>
<td>可以强制转换为其他类型</td>
<td>不能强制转换为其他类型</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/post/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>当我们使用代码描述主人喂养宠物的场景，首先在这个场景当中应该有“宠物对象” ，宠物对象应该有吃的行为，另外还需要一个“主人对象” ，主人对象应该有一个喂的行为。然而对于不同的宠物，吃的行为也不相同，或许是吃的东西不同，也或许是吃的方式不同，此时每当出现新的宠物时，我们就需要修改对于宠物吃行为的描述，这不符合OCP原则。对于需要更改的“宠物对象”，应当将其“封装”起来，在新的模块中对宠物不同的吃行为进行描述，而无需修改原本“宠物对象”的描述。</p>
<span id="more"></span>
<h1><span id="多态polymorphism">多态(polymorphism)</span></h1>
<p>编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)多态情况</p>
<h2><span id="前提">前提</span></h2>
<p>继承或实现</p>
<p>重写</p>
<h2><span id="现象">现象</span></h2>
<ol>
<li>父类引用类型变量指向多种子类对象(父父new子)</li>
<li>该变量不能再访问子类中新添加的属性和方法（局限）</li>
<li>属性没有多态，即使子类有同名属性，编译期和运行期也访问的是父类的属性，但可以通过子类重写的方法调用子类的属性</li>
<li>子类重写父类的方法，编译期看到的是父类中的方法,运行期执行的是子类重写后的方法(编译期看左边 运行期看右边)</li>
</ol>
<h2><span id="原理">原理</span></h2>
<h3><span id="虚拟方法调用多态情况下">虚拟方法调用(多态情况下)</span></h3>
<p>子类中定义了与父类同名同参数的方法,此时父类的方法称为<strong>虚拟方法</strong>(Virtual Method Invocation)</p>
<ul>
<li>
<p>在编译期，对象还没有创建出出来，只能看到父类的虚拟方法</p>
</li>
<li>
<p>直到运行期,真正的子类对象被创建出来,父类引用变量得到具体的子类对象地址，并动态调用子类重写的该方法。（动态绑定）</p>
</li>
</ul>
<h3><span id="静态绑定与动态绑定">静态绑定与动态绑定</span></h3>
<p>重载，允许存在多个同名不同参数方法。编译器根据方法不同的参数列表，对同名方法的名称做修饰。同名方法就成了不同的方法。 它们的调用地址在编译期就绑定了。因此，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定” ；</p>
<p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或 “动态绑定 ” 。</p>
<h2><span id="作用">作用</span></h2>
<p>提高了代码的通用性、提高软件的扩展性、实现软件设计的解耦</p>
<h2><span id="应用">应用</span></h2>
<p>当方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</p>
<h2><span id="类型转换casting">类型转换(Casting)</span></h2>
<h3><span id="基本数据类型">基本数据类型</span></h3>
<ul>
<li>
<p>自动类型转换：小的数据类型可以自动转换成大的数据类型</p>
</li>
<li>
<p>强制类型转换：可以把大的数据类型强制转换成小的数据类型</p>
</li>
</ul>
<h3><span id="引用数据类型">引用数据类型</span></h3>
<p>对Java对象的强制类型转换称为<strong>造型</strong></p>
<ul>
<li>
<p>向上转型：从子类到父类的类型转换可以自动进行(多态)</p>
</li>
<li>
<p>向下转型：从父类到子类的类型转换必须通过造型(强制类型转换)实现</p>
</li>
<li>
<p>无继承关系的引用类型间的转换是非法的</p>
</li>
</ul>
<p>多态情况下，当我们需要访问子类中新添加的属性和方法时，需要向下转型（强转）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);		<span class="comment">//调用的是子类重写父类的方法	sub_1</span></span><br><span class="line">    <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> (Sub)base;		<span class="comment">//造型</span></span><br><span class="line">    s.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);			<span class="comment">//调用的是子类独有的方法	sub_2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="instanceof-操作符">instanceof 操作符</span></h3>
<p>在造型前可以使用instanceof操作符测试一个对象的类型</p>
<p>x instanceof A：</p>
<ul>
<li>
<p>检验x是否为类A的对象，返回值为boolean型。 x是A类对象返回true，反之返回false</p>
</li>
<li>
<p>如果x属于类A的子类B，返回值也为true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;…&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graduate</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;…&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(Person e)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Person) <span class="comment">// 处理Person类及其子类对象 </span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) <span class="comment">//处理Student类及其子类对象 </span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Graduate) <span class="comment">//处理Graduate类及其子类对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x所属的类与A类对象没有继承关系，则编译错误。</p>
<h2><span id="验证多态是运行时行为">验证：多态是运行时行为</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            animal = <span class="keyword">new</span> <span class="title class_">Cat</span> ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            animal = <span class="keyword">new</span> <span class="title class_">Dog</span> ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    animal.eat();<span class="comment">//运行时才能确定animal引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; animal eat food&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; cat eat fish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog eat bone &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/post/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1><span id="异常">异常</span></h1>
<ul>
<li>java程序运行的时候或编译的时候可能引发异常
<ul>
<li>编译的时候引发的异常会导致无法编译</li>
<li>运行时引发的异常会到导致程序终止</li>
</ul>
</li>
<li>异常在java中也是面向对象的，Java通过API中Throwable类的众多子类描述各种不同的异常。描述了出现在一段编码中的错误条件。当条件生成时，错误将引发异常。</li>
</ul>
<h2><span id="结构">结构</span></h2>
<img src="https://pic.imgdb.cn/item/63bfed14be43e0d30e1d66cd.jpg">
<h3><span id="throwable">Throwable</span></h3>
<p>异常的父类</p>
<h3><span id="exception">Exception</span></h3>
<p>是程序本身可以处理的异常。异常需要捕获和处理，否则无法编译。</p>
<h3><span id="error">Error</span></h3>
<p>错误，是程序无法处理的错误，表示运行应用程序中较严重问题。</p>
<p>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题，JVM一般会选择线程终止。。例如，</p>
<ol>
<li>Java虚拟机运行错误（Virtual MachineError）</li>
<li>JVM不再有继续执行操作所需的内存资源（OutOfMemoryError）。</li>
<li>Java虚拟机运行错误（Virtual MachineError）</li>
<li>类定义错误（NoClassDefFoundError）</li>
</ol>
<p>这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况</p>
<h3><span id="runtimeexception">RuntimeException</span></h3>
<p>Exception的子类，运行时异常，无需要捕获和处理，也能编译，但是运行时发生错误，则程序会终断，因此运行时异常还是需要捕获和处理</p>
<p>通常表示“JVM 常用操作”引发的错误。例如，</p>
<ol>
<li>
<p>若试图使用空值对象引用（NullPointerException）</p>
</li>
<li>
<p>除数为零（ArithmeticException）</p>
</li>
<li>
<p>数组越界（ArrayIndexOutOfBoundException）</p>
<p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
</li>
</ol>
<h2><span id="分类">分类</span></h2>
<p>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</p>
<h3><span id="可查异常">可查异常</span></h3>
<ul>
<li>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常</li>
<li>可查异常在一定程度上可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</li>
<li>Java编译器会检查它，当程序中可能出现这类异常，必须用try-catch语句捕获或throws子句声明抛出，否则编译不会通过</li>
</ul>
<h3><span id="不可查异常">不可查异常</span></h3>
<ol>
<li>包括运行时异常（RuntimeException与其子类）和错误（Error）</li>
<li>编译器不要求强制处置，可以不用try-catch语句捕获、不用throws子句声明抛出，编译可通过</li>
</ol>
<h2><span id="处理异常机制">处理异常机制</span></h2>
<p>在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常</p>
<h3><span id="抛出异常">抛出异常</span></h3>
<p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行</p>
<p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常</p>
<h3><span id="捕获异常">捕获异常</span></h3>
<p>在方法抛出异常之后，运行时系统将转为寻找处理的异常类型与方法抛出的异常类型相符的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
<p>捕捉异常通过try-catch语句或者try-catch-finally语句实现</p>
<p>总结：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>
<h2><span id="try-catch语句">try、catch语句</span></h2>
<ul>
<li>捕获处理异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a = scanner.nextInt();    <span class="comment">//捕获异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);    <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="try-catch-catch-">try-catch-catch-…</span></h2>
<ul>
<li>多路catch</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a = scanner.nextInt();            <span class="comment">//捕获异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);            <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;出现了未知名的错误&quot;</span>);            <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    a[index] = scanner.nextInt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InputMismatchException e) &#123;</span><br><span class="line">    <span class="comment">//打印错误堆栈</span></span><br><span class="line">    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//打印错误消息</span></span><br><span class="line">    <span class="comment">//e.getMessage();</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你输入的下标超标&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    System.out.println(<span class="string">&quot;不知名错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</p>
<h2><span id="try-catch-finally语句">try、catch、finally语句</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//捕获异常</span></span><br><span class="line">    a = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="try-catch-finally-return">try、catch、finally、return</span></h2>
<h3><span id="try-catch-finally中都有return">try、catch、finally中都有return</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;        <span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;        <span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MyApp3.fun1();</span><br><span class="line">    System.out.println(i);<span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会将try或catch中的return语句”覆盖“掉，直接执行finally中的return语句，得到返回值</p>
<h3><span id="finally中没有return">finally中没有return</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;        <span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;        <span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MyApp3.fun1();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行finally中的语句后，从try或catch中返回</p>
<h3><span id="finally中没有return但修改了返回值">finally中没有return但修改了返回值</span></h3>
<p>无论是try还是catch里面的return返回规则为：</p>
<ul>
<li>值类型：return会第一次记录值，然后finally，然后再return（finally无法修改return结果）</li>
<li>引用类型：return会第一次记地址，然后finally，然后再return（finally可以修改return结果）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        b=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;<span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        b=<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">        b=<span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MyApp3.fun1();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> Stu <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    Stu stu=<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="number">1000</span>,<span class="string">&quot;hzj1&quot;</span>);</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        stu.setId(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//这里先执行return，然后在执行finally,然后再执行return</span></span><br><span class="line">        <span class="comment">//这里return会记录地址（引用类型）</span></span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">        <span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        stu.setId(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">        stu.setId(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">i</span> <span class="operator">=</span> MyApp4.fun1();</span><br><span class="line">    System.out.println(i);	<span class="comment">//5000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>常用文本编辑快捷键</title>
    <url>/post/%E5%B8%B8%E7%94%A8%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>掌握一些最基本的快捷方式，对快速编辑有很好的效果。下面列举一些常用的快捷方式，如下所示：</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ctrl+c</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">ctrl+v</td>
<td style="text-align:center">粘贴</td>
</tr>
<tr>
<td style="text-align:center">ctrl+x</td>
<td style="text-align:center">剪切</td>
</tr>
<tr>
<td style="text-align:center">ctrl+s</td>
<td style="text-align:center">保存</td>
</tr>
<tr>
<td style="text-align:center">ctrl+z</td>
<td style="text-align:center">撤销</td>
</tr>
<tr>
<td style="text-align:center">ctrl+y</td>
<td style="text-align:center">重做</td>
</tr>
<tr>
<td style="text-align:center">ctrl+a</td>
<td style="text-align:center">全选</td>
</tr>
<tr>
<td style="text-align:center">ctrl + f</td>
<td style="text-align:center">查找</td>
</tr>
<tr>
<td style="text-align:center">home 键</td>
<td style="text-align:center">光标回到行首</td>
</tr>
<tr>
<td style="text-align:center">end 键</td>
<td style="text-align:center">光标回到行尾</td>
</tr>
<tr>
<td style="text-align:center">ctrl + home 键</td>
<td style="text-align:center">光标回到文章开始</td>
</tr>
<tr>
<td style="text-align:center">ctrl + end 键</td>
<td style="text-align:center">光标回到文章末尾</td>
</tr>
<tr>
<td style="text-align:center">shift + home 或 end 键</td>
<td style="text-align:center">选中一行</td>
</tr>
<tr>
<td style="text-align:center">ctrl + shift +右箭头或左箭头</td>
<td style="text-align:center">选中一个单词</td>
</tr>
<tr>
<td style="text-align:center">鼠标双击</td>
<td style="text-align:center">选中一个单词</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>抽象类和接口</title>
    <url>/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象时，这样的类往往被称为抽象类。</p>
<p>抽象类是为了把<strong>相同的但不确定</strong>的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象方法。</p>
<p>当然，随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。父类足够抽象时，以至于它没有具体的实例。</p>
<p>然而，有时必须从几个类中抽象出共同的行为特征，继承它们所有的属性和方法。但是，Java不支持多重继承。这时，使用接口可以达到多重继承的效果。 例如：鼠标、键盘、打印机、扫描 仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须 能…”的思想。继承是一个&quot;是不是&quot;的关系，而接口实现则是 &quot;能不能&quot;的关系。</p>
<span id="more"></span>
<h1><span id="abstract">abstract</span></h1>
<h2><span id="抽象类">抽象类</span></h2>
<p>abstract修饰的类称为抽象类，命名规范:xxxxAbstract  Abstractxxxx  xxxxBase</p>
<ul>
<li>抽象类不能被实例化，抽象类就是用来继承并实现的，但是有构造器</li>
<li>抽象类中可以有抽象方法，供继承类重写，若继承类还是抽象类，可以不重写抽象方法</li>
<li>最多只能继承一个抽象类（单继承）</li>
</ul>
<h2><span id="抽象方法">抽象方法</span></h2>
<p>abstract修饰的方法称为抽象方法</p>
<ul>
<li>抽象方法没有方法体，抽象方法就是供子类重写的（抽象子类不需要重写）</li>
<li>含有抽象方法的类一定是抽象类或接口</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>类</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>不能被继承</td>
<td>不能被重写</td>
</tr>
<tr>
<td>abstract</td>
<td>供子类继承实现</td>
<td>供继承类重写</td>
</tr>
<tr>
<td>static</td>
<td></td>
<td>需要方法体随类加载而加载</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td>对子类不可见</td>
</tr>
</tbody>
</table>
<p>因此，final不能修饰抽象类和抽象方法</p>
<p>static、private不能修饰抽象方法</p>
<h2><span id="匿名抽象类">匿名抽象类</span></h2>
<p>如果抽象类没有实现类，仍然要获取抽象类的实例对象时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>;</span><br><span class="line">    abstrect <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;think&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接构造抽象类对象，需要在<strong>构造函数后面的花括号实现抽象方法</strong>。</p>
<h2><span id="模板方法设计模式templatemethod">模板方法设计模式(TemplateMethod)</span></h2>
<p>当功能内部一部分实现步骤是固定、通用的，一部分实现是不确定的。这时可以把不确定的、易变部分暴露出去， 让子类去实现。 由此定义出功能算法的骨架，子类不改变算法的结构，且无需重复固定的代码，只需要重定义算法的某些特定步骤。</p>
<p>银行的营业厅办理业务需要 以下步骤：</p>
<ol>
<li>取号 2.办业务 3.评价。</li>
</ol>
<p>三个步骤中取号和评价都是 <strong>固定的流程</strong>，每个人要做的 事儿都是一样的。但是办业 务这个步骤根据每个人要办 的事情不同所以需要有<strong>不同的实现</strong>。我们可以将整个办业务这件事儿封装成一个抽象类：取号和评价为模板方法，而办业务为供子类重写的抽象方法。</p>
<h1><span id="接口">接口</span></h1>
<p>interface，特殊的、轻量级的抽象类，接口名称和类名一样 符合标识符的规则和规范(首字母大写)</p>
<h2><span id="接口实现">接口实现</span></h2>
<p>接口不能被实例化，供实现类使用，没有构造器</p>
<p>如果一个类实现了接口，则需要实现接口中所有方法，抽象类则不用</p>
<h3><span id="jdk8前">JDK8前</span></h3>
<p>接口中包含	公共的静态常量、公共的抽象方法</p>
<h3><span id="jdk8后">JDK8后</span></h3>
<h2><span id="接口和类">接口和类</span></h2>
<p>一个类可以实现多个接口</p>
<p>一个接口可以继承多个接口</p>
<table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象级别</td>
<td>抽象类不能被实例化，供继承并实现</td>
<td>接口不能被实例化，供实现类使用，接口抽象级别高于抽象类</td>
</tr>
<tr>
<td>构造器</td>
<td>有构造器</td>
<td>没有构造器</td>
</tr>
<tr>
<td>继承</td>
<td>实现类最多继承一个抽象类</td>
<td>类可实现多个接口，接口可继承多个接口</td>
</tr>
<tr>
<td>成员</td>
<td>除了含有抽象方法，其余和普通类相差不大</td>
<td>只能是公共的静态常量、公共的抽象方法、（静态方法、默认方法为JDK8后）</td>
</tr>
<tr>
<td></td>
<td>继承类必须实现抽象方法，或本身为抽象类</td>
<td>实现类必须实现抽象方法，或本身为抽象类</td>
</tr>
<tr>
<td>没有实现类时</td>
<td>匿名抽象类</td>
<td>匿名实现类对象</td>
</tr>
<tr>
<td>设计模式</td>
<td>模板方法</td>
<td>简单工厂、工厂方法、代理模式</td>
</tr>
<tr>
<td></td>
<td>作为模板</td>
<td>作为标准或某种特性</td>
</tr>
</tbody>
</table>
<p>抽象类、接口都通过对象的多态性产生实例化对象，但由于抽象类单继承的局限，接口使用更为广泛</p>
<h2><span id="匿名实现类对象">匿名实现类对象</span></h2>
<p>如果接口没有实现类，仍要得到接口的实现时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;think&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/post/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>赋值变量的过程中，不仅需要注意变量类型与数据类型是否一致，还需观察数据大小是否在数据类型的范围中。所以灵活使用数据类型能使我们更好的运用数据，根据数值大小将变量分配在合理的类型范围中，能有效减少存储空间。</p>
<span id="more"></span>
<h1><span id="基本数据类型">基本数据类型</span></h1>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">占用字节</th>
<th style="text-align:center">表数范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127(-2<sup>7</sup> ~2<sup>7</sup> -1 )</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-32768~32767(-2<sup>15</sup> ~ 2<sup>15</sup>-1 )</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">约21亿(-2<sup>31</sup> ~ 2<sup>31</sup> -1)</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2<sup>63</sup> ~ 2<sup>63</sup> -1</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">范围大于long(-3.403E38 ~ 3.403E38)</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1.798E308 ~ 1.798E308</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">1</td>
<td style="text-align:center">true,false</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0~65535</td>
</tr>
</tbody>
</table>
<ul>
<li>byte类型占用1个字节（B）即8位（bit），一共可以表示2的八次方个数即256个，其中首位为符号位，因此可以表示最大最小的数分别为：0111 1111(127)、1111 1111(-127)，从-127到127只有255个数，其中还有1000 0000（-0）表示成-128</li>
<li>int类型占用4个字节</li>
<li>浮点类型不能精确表示数据</li>
<li>浮点类型表数范围大于long类型，3.404*10<sup>38</sup>&gt;8<sup>38</sup>&gt;2<sup>114</sup>&gt;2<sup>63</sup>-1</li>
<li>boolean类型数据不能参与运算，不过Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都 使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。</li>
</ul>
<h1><span id="字符型">字符型</span></h1>
<p>字符型数据通常有三种表示：</p>
<ul>
<li>单引号括起的单个字符 ‘a’</li>
<li>转义字符： \</li>
<li>直接使用Unicode编码’\u000a’</li>
</ul>
<p>Java中存在一些无法直接表示的特殊字符，如：换行(\n),	Unicode编码(\u4e2d)</p>
<p>使用转义字符来表示这些特殊的字符,那么如何输出“\”本身呢？</p>
<p>“\”本身由“\\”表示,同理“\\”由“\\\\”表示，“\u”由“\\u”表示，将“\\”看作一个整体</p>
<p>如果出现“\\\”多出一个转义字符无法形成新的整体，则会报错</p>
<h1><span id="数据类型的转换">数据类型的转换</span></h1>
<ul>
<li>自动转换：表数范围小的数据类型变量转换成表述范围大的数据类型变量（小水杯的水倒入大水桶，水不会溢出）</li>
<li>强制转换：表数范围大的数据类型变量转换成表述范围小的数据类型变量（小水杯中的水可能无法装下大水桶中的水，即发生数据溢出）</li>
</ul>
<h2><span id="字面量的类型">字面量的类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span>; <span class="comment">//int类型</span></span><br><span class="line"><span class="number">3300L</span>; <span class="comment">//long类型</span></span><br><span class="line"><span class="number">123.56f</span>;<span class="comment">//float类型</span></span><br><span class="line"><span class="number">3.14</span>;<span class="comment">//double类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>整数
<ol>
<li>默认为int类型</li>
<li>L结尾为long类型，建议大写，小写不好区分</li>
</ol>
</li>
<li>小数
<ol>
<li>默认为double类型</li>
<li>F或f结尾为float类型</li>
</ol>
</li>
</ul>
<h2><span id="常数赋值">常数赋值</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1L</span>;	<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不难看出，当表数范围大的类型赋值给表数范围小的类型，将会产生错误</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> Long.MAX_VALUE;<span class="comment">//9223372036854775807</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">9223372036854775808L</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字面量的值超过了字面量数据类型的表数范围也会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>; 	</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">56</span>;</span><br></pre></td></tr></table></figure>
<p>byte、short、char有特殊之处，此时虽然是范围大的类型赋值给范围小的类型，但</p>
<ul>
<li>当字面量类型为常数且整数类型时，若字面量大小在byte、short、char的表数范围内，则可以直接赋值</li>
</ul>
<p>换种方式，将整数类型的变量赋值给byte、short、char，即使在它们的表数范围内，也会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> i;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>这是因为在编译过程中，如果赋值的是常数，系统能直接判断是否在表数范围内，而变量在程序执行过程中可能发生变化，无法直接判断变量中的值是否在表数范围内，从而报错</p>
<h2><span id="多种类型变量混合运算">多种类型变量混合运算</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">x4</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">x5</span> <span class="operator">=</span> <span class="number">1.0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">x6</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x3 + x4 + x5 + x6;</span><br></pre></td></tr></table></figure>
<p>将x1、x2、x3、x4、x5、x6相加，系统会将所有数据类型转换成表数范围最大的类型，因此需要用double类型的sum接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x3 + x4 + x5;</span><br></pre></td></tr></table></figure>
<p>同理上述相加可用<strong>double以及float</strong>类型的sum接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">x7</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x7;</span><br></pre></td></tr></table></figure>
<p>byte、short、charr之间不会相互转换，他们三者在计算时首先转换为int类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1.0</span>*x3;</span><br></pre></td></tr></table></figure>
<p>乘除法同样符合</p>
<h3><span id="难点">难点</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    s = s + <span class="number">1</span>;			<span class="comment">//报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    byte b = 3;</span></span><br><span class="line"><span class="comment">    b = b + 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    short s = 3;</span></span><br><span class="line"><span class="comment">    s = s + 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    char c = 3;</span></span><br><span class="line"><span class="comment">    c = c + 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>s = s + 1 ，不能将右侧的s直接代换成1，因为变量s可能在程序执行过程中发生变化，可以拆解成两步：</p>
<ol>
<li><code>short result = s + 1;</code></li>
<li><code>short s = result;</code></li>
</ol>
<p>第一步中，系统会将所有数据类型转换成表数范围最大的类型即int，int型变量无法直接赋值给short类型，因此报错</p>
<h1><span id="总结">总结</span></h1>
<h2><span id="常数赋值等号右边没有变量">常数赋值（等号右边没有变量）</span></h2>
<ol>
<li>先观察字面量类型，观察是否超过字面量类型表数范围</li>
<li>字面量为常数且int类型时，被赋值变量类型为byte、short、char，字面量大小在byte、short、char的表数范围内，则可以直接赋值</li>
<li>表数范围小的类型可以赋值给表数范围大的类型，反之报错</li>
</ol>
<h2><span id="多种类型变量混合运算">多种类型变量混合运算</span></h2>
<ol>
<li>byte、short、char三者在计算时首先转换为int类型</li>
<li>观察等号右边的最大表数范围的数据类型是否小于左边变量类型的表数范围</li>
<li>乘除法同样符合上述规则</li>
</ol>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>标识符</title>
    <url>/post/%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>标识符是指用来标识某个实体的一个符号，在不同的应用环境下有不同的含义。.在计算机 编程语言 中，标识符是用户编程时使用的名字，用于给变量、 常量 、 函数 、语句块等命名，以建立起名称与使用之间的关系。标识符通常由字母和数字以及其它字符构成。</p>
<span id="more"></span>
<p>Java源程序中，凡是程序员能够自己命名的都是标识符</p>
<h1><span id="标识符规则">标识符规则</span></h1>
<ol>
<li>标识符由26个英文字母、0-9数字、_$字符组成；不能出现#@！￥%&amp;等其它字符</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字、保留字，但可以包含它们，不能是if，可以是wifi</li>
<li>标识符中不能包含空格，不能是HelloWord</li>
</ol>
<p>区分源文件命名：<a href="../Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">源文件名与类名</a></p>
<h1><span id="标识符命名规范">标识符命名规范</span></h1>
<table>
<thead>
<tr>
<th style="text-align:center">标识符</th>
<th style="text-align:center">命名规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">包名</td>
<td style="text-align:center">全部英文字母小写</td>
</tr>
<tr>
<td style="text-align:center">类名、接口名</td>
<td style="text-align:center">每个英文单词首字母大写</td>
</tr>
<tr>
<td style="text-align:center">变量名、方法名</td>
<td style="text-align:center">首个英文单词首字母小写，之后每个单词首字母大写</td>
</tr>
<tr>
<td style="text-align:center">常量名</td>
<td style="text-align:center">全部英文字母大写，单词之间由分隔符隔开</td>
</tr>
</tbody>
</table>
<h1><span id="关键字">关键字</span></h1>
<table>
<thead>
<tr>
<th style="text-align:left">作用</th>
<th style="text-align:left">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">用于定义数据类型的关键字</td>
<td style="text-align:left">class interface enum byte short int long float double char boolean void</td>
</tr>
<tr>
<td style="text-align:left">用于定义流程控制的关键字</td>
<td style="text-align:left">if else switch case default while do for break continue return</td>
</tr>
<tr>
<td style="text-align:left">用于定义访问权限修饰符的关键字</td>
<td style="text-align:left">private protected public</td>
</tr>
<tr>
<td style="text-align:left">用于定义类，函数，变量修饰符的关键字</td>
<td style="text-align:left">abstract final static synchronized</td>
</tr>
<tr>
<td style="text-align:left">用于定义类与类之间关系的关键字</td>
<td style="text-align:left">extends implements</td>
</tr>
<tr>
<td style="text-align:left">用于定义建立实例及引用实例，判断实例的关键字</td>
<td style="text-align:left">new this super instanceof</td>
</tr>
<tr>
<td style="text-align:left">用于异常处理的关键字</td>
<td style="text-align:left">try catch finally throw throws</td>
</tr>
<tr>
<td style="text-align:left">用于包的关键字</td>
<td style="text-align:left">package import</td>
</tr>
<tr>
<td style="text-align:left">其他修饰符关键字</td>
<td style="text-align:left">native strictfp transient volatile assert</td>
</tr>
<tr>
<td style="text-align:left">用于定义数据类型值的字面值</td>
<td style="text-align:left">true false null</td>
</tr>
</tbody>
</table>
<h1><span id="保留字">保留字</span></h1>
<p>现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字</p>
<p>goto，const</p>
<h1><span id="总结">总结</span></h1>
<h2><span id="一个java源文件可以有名称相同大小写不同的两个类吗">一个java源文件可以有名称相同，大小写不同的两个类吗?</span></h2>
<p>Java源文件可以有名称相同，大小写不同的两个类；</p>
<p>因为Java标识符严格区分大小写</p>
<p>不过在编译过程中，由于window系统不区分大小写，windows将前后编译生成的字节码文件视为同一个（即使这两个文件的命名一个是大写，一个是小写），后编译的类产生的字节码文件将替换掉先编译的类产生的字节码文件。</p>
<h2><span id="java可不可以使用中文命名">java可不可以使用中文命名?</span></h2>
<p>可以 因为jdk使用的是unicode编码(全球统一编码),能够识别中文</p>
<h2><span id="java源文件可以不可以数字开头">java源文件可以不可以数字开头?</span></h2>
<p>可以 java源文件不用遵循命名规则（public的类不行）</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>类加载的初始化顺序</title>
    <url>/post/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2><span id="静态代码块">静态代码块</span></h2>
<ul>
<li>
<p>随着类的加载而运行，只执行一次</p>
</li>
<li>
<p>当出现多个静态代码块(包括静态属性赋值）时，按顺序执行</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(Order.i);		<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="构造代码块">构造代码块</span></h2>
<ul>
<li>随着对象的创建而运行，且先于构造函数的执行</li>
<li>有多个构造代码块时，也按顺序执行</li>
</ul>
<h2><span id="构造器">构造器</span></h2>
<ul>
<li>与类名同名的，通过new运算符来新建一个类的实例的函数。可以同时拥有多个不同参数类型顺序的构造器</li>
<li>当未定义任何构造器时，编译器会默认提供一个无参的构造器</li>
</ul>
<span id="more"></span>
<h2><span id="执行顺序">执行顺序</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Order();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">静态代码块</span><br><span class="line">构造代码块</span><br><span class="line">构造器</span><br><span class="line">===============</span><br><span class="line">构造代码块</span><br><span class="line">构造器</span><br></pre></td></tr></table></figure>
<p>可以看出</p>
<ol>
<li>静态代码块&gt;&gt;构造代码块&gt;&gt;构造器</li>
<li>不管new几次对象，静态代码块都只执行一次，而构造代码块和构造器每次创建对象时都会执行</li>
</ol>
<h2><span id="继承的情况">继承的情况</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Inheritance</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> GrandChild();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> GrandChild();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Child</span> <span class="title">extends</span> <span class="title">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GrandChild</span> <span class="title">extends</span> <span class="title">Child</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GrandChild()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">父类的静态代码块</span><br><span class="line">子类的静态代码块</span><br><span class="line">孙子类的静态代码块</span><br><span class="line">父类的构造代码块</span><br><span class="line">父类的构造器</span><br><span class="line">子类的构造代码块</span><br><span class="line">子类的构造器</span><br><span class="line">孙子类的构造代码块</span><br><span class="line">孙子类的构造器</span><br><span class="line">===============</span><br><span class="line">父类的构造代码块</span><br><span class="line">父类的构造器</span><br><span class="line">子类的构造代码块</span><br><span class="line">子类的构造器</span><br><span class="line">孙子类的构造代码块</span><br><span class="line">孙子类的构造器</span><br></pre></td></tr></table></figure>
<h3><span id="子类对象实例化过程">子类对象实例化过程</span></h3>
<ol>
<li>
<p>首先不断向上查找直至到达顶层父类Object，然后不断向下依次调用父类的构造器进行父特征的初始化</p>
</li>
<li>
<p>然后向下依次执行静态代码块（静态代码块随着类的加载执行且执行一次，再次创建对象无需加载类）</p>
</li>
<li>
<p>接着依次创建对象，依次执行构造代码块、构造器</p>
</li>
<li>
<p>直到创建完所有子类对象</p>
<p><a href="../super/#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">若父类定义了有参构造器而没定义无参构造器，此时子类的构造器会报错</a></p>
</li>
</ol>
<h2><span id="静态内部类">静态内部类</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticInnerClass</span>&#123;</span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的构造器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的静态代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的构造代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span>()</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">class</span> <span class="title">InnerClass</span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;实例内部类的构造器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*static void testMethod()&#123;					//编译报错</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;实例内部类静态方法&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        static&#123;									   //编译报错</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;实例内部类静态代码块&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;实例内部类的构造代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="外部类执行顺序">外部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类构造代码块</span><br><span class="line">外部类构造器</span><br></pre></td></tr></table></figure>
<h3><span id="外部类静态方法执行顺序">外部类静态方法执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.testMethod();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类静态方法</span><br></pre></td></tr></table></figure>
<ul>
<li>执行静态方法时，先加载类和静态代码块</li>
<li>不创建类实例对象，直接访问静态方法</li>
</ul>
<h3><span id="静态内部类执行顺序">静态内部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticInnerClass();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">静态内部类的静态代码块</span><br><span class="line">静态内部类的构造代码块</span><br><span class="line">静态内部类的构造器</span><br></pre></td></tr></table></figure>
<ul>
<li>首先加载外部类以及外部类静态代码块，但没有创建外部类实例对象</li>
<li>接着顺序执行构造静态内部类实例对象</li>
</ul>
<h3><span id="静态内部类静态方法执行顺序">静态内部类静态方法执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.StaticInnerClass.testMethod();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">静态内部类的静态代码块</span><br><span class="line">静态内部类的静态方法</span><br></pre></td></tr></table></figure>
<ul>
<li>同样加载了外部类及外部类静态代码块，但没有创建外部类实例对象</li>
<li>加载了当前内部类及静态代码块，但没有创建内部类实例对象</li>
</ul>
<h3><span id="实例内部类执行顺序">实例内部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类构造代码块</span><br><span class="line">外部类构造器</span><br><span class="line">实例内部类的构造代码块</span><br><span class="line">实例内部类的构造器</span><br></pre></td></tr></table></figure>
<ul>
<li>先后创建了外部类、内部类的实例对象</li>
</ul>
<p><strong>结论</strong>：<br>
静态内部类并不会随着外部类的初始化而被初始化，而是当静态内部类的方法被调用时，静态内部类才被初始化。反之，静态内部类被调用时，仅加载了外部类及外部类静态代码块，并没有创建外部类实例对象</p>
<table>
<thead>
<tr>
<th></th>
<th>类的执行顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>不含继承关系、不含内部类</td>
<td>静态代码块&gt;&gt;构造代码块&gt;&gt;构造器，静态代码块随类的加载只执行一次</td>
</tr>
<tr>
<td>含继承关系</td>
<td>访问子类对象时，从上向下依次加载类和静态代码块，再依次创建对象（构造代码块&gt;&gt;构造器）</td>
</tr>
<tr>
<td>含内部类</td>
<td>访问内部类对象时，无论静态或非静态，都先加载外部类及外部类静态代码块，不创建外部实例对象，然后创建内部类对象</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>流程控制</title>
    <url>/post/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(b = <span class="literal">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        从键盘分别输入年、月、日，判断这一天是当年的第几天</span></span><br><span class="line"><span class="comment">        注：判断一年是否是闰年的标准：</span></span><br><span class="line"><span class="comment">        1）可以被4整除，但不可被100整除、或</span></span><br><span class="line"><span class="comment">        2）可以被400整除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入月份：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入几号：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">month2</span> <span class="operator">=</span> <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year %<span class="number">100</span> != <span class="number">0</span> ||year % <span class="number">400</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    month2 = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        day += month2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        day += date;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的月份不合法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(day);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>树</title>
    <url>/post/%E6%A0%91/</url>
    <content><![CDATA[<h1><span id="二叉排序树">二叉排序树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>也称二叉查找树，一棵空树，或者是具有下列特性的二叉树:</p>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值</li>
<li>左、右子树也分别是一棵二叉排序树</li>
</ol>
<p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值</p>
<p>对二叉排序树进行中序遍历可以得到一个递增的有序序列</p>
<h2><span id="操作">操作</span></h2>
<h3><span id="二叉树的结构">二叉树的结构</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="查找操作">查找操作</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="comment">//如果递归过程中T为空，则查找结果返回NULL；或者查找成功，返回指向该关键字的指针</span></span><br><span class="line">	<span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; T-&gt;data != key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data) T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBSTNode</span><span class="params">(BSTreee T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBSTNode(T-&gt;lchild,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBSTNode(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="插入操作">插入操作</span></h3>
<p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data == key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &gt; key) T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &lt; key) T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTree b = (BSTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BSTree));</span><br><span class="line">    b-&gt;data = key;</span><br><span class="line">    b-&gt;rchild = b-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T = b;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BSTree T,KeyType key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        BiTree b = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Bitree));</span><br><span class="line">        b-&gt;data = key;</span><br><span class="line">        b-&gt;lchild = b-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = b;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> InsertBST(T-&gt;lchild,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InsertBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="构建操作">构建操作</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    InsertBST(T,a[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3><span id="删除操作">删除操作</span></h3>
<ol>
<li>叶子结点：删除该结点不需要做其他操作；</li>
<li>仅有左或右子树的结点：删除后让被删除结点的直接后继接替它的位置；</li>
<li>左右子树都有的结点：遍历得到被删除结点的直接前驱或者直接后继来接替它的位置，然后再删除</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/63be79c8be43e0d30ec4aff5.jpg" alt></p>
<p>删除Z结点：</p>
<ol>
<li>用左孩子结点代替被删除结点，若该左孩子结点有右子树，则无法满足二叉排序树定义，没有右子树则直接替换，删除该元素</li>
<li>用左孩子的右孩子代替被删除的结点，若该节点有右子树，则无法满足二叉排序树定义</li>
<li>用左孩子的右孩子的右孩子的…右孩子的结点代替删除的结点，该节点没有右子树，代替可满足二叉排序树定义</li>
<li>且该节点有左子树或是叶子结点，删除同上述，由此得到直接前驱的概念</li>
</ol>
<ul>
<li>直接前驱：Z结点左孩子的右孩子的右孩子的…右孩子的结点，直到该节点没有右子树，即左子树中最右下的结点</li>
<li>直接后继：同理，是Z结点右子树中最坐下的结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> *<span class="title function_">DeleteBST</span><span class="params">(BSTNode *p)</span>&#123;</span><br><span class="line">    BSTree q,s;</span><br><span class="line">    <span class="keyword">if</span>(*p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; (*p)-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;   </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;    </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        q = *p;							<span class="comment">//递归更加直观</span></span><br><span class="line">        s = (*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q != *p)&#123;</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="comment">/*s = (*p)-&gt;lchild;</span></span><br><span class="line"><span class="comment">        while(s-&gt;rchild != NULL)&#123;</span></span><br><span class="line"><span class="comment">            s = s-&gt;rchild;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        (*p)-&gt;data = s-&gt;data;</span></span><br><span class="line"><span class="comment">        DeleteBST(s);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="查找效率">查找效率</span></h2>
<p>平均查找长度ASL（Average Search Length）：需要对比关键字的次数</p>
<ol>
<li>
<p>查找成功的ASL</p>
<img src="https://pic.imgdb.cn/item/63be996bbe43e0d30e01cf1e.jpg" style="zoom:50%;">
</li>
<li>
<p>查找失败的ASL</p>
<img src="https://pic.imgdb.cn/item/63be99b9be43e0d30e0272f7.jpg" style="zoom:50%;">
</li>
</ol>
<h2><span id="引申出平衡二叉树">引申出平衡二叉树</span></h2>
<p>二叉排序树的优点明显，插入删除的时间性能比较好。</p>
<p>而对于二叉排序树的查找，其比较次数等于给定值的结点在二叉排序树的层数，即树的高</p>
<p>最好情况：n个结点的二叉树最小高度为 log<sub>2</sub>n（向下取整）+1</p>
<p>最坏情况：每个结点1个分支，树高=节点数=n</p>
<p>也就是说，我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，那么查找的时间复杂也就为O(logn)，近似于折半查找</p>
<h1><span id="平衡二叉树">平衡二叉树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>平衡二叉树(AVL)是一种二叉排序树，其中每一个节点的左子树和右子树的高度差不超过1</p>
<p>结点的平衡因子：二叉树上结点的左子树深度减去右子树深度的值称为平衡因子</p>
<p>平衡二叉树上所有结点的平衡因子只能是-1、0和1</p>
<p>假设n<sub>h</sub>为深度为h的平衡树中含有的最少结点数，n<sub>0</sub>=0，n<sub>1</sub>=1，n<sub>2</sub>= 2 ，平衡二叉树中有n<sub>h</sub> = n<sub>h-1</sub> + n<sub>h-2</sub> +1可证明最大深度和平均查找长度O(long<sub>2</sub>n)</p>
<h2><span id="操作">操作</span></h2>
<h3><span id="平衡二叉树的结构">平衡二叉树的结构</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">rchild</span>, *<span class="title">lchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure>
<h3><span id="查找操作">查找操作</span></h3>
<h3><span id="插入操作">插入操作</span></h3>
<p>当我们在二叉排序树中插入(或删除)一个结点时，可能导致其插入路径上的结点不平衡（平衡因子绝对值大于1）</p>
<p>若导致了不平衡，须将最小不平衡子树调整平衡，则其他结点都会恢复平衡</p>
<p>最小不平衡子树：从插入结点王辉找到第一个不平衡结点，以该结点为根的子树</p>
<h4><span id="ll平衡旋转右单旋转">LL平衡旋转(右单旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea349be43e0d30e12a52e.jpg" alt></p>
<p>在结点A的左孩子(L)的左子树(L)上插入了新结点</p>
<p>将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树</p>
<h4><span id="rr平衡旋转左单旋转">RR平衡旋转(左单旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bf666ebe43e0d30e2ce419.jpg" alt="image-20230111195440307"></p>
<p>在结点A的右孩子®的右子树®上插入了新结点</p>
<p>将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树</p>
<h4><span id="lr平衡旋转先左后右双旋转">LR平衡旋转(先左后右双旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea837be43e0d30e1d7d44.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63bea87abe43e0d30e1ddaf3.jpg" alt></p>
<p>在A的左孩子(L)的右子树®上插入新结点</p>
<p>先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置,即进行一次RR平衡旋转(左单旋转），然后再把该C结点向右上旋转提升到A结点的位置,即进行一次LL平衡旋转(右单旋转)</p>
<h4><span id="rl平衡旋转先右后左双旋转">RL平衡旋转(先右后左双旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea8b2be43e0d30e1e2b37.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63bea8ddbe43e0d30e1e681a.jpg" alt></p>
<p>在A的右孩子®的左子树(L)上插入新结点</p>
<p>先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置,即进行一次LL平衡旋转(右单旋转)，然后再把该C结点向左上旋转提升到A结点的位置,即进行一次RR平衡旋转(左单旋转)</p>
<p>新结点插入C的左子树还是插入C的右子树不影响旋转过程</p>
<p><img src="https://pic.imgdb.cn/item/63beaaafbe43e0d30e2182c7.jpg" alt></p>
<ul>
<li>插入操作导致的最小不平衡子树（此时插入前平衡）：高度加1，经过调整后最小不平衡子树的高度恢复，从而其祖先结点也恢复</li>
</ul>
<h2><span id="查找效率">查找效率</span></h2>
<ul>
<li>若树高为h，最坏情况下，查找一个关键字最多需要比较h次，即查找操作的时间复杂度不可能超过O(h)</li>
</ul>
<h1><span id="红黑树">红黑树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>红黑树也是二叉排序树，与普通BST相比：左根右，根叶黑 ，不红红，黑路同，左子孙结点值小于根节点值小于右子孙结点值</p>
<ol>
<li>每个结点或是红色，或是黑色的</li>
<li>根节点是黑色的</li>
<li>叶结点（外部结点、NULL结点、失败结点）均是黑色的</li>
<li>不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</li>
<li>对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</li>
</ol>
<ul>
<li>平衡二叉树 AVL：插入/删除 很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不 平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行 LL/RR/LR/RL 调整</li>
<li>红黑树 RBT：插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一 般都可以在常数级时间内完成 平衡二叉树：适用于以查为主、很少插入/删除的场景 红黑树：适用于频繁插入、删除的场景，实用性更强 性能逐渐优秀</li>
</ul>
<h2><span id="红黑树的结构">红黑树的结构</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    RBNode* parent;</span><br><span class="line">    RBNode* lchild;</span><br><span class="line">    RBNode* rchild;</span><br><span class="line">    <span class="type">int</span> color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="性质">性质</span></h2>
<ol>
<li>结点的黑高（bh）：从某结点出发（<strong>不含该节点</strong>）到达任一<strong>空叶结点</strong>的<strong>路径上黑结点总数</strong></li>
<li>从根节点到叶结点的最长路径不大于最短路径的2倍</li>
<li>有n个内部节点的红黑树高度 h ≤ 2log<sub>2</sub>(n+1)</li>
<li>查找效率与AVL 树同等数量级 红黑树查找操作时间复杂度 = O(log<sub>2</sub>n)</li>
</ol>
<h2><span id="操作">操作</span></h2>
<h3><span id="插入操作">插入操作</span></h3>
<ol>
<li>先查找，确定插入位置（原理同二叉排序树），插入新结点</li>
<li>新结点是根——染为黑色</li>
<li>新结点非根——染为红色</li>
<li>若插入新结点后依然满足红黑树定义，则插入结束，若不满足红黑树定义，则通过叔叔结点的颜色调整
<ol>
<li>黑叔：旋转+染色
<ol>
<li>LL型：右单旋，父换爷+染色</li>
<li>RR型：左单旋，父换爷+染色</li>
<li>LR型：左、右双旋，儿换爷+染色</li>
<li>RL型：右、左双旋，儿换爷+染色</li>
</ol>
</li>
<li>红叔：染色+变新
<ol>
<li>叔父爷染色，爷变为新结点</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="构建操作java">构建操作（java）</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;		<span class="comment">//构建红黑树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多</p>
<p><img src="https://pic.imgdb.cn/item/63bf6956be43e0d30e315a52.jpg" alt="不严格平衡的红黑树"></p>
<p>​    <strong>Answer 1：</strong></p>
<ol>
<li>
<p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p>
</li>
<li>
<p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p>
</li>
<li>
<p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p>
</li>
<li>
<p>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多</p>
</li>
<li>
<p>功能、性能、空间开销的折中结果。<br>
AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。<br>
红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。</p>
<p><strong>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</strong></p>
</li>
</ol>
<p>​    <strong>1 好处 及 用途</strong></p>
<p>​    红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。</p>
<p>​    红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。当然，还有一些更好的，但实现起来更复杂的<a href="http://lib.csdn.net/base/datastructure">数据结构</a> 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的<a href="http://lib.csdn.net/base/datastructure">算法</a>时间复杂度和AVL相同，但统计性能比AVL树更高。</p>
<p>​    当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>​     在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。</p>
<p>​     典型的用途是实现关联数组</p>
<p>​    <strong>2. AVL树是最先发明的自平衡二叉查找树。</strong></p>
<p>​    在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。引入二叉树的目的是为了提高二叉树的搜索的效率, 减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度.</p>
<p>​    AVL树的定义:<br>
​    一棵AVL树满足以下的条件:<br>
​    1&gt;它的左子树和右子树都是AVL树<br>
​    2&gt;左子树和右子树的高度差不能超过1<br>
​    从条件1可能看出是个递归定义,如GNU一样.</p>
<p>​    性质:<br>
​    1&gt;一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1)<br>
​    2&gt;一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)).<br>
​    3&gt;一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).</p>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>编码与数制</title>
    <url>/post/%E7%BC%96%E7%A0%81%E4%B8%8E%E6%95%B0%E5%88%B6/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>1、2、3、4……，我们从小便学习这么计数，并使用到现在。但是这样的计数方式从何而来呢？又如何发展成如今计算机的计数方式？</p>
<span id="more"></span>
<p>罗马人从使用手指计数到在羊皮上画出Ⅰ、Ⅱ、Ⅲ来代替手指的字符，他们定义出了能够表示不同个数的符号，并随后引出了X(十)、C(百)、(M)千等等符号。随着要表示的数量越来越多，他们不得不引出更多的符号。</p>
<p>印度人发明了如今成为国际通用的阿拉伯数字，与罗马人的计数方式相比，阿拉伯数字不需要不断引出新的符号，而是用数字的位置来表示，高位在左，低位在右，传入欧洲后，加上逢十进一，演变成如今人们使用的数字计数，即十进制计数法（D)。</p>
<h1><span id="进位计数法">进位计数法</span></h1>
<h2><span id="r进制计数法">r进制计数法</span></h2>
<p>r进制计数法是从十进制计数法中抽象出来的概念，r可以表示任何整数，逢r进一</p>
<p>相比于传统计数方法，r进制计数法</p>
<ul>
<li>
<p>利用了数字位置的信息</p>
<p>每个数位表示不同的常数，第0位表示r<sup>0</sup>,第1位表示r<sup>1</sup>……</p>
<p>（从0开始）第i位表示r<sup>i</sup>，r<sup>i</sup>就是第i位的<strong>位权</strong></p>
</li>
<li>
<p>每个数位使用r种不同数码</p>
<p>r就是<strong>基数</strong></p>
<p>真实的数字 = 累加 （每个数位的数字	乘以	该位的位权）</p>
<blockquote>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
</li>
</ul>
<h2><span id="二进制计数法">二进制计数法</span></h2>
<p>在计算机中使用高电平和低电平两种稳定状态的电子器件，因而使用二进制来表示计算机中的数据</p>
<p>二进制中的1、0对应了逻辑中的真、假，为逻辑运算提供便利条件</p>
<p>常用的还有<strong>八进制计数法（O）、十六进制计数法（H）</strong></p>
<h1><span id="不同进制间的转换">不同进制间的转换</span></h1>
<p>为了深入了解不同进制表示的数据，还需分析不同进制间的转换</p>
<h2><span id="任意进制-gt-十进制">任意进制 -&gt; 十进制</span></h2>
<h3><span id="按权展开相加法">按权展开相加法</span></h3>
<p>累加 （每个数位的数字	乘以	该位的位权）</p>
<h2><span id="二进制-gt-八进制-十六进制">二进制 -&gt; 八进制 、十六进制</span></h2>
<ul>
<li>二进制的3个数位最多能表示8个数字</li>
<li>二进制的4个数位最多能表示16个数字</li>
</ul>
<p>二进制 -&gt; 八进制 ：</p>
<ol>
<li>小数点左边：3位1组-&gt;最左边补0凑3位</li>
<li>小数点右边：3位1组-&gt;最右边补0凑3位</li>
<li>每组转化成八进制数</li>
</ol>
<p>二进制 -&gt; 十六进制：</p>
<ol>
<li>小数点左边：4位1组-&gt;最左边补0凑4位</li>
<li>小数点右边：4位1组-&gt;最右边补0凑4位</li>
<li>每组转化成十六进制数</li>
</ol>
<h2><span id="八进制-十六进制-gt-二进制">八进制 、十六进制 -&gt; 二进制</span></h2>
<p>八进制 -&gt; 二进制 ：1位 -&gt; 3位二进制数</p>
<p>十六进制 -&gt; 二进制：1位 -&gt; 4位二进制数</p>
<p>最后去掉最高位最小位的0</p>
<h2><span id="八进制-gt-十六进制">八进制 -&gt; 十六进制</span></h2>
<p>以二进制为桥梁  八进制-&gt;二进制-&gt;十六进制</p>
<h2><span id="十进制-gt-二进制">十进制 -&gt; 二进制</span></h2>
<h3><span id="基数乘除法">基数乘除法</span></h3>
<p>进位计数法有效利用了数码的位置信息，如何借助数字位置信息实现进制转换呢？</p>
<blockquote>
<p>对于一个r进制数：K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
<p>乘以基数r</p>
<blockquote>
<p>r*(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)</p>
<p>=r*(K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)</p>
<p>=K<sub>n</sub>*r<sup>n+1</sup>+K<sub>n-1</sub>*r<sup>n</sup>+…+K<sub>2</sub>*r<sup>3</sup>+K<sub>1</sub>*r<sup>2</sup>+K<sub>0</sub>*r<sup>1</sup>+K<sub>-1</sub>*r<sup>0</sup>+K<sub>-2</sub>*r<sup>-1</sup>+…+K<sub>-m</sub>*r<sup>-m+1</sup>+0*r<sup>m</sup></p>
<p>=K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>0</p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生左移，并在最右边一位补0</p>
<p>除以基数r</p>
<blockquote>
<p>(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)\r</p>
<p>= (K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)\r</p>
<p>=0*r<sup>n</sup>+K<sub>n</sub>*r<sup>n-1</sup>+K<sub>n-1</sub>*r<sup>n</sup>-2+…+K<sub>2</sub>*r<sup>1</sup>+K<sub>1</sub>*r<sup>0</sup>+K<sub>0</sub>*r<sup>-1</sup>+K<sub>-1</sub>*r<sup>-2</sup>+K<sub>-2</sub>*r<sup>-3</sup>+…+K<sub>-m</sub>*r<sup>-m-1</sup></p>
<p>=0K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生右移，并在最左边一位补0</p>
<table>
<thead>
<tr>
<th></th>
<th>第n+1位</th>
<th>第n位</th>
<th>第n-1位</th>
<th>…</th>
<th>第2位</th>
<th>第1位</th>
<th>第0位</th>
<th>第-1位</th>
<th>…</th>
<th>第-(m-1)</th>
<th>第-m位</th>
<th>第-(m+1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>原数</td>
<td></td>
<td>Kn</td>
<td>Kn-1</td>
<td>…</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>…</td>
<td>K-(m-1)</td>
<td>K-m</td>
<td></td>
</tr>
<tr>
<td>乘以基数r</td>
<td>Kn</td>
<td>Kn-1</td>
<td>Kn-2</td>
<td>…</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>K-2</td>
<td>…</td>
<td>K-m</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>除以基数r</td>
<td></td>
<td>0</td>
<td>Kn</td>
<td>…</td>
<td>K3</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>…</td>
<td>K-(m-2)</td>
<td>K-(m-1)</td>
<td>K-m</td>
</tr>
</tbody>
</table>
<h4><span id="对于整数除基取余法">对于整数：除基取余法</span></h4>
<p>将数字除以基数，相当于右移了数字，小数点右边的为余数，先除得的余数为低位，即二进制的最低位</p>
<p>继续将商除以基数，继续右移，直到商为0，后除得的余数为高位</p>
<p><strong>除基取余，先余为低，后余为高，商0结束</strong></p>
<h4><span id="对于小数乘基取整法">对于小数：乘基取整法</span></h4>
<p>将数字乘以基数，相当于左移了数字，小数点左边的为高位</p>
<p>此时乘积的结构为： 高位数码（整数部分） + 剩余数  (**.**K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)*r =  K<sub>-1</sub> <strong>.</strong> K<sub>-2</sub>…K<sub>-m</sub></p>
<p>乘积减去高位数码得到剩余数，再将剩余数继续乘基数，重复以上步骤，直到高位数码为0</p>
<p><strong>乘基取整，先整为高，后整为低，整0结束</strong></p>
<p>注意：不是每个小数都能用二进制表示</p>
<h3><span id="拼凑法">拼凑法</span></h3>
<p>在十进制转换为二进制中，大小适中的数字，可以通过位权凑出数字</p>
<table>
<thead>
<tr>
<th style="text-align:left">2<sup>-4</sup></th>
<th style="text-align:left">2<sup>-3</sup></th>
<th style="text-align:left">2<sup>-2</sup></th>
<th style="text-align:left">2<sup>-1</sup></th>
<th style="text-align:left">2<sup>0</sup></th>
<th style="text-align:left">2<sup>1</sup></th>
<th style="text-align:left">2<sup>2</sup></th>
<th style="text-align:left">2<sup>3</sup></th>
<th style="text-align:left">2<sup>4</sup></th>
<th style="text-align:left">2<sup>5</sup></th>
<th style="text-align:left">2<sup>6</sup></th>
<th style="text-align:left">2<sup>7</sup></th>
<th style="text-align:left">2<sup>8</sup></th>
<th style="text-align:left">2<sup>9</sup></th>
<th style="text-align:left">2<sup>10</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0.0625</td>
<td style="text-align:left">0.125</td>
<td style="text-align:left">0.25</td>
<td style="text-align:left">0.5</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">4</td>
<td style="text-align:left">8</td>
<td style="text-align:left">16</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64</td>
<td style="text-align:left">128</td>
<td style="text-align:left">256</td>
<td style="text-align:left">512</td>
<td style="text-align:left">1024</td>
</tr>
</tbody>
</table>
<p>75.325D = 64 + 8 + 2 + 1 + 0.25 + 0.125 = 2<sup>6</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> + 2<sup>-2</sup> + 2<sup>-3</sup> = 1001011.011B</p>
<p>在了解了计算机的进位计数法及不同进制的转换后，便可以学习如何将生活中的数存入计算机</p>
<h1><span id="整数的表示">整数的表示</span></h1>
<p>在日常生活中带正负号的数，我们通常称为 <strong>真值</strong></p>
<p>将数据<strong>符号数字化</strong>后并能够存储到计算机中的数称为 <strong>机器数</strong>。</p>
<p>先看简化的无符号整数（以下都是二进制计数）</p>
<h2><span id="无符号整数">无符号整数</span></h2>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub></p>
<ul>
<li>没有符号位，默认为正号</li>
<li>最大值为：2<sup>n+1</sup>-1，最小值为0</li>
</ul>
<h3><span id="加法运算">加法运算</span></h3>
<blockquote>
<p>1+1 = 0001 + 0001 = 0010B = 2D</p>
</blockquote>
<h3><span id="减法运算">减法运算</span></h3>
<p>减法只考虑正数减正数：</p>
<ol>
<li>正数减负数、负数减正数本质上是加法，</li>
<li>负数减负数其实也就是正数减正数</li>
</ol>
<blockquote>
<p>2-1 = 0010 - 0001 = 0001 =1D</p>
</blockquote>
<p>实际上，早期的计算机中设有关于减法的相关电路，复杂的电路伴随着高昂的成本，因此如今的计算机逻辑运算单元中，只有加法器进行加法的运算，减法的运算也是通过加法器实现。那么如何通过加法运算实现减法呢？</p>
<h3><span id="钟表时针">钟表时针</span></h3>
<p>类似于钟表的时针：如果说现在时针现在停在10点钟，那么什么时候时针会停在8点钟呢？</p>
<p>时针倒拨2小时，或是正拨10小时，超过12小时后，时针将走第二圈，并最终停在8点钟</p>
<blockquote>
<p>10 - 2 = 8，10 + 10 = 20 = 12 + 8</p>
<p>即 (10 - 2) mod 12 = 8</p>
<p>​	(10 + 10) mod 12 = 8</p>
</blockquote>
<ul>
<li>
<p>mod就是<strong>取模运算</strong>，它们除以整数12，并计算最后的余数</p>
</li>
<li>
<p>8和20对于模12<strong>同余</strong>(有着相同的余数)，它们将共同停在余数8点钟</p>
</li>
</ul>
<h3><span id="取模运算">取模运算</span></h3>
<p>对整数a、b，取模运算就是a除以b，并计算余数（模余），记作</p>
<blockquote>
<p>a Mod b = a - [a/b]*b，[a/b]为向下取整</p>
</blockquote>
<p>如：20 Mod 12 = 20 - [20/12]*12 = 20 - 1*12 = 8</p>
<h3><span id="同余">同余</span></h3>
<p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余,记作</p>
<blockquote>
<p>a Mod r =  b Mod r =&gt; a ≡ b (mod m)</p>
<p>性质：<strong>a、b满足a-b为r的整数倍</strong></p>
</blockquote>
<h3><span id="思考">思考</span></h3>
<p>与钟表时针相比，计算机计数也有相似的地方：</p>
<table>
<thead>
<tr>
<th style="text-align:left">钟表时针</th>
<th style="text-align:left">计算机计数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">钟表时针取值只有[0-11]，超过12后会从0重新开始</td>
<td style="text-align:left">计算机作二进制表示的数位有限，超过一定数值也会重新开始计数</td>
</tr>
<tr>
<td style="text-align:left">将时针倒拨可以通过正拨等价实现</td>
<td style="text-align:left">计算机减法也可以使用加法等价实现</td>
</tr>
<tr>
<td style="text-align:left">(10-2) mod 12 = (10+10) mod 12</td>
<td style="text-align:left">(x - a) Mod r = (x + b) Mod r</td>
</tr>
<tr>
<td style="text-align:left">(10-2) ≡ (10+10) (mod 12)</td>
<td style="text-align:left">(x-a) ≡ (x+ b) (mod r)</td>
</tr>
</tbody>
</table>
<ul>
<li>x - a与x + b同余</li>
<li>根据<a href="#%E5%90%8C%E4%BD%99">同余的性质</a>，(x+ b) - (x-a) = r*Z，化简得 b = r*Z - a	（Z为整数、r为模）</li>
</ul>
<p>为了方便计算，可以只找离模最近的数，取Z = 1，即 b = r - a</p>
<p>也就是说，减法中减去a与加上 <strong>r - a</strong>等价，但r - a中仍存在减法，</p>
<p>这时需要利用计算机中的取反操作：</p>
<blockquote>
<p><strong>r  = a + ~a +1</strong>	（~为取反符号）</p>
</blockquote>
<p>二进制中任何一个数与它取反后的数相加，都会得到每个位为1的数，此时加上1就能得到该位下的模</p>
<blockquote>
<p>b = r - a = ~a +1</p>
</blockquote>
<p>x减去a 可以等价成 x 加上取反后的a加1，即</p>
<blockquote>
<p><strong>x - a = x + b =  x + ~a + 1</strong></p>
</blockquote>
<p>至此，减法运算可以仅通过加法、取反来实现</p>
<h2><span id="带符号整数">带符号整数</span></h2>
<h3><span id="原码">原码</span></h3>
<p>接着引入符号位的概念，最高位为符号位，正数为0，负数为1</p>
<p>符号位与真值的绝对值构成了原码</p>
<blockquote>
<p>[1]<sub>原</sub> = 0001	[-1]<sub>原</sub> = 1001</p>
</blockquote>
<p>8位的原码表示范围为：</p>
<blockquote>
<p>​	1111 1111 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4><span id="原码的运算">原码的运算</span></h4>
<ul>
<li>原码中的符号位仅用来表示数的正、负，不参加运算，只有数值部分参与运算</li>
<li>原码运算时，先比较两个数的符号，若两个数的符号相同，则将两个数的相加，最后加上符号</li>
<li>若两数的符号不同，则需比较两数的数值大小，然后将数值较大的数减去数值较小的数，并将数值较大的数的符号作为最后结果的符号。</li>
</ul>
<h3><span id="补码">补码</span></h3>
<p>回顾<a href="#%E6%80%9D%E8%80%83">无符号整数的减法运算</a>，x减去a 可以等价成 x 加上取反后的a加1</p>
<h4><span id="补码引言">补码引言</span></h4>
<p>无符号4位2进制的模为2<sup>4</sup></p>
<blockquote>
<ol>
<li>被减数-减数 = 0：1 - 1 = 0001 + 1111 = 1)0000B = 0D</li>
<li>被减数-减数 &gt; 0：2 - 1 = 0010 + 1111 = 1)0001B = 1D</li>
<li>被减数-减数 &lt; 0：1 - 2 = 0001 + 1110 = 1111B = 15D(16 - 1)</li>
</ol>
</blockquote>
<p>结果都比原来多了2<sup>4</sup>,都多加了一个模</p>
<ol>
<li>对于被减数 - 减数 &gt;= 0，忽视溢出位，数值位等于实际值</li>
<li>对于被减数 - 减数 &lt; 0，还需减去一个模，a - r = a - (a + ~a + 1) = -(~a + 1)，数值位才等于实际值</li>
</ol>
<p>我们继续整合符号位，当符号位中0表示负号，1表示正号时，符号位参与运算后为1</p>
<ul>
<li>对于被减数 - 减数 &gt;= 0，溢出位参与符号位的运算恰好使得结果的符号为正</li>
<li>对于被减数 - 减数&lt; 0，符号位不变表示结果小于0，恰好表示了 -(~a + 1)中的负号</li>
<li>对于减数，将x - a = x+ b 看作 x -a = x + [-a]<sub>新的形式</sub>，- a = [-a]<sub>新的形式</sub></li>
</ul>
<h4><span id="小结">小结</span></h4>
<p>加上符号位的减法运算，我们可以总结出：</p>
<ol>
<li>减法变加法，减数看成负数，数值位为按位取反后加1，符号位为1</li>
<li>符号位应为数值位高一位，参与加法运算</li>
<li>结果如果符号位为0则不变，如果符号为1，符号位不变，作 取反加1 的变换</li>
</ol>
<p>至此，补码的定义逐渐清晰起来</p>
<h4><span id="定义">定义</span></h4>
<ul>
<li>补码的符号位为数值位高一位，0表示负，1表示正</li>
<li>正数的补码与原码一致，负数的补码符号位不变，数值位作 取反加1</li>
</ul>
<p>8位的补码表示范围为：</p>
<p>​	1111 1111 ~ 0111 1111，补码没有-0的结果，补码中的1000 0000表示-128</p>
<p>(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub> + [1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub> = -128D</p>
<p>表示范围：-128 ~ 127</p>
<h4><span id="补码的加法">补码的加法</span></h4>
<p>最低位开始，按位相加，并往高位进位（符号位参与运算）</p>
<h4><span id="补码的减法">补码的减法</span></h4>
<p>减法变加法，减数看成负数，被减数的补码加上减数的负数的补码，，减数符号位为1不变，数值位为按位取反后加1</p>
<p>有符号5位2进制的模为2<sup>5</sup>，第5位为符号位</p>
<blockquote>
<p><strong>[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></strong></p>
</blockquote>
<ol>
<li>被减数-减数 = 0	[1]<sub>补</sub> - [1]<sub>补</sub> = [1]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0000]<sub>补</sub> = 0D</li>
<li>被减数-减数 &gt; 0	[2]<sub>补</sub> - [1]<sub>补</sub> = [2]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0010 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0001]<sub>补</sub> = 1D</li>
<li>被减数-减数 &lt; 0	[1]<sub>补</sub> - [2]<sub>补</sub> = [1]<sub>补</sub> + [-2]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1110]<sub>补</sub> = [<u>1</u>1111]<sub>补</sub>= -1D</li>
</ol>
<p>结果还是补码，计算机内，所有带符号整数的加减法都先转换为补码</p>
<h4><span id="补码lt-gt原码">补码&lt;-&gt;原码</span></h4>
<ol>
<li>
<p>在补码减法运算中，[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub>；根据原码、补码定义，[b]<sub>补</sub> = [b]<sub>原</sub>，-[b]<sub>原</sub> = [-b]<sub>原</sub>，</p>
<blockquote>
<p>[a]<sub>原</sub> + [-b]<sub>原</sub> = [a]<sub>原</sub> - [b]<sub>原</sub> =  [a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></p>
</blockquote>
</li>
</ol>
<p>也就是 [-b]<sub>原</sub>到 [-b]<sub>补</sub>的转换，[-b]<sub>原</sub>的符号位为1不变，数值位按位取反后加1</p>
<ol start="2">
<li>而被减数-减数 &lt; 0，结果为补码，要转换成原码，符号位为1不变，还需将数值位按位取反后加1</li>
</ol>
<p>总结：补码与原码之间的转换相同，正数不变，负数符号位为1不变，数值位按位取反后加1</p>
<h3><span id="反码">反码</span></h3>
<p>在使用补码作减法运算中，对于正数用不到按位取反的操作，而多次将负数的数值位按位取反再加一，将数值位按位取反也定义成新的形式，这个新的形式就是反码</p>
<h4><span id="定义">定义</span></h4>
<ul>
<li>反码的最高位为符号位，符号位为1为负数，符号位为0则为负数</li>
<li>正数的反码与原码相同，负数的反码符号位为1不变，数值位按位取反</li>
</ul>
<p>8位的反码表示范围为：</p>
<blockquote>
<p>​	1000 0000 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4><span id="反码-gt-补码">反码 -&gt; 补码</span></h4>
<p>[X]<sub>补</sub> = [X]<sub>反</sub> + 1</p>
<h3><span id="移码">移码</span></h3>
<p>移码的符号位用“1”表示正数，用“0”表示负数，数值部分与补码相同。</p>
<p>常用于表示浮点数的阶码</p>
<h2><span id="总结">总结</span></h2>
<table>
<thead>
<tr>
<th>n + 1 bit</th>
<th>无符号整数</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
<th>移码</th>
</tr>
</thead>
<tbody>
<tr>
<td>表示范围</td>
<td>0 ~ 2<sup>n+1</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最大值</td>
<td>11…11=2<sup>n+1</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11=2<sup>n</sup>-1</td>
<td>1,11…11=2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最小值</td>
<td>00…00 = 0</td>
<td>1,11…11 = -(2<sup>n</sup>-1)</td>
<td>1,00…00 = -(2<sup>n</sup>-1)</td>
<td>1,00…00=-(2<sup>n</sup>)</td>
<td>0,00…00=-(2<sup>n</sup>)</td>
</tr>
<tr>
<td>0的表示</td>
<td>00…00</td>
<td>[+0]<sub>原</sub>=0,00…00,[-0]<sub>原</sub>=1,00…00</td>
<td>[+0]<sub>反</sub>=0,00…00[-0]<sub>反</sub>=1,11…11</td>
<td>[0]<sub>补</sub>=0,00…00</td>
<td>[0]<sub>移</sub>=1,00…00</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63993b6ab1fccdcd36b1b146.png" alt="相互转换"></p>
<h1><span id="定点数的表示">定点数的表示</span></h1>
<p>定点数约定小数点的位置不变，定点纯整数约定了小数点在数值位的最后。定点纯小数约定了数值位的最高位在小数点后面。</p>
<h2><span id="定点小数的原码-反码表示">定点小数的原码、反码表示</span></h2>
<p>​	整数符号位后接，号，小数符号位接.号</p>
<h2><span id="定点小数的补码">定点小数的补码</span></h2>
<p>​	定点小数的补码加减法运算同带符号整数的补码加减法运算</p>
<h2><span id="位数扩展">位数扩展</span></h2>
<p>定点小数与定点整数做时，扩展位置不同</p>
<ul>
<li>定点小数右边扩展</li>
<li>定点整数在符号位后一位扩展</li>
</ul>
<h1><span id="浮点数的表示">浮点数的表示</span></h1>
<p>浮点数是与定点数相对的概念，定点数约定小数点的位置不变。</p>
<p>使用定点数表示时，当定点数占用的字长多而有效数字少时，就会造成存储空间的浪费；使用浮点数表示，合理改变小数点的位置，仅存储有效数字和2次幂信息，在位数有限的情况下，既扩大了数的表示范围，又保留了数的有效精度</p>
<h2><span id="浮点数的形式">浮点数的形式</span></h2>
<p>浮点数由尾数M和阶码E构成。基数为2的数F的浮点数表示为：</p>
<blockquote>
<p>F = M*2<sup>E</sup></p>
</blockquote>
<ul>
<li>尾数M存储有效数字，尾数反映数字的精度</li>
<li>阶码E存储2次幂信息，阶码反映表示范围，以及小数点的位置</li>
</ul>
<h3><span id="浮点数编码规则">浮点数编码规则</span></h3>
<table>
<thead>
<tr>
<th>阶符</th>
<th>阶码</th>
<th>数符</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>k位</td>
<td>1位</td>
<td>n位</td>
</tr>
<tr>
<td>阶码的正负</td>
<td>数值大小</td>
<td>浮点数的正负</td>
<td>数值精度</td>
</tr>
</tbody>
</table>
<ul>
<li>尾数M必须为<strong>小数</strong>，用n+1位有符号定点小数表示，可采用的原码，补码。</li>
<li>阶码E必须为<strong>整数</strong>，用k+1位有符号定点整数表示，可采用原码，补码，移码。</li>
<li>浮点数编码的位数m=(n+1)+(k+1)</li>
</ul>
<h2><span id="非规格化浮点数">非规格化浮点数</span></h2>
<p>当对尾数M只要求是小数而无其他限制时，此时的浮点数被称为非规格化浮点数。</p>
<p>假设阶码和尾数都用原码表示，则非规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th>阶码和尾数</th>
<th>数值</th>
<th>阶码和尾数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶码最小值</td>
<td>- (2<sup>k</sup>-1)</td>
<td>阶码最大值</td>
<td>2<sup>k</sup>-1</td>
</tr>
<tr>
<td>尾数最小负值</td>
<td>-(1- 2<sup>-n</sup>)</td>
<td>尾数最大负值</td>
<td>-2<sup>-n</sup></td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>2<sup>-n</sup></td>
<td>尾数最大正值</td>
<td>1-2<sup>-n</sup></td>
</tr>
</tbody>
</table>
<p>以8位数值位，一位符号位的阶码为例子： 由于用原码表示，</p>
<p>阶码的最小值：1 11111111 即 -(2^8 - 1) = -255</p>
<p>阶码的最大值：0 0000000 即   2^8 - 1  =  255</p>
<p>尾数也是8位数值位，1为符号位原码的形式：</p>
<p>由于我们限定了浮点数的尾数只能是小数，所以我们当成定点纯小数的形式进行分析：</p>
<p>尾数的最小负值：1.11111111	即-(1- 2<sup>-8</sup>)</p>
<p>尾数的最大负值：1.0000001	即-2<sup>8</sup></p>
<p>尾数的最大正值：0.11111111	即1- 2<sup>-8</sup></p>
<p>尾数的最小正值	0.0000001	即2<sup>8</sup></p>
<h2><span id="规格化浮点数">规格化浮点数</span></h2>
<p>假如一个尾数M用原码表示为0.00000001，那么这8位尾数的前7位都是0，这7个0实际上是无效数值位，我们完全可以改写成：</p>
<blockquote>
<p>0.1XXXXXXX×2<sup>-7</sup></p>
</blockquote>
<p>当1左移到最高位时，尾数后面多出来了7位可以多表示7个有效位来提高精度</p>
<p>规格化浮点数，就是调整一个非规格化浮点数的位数和阶码的大小，使非零的浮点数在尾数的最高位上保证是一个有效值</p>
<p>规格化浮点数使尾数存储空间能表示更多的有效数位</p>
<h3><span id="规范">规范</span></h3>
<p>若尾数M用原码表示，</p>
<ul>
<li>
<p>当M ≥0时，[M]<sub>原</sub> = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M]<sub>原</sub> = 1.1XXXXXXX</p>
<p>若尾数M用补码表示，</p>
</li>
<li>
<p>当M ≥0时，[M] 补 = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M] 补 = 1.0XXXXXXX</p>
</li>
</ul>
<h3><span id="表示范围">表示范围</span></h3>
<p>尾数用原码表示，则规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>数值</th>
<th></th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>尾数最小负值</td>
<td>-(1-2<sup>n</sup>)</td>
<td>尾数最大负值</td>
<td>-1/2</td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>1/2</td>
<td>尾数最大正值</td>
<td>1-2<sup>n</sup></td>
</tr>
</tbody>
</table>
<p>因此规格化浮点数将尾数M的绝对值限定在规定的数值范围之内，即</p>
<blockquote>
<p>1/2 ≤ ∣ M ∣ &lt; 1 （原码）</p>
</blockquote>
<p>要使尾数的绝对值在此范围内，通过改变小数点的位置（相应地改变阶码）就可以做到。</p>
<h3><span id="操作">操作</span></h3>
<table>
<thead>
<tr>
<th>非规格化浮点数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>当运算结果最高位不是有效位时</td>
<td>尾数每左移一位，阶码减一</td>
</tr>
<tr>
<td>当运算结果的尾数的有效位进到小数点前面时</td>
<td>尾数每右移一位，阶码加一</td>
</tr>
</tbody>
</table>
<ul>
<li>判断浮点数是否规格化：尾数最高位是否是有效位</li>
<li>正数补码（原码）而言，有效位都为1；而对于负数补码而言，有效位为0，对于负数原码，有效位为1</li>
<li>特别地，补码表示中，-1/2（1.100000000）不是规格化形式，-1（1.00000000）是规格化形式；，注意不要与原码规格化判定的绝对值范围混淆</li>
</ul>
<h2><span id="ieee-754标准浮点数">IEEE 754标准浮点数</span></h2>
<h3><span id="单精度浮点数">单精度浮点数</span></h3>
<p>IEEE 754规定单精度浮点数的真值N一般表示为：</p>
<blockquote>
<p>N = (-1)<sup>S</sup> * 2<sup>e-127</sup> * 1.f</p>
</blockquote>
<table>
<thead>
<tr>
<th>数符S</th>
<th>阶码e</th>
<th>尾数f</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>8位</td>
<td>23位</td>
</tr>
<tr>
<td>浮点数的正负</td>
<td>含1位阶符，采用移码表示，偏移量127</td>
<td>浮点数的精度，采用原码表示</td>
</tr>
</tbody>
</table>
<ul>
<li>IEEE 754中的阶码采用移码来表示，但对于单精度浮点数来说，移码的偏移量不是2<sup>7</sup>而是2<sup>7</sup> − 1 = 127 ,这是因为IEEE 754将移码编码的全0和全1作为了特殊标识。</li>
<li>IEEE 754浮点数是规格化浮点数，为了能够更多地表示尾数的有效数位，规定尾数真值的整数部分必须为1，尾数编码时整数1隐去，小数部分f用原码表示。</li>
</ul>
<table>
<thead>
<tr>
<th>真值D</th>
<th>补码</th>
<th>移码</th>
<th>阶码真值</th>
</tr>
</thead>
<tbody>
<tr>
<td>-128</td>
<td>1000 0000</td>
<td>0000 0000</td>
<td>/</td>
</tr>
<tr>
<td>-127</td>
<td>1000 0001</td>
<td>0000 0001</td>
<td>1111 1110</td>
</tr>
<tr>
<td>-126</td>
<td>1000 0010</td>
<td>0000 0010</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>-1</td>
<td>1111 1111</td>
<td>0111 1111</td>
<td>0000 0000</td>
</tr>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>1000 0000</td>
<td>0000 0001</td>
</tr>
<tr>
<td>1</td>
<td>0000 0001</td>
<td>1000 0001</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>125</td>
<td>0111 1101</td>
<td>1111 1101</td>
<td></td>
</tr>
<tr>
<td>126</td>
<td>0111 1110</td>
<td>1111 1110</td>
<td></td>
</tr>
<tr>
<td>127</td>
<td>0111 1111</td>
<td>1111 1111</td>
<td></td>
</tr>
</tbody>
</table>
<h4><span id="阶码e全0和全1时的特殊含义">阶码e全0和全1时的特殊含义</span></h4>
<ol>
<li>当阶码全0，且尾数f不全0时，表示该浮点数不是规格化浮点数，尾数实际为：0.XXXXXXXX 次正规数,而不是规定形式的：1.XXXXXXXX</li>
<li>当阶码e全1，且尾数f全为0时，则该浮点数表示正无穷大或负无穷大，当数符s为1时，表示负无穷大，当数符s为0时，表示正无穷大。</li>
<li>当阶码e全1，且尾数f不全为0时，则该浮点数表示非数值数据（NaN）。</li>
</ol>
<h4><span id="为什么ieee-754使用移码表示阶码e">为什么IEEE 754使用移码表示阶码e</span></h4>
<h5><span id="保证浮点数的机器零的阶码为全0">保证浮点数的机器零的阶码为全0</span></h5>
<p>机器零：机器数表示0的形式</p>
<p>​	IEEE 754标准下，浮点数尾数真值的整数部分隐藏了真值1，因此无法通过尾数全0来表示机器0；使用阶符表示机器0时，当阶码的真值趋向负无穷时，即指数趋于负无穷，此时浮点真值也趋于0，因此规定使用阶码中真值为负数且最小的数来表示机器0；假设使用8位补码来表示阶码，此时机器0表示为1000 0000B（-127D)，若使用8位移码，则使用 0000 0000 ；使用移码更直观，因此规定<strong>尾数、阶码同时全为0来表示机器0</strong>。（阶码全0，尾数不全0时，表示浮点数非规格化）</p>
<h5><span id="移码全部位于正轴上随真值增大而增大">移码全部位于正轴上，随真值增大而增大</span></h5>
<p>​	移码是对于某一个系列或集合的数使它们都映射到正数轴上去，即在数轴上把数都统一往右移动n位，使得所有的数都不为负数。IEEE 754标准下，移码E=e+偏移量，因此对于所有的E都有E大于等于0。由于移码都是从0开始的正数，所以即使是二进制的表示形式，也能直接<strong>比较阶码对应数值的大小</strong>(而补码之间的比较要观察符号位，同时转换成原码对数值位进行比较)。</p>
<h5><span id="移码也能减法变加法">移码也能减法变加法</span></h5>
<p>移码相对于补码仅符号位取反，进行减法运算时，也能加法变减法，只是符号位代表的含义不同，0表示负数，1表示正数，使用移码减法运算和补码减法运算得到的结果真值相同。</p>
<h5><span id="总结">总结</span></h5>
<p>对于单精度浮点数：<br>
(1)阶码的真值E=e-127，并且0&lt;e&lt;255，-126&lt;E&lt;127。</p>
<p>(2)当e=0或255时，在IEEE 754中表示特殊的数。</p>
<p>(3)所能表示的范围为：</p>
<ul>
<li>正数为：+2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到+2 <sup>−126</sup> ×(1+0)</li>
<li>负数为：−2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到−2 <sup>−126</sup> ×(1+0)</li>
</ul>
<h3><span id="双精度浮点数">双精度浮点数</span></h3>
<p>简要说明双精度浮点数（与单精度浮点数相类似）：</p>
<p>（1)阶码的真值E的取值范围为：-1022 ~ +1023,偏移量为+1023,阶码移码编码e为：<br>
+1 ~ + 2046</p>
<p>（2）双精度浮点数的规格化数表示为：N=(−1) s ×2 e−1023 ×1.f</p>
<p>（3）所能表示的规格化数范围：<br>
正数为：+2 +1023 ×(1+1−2 −52 )到+2 −1022 ×(1+0)</p>
<p>负数为：−2 +1023 ×(1+1−2 −52 )到−2 −1022 ×(1+0)</p>
<p>（4）当e=0或e=2047时，在IEEE 754标准中表示特殊的数</p>
<h3><span id="舍入模式">舍入模式</span></h3>
<p>我们在进行对阶或者右规格化的时候，阶数较小的操作数在进行右移的时候，会造成尾数部分的低位丢失，从而会造成误差。因此我们才需要根据需求，采取四种舍入模式中的一种对尾数进行舍入操作以减少误差。</p>
<p>二、IEEE754标准中的4种舍入模式<br>
1、就近舍入：</p>
<p>即十进制下的四舍五入。但是也会出现以下几种情况：</p>
<p>多余数字是1001，它大于0.5，故最低位进1。<br>
多余数字是0111，它小于0.5，则直接舍掉多余数字。<br>
多余数字是1000，正好是等于0.5的特殊情况；那么此时最低位为0则舍掉多余位，最低位为1则进位1。<br>
注意这里说明的数位都是指二进制数。因为这是尾数，所以在计算这些二进制和0.5的关系的时候，也即转为10进制的时候，我们用每一位的权重乘以2^(-i)然后求和即可。</p>
<p>2、朝0舍入：即朝数轴零点方向舍入，所以我们直接截尾即可。</p>
<p>3、朝正无穷舍入：对正数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；负数的话不管多余位是多少直接截尾即可。</p>
<p>4、朝负无穷舍入：对负数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；正数的话不管多余位是多少直接截尾即可。</p>
]]></content>
      <categories>
        <category>计算机组成与原理</category>
      </categories>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/post/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<span id="more"></span>
<h1><span id="算数运算符">算数运算符</span></h1>
<h2><span id="加法-取正">+:	 加法 、取正</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>，b = <span class="number">2</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(a + b + str);<span class="comment">//3hello</span></span><br><span class="line">System.out.println(str + a + b);<span class="comment">//hello12</span></span><br><span class="line">System.out.println(str + (a + b));<span class="comment">//hello3</span></span><br><span class="line">System.out.println(a + str + b);<span class="comment">//1hello2</span></span><br></pre></td></tr></table></figure>
<p>从左向右执行：</p>
<ul>
<li>符号两边有任意一边是字符串 做的是字符串拼接</li>
<li>符号两边都是数字 做的是加法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;<span class="comment">//48</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">System.out.println(x + y + c);<span class="comment">//52</span></span><br><span class="line">System.out.println(s + y + c);<span class="comment">//030</span></span><br><span class="line">System.out.println(y + c + s);<span class="comment">//510</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;*	*&quot;</span>);<span class="comment">//*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//数字</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//数字*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));<span class="comment">//*	*</span></span><br></pre></td></tr></table></figure>
<h2><span id="-减法-取负">-  :	减法 、 取负</span></h2>
<h2><span id="乘法">* :	乘法</span></h2>
<h2><span id="除法">\ :	除法</span></h2>
<p>​		<code>System.out.println(10/3*3);//9</code></p>
<h2><span id="取余">%：取余</span></h2>
<ul>
<li>
<p>任意数字和n取余结果是[0，n-1]</p>
</li>
<li>
<p>取余结果符号和被除数符号一致</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(a  + <span class="string">&quot; % &quot;</span> + b  + <span class="string">&quot; = &quot;</span> + (a % b));</span><br><span class="line">System.out.println(-a + <span class="string">&quot; % &quot;</span> + b  + <span class="string">&quot; = &quot;</span> + (-a % b));</span><br><span class="line">System.out.println(a  + <span class="string">&quot; % &quot;</span> + -b + <span class="string">&quot; = &quot;</span> + (a % -b));</span><br><span class="line">System.out.println(-a + <span class="string">&quot; % &quot;</span> + -b + <span class="string">&quot; = &quot;</span> + (-a % -b));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	随意给出一个整数，打印显示它的个位数，十位数，百</span></span><br><span class="line"><span class="comment">	位数的值，例如:数字345的情况如下：</span></span><br><span class="line"><span class="comment">	个位数：5 十位数：4 百位数：3</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">345</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;个位数:&quot;</span> + number%<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;十位数:&quot;</span> + number/<span class="number">10</span>%<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;百位数:&quot;</span> + number/<span class="number">100</span>);<span class="comment">//number/10/10</span></span><br></pre></td></tr></table></figure>
<h2><span id="前-后-前-后">前++ 、 后++、前–、后–</span></h2>
<h3><span id>++</span></h3>
<ul>
<li>同:运算结果相同 都是减1</li>
<li>异:前++：先加1 再赋值     后++：先赋值 再加1</li>
</ul>
<h2><span id>–</span></h2>
<ul>
<li>同:运算结果相同 都是减1</li>
<li>异:前–：先减1 再赋值     后–：先赋值 再减</li>
<li>++ – 不改变自身数据类型 所以 byte b = 3 ;b++;不报错，区别于<a href="../%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型中的常数赋值</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//b = b + 1;//报错</span></span><br><span class="line">b++;<span class="comment">//++b  === (byte)(b + 1)</span></span><br></pre></td></tr></table></figure>
<h1><span id="赋值运算符">赋值运算符</span></h1>
<h2><span id="基本运算符">基本运算符： =</span></h2>
<h2><span id="扩展运算符-">扩展运算符： += -= *= /= %=</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给一个数加1 有几种方式</span></span><br><span class="line">i = i + <span class="number">1</span>;<span class="comment">//方式1</span></span><br><span class="line">i++;<span class="comment">//++i; 方式2</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">//方式3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不改变自身数据类型 byte b = 5; b += 1; 不报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//b = b + 1; //报错</span></span><br><span class="line">b += <span class="number">1</span>;	<span class="comment">//不报错 b = (byte)(b + 1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">ii *= <span class="number">0.1</span>;<span class="comment">//不报错 ii = (int)(ii * 0.1) </span></span><br></pre></td></tr></table></figure>
<h1><span id="关系运算符">关系运算符</span></h1>
<h1><span id="逻辑运算符">逻辑运算符</span></h1>
<p>操作数是boolean 运算结果也是boolean类型</p>
<h2><span id="逻辑与-短路与">逻辑与、短路与</span></h2>
<ul>
<li>有一假结果是假</li>
<li>同:运算结果相同</li>
<li>当运算符左侧是false,&amp;右侧继续运算 &amp;&amp; 发生短路 右侧不运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp; 和 &amp;&amp;短路与的区别</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">//boolean result = sex == &#x27;女&#x27; &amp; age++ == 10;	//age = 11</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> sex == <span class="string">&#x27;女&#x27;</span> &amp;&amp; age++ == <span class="number">10</span>;		<span class="comment">//age = 10</span></span><br></pre></td></tr></table></figure>
<h2><span id="逻辑或-短路或">逻辑或、短路或</span></h2>
<ul>
<li>有一真结果为真</li>
<li>运算结果相同</li>
<li>当运算符左侧是true,|右侧继续运算 || 发生短路 右侧不运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//| 和 || 的区别</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">//boolean result = sex == &#x27;男&#x27; | age++ == 10;	//age = 11</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> sex == <span class="string">&#x27;男&#x27;</span> || age++ == <span class="number">10</span>;		<span class="comment">//age = 10</span></span><br></pre></td></tr></table></figure>
<h2><span id="逻辑非">逻辑非</span></h2>
<ul>
<li>！取反</li>
</ul>
<h2><span id="逻辑异或">逻辑异或</span></h2>
<ul>
<li>^ :相同为假 不同为真</li>
</ul>
<h1><span id="位运算符">位运算符</span></h1>
<p>操作的是数值,得到数值的补码然后进行位运算</p>
<h2><span id="移位运算一元运算符">移位运算(一元运算符)</span></h2>
<h3><span id="左移-ltlt">左移 &lt;&lt;</span></h3>
<p>每移动一位相当于* 2 空位补0</p>
<h3><span id="右移-gtgt">右移 &gt;&gt;</span></h3>
<p>每移动一位相当于/ 2 最高位是0就补0 是1就补1</p>
<h3><span id="无符号右移-gtgtgt">无符号右移 &gt;&gt;&gt;</span></h3>
<p>每移动一位相当于/ 2 最高位补0</p>
<h2><span id="逻辑运算二元运算符">逻辑运算(二元运算符)</span></h2>
<p>每一位上如果是1 看做true 如果是0 看做false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3><span id="逻辑与-amp">逻辑与 &amp;</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x &amp; y;<span class="comment">//4</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000100 4</span></span><br></pre></td></tr></table></figure>
<h3><span id="逻辑或">逻辑或 |</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = x | y;<span class="comment">//13</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001101 13</span></span><br></pre></td></tr></table></figure>
<h3><span id="逻辑非-~">逻辑非 ~</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = ~x;<span class="comment">//-13</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11110011 补码</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11110010 反码	补码减去1得到反码</span></span><br><span class="line"><span class="comment">//10000000 00000000 00000000 00001101 源码 	符号位不变其他位取反得到源码	- 13</span></span><br></pre></td></tr></table></figure>
<h3><span id="逻辑异或">逻辑异或 ^</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = x ^ y;<span class="comment">//9</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001001 9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>m = (m^^<sup>n)</sup>^^n</li>
</ul>
<h3><span id="3种变量交换">3种变量交换</span></h3>
<h4><span id="临时变量">临时变量</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br></pre></td></tr></table></figure>
<h4><span id="累加消除">累加消除</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = a + b;</span><br><span class="line">a = b - a;</span><br><span class="line">b = b - a;</span><br></pre></td></tr></table></figure>
<ol>
<li>少定义一个变量</li>
<li>有局限，可能超过int类型</li>
</ol>
<h4><span id="异或消除">异或消除</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br></pre></td></tr></table></figure>
<ol>
<li>少定义一个变量</li>
<li>没有局限</li>
<li>m = (m^^<sup>n)</sup>^^n</li>
</ol>
<h1><span id="三元运算符">三元运算符</span></h1>
<ul>
<li>
<p>boolean表达式 ? 表达式1 : 表达式2</p>
</li>
<li>
<p>boolean表达式返回true  表达式1的结果作为整个表达式的结果</p>
</li>
<li>
<p>boolean表达式返回false 表达式2的结果作为整个表达式的结果</p>
</li>
</ul>
<p>注意:</p>
<ol>
<li>表达式1 和 表达式2 结果类型必须保持一致</li>
<li>表达式结果会发生自动类型转换，转换成范围大的数据类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span> ? <span class="string">&quot;已成年&quot;</span> : <span class="number">1.0</span>;<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="number">1</span> : <span class="number">1.0</span>;	<span class="comment">//不报错 发生自动类型转换 1.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);<span class="comment">//发生自动类型转换</span></span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>继承</title>
    <url>/post/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>is a”代表的是类之间的继承关系，比如PC机是计算机，工作站也是计算机。PC机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java语言实现时，应该将PC机和工作站定义成两种类，均继承计算机类。</p>
<p>“has a”代表的是对象和它的成员的从属关系。同一种类的对象，通过它们的属性的不同值来区别。比如一台PC机的操作系统是Windows，另一台PC机的操作系统是Linux。操作系统是PC机的一个成员变量，根据这一成员变量的不同值，可以区分不同的PC机对象。</p>
<p>is a 是如果A是B，那么B就是A的基类。比如：等边三角形是使是三角形，那么，三角形就是等边三角形的基类。<br>
has a 是如果A中有B，那么，B就是A的组成部分</p>
<p>如果你确定两件对象之间是is-a的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承而不是聚合。<br>
如果你确定两件对象之间是has-a的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类，而不是从电脑类继承。</p>
<span id="more"></span>
<p>如果多个类有着共同的属性,并且类之间符合is a 的关系，可以将共性的抽取到一个类中,作为父类,</p>
<p>别的类通过使用extends继承它,进而获取它的所有的成员(处理构造器)</p>
<h2><span id="意义">意义</span></h2>
<p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个 类无需再定义这些属性和行为，只要继承那个类即可。</p>
<h2><span id="使用">使用</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类:继承其他类的类,又叫派生类</li>
<li>父类:被继承的类,又叫基类或者超类</li>
</ul>
<ol>
<li>Java只支持单继承,不能多继承,支持多级继承</li>
<li>如果继承了一个类,那么就拥有了除了构造方法之外的父类的所有的成员(属性和方法)</li>
<li>私有成员(private)不能被继承的,引用了私有成员的方法可以被子类继承的</li>
</ol>
<p>静态成员也是被继承的(没有意义)</p>
<h2><span id="方法的重写">方法的重写</span></h2>
<p>当子类从父类中继承过来的方法不满足自身的要求的时，在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将代替父类的方法执行。</p>
<table>
<thead>
<tr>
<th></th>
<th>子类重写后的方法、父类被重写的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法名称、参数列表</td>
<td>相同</td>
</tr>
<tr>
<td>异常、返回值类型</td>
<td>小于等于</td>
</tr>
<tr>
<td>访问权限</td>
<td>大于等于</td>
</tr>
</tbody>
</table>
<ul>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>
<li>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)， 或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法重写属于父类的方法。</li>
</ul>
<h3><span id="重载overload和重写override">重载(Overload)和重写(Override)</span></h3>
<table>
<thead>
<tr>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>在一个类中</td>
<td>在子类和父类中</td>
</tr>
<tr>
<td>同名方法的参数列表不同(参数类型，参数个数以及参数顺序)</td>
<td><strong>同名方法的参数列表都必须相同</strong></td>
</tr>
<tr>
<td>返回类型没有要求</td>
<td><strong>返回类型与父类一致（引用类型要能向上转型）</strong></td>
</tr>
<tr>
<td>访问权限没有要求</td>
<td>相比于重写前的方法，<strong>访问权限不能更低</strong></td>
</tr>
<tr>
<td>异常没有要求</td>
<td>相比于重写前的方法，不能申明更加宽泛的检查型异常</td>
</tr>
<tr>
<td>实现类中的多态（编译时的多态性）</td>
<td>多态的前提（运行时的多态性）</td>
</tr>
</tbody>
</table>
<h2><span id="访问权限修饰符">访问权限修饰符</span></h2>
<p>在类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<p>（public&gt;protected&gt;default&gt;private)</p>
<table>
<thead>
<tr>
<th>访问权限修饰符</th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>类内部</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>同包</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>不同包子类</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>同一个工程</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>其中，对于class的权限修饰只可以用public和default(缺省)。</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/post/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<span id="more"></span>
<!-- toc -->
<ul>
<li><a href="#java%E4%B8%AD%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB">java中集合和数组的区别</a></li>
<li><a href="#java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E9%83%BD%E6%98%AF%E5%AE%B9%E5%99%A8">java中的集合和数组都是容器</a></li>
<li><a href="#java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">java中的集合框架</a>
<ul>
<li><a href="#%E9%9B%86%E5%90%88%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%85javautil">集合所在的包java.util</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE">集合类图</a></li>
<li><a href="#collection%E6%96%B9%E6%B3%95">Collection方法</a></li>
<li><a href="#%E5%AD%90%E6%8E%A5%E5%8F%A3%E7%89%B9%E7%82%B9">子接口特点</a></li>
</ul>
</li>
<li><a href="#arraylist%E9%9B%86%E5%90%88">ArrayList集合</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0">遍历元素</a></li>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">底层实现</a>
<ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B">添加元素过程</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B">删除元素过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%AD%E4%BB%A3">迭代器迭代</a>
<ul>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a></li>
<li><a href="#%E5%9C%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%AD%E4%BB%A3%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E7%9A%84%E5%A2%9E%E5%8A%A0%E6%88%96%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95">在迭代器迭代中，为什么不能使用集合的增加或删除方法</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95">迭代器删除方法</a>
<ul>
<li><a href="#modcount">modCount</a></li>
<li><a href="#expectedmodcount">expectedModCount</a></li>
<li><a href="#cursor">cursor</a></li>
<li><a href="#lastret">lastRet</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E5%8E%9F%E7%90%86">迭代器删除原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#linkedlist">LinkedList</a></li>
<li><a href="#hashset">HashSet</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E7%89%B9%E7%82%B9-1">特点</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B-1">添加元素过程</a></li>
<li><a href="#%E5%88%A4%E9%87%8D">判重</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95-1">方法</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0-1">遍历元素</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8eclipseidea%E5%A4%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95%E6%9C%8931%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97">为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#treeset">TreeSet</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0-1">概述</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95-2">方法</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0-2">遍历元素</a></li>
<li><a href="#%E7%89%B9%E7%82%B9-2">特点</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%99%A8">比较器</a>
<ul>
<li><a href="#%E5%86%85%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8">内部比较器</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8">外部比较器</a></li>
</ul>
</li>
<li><a href="#treeset%E5%8E%BB%E9%87%8D">TreeSet去重</a></li>
<li><a href="#%E7%89%B9%E7%82%B9-3">特点</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98">排序问题</a>
<ul>
<li><a href="#treeset%E6%8E%92%E5%BA%8F%E4%BD%86%E4%B8%8D%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D">TreeSet排序但不去除重复</a></li>
<li><a href="#arraylist%E7%BB%93%E5%90%88collections%E6%96%B9%E6%A1%88%E6%8E%92%E5%BA%8F%E4%BD%86%E4%B8%8D%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D">ArrayList结合Collections方案排序但不去除重复</a></li>
<li><a href="#collections%E5%B7%A5%E5%85%B7%E7%B1%BB">Collections工具类</a>
<ul>
<li><a href="#sort%E6%96%B9%E6%B3%95">sort()方法</a></li>
<li><a href="#arrayssort">Arrays.sort()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#map%E6%8E%A5%E5%8F%A3%E9%94%AEkey%E5%80%BCvalue%E5%AF%B9">Map接口【键（key）值(value)对】</a>
<ul>
<li><a href="#map%E6%8E%A5%E5%8F%A3%E7%BB%93%E6%9E%84">Map接口结构</a></li>
<li><a href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E7%BB%93%E6%9E%84">键值对的结构</a></li>
<li><a href="#hashset%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">HashSet和TreeSet实现方案</a></li>
</ul>
</li>
<li><a href="#hashmap">HashMap</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95-3">方法</a></li>
<li><a href="#%E9%81%8D%E5%8E%86">遍历</a></li>
<li><a href="#%E5%8E%BB%E9%87%8D">去重</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">执行原理</a>
<ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B-2">添加元素过程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="java中集合和数组的区别">java中集合和数组的区别</span></h1>
<ul>
<li>数组的长度是固定的，集合的长度无限制</li>
<li>数组里面的每个元素都必须是相同类型，集合里面的元素可以是任意类型
<ul>
<li>集合里面的元素往往在很多时候是需要统一的，集合采用了泛型的方法来统一元素类型</li>
</ul>
</li>
<li>数组拥有固定的算法，集合有很多种类，已经实现了各种算法</li>
</ul>
<h1><span id="java中的集合和数组都是容器">java中的集合和数组都是容器</span></h1>
<ul>
<li>学习集合的各种知识点
<ul>
<li>集合的类型</li>
<li>集合的操作（添加、删除、修改、遍历）</li>
<li>不同类型的集合的大致的实现原理</li>
</ul>
</li>
</ul>
<h1><span id="java中的集合框架">java中的集合框架</span></h1>
<h2><span id="集合所在的包javautil">集合所在的包java.util</span></h2>
<h2><span id="集合类图">集合类图</span></h2>
<img src="https://pic.imgdb.cn/item/63bb70bbbe43e0d30e6e3441.jpg" alt="image-20230105103228912" style="zoom: 50%;">
<p>Collection 接口是List、Set接口的父接口，JDK不提供Collection接口的任何直接实现,而是提供其子接口Set、List的实现。</p>
<p>集合的元素可以是任意，也可以用泛型统一。在 Java5 之前,Java 集合会丢失容器中所有对象的数据类型,把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后,Java集合可以记住容器中对象的数据类型。</p>
<p>集合的元素数量无需固定，属于动态增长和缩小</p>
<p>遍历的时候无法删除元素【遍历的时候不能改变集合的长度，删除和修改都会报错】</p>
<h2><span id="collection方法">Collection方法</span></h2>
<table>
<thead>
<tr>
<th>Collection</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回集合元素个数</td>
<td>int size()</td>
</tr>
<tr>
<td>清空集合</td>
<td>void clear()</td>
</tr>
<tr>
<td>是否是空集合</td>
<td>boolean isEmpty()</td>
</tr>
<tr>
<td>是否包含指定集合中的所有元素</td>
<td>boolean containsAll(Collection c)（调用元素的equals方法比较）</td>
</tr>
<tr>
<td>删除指定集合中的元素（差集）</td>
<td>boolean removeAll(Collection coll)</td>
</tr>
<tr>
<td>保留指定集合中的元素（交集）</td>
<td>boolean retainAll(Collection c)</td>
</tr>
<tr>
<td>集合是否相等</td>
<td>boolean eqauls(Object o)</td>
</tr>
<tr>
<td>转成对象数组</td>
<td>Object[] toArray()</td>
</tr>
<tr>
<td>返回迭代器对象</td>
<td>iterator()</td>
</tr>
</tbody>
</table>
<h2><span id="子接口特点">子接口特点</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>List</th>
<th>Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序</td>
<td>插入顺序</td>
<td>值顺序</td>
</tr>
<tr>
<td>重复</td>
<td>元素可以重复</td>
<td>不支持重复</td>
</tr>
<tr>
<td>下标</td>
<td>有下标</td>
<td>无下标</td>
</tr>
</tbody>
</table>
<h1><span id="arraylist集合">ArrayList集合</span></h1>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用泛型规定集合里面的元素统一数据类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>ArrayList</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>add(Object o)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>根据下标添加元素</td>
<td>add(int index,Object o)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>直接删除元素</td>
<td>remove(Object o)</td>
<td>boolean</td>
<td>删除成功返回true，失败返回false</td>
</tr>
<tr>
<td>根据下标删除元素</td>
<td>remove(int index)</td>
<td>Object</td>
<td>返回被删除的元素</td>
</tr>
<tr>
<td>根据下标修改元素</td>
<td>set(int index, Object o)</td>
<td>Object</td>
<td>返回被修改元素</td>
</tr>
<tr>
<td>根据下标查找元素</td>
<td>get(int index)</td>
<td>Object</td>
<td>下标不存在，或超标，返回异常</td>
</tr>
<tr>
<td>查找是否包含某个元素</td>
<td>contains(Object o)</td>
<td>boolean</td>
<td>包含返回true，不包含返回false</td>
</tr>
<tr>
<td>查找是否包含某个元素</td>
<td>indexOf(Object o)</td>
<td>int</td>
<td>包含返回该元素的下标，不包含则返回-1</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>
<p>使用remove方法删除int类型值时，会优先将int值看作index参数，即调用remove(int index)根据下标删除元素方法。若需要删除int型元素，还需将int值装箱成Integer类型<code>arrayList.remove(Integer.valueOf(1));</code></p>
</li>
<li>
<p>遍历的时候无法直接删除元素【遍历的时候不能改变集合的长度，删除和修改都会报错】，如需便利时删除，可使用迭代器的删除方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (next.equals(<span class="string">&quot;hzj4&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(next);</span><br><span class="line">        iterator.remove(); 		<span class="comment">//迭代器遍历删除方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>remove(Object o)方法通过equals(o)方法找到第一个元素并删除，若想将equal(o)的所有元素删除</p>
<p><code> while (arrayList.remove(Object o));</code></p>
</li>
</ul>
<h2><span id="遍历元素">遍历元素</span></h2>
<ul>
<li>迭代器迭代元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用下标遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    System.out.println(arrayList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用foreach遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String s : arrayList) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="特点">特点</span></h2>
<ul>
<li>ArrayList集合是有序的，自然顺序</li>
<li>ArrayList集合拥有下标</li>
<li>ArrayList集合的元素可以重复（地址一样）</li>
</ul>
<h2><span id="底层实现">底层实现</span></h2>
<ul>
<li>
<p>ArrayList底层实现是数组</p>
</li>
<li>
<p>空构造初始化数组长度是0，可带参构造初始化数组长度是参数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; temp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">50</span>);<span class="comment">//初始化底层数组容量是50</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>grow方法扩容</p>
</li>
<li>
<p>缩容</p>
<ul>
<li>删除元素的时候底层数组不会缩放，需要手动调用trimToSize()缩小底层数组长度（缩放到当前元素大小的长度）</li>
<li>删除元素的时候都会会将被删除元素以后的所有元素前移，原来的下标指向的元素会改变，因此不能在遍历的时候删除，需要使用迭代器删除</li>
</ul>
</li>
</ul>
<h3><span id="添加元素过程">添加元素过程</span></h3>
<ol>
<li>ArrayList空构造初始化数组长度为0</li>
<li>空数组扩容至10个，逐个添加元素</li>
<li>添加元素超过数组长度时，新数组长度将扩容至原数组的1.5倍  （向上取整）
<ol>
<li>当扩容1.5倍后数组长度超过数组最大长度时
<ol>
<li>扩容至数组最大值（MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8）部分JVM在数组中保留一些字头信息</li>
<li>数组最大值仍小于旧数组加1的长度时，扩容至int最大值</li>
<li>int最大值仍小于旧数组加1的长度时，再添加一个元素，长度就溢出int类型，因此产生OutOfMemoryError()异常</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>；</span><br><span class="line">elementData = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minCapacity</span> <span class="operator">=</span> size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (elementData == &#123;&#125;) &#123;		<span class="comment">//空数组添加扩容至10</span></span><br><span class="line">        minCapacity = Math.max(<span class="number">10</span>,minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;					<span class="comment">//修改次数，添加、删除时加1</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length)&#123;	<span class="comment">//当前数组长度小于添加元素后的长度，意味着旧数组需要扩容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);	<span class="comment">//扩容后新数组长度为旧数组长度的一半</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity)	</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; Integer.MAX_VALUE - <span class="number">8</span>)&#123;        <span class="comment">//0x7fffffff-8</span></span><br><span class="line">            <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">            newCapacity = (minCapacity &gt; Integer.MAX_VALUE - <span class="number">8</span>) ?Integer.MAX_VALUE:Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除元素过程">删除元素过程</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)		<span class="comment">//删除索引不存在</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);		<span class="comment">//获取要删除的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;		<span class="comment">//移动次数</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>删除索引不能超过数组非空元素</li>
<li>删除该索引下的值，并将之后的元素都前移一次，最后一个元素置空（底层C语言实现）</li>
</ol>
<h1><span id="迭代器迭代">迭代器迭代</span></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = i.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="原理">原理</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; iterator = <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cursor;       					<span class="comment">// 游标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; 					<span class="comment">// 指向上一个元素的下标，没有元素为-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;	<span class="comment">//期望修改的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cursor != size)&#123;		<span class="comment">//遍历所有非空元素</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)	<span class="comment">//修改次数与预期不符合</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="keyword">if</span> (cursor &gt;= size)			<span class="comment">//游标已经超过了数组中有数据元素的下标</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;	<span class="comment">//获取当前数组</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)	<span class="comment">//游标超过了数组长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) elementData[lastRet = cursor++];	<span class="comment">//游标指向下一个</span></span><br><span class="line">    <span class="comment">//iterator.remove();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>遍历所有非空元素</li>
<li>检查迭代期间的修改次数、是否超过数组非空元素、游标是否超过数组长度</li>
<li>获取当前游标指向的元素，并让游标指向下一个元素</li>
</ol>
<h2><span id="在迭代器迭代中为什么不能使用集合的增加或删除方法">在迭代器迭代中，为什么不能使用集合的增加或删除方法</span></h2>
<p>在迭代器迭代过程中，游标会逐个指向下个元素的下标，当使用集合的增加或删除方法时，可能改变元素在数组中的存储位置，即元素下标指向的元素可能改变，从而游标无法指向原来逐个向下的元素，最终无法通过遍历修改指定的元素</p>
<h2><span id="迭代器删除方法">迭代器删除方法</span></h2>
<p>上述问题通过引入以下属性及迭代器的删除方法得以解决</p>
<h3><span id="modcount">modCount</span></h3>
<p>记录当前集合中的增加或删除次数，初始值为0</p>
<h3><span id="expectedmodcount">expectedModCount</span></h3>
<ul>
<li>用于判断迭代期间是否进行了对数组的增加或删除操作，初始值为创建迭代器对象时集合的modCount，迭代期间modCount发生改变，即expectedModCount不等于modCount时，说明迭代期间进行了增加或删除操作，抛出ConcurrentModificationException异常</li>
<li>在迭代器删除方法中，将更新expectedModCount值</li>
</ul>
<h3><span id="cursor">cursor</span></h3>
<p>指向迭代当前元素的游标，在获取完当前元素后指向下一个元素</p>
<h3><span id="lastret">lastRet</span></h3>
<ul>
<li>初始值为-1，迭代第一个对象后，游标已经指向下一个对象，lastRet就指向当前对象</li>
<li>迭代器删除方法调用集合的删除方法删除lastRet指向的旧元素的位置，并将cursor退回到lastRet的位置实现遍历删除</li>
<li>每次遍历删除后设置lastRet为初始值，避免在一次迭代中重复使用迭代器删除方法</li>
</ul>
<h3><span id="迭代器删除原理">迭代器删除原理</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)			<span class="comment">//还没开始遍历，或一次迭代中重复使用迭代器删除方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();	</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)	<span class="comment">//修改次数与预期不符合，迭代期间进行了增加或删除操作</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;			<span class="comment">//游标回到原来位置</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;				<span class="comment">//设置lastRet为初始值，避免在一次迭代中重复使用迭代器删除方法</span></span><br><span class="line">        expectedModCount = modCount;		<span class="comment">//更新expectedModCount值</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>至少遍历过一次且未连续使用迭代器删除</li>
<li>检查迭代期间是否修改</li>
<li>调用集合删除方法删除，游标回到原来位置</li>
</ol>
<h1><span id="linkedlist">LinkedList</span></h1>
<h1><span id="hashset">HashSet</span></h1>
<h2><span id="概述">概述</span></h2>
<ol>
<li>HashSet是Set接口的典型实现，元素可以是null</li>
<li>HashSet按Hash算法来存储集合中的元素</li>
<li>底层是数组，初始容量为16，当如果使用率超过0.75，（即超过16*0.75=12）就会扩大容量为原来的2倍</li>
</ol>
<h2><span id="特点">特点</span></h2>
<ul>
<li>由哈希值以及数组长度来决定在数组中的存储位置
<ol>
<li>元素没有明确的排列顺序（遍历输出无序）</li>
<li>不支持重复的元素</li>
<li>没有下标</li>
</ol>
</li>
</ul>
<h2><span id="添加元素过程">添加元素过程</span></h2>
<img src="https://pic.imgdb.cn/item/63bbba7dbe43e0d30ef34746.jpg" style="zoom:80%;">
<ol>
<li>
<p>当向HashSet 集合中添加一个元素时，会调用该对象的 hashCode() 方法获得该对象的hashCode值</p>
</li>
<li>
<p>然后根据hashCode值，通过某种散列函数决定该对象在HashSet底层数组中的存储位置</p>
<blockquote>
<p>该散列函数根据hashCode值与底层数组的长度相计算，得到在数组中的下标，该函数计算将尽可能均匀存储元素，即越是散列分布，代表该散列函数设计的越好</p>
</blockquote>
</li>
<li>
<p>若要添加元素的hashCode与集合中某个元素的hashCode值相等（即存储位置一致），会再调用equals方法判断两元素是否相等</p>
</li>
<li>
<p>若equals方法判断两元素相等，则添加元素重复，添加失败；若不相等，由于原数组位置上已经有元素(哈希冲突)，则将新添加元素通过链表的方式连接到数组同一位置上</p>
</li>
<li>
<p>若要添加元素与集合中某个元素的hashCode值不相等，无论两元素equals方法判断是否相等，都会把它们存储在不同的位置，即添加成功。</p>
</li>
</ol>
<h2><span id="判重">判重</span></h2>
<ul>
<li>
<p>HashSet判断两个元素相等规则：<strong>hashCode() 相等 &amp;&amp; equals相等</strong></p>
<ol>
<li>
<p>先判断hashCode是否相等，若hashCode不相等直接判断不重复，若hashCode相等还要看equals是否相等</p>
</li>
<li>
<p>若equals不相等，则判断不重复，若equals相等，则判断重复</p>
<p><a href="../Object%E7%B1%BB">hashCode、equals方法</a></p>
</li>
</ol>
</li>
<li>
<p>往HashSet添加的重复数据会被丢弃</p>
</li>
<li>
<p>相等的对象必须具有相等的散列码，对于引用型对象，需重写equals()和hashCode()方法，以实现对象相等规则</p>
<ul>
<li>对象中用作equals()方法比较的Field，都应该用来计算hashCode值</li>
<li>equals()方法比较返回true时，hashCode()方法的返回值也应相等</li>
</ul>
</li>
</ul>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;E&gt; strings=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>HashSet</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>add(Object o)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>直接删除元素</td>
<td>remove(Object o)</td>
<td>boolean</td>
<td>删除成功返回true，失败返回false</td>
</tr>
<tr>
<td>查找某个元素是否存在</td>
<td>contains(Object o)</td>
<td>boolean</td>
<td>包含返回true，不包含返回false</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>优点：HashSet增加、删除、查找某个元素是否存在时,通过元素哈希值直接确定位置，不需要调整数组位置</li>
<li>缺点：HashSet不能通过指定条件返回某个元素，只能根据指定条件遍历HashSet来获取</li>
</ul>
<h2><span id="遍历元素">遍历元素</span></h2>
<ul>
<li>foreach循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (E temp : hashset) &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代器遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; iterator = hashset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>HashSet没有下标，不能通过下标遍历</li>
<li>HashSet只能通过遍历返回集合中的某个元素。因为没有下标无法定位到指定位置的元素</li>
<li>HashSet集合遍历输出的顺序与添加顺序无关</li>
</ul>
<h3><span id="为什么用eclipseidea复写hashcode方法有31这个数字">为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object a[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="literal">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>31是一个质数，如果用该质数乘上某个数字，结果只能被质数和被乘数还有1整除，方便从结果倒推</li>
<li>在作乘法不溢出的情况下选择尽量大的系数，因为乘积越大，能表示的哈希地址越多，发生冲突的概率越小</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>用移位和减法来代替乘法。31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机可以自动完成相关优化（提高算法效率）</li>
</ol>
<h1><span id="treeset">TreeSet</span></h1>
<h2><span id="概述">概述</span></h2>
<ol>
<li>TreeSet 的元素必须实现Comparable接口的 compareTo(Object obj) 方法或Comparator接口的compare(Object obj1,Object obj2)</li>
</ol>
<p>包装类已经实现了Comparable ：</p>
<table>
<thead>
<tr>
<th>包装类</th>
<th>compareTo(Object obj) 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有的数值型对应的包装类</td>
<td>按对应的数值大小进行比较</td>
</tr>
<tr>
<td>Character</td>
<td>按字符的 unicode值来进行比较</td>
</tr>
<tr>
<td>Boolean</td>
<td>true对应的包装类实例大于 false对应的包装类实例</td>
</tr>
<tr>
<td>String</td>
<td>按字符串中字符的 unicode 值进行比较</td>
</tr>
<tr>
<td>Date、Time</td>
<td>后边的时间、日期比前面的时间、日期大</td>
</tr>
</tbody>
</table>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;E&gt; e = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>TreeSet</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>add(Object o)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>直接删除元素</td>
<td>remove(Object o)</td>
<td>boolean</td>
<td>删除成功返回true，失败返回false</td>
</tr>
<tr>
<td>查找某个元素是否存在</td>
<td>contains(Object o)</td>
<td>boolean</td>
<td>包含返回true，不包含返回false</td>
</tr>
<tr>
<td>获取第一个元素</td>
<td>first()</td>
<td>Object</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>获取最后一个元素</td>
<td>last()</td>
<td>Object</td>
<td>返回最后一个元素</td>
</tr>
<tr>
<td>拿出第一个元素</td>
<td>pollFirst()</td>
<td>Object</td>
<td>返回第一个元素【原集合第一个元素删除】</td>
</tr>
<tr>
<td>拿出最后一个元素</td>
<td>pollLast()</td>
<td>Object</td>
<td>返回最后一个元素【原集合最后一个元素删除】</td>
</tr>
<tr>
<td>大于等于</td>
<td>ceiling(Object o)</td>
<td>Object</td>
<td>返回比指定元素大的元素（含相等）【找不到元素返回null】</td>
</tr>
<tr>
<td>大于</td>
<td>higher(Object o)</td>
<td>Object</td>
<td>返回比指定元素大的元素（不含相等）【找不到元素返回null】</td>
</tr>
<tr>
<td>小于等于</td>
<td>floor(Object o)</td>
<td>Object</td>
<td>返回比指定元素小的元素（含相等）【找不到元素返回null】</td>
</tr>
<tr>
<td>小于</td>
<td>lower(Object o)</td>
<td>Object</td>
<td>返回比指定元素小的元素（不含相等）【找不到元素返回null】</td>
</tr>
</tbody>
</table>
<h2><span id="遍历元素">遍历元素</span></h2>
<ul>
<li>
<p>foreach循环</p>
</li>
<li>
<p>迭代器遍历</p>
</li>
</ul>
<h2><span id="特点">特点</span></h2>
<ul>
<li>支持重复元素</li>
<li>没有下标</li>
<li>拥有升降序</li>
</ul>
<h2><span id="比较器">比较器</span></h2>
<ul>
<li>
<p>添加元素时，TreeSet 会调用集合元素的 compareTo(Object obj) 方法或compare(Object obj1,Object obj2) 来比较元素之间的大小关系（相等为0,大于或者小于使用正整数或者负数，但是官方建议使用1或者-1）， 然后将集合元素按升序(默认情况)排列</p>
</li>
<li>
<p>通常情况下，应保证当两个对象通过equals()方法比较返回true，则通过compareTo(Object obj)方法比较也应返回0</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>内部比较器</th>
<th>外部比较器</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用场景</td>
<td>只能按照一个规则比较，一般用于默认排序规则</td>
<td>可以按照不同的规则比较，创建多个比较规则对象</td>
</tr>
<tr>
<td>实现接口</td>
<td>java.lang.Comparable</td>
<td>java.util.Comparator</td>
</tr>
<tr>
<td>实现</td>
<td>实体类中实现接口，重写int compareTo(Object o)方法</td>
<td>创建实现类实现接口，重写int compare(Object o1,Object o2)方法</td>
</tr>
<tr>
<td>TreeSet构造</td>
<td>无参构造TreeSet</td>
<td>实现类实例作为形参传入TreeSet构造器</td>
</tr>
</tbody>
</table>
<h3><span id="内部比较器">内部比较器</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Stu&gt; &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.getScore()==o.getScore())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.getScore()&gt;o.getScore())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="外部比较器">外部比较器</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建按照学生年龄比较的规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuAgeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Stu&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Stu o1, Stu o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1.getAge()== o2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getAge()&gt;o2.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="treeset去重">TreeSet去重</span></h2>
<ul>
<li>判断两元素相等的标准：实现比较器中比较方法判断</li>
<li>TreeSet去重依然丢弃重复</li>
</ul>
<h2><span id="特点">特点</span></h2>
<ul>
<li>支持重复元素</li>
<li>没有下标</li>
<li>拥有升降序</li>
</ul>
<h1><span id="排序问题">排序问题</span></h1>
<ul>
<li>TreeSet排序可以通过重写比较方法灵活操作相等的元素</li>
</ul>
<h2><span id="treeset排序但不去除重复">TreeSet排序但不去除重复</span></h2>
<p>使用内部比较器重写compareTo方法，其中判断相等时不返回0，从而实现不去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.getAge()==o.getAge())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getAge()&gt;o.getAge()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="arraylist结合collections方案排序但不去除重复">ArrayList结合Collections方案排序但不去除重复</span></h2>
<table>
<thead>
<tr>
<th>使用内部比较器</th>
<th>使用外部比较器</th>
</tr>
</thead>
<tbody>
<tr>
<td>实体类实现内部比较器</td>
<td>Comparator实现类实现外部比较器</td>
</tr>
<tr>
<td>将元素添加到ArrayList中</td>
<td>将元素添加到ArrayList中</td>
</tr>
<tr>
<td>Collections.sort(arrayList);</td>
<td>Collections.sort(arrayList,外部比较器)</td>
</tr>
</tbody>
</table>
<h2><span id="collections工具类">Collections工具类</span></h2>
<h3><span id="sort方法">sort()方法</span></h3>
<ul>
<li>用Arrays.sort()方法实现的</li>
<li>Collections.sort()</li>
<li>Collections.sort(stus,外部比较器)     可传入外部比较器</li>
</ul>
<h3><span id="arrayssort">Arrays.sort()</span></h3>
<ul>
<li>JDK8以前
<ul>
<li>判断待排序数组的长度，如果小于7则直接插入排序，否则使用归并排序。</li>
</ul>
</li>
<li>JDK8以后
<ul>
<li>java会使用TimSort进行排序。判断待排序数组的长度，如果长度小于32时会使用二分插入排序，否则会使用优化过的归并排序</li>
</ul>
</li>
</ul>
<h1><span id="map接口键key值value对">Map接口【键（key）值(value)对】</span></h1>
<h2><span id="map接口结构">Map接口结构</span></h2>
<p><img src="/post/%E9%9B%86%E5%90%88/D:%5C%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99%5Chzj%5Csz2212%5C004-%E9%9B%86%E5%90%88%5C%E9%9B%86%E5%90%88.assets%5Cimage-20230110111753024.png" alt="image-20230110111753024"></p>
<h2><span id="键值对的结构">键值对的结构</span></h2>
<ul>
<li>键：唯一性（采用Set集合标准）</li>
<li>值：非唯一性（采用List集合标准）</li>
</ul>
<h2><span id="hashset和treeset实现方案">HashSet和TreeSet实现方案</span></h2>
<ul>
<li>HashMap的实现其实就是HashSet的实现（哈希表）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TreeMap的实现其实就是TreeSet的实现（红黑树）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="hashmap">HashMap</span></h1>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;K,V&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>put(K k,V v)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>根据键删除元素</td>
<td>remove(K k)</td>
<td>V</td>
<td>返回被删除的对象</td>
</tr>
<tr>
<td>根据键和值删除元素</td>
<td>remove(K k,V v)</td>
<td>boolean</td>
<td>键与值不匹配删除失败，返回false，反之true</td>
</tr>
<tr>
<td>根据键修改元素</td>
<td>replace(K k,V v)</td>
<td>V</td>
<td>返回被修改的对象</td>
</tr>
<tr>
<td>根据键获取对象</td>
<td>get(K k)</td>
<td>V</td>
<td>返回查找的对象</td>
</tr>
<tr>
<td>获取所有键</td>
<td>keySet()</td>
<td>Set&lt;K&gt;</td>
<td>返回包含所有键的Set集合</td>
</tr>
<tr>
<td>获取所有值</td>
<td>values()</td>
<td>Collection&lt;V&gt;</td>
<td>返回包含所有值的Collection集合</td>
</tr>
</tbody>
</table>
<h2><span id="遍历">遍历</span></h2>
<ul>
<li>遍历所有键</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; keys = stus.keySet();</span><br><span class="line"><span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">value</span> <span class="operator">=</span> stus.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历所有值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Stu&gt; values = stus.values();</span><br><span class="line"><span class="keyword">for</span> (Stu value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代器迭代所有键（只有删除的时候才会使用迭代器）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = stus.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(next &gt; <span class="number">1004</span>)&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="去重">去重</span></h2>
<p>HashMap去重规则与HashSet一致</p>
<p>唯一区别：HashMap添加重复数据将替换原有数据</p>
<h2><span id="执行原理">执行原理</span></h2>
<h3><span id="添加元素过程">添加元素过程</span></h3>
<ol>
<li>
<p>判断若是首次插入元素，未初始化结点数组</p>
<ol>
<li><a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F">调整数组大小</a></li>
</ol>
</li>
<li>
<p>已初始化过数组，<a href="#%E6%8F%92%E5%85%A5%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87">计算要插入结点数组的下标</a></p>
<ol>
<li>
<p>若该位置没有元素，则直接插入</p>
</li>
<li>
<p>若该位置有元素说明发生<a href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E">哈希碰撞</a>，可能出现下面几种情况</p>
<ol>
<li>
<p>两元素<a href="#%E5%88%A4%E9%87%8D">重复</a>（HashSet判重标准），<a href="#%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%84%E7%90%86">处理重复元素</a></p>
</li>
<li>
<p>两元素不重复，原数组元素为树节点（已树化），直接<a href="#">插入树</a></p>
</li>
<li>
<p>两元素不重复，原数组元素为普通结点，则遍历该链表</p>
<ol>
<li>
<p>全链表没有重复元素，则插入该链表，若插入元素为该链表第九个，需处理链表过长（<a href="#%E6%A0%91%E5%8C%96">树化</a>或<a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F">扩容</a>）</p>
</li>
<li>
<p>遍历过程中发现链表有重复元素，<a href="#%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%84%E7%90%86">处理重复元素</a></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>若添加新元素后的数组总个数超过threshold，还需<a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F">调整数组大小</a></p>
</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认容量： 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;		<span class="comment">//最大容量 2^30^</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;		<span class="comment">//负载因子:数组增长率</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;				<span class="comment">//树化链长条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;			<span class="comment">//链化参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;			<span class="comment">//树化数组长度条件</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;						<span class="comment">//结点数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//当前结点数组为空，或长度为0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)		</span><br><span class="line">        n = (tab = resize()).length;		<span class="comment">//新建长度为默认容量16结点数组，，更新threshold为负载因子乘上默认容量</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)		<span class="comment">//要插入的数组位置为空</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);	<span class="comment">//插入该数组</span></span><br><span class="line">    <span class="keyword">else</span> &#123;								<span class="comment">//结点数组既不为空且插入位置发生冲突</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)		<span class="comment">//原数组元素为树节点</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">//TREEIFY_THRESHOLD=8	插入第九个树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// key有映射</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)	<span class="comment">//true丢弃重复元素，false替换</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);			<span class="comment">// LinkedHashMap</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;	<span class="comment">//返回被替换的真值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;		<span class="comment">//记录本次修改</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)		<span class="comment">//threshold比较标准是总数组元素个数，不是数组长度</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);	<span class="comment">// LinkedHashMap</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="调整数组大小">调整数组大小</span></h4>
<ol>
<li>首次添加元素，对数组初始化
<ol>
<li>新建结点数组，长度为默认容量16，更新threshold为负载因子乘上默认容量</li>
</ol>
</li>
<li>首次添加元素，但<a href="#%E6%9E%84%E9%80%A0%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96threshold">构造集合时初始化了数组长度</a>
<ol>
<li>初始化时指定的数组长度大于等于最大数组容量，更新threshold为int最大值</li>
<li>初始化时指定数组长度小于最大数组容量，更新threshold为指定长度乘上负载因子</li>
</ol>
</li>
<li>数组总元素个数超过threshold，需要扩容（数组中挂链长度大于8但数组长度小于64，为了分解链表也会扩容，扩容至64<a href="#%E6%A0%91%E5%8C%96">树化</a>）
<ol>
<li>数组长度已经大于等于最大容量，更新threshold为int最大值</li>
<li>数组已初始化（长度大于等于默认容量）且数组长度扩容两倍仍小于最大容量，则扩容为原来的两倍，threshold也扩大两倍</li>
<li>由于数组中已有数据，扩容时还需遍历数组，将旧数组元素转移到新数组中
<ol>
<li>当前下标元素既没树化，也没链化，则直接运算其下标存入新数组中</li>
<li>当前元素为树节点（已树化），则插入树中</li>
<li>当前元素已链化，分解链表</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;	<span class="comment">//调整大小		数组初始化/数组长度插入新元素后大于threshold</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;					   <span class="comment">//结点数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;	<span class="comment">//大于等于最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;	<span class="comment">//threshold设为int最大值</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;				   <span class="comment">//返回旧结点数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新结点数组扩容后仍小于最大容量且旧结点数组长度大于等于16（意味着已经初始化）</span></span><br><span class="line">        <span class="comment">//新结点数组长度扩大两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;	</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// newThr为oldThr两倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 结点数组为空，但threshold已初始化，则按照以有的threshold初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 未初始化threshold和结点数组，表示使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;		<span class="comment">//新结点数组长度置为默认容量（16）</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);	<span class="comment">//newThr置为负载因子乘上默认容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;	<span class="comment">//按照以有的threshold初始化</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">//初始化数组长度大于等于最大容量时，新threshold设为int最大值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? </span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;	 		<span class="comment">//更新threshold</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];		<span class="comment">//新建结点数组，长度为newCap</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;			<span class="comment">//数组中尚且有元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;	<span class="comment">//当前下标有元素时</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;			<span class="comment">//清除旧数组元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)			<span class="comment">//当前元素没有挂链</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;		<span class="comment">//直接复制到新数组中</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)		<span class="comment">//树节点</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 当前元素有挂链</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//1.新数组长度为旧数组两倍</span></span><br><span class="line">                    <span class="comment">//2.当前下标位置有挂链</span></span><br><span class="line">                    <span class="comment">//3.按照旧数组长度，如2^i，即看第i位是否为1，将挂链分为两条链表</span></span><br><span class="line">                    <span class="comment">//4.第i位为0的存储在原位置，为1的存储在原数组长度加上原位置的位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;		<span class="comment">//next指向下个元素</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;	</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);	<span class="comment">//遍历原链表结点，并赋值到新链表上</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="构造时初始化threshold">构造时初始化threshold</span></h4>
<p>构造HashMap或HashSet时带参将初始化threshold，参数即使大于最大容量也会自降为最大容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>参数大于1时，初始化的threshold值为大于等于参数且最接近参数的 2<sup>i</sup>数列	（i&gt;=4,i为正整数，最大为最大容量（2<sup>30</sup>））</p>
<blockquote>
<p>例如14、22、54的参数，则实际初始化threshold为16、32、64</p>
</blockquote>
</li>
<li>
<p>参数小于等于1时，初始化threshold值为1</p>
</li>
<li>
<p>参数大于等于最大容量时，初始化threshold值理论上为设置的最大容量，但实际测试超过2<sup>29</sup>时， (OutOfMemoryError)异常</p>
</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;	</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;	</span><br><span class="line">    <span class="comment">//若n的二进制形式中至少有一个位为1 </span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;		<span class="comment">//n与自身右移1位进行或运算（有1则1），导致为1的位的右边1位必定为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;		<span class="comment">//再与自身右移2位进行或运算，则1位右边3位都为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;		<span class="comment">//再与自身右移4位进行或运算，则1位右边7位都为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;		<span class="comment">//再与自身右移8位进行或运算，则1位右边15位都为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;		<span class="comment">//再与自身右移16位进行或运算，则1位右边31位都为1</span></span><br><span class="line">    <span class="comment">//运算后n的结果：为1的最高位其后至多31位都为1</span></span><br><span class="line">    <span class="comment">//n+1：为1最高位为第i-1位,即大于等于cap且最接近的2^i^数列</span></span><br><span class="line">    <span class="comment">//上述为cap大于1的情况</span></span><br><span class="line">    <span class="comment">//cap小于1时，n&lt;0，结果为1</span></span><br><span class="line">    <span class="comment">//cap等于1时，n=0，结果也为1</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="插入数组下标">插入数组下标</span></h4>
<p><code>(n - 1) &amp; hash</code> n为数组长度</p>
<p>数组长度n为2<sup>i</sup>数列，与n-1进行按位且运算，结果取二进制形式下的后i位</p>
<p>对于二进制下不超过16位的值类型，相当于取模运算，因为哈希计算过程中，hashCode还要异或上自身的高16位</p>
<blockquote>
<ol>
<li>让高16位也参与运算，可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率</li>
<li>异或运算是为了更好保留两组32位二进制数中各自的特征，且运算和或运算会导致结果偏向0或1</li>
</ol>
</blockquote>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="哈希碰撞">哈希碰撞</span></h4>
<p>即插入数组下标冲突，不超过16位的值类型的哈希碰撞，意味着它们与数组长度取模后的结果相等</p>
<p>当两元素发生哈希碰撞，通常还要判断两元素是否重复</p>
<h4><span id="判重">判重</span></h4>
<p><code>p.hash == hash &amp;&amp;  (p.key == key || (key != null &amp;&amp; key.equals(p.key)))</code></p>
<p>首先hash一定相等，且键的地址一样或equals相等，则说明两元素重复</p>
<h4><span id="重复元素的处理">重复元素的处理</span></h4>
<p>添加方法的参数onlyIfAbsent 为true时丢弃重复元素，false替换原数组元素</p>
<h4><span id="树化">树化</span></h4>
<p>结点数组里的一个下标位中的元素采用红黑树结构存储</p>
<ol>
<li>若结点数组中的链表链长大于8，且桶长大于等于64，则树化，否则为调整数组大小</li>
<li>将链表上的元素转换成红黑树的形式插入结点数组中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<span class="comment">//64</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;<span class="comment">//链表上有元素</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">//遍历该链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);	<span class="comment">//将结点转换为树结点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)	<span class="comment">//树节点链表插入数组中</span></span><br><span class="line">            hd.treeify(tab);	<span class="comment">//将树节点链表构建成红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="链化">链化</span></h4>
<p>结点数组里的一个下标位中的元素采用链表结构存储</p>
<p>如果已经树化，如果树的节点小于6，则链化</p>
<h2><span id></span></h2>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
</search>
