<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP面向切面编程</title>
    <url>/post/AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在编写业务层代码时，除了实现业务接口中的方法外（主业务逻辑），可能还需要一些非业务方法，也称为交叉业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doOther&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>在业务实现类添加交叉业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doSome&quot;</span>);</span><br><span class="line">        doTrans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">        doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doOther&quot;</span>);</span><br><span class="line">        doTrans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法开始执行时输出日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTrans</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法执行后加入事务日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在工具类中定义交叉业务逻辑，供主业务逻辑调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceTools</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法开始执行时输出日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doTrans</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非主业务逻辑，在方法执行后加入事务日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SomeService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceTools.doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doSome&quot;</span>);</span><br><span class="line">        ServiceTools.doTrans();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceTools.doLog();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了业务方法doOther&quot;</span>);</span><br><span class="line">        ServiceTools.doTrans();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码中交叉业务与主业务深度耦合在一起</p>
<ul>
<li>当交叉业务逻辑较多时，业务实现类中会出现大量的交叉业务逻辑代码调用语句，使业务逻辑混杂不清，代码可读性差</li>
<li>当交叉业务逻辑需求复杂时，对于不同的需求分别设计交叉业务逻辑，代码的扩展性差</li>
</ul>
<p>所以，可以采用动态代理方式。在不修改主业务逻辑的前提下，扩展和增强其功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        ServiceTools.toLog();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        ServiceTools.toTrans();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:/application.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SomeService target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line">        <span class="type">SomeService</span> <span class="variable">someService</span> <span class="operator">=</span> (SomeService) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">        someService.doSome();</span><br><span class="line">        someService.doOther();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>DOS常用命令</title>
    <url>/post/DOS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2><span id="dos命令的基础使用">DOS命令的基础使用：</span></h2>
<h3><span id="dir"><code>dir</code></span></h3>
<ul>
<li>查看当前目录，其中dir指directory</li>
</ul>
<h3><span id="mkdirmd"><code>mkdir</code>(md)</span></h3>
<ul>
<li>创建文件夹</li>
</ul>
<span id="more"></span>
<h3><span id="rmdirrd"><code>rmdir</code>(rd)</span></h3>
<ul>
<li>删除文件夹，若要删除非空的文件夹，需要<code>-s</code>来强行删除该文件夹下的所有子文件夹与文件，再加上<code>-q</code>则无需确认（安静模式）</li>
</ul>
<h3><span id="cd"><code>cd</code></span></h3>
<ul>
<li>
<p>可以跳转至当前目录的所有子孙目录，但无法进行跨盘符跳转；若要进行跨盘符跳转，则使用“盘符”+“:”，例如<code>c:</code>,<code>d:</code>,<code>e:</code></p>
</li>
<li>
<p>特别地，<code>cd .\</code>表示当前目录<code>cd ..</code> 表示返回上一级目录,<code>cd \</code> 表示返回根目录</p>
</li>
</ul>
<h3><span id="echo回声"><code>echo</code>(回声)</span></h3>
<ul>
<li><code>echo 123</code>只使用echo + 字符串，则表示打印该字符串</li>
<li><code>echo 123 &gt; d:\hello.txt </code>加上大于号，表示将打印的字符串重定向到指定位置，此时对同一个文件多次echo将会覆盖上次写的内容</li>
<li><code>echo 123 &gt;&gt; d:\hello.txt</code> 两个大于号可对上次写下的内容进行叠加</li>
</ul>
<h3><span id="del"><code>del</code></span></h3>
<ul>
<li>删除文件</li>
<li><code>del *.txt</code> 通配符删除，意为将当前目录下所有后缀为txt的文·件删除</li>
</ul>
<h3><span id="type"><code>type</code></span></h3>
<ul>
<li>仅能查看文本文件内容</li>
</ul>
<h3><span id="cls"><code>cls</code></span></h3>
<ul>
<li>clean sreen 清空屏幕</li>
</ul>
<h3><span id="tree"><code>tree</code></span></h3>
<ul>
<li>以树形显示该目录下的所有文件夹</li>
<li>加上<code>-f</code> 可同时显示该目录下的所有文件</li>
</ul>
<h2><span id="绝对路径与相对路径">绝对路径与相对路径：</span></h2>
<ul>
<li>
<p>绝对路径：从盘符开始的路径</p>
</li>
<li>
<p>相对路径：从当前目录开始的路径</p>
</li>
</ul>
<h2><span id="网络命令">网络命令</span></h2>
<ul>
<li>
<p><code>ping</code> 检查是否可以和其他主机通信</p>
<p><code>-t</code> 不间断发送数据包</p>
</li>
<li>
<p><code>ipconfig</code> 查看网卡信息</p>
<p><code>/all</code> 查看详细的网卡信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
      <tags>
        <tag>Dos</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpSession</title>
    <url>/post/HttpSession/</url>
    <content><![CDATA[<p><img src="https://pic.imgdb.cn/item/64113030ebf10e5d5374df8a.jpg" alt></p>
<ul>
<li>相同的客户端相同的浏览器对应一个HttpSession对象</li>
<li>HttpSession对象在服务端【tomcat】里面</li>
<li>一个HttpSession对象可以有多个键值对数据</li>
<li>当浏览器请求服务端的任意资源时，使用了HttpSession对象的任意方法，服务端将立即创建一个SessionID对应一个HttpSession对象</li>
<li>浏览器通过cookie存储SessionID</li>
</ul>
<h2><span id="httpsession">HttpSession</span></h2>
<p><strong>浏览器会话对象</strong></p>
<ul>
<li>HttpSession拥有存储数据的能力【以KV方式存储对象，setAttribute方法】</li>
<li>HttpSession对象里面存储的数据在 相同的客户端 相同的浏览器 范围内共享</li>
</ul>
<p><strong>生命周期</strong></p>
<ul>
<li>HttpSession对象生命周期为整个浏览器运行期间，浏览器运行结束，即浏览器关闭（所有页面关闭），HttpSession对象的生命周期结束</li>
<li>不同品牌的浏览器HttpSession对象生命周期不一样</li>
</ul>
<p><strong>浏览器会话销毁</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>HttpSession</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>浏览器关闭</td>
<td>存在</td>
<td>仅cookies销毁，浏览器无法传递上一次的SessionID</td>
</tr>
<tr>
<td>httpSession.removeAttribute(K);</td>
<td>存在</td>
<td>仅HttpSession中的key删除</td>
</tr>
<tr>
<td>tomcat的设置过期时间或者代码设置httpSession.setMaxInactiveInterval(单位是秒);</td>
<td>销毁</td>
<td>HttpSession对象立即GC清除</td>
</tr>
<tr>
<td>tomcat重启</td>
<td>销毁</td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="tomcat管理httpsession">tomcat管理HttpSession</span></h2>
<ul>
<li>当浏览器首次使用httpSession的任意方法，tomcat会立即创建该浏览器的SessionID（Tomcat创建的是JSESSIONID），然后会把SessionID立即存储到浏览器的Cookies里面，浏览器可以通过Cookies携带的SessionID访问tomcat的HttpSession对象，获取键值对数据</li>
<li>若浏览器没有使用httpSession的任意方法，则tomcat不会创建该浏览器的SessionID</li>
</ul>
<h2><span id="cookie">cookie</span></h2>
<p>在浏览器中存储tomcat中的HttpSession对象的SessionID的值</p>
<ul>
<li>客户端浏览器中的cookies的SessionID丢失（手动删除），再次使用HttpSession任意方法，则Tomcat重新生成SessionID（重新创建一个HttpSession对象）存储到浏览器的cookie中</li>
<li>客户端浏览器中禁止cookies，由于浏览器无法通过cookie访问tomcat中的HttpSession对象，每次使用HttpSession任意方法，Tomcat都会重新生成SessionID（重新创建一个HttpSession对象），此时可以通过url + &quot;;jsessionid=【sessionID】&quot;访问tomcat中的HttpSession对象</li>
<li>若cookie未禁用且url带有不同的SessionID的方式访问tomcat中的HttpSession，则cookie传递优先级最高</li>
</ul>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/post/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行运行</td>
<td>Shift + F10</td>
<td>万能解错/生成返回值</td>
<td>Alt + Enter</td>
</tr>
<tr>
<td>提示补全</td>
<td>Ctrl +空格(改成 Alt+/)</td>
<td>返回上次查看代码的位置</td>
<td>Ctrl + Alt + 左右箭头</td>
</tr>
<tr>
<td>单行注释</td>
<td>Ctrl + /</td>
<td>查看继承关系</td>
<td>Ctrl + H</td>
</tr>
<tr>
<td>多行注释</td>
<td>Ctrl + Shift + /</td>
<td>格式化代码</td>
<td><strong>Ctrl + Alt + L</strong></td>
</tr>
<tr>
<td>向下复制一行</td>
<td>Ctrl + D</td>
<td>提示方法参数类型</td>
<td>Ctrl + P</td>
</tr>
<tr>
<td>删除一行或多行</td>
<td>Ctrl + Y</td>
<td>复制</td>
<td>Ctrl + C</td>
</tr>
<tr>
<td>向上/下移动一行</td>
<td><strong>Alt+Shift+上或下箭头</strong></td>
<td>撤销</td>
<td>Ctrl + Z</td>
</tr>
<tr>
<td>向下开始新的一行</td>
<td>Shift + Enter</td>
<td>剪切</td>
<td>Ctrl + X</td>
</tr>
<tr>
<td>向上开始新的一行</td>
<td>Ctrl + Alt + Enter</td>
<td>粘贴</td>
<td>Ctrl + V</td>
</tr>
<tr>
<td>查看源码</td>
<td>Ctrl + 鼠标左键</td>
<td>保存</td>
<td>Ctrl + S</td>
</tr>
<tr>
<td>搜索类</td>
<td>Ctrl + N</td>
<td>全选</td>
<td>Ctrl + A</td>
</tr>
<tr>
<td>整体向后移动</td>
<td>Tab</td>
<td>全局查找</td>
<td>Ctrl + Shift+R</td>
</tr>
<tr>
<td>整体向前移动</td>
<td>Shift + Tab</td>
<td>查找任何东西</td>
<td>Shift+Shift</td>
</tr>
<tr>
<td>查看类的结构</td>
<td>Ctrl + F12</td>
<td>查看类的继承结构图</td>
<td>Ctrl + Alt + U</td>
</tr>
<tr>
<td>重构方法变量名</td>
<td>Shift + F6</td>
<td>抽取方法</td>
<td>Ctrl + Alt + M</td>
</tr>
<tr>
<td>大小写转换</td>
<td>Ctrl +Shift + U</td>
<td>最近修改的文件</td>
<td>Ctrl + E</td>
</tr>
<tr>
<td>生成get/set/toString</td>
<td>Alt + Insert</td>
<td>选择粘贴内容</td>
<td>Ctrl + Shift + V</td>
</tr>
<tr>
<td>查看文档说明</td>
<td>Ctrl + Q</td>
<td>优化导入的类</td>
<td>Ctrl + Alt + O</td>
</tr>
<tr>
<td>收起/展开所有方法</td>
<td>Ctrl + Shift + “+/-”</td>
<td>寻找方法被调用的地方</td>
<td>Alt + Alt + F7</td>
</tr>
<tr>
<td>生成surround with</td>
<td>Ctrl + Alt+T</td>
<td>跳到文件尾部</td>
<td>Ctrl + End</td>
</tr>
<tr>
<td>查找</td>
<td>Ctrl + F</td>
<td>跳到文件头部</td>
<td>Ctrl + Home</td>
</tr>
<tr>
<td>查找替换</td>
<td>Ctrl + R</td>
<td>实现/重写方法</td>
<td>Ctrl + O/</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>常用模板</title>
    <url>/post/IDEA%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>模板</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>psvm</strong></td>
<td>可生成 main 方法</td>
</tr>
<tr>
<td><strong>sout</strong></td>
<td>System.out.println() 快捷输出</td>
</tr>
<tr>
<td><strong>soutp</strong></td>
<td>System.out.println(&quot;方法形参名 = &quot; +  形参名);</td>
</tr>
<tr>
<td><strong>soutv</strong></td>
<td>System.out.println(&quot;变量名 = &quot; + 变 量);</td>
</tr>
<tr>
<td><strong>soutm</strong></td>
<td>System.out.println(“当前类名.当前方 法”);</td>
</tr>
<tr>
<td><strong>“abc”.sout</strong></td>
<td>System.out.println(“abc”);</td>
</tr>
<tr>
<td><strong>fori</strong></td>
<td>可生成 for 循环</td>
</tr>
<tr>
<td>iter</td>
<td>可生成增强 for 循环</td>
</tr>
<tr>
<td>itar</td>
<td>可生成普通 for 循环</td>
</tr>
<tr>
<td>list.for</td>
<td>可生成集合 list 的 for 循环 ,for(String s:list){}</td>
</tr>
<tr>
<td><strong>ifn</strong></td>
<td>可生成 if(xxx = null)</td>
</tr>
<tr>
<td><strong>inn</strong></td>
<td>可生成 if(xxx != null)或xxx.nn或 xxx.null</td>
</tr>
<tr>
<td>prsf</td>
<td>可生成 private static final</td>
</tr>
<tr>
<td>psf</td>
<td>可生成 public static final</td>
</tr>
<tr>
<td>psfi</td>
<td>可生成 public static final int</td>
</tr>
<tr>
<td>psfs</td>
<td>可生成 public static final String</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>JDK的安装及环境变量的配置</title>
    <url>/post/JDK%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>JDK是Java开发的重要工具，安装JDK是学好Java的第一步</p>
<span id="more"></span>
<h1><span id="jdk-的安装">JDK 的安装</span></h1>
<h2><span id="下载">下载</span></h2>
<p>首先通过甲骨文官方下载JDK所需的安装包</p>
<p><a href="https://www.oracle.com/java/technologies/downloads/archive/">Java Archive | Oracle</a></p>
<p>选择需要的JDK版本，通常使用的是JDK8</p>
<img src="https://pic.imgdb.cn/item/6391d5c8b1fccdcd362211e2.png" style="zoom:50%;">
<p>往下找到适配自己系统的JDK，这里演示的是windows64字节</p>
<img src="https://pic.imgdb.cn/item/6391d6b8b1fccdcd362376b7.png" style="zoom: 33%;">
<p>点击下载链接，勾选接受协议，将会跳转至Oracle登录界面，没有Oracle账号还需注册，登录成功即可开始下载</p>
<h2><span id="安装">安装</span></h2>
<ul>
<li>
<p>作为开发人员安装JDK，<strong>设置公共JRE公共功能不可用</strong>，因JDK本身即包含了JRE，无需再次安装，关于JDK： <a href="../Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0">Java语言概述</a></p>
</li>
<li>
<p>其次，安装的路径下<strong>不得存在中文</strong>，</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391d82cb1fccdcd3625d862.png" style="zoom: 80%;">
<h1><span id="环境变量的配置">环境变量的配置</span></h1>
<h2><span id="查看环境变量">查看环境变量</span></h2>
<p>鼠标右击此电脑点击属性，对于win11的系统，点击设备规格下的高级系统设置，点击环境变量</p>
<img src="https://pic.imgdb.cn/item/6391de65b1fccdcd362eea05.png" style="zoom: 80%;">
<h2><span id="java_home">JAVA_HOME</span></h2>
<p>点击系统变量中的新建，添加一个名为JAVA_HOME的变量，变量值为JDK的安装路径</p>
<img src="https://pic.imgdb.cn/item/6391de3db1fccdcd362eb8e5.png" style="zoom: 80%;">
<h2><span id="path">Path</span></h2>
<p>点击系统变量中的编辑，点击新建，输入<code>%JAVA_HOME%\bin</code></p>
<img src="https://pic.imgdb.cn/item/6392fd2db1fccdcd36c029a3.png" style="zoom:80%;">
<h2><span id="classpath">CLASSPATH</span></h2>
<p>同理添加一个名为CLASSPATH的变量，变量值为</p>
<p><code> .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></p>
<p>这里需注意：</p>
<ul>
<li>CLASSPATH变量中的字符必须是英文字符</li>
<li>此处的%JAVA_HOME%意为对上一个JAVA_HOME的引用，即JDK的安装路径</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391e15eb1fccdcd3633b5d5.png" style="zoom: 80%;">
<p>随后一路确定，即配置完成</p>
<h1><span id="测试">测试</span></h1>
<p>win+r查看cmd，输入<code>java -version</code>查看JDK版本信息</p>
<img src="https://pic.imgdb.cn/item/6391e1f1b1fccdcd36358bae.png" style="zoom: 80%;">
<h1><span id="总结">总结</span></h1>
<h2><span id="为什么要配置环境变量">为什么要配置环境变量?</span></h2>
<h3><span id="path">path</span></h3>
<p>将JDK的bin目录写入系统环境变量path中</p>
<ol>
<li>
<p>JDK编译原理：编译源码时需要在DOS命令行中输入命令，执行JDK的bin目录下的某个可执行文件(.exe)；</p>
<p>windows首先在当前目录下查找是否存在所指的可执行文件，若没有找到，再到path环境变量指定的目录中查找，若仍未找到，则报错</p>
</li>
<li>
<p>若未配置path变量：通过绝对路径找到JDK的bin目录后才能使用相应的命令</p>
</li>
<li>
<p>若已配置path变量：在DOS命令行中的任何路径下都能使用相应的命令</p>
</li>
</ol>
<h3><span id="java_home">JAVA_HOME</span></h3>
<p>将JDK目录写入JAVA_HOME环境变量中，再将JAVA_HOME配置给其他需要配置JDKbin目录的环境变量</p>
<ol>
<li>若未配置JAVA_HOME：
<ol>
<li>当多个环境变量配置了JDK的bin目录时，修改JDK版本号也就需要修改所有关联JDK的环境变量</li>
</ol>
</li>
<li>若已配置JAVA_HOME：
<ol>
<li>修改JDK路径只需要更新JAVA_HOME的路径</li>
<li>部分第三方软件约定使用JAVA_HOME来指定JDK路径（Tomcat）</li>
</ol>
</li>
</ol>
<h3><span id="classpath一般不需配置">CLASSPATH（一般不需配置）</span></h3>
<p>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</p>
<blockquote>
<ol>
<li>不同路径由<code>;</code>隔开</li>
<li><code>.</code>指的是当前路径</li>
<li>其余两条路径<code> %JAVA_HOME%\lib\dt.jar</code>、<code>%JAVA_HOME%\lib\tools.jar</code>。</li>
</ol>
</blockquote>
<p>将上述写入CLASSPATH环境变量中</p>
<ol>
<li>
<p>源码编译后生成的字节码文件，执行文件需要通过DOS命令行中输入执行命令，交由JVM执行处理</p>
<p>JVM的类加载器从CLASSPATH路径中查找字节码文件，JDK1.5及以上CLASSPATH默认为当前路径</p>
</li>
<li>
<p>若未配置CLASSPATH：JVM无法查找不在当前目录下的字节码文件（报错）</p>
</li>
<li>
<p>若配置CLASSPATH：JVM可以执行CLASSPATH路径中的字节码文件</p>
</li>
</ol>
<p>一般而言，对于要编译运行的代码会在当前路径进行，因此，CLASSPATH一般不需要配置</p>
<p><strong>CLASSPATH中为什么要有当前路径</strong></p>
<p>因为未配置CLASSPATH会从当前目录下找字节码文件，而<strong>配置了CLASSPATH后只会从CLASSPATH的路径下寻找</strong></p>
<p><strong>当两个类被分别放在不同目录下，但两个类之间存在调用另一个类的方法，如何使两个类正常运行？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test1</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args&#123;</span></span><br><span class="line"><span class="params">		System.out.println(<span class="string">&quot;222222222&quot;</span>)</span>;</span><br><span class="line">     	test1.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test2类调用了test1类的方法，经过测试我们无法直接编译test2.Java源文件</p>
<p><img src="https://pic.imgdb.cn/item/639318d0b1fccdcd36f02e1e.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -classpath &quot;另一个类所处目录路径&quot; test2.java</span><br></pre></td></tr></table></figure>
<p>通过Java命令-classpath修改CLASSPATH路径，实现对test2的编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -classpath .;&quot;另一个类所处目录路径&quot; test2</span><br></pre></td></tr></table></figure>
<p>执行.class文件时，仅配置了另一个类所处目录的路径会找不到当前要执行的test2.class，因此加上当前目录，即可运行</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>JVM内存结构</title>
    <url>/post/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/101495810">JVM内存模型（详解） - 知乎 (zhihu.com)</a></p>
<p><img src="https://pic.imgdb.cn/item/63ae5b6208b6830163cf8eca.png" alt="JVM内存模型"></p>
<h3><span id="程序计数器program-counter-register">程序计数器（Program Counter Register）</span></h3>
<p>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令：分支、跳转、循环、异常处理、线程恢复等基础操作都会依赖这个计数器来完成。每个线程都有独立的程序计数器，用来在线程切换后能恢复到正确的执行位置，各条线程之间的计数器互不影响，独立存储。所以它是一个“线程私有”的内存区域。</p>
<h3><span id="本地方法栈-native-method-stack">本地方法栈（ Native Method Stack）</span></h3>
<p>本地方法栈和虚拟机栈所发挥的作用是很相似的，它们之间的区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法（由其它语言实现）服务。</p>
<span id="more"></span>
<h3><span id="虚拟机栈vm-stack">虚拟机栈（VM Stack）</span></h3>
<p>JVM栈是线程私有的内存区域。主要存放方法执行数据</p>
<ol>
<li>每个方法执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息</li>
<li>局部变量表存放各种基本数据类型、对象引用（reference类型，指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一跳字节码指令的地址）</li>
<li>动态连接（Dynamic Linking）通过每个栈帧都包含一个指向该栈帧所属方法（常量池）的引用，在<strong>运行期间</strong>将指向该方法的<a href="../Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/#%E8%A7%A3%E6%9E%90">符号引用</a>转化为直接引用
<ol>
<li>静态解析：在类加载的解析阶段或者第一次使用时将指向该方法的符号引用转化为直接引用，</li>
</ol>
</li>
</ol>
<h3><span id="堆heap">堆（Heap）</span></h3>
<p>通常情况下，它占用的空间是所有内存区域中最大的</p>
<ol>
<li>存储实例对象、数组、成员变量</li>
<li>堆由垃圾收集器自动回收，堆区由各子线程共享使用</li>
<li>堆的内存空间既可以固定大小，也可运行时动态地调整</li>
</ol>
<h3><span id="方法区method-area">方法区（Method Area）</span></h3>
<p>线程共享的内存区域</p>
<ol>
<li>存储字节码文件，包含所有的class文件和static变量(静态域)、常量(常量池)、即时编译后的代码等数据</li>
<li>静态域：存放类中以static声明的静态成员变量</li>
<li>常量池：在编译期间就将一部分数据存放于该区域，包含以final修饰的基本数据类型的常量值、String字符串。（在java6时它是方法区的一部分；1.7又把他放到了堆内存中；1.8之后出现了元空间，它又回到了方法区）</li>
</ol>
<h3><span id="类成员存储">类成员存储</span></h3>
<h3><span id="前提">前提</span></h3>
<p><a href="../%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">类加载及执行原理</a></p>
<h3><span id="属性存储">属性存储</span></h3>
<p>属性根据声明位置不同分为成员变量和局部变量</p>
<ol>
<li>局部变量声明在方法体中，在程序执行过程中随着方法被调用一起入栈，存储在栈的栈帧的局部变量表中</li>
<li>成员变量分为静态变量和实例变量
<ol>
<li>静态变量在类加载的准备阶段分配在方法体的静态域中，并设置初始值</li>
<li>实例变量则在程序执行中和对象实例一起存放在堆中</li>
</ol>
</li>
</ol>
<h3><span id="方法存储">方法存储</span></h3>
<p>方法根据是否用static修饰可以分为静态方法和实例方法</p>
<ol>
<li>实例方法：创建对象实例时，对象实例和该对象中的实例方法被存放在堆中，通过实例对象的引用调用实例方法</li>
<li>静态方法：随着类加载而加载到方法区中，但不会自动执行，可通过类名.方法名访问</li>
</ol>
<h4><span id="实例方法调用过程">实例方法调用过程</span></h4>
<ol>
<li>在JVM中的一个进程中，每个线程都会拥有一个<strong>方法调用栈</strong>，用于跟踪线程运行中一系列的方法调用过程</li>
<li>当线程调用一个方法时就会向方法栈中压入一个新栈帧。<strong>栈帧</strong>是用于支持虚拟机进行方法调用和方法执行的数据结构，也是虚拟机运行时数据区中的虚拟机栈的栈元素。</li>
<li>每个<strong>方法从调用开始至执行结束的过程</strong>，都对应着一个栈帧在虚拟机栈里面从<strong>入栈到出栈的过程</strong></li>
<li>当方法执行完成时，该栈帧就会<strong>弹出栈帧的元素作为这个方法的返回值</strong>（参数传递），并且清除这个栈帧</li>
<li><strong>栈顶</strong>的栈帧就是当前正在执行的方法</li>
<li>每个栈帧都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>();  <span class="comment">//function是对象引用存在栈中，new Funciotn()的实例放在堆中（包含方法区中的类型信息(方法信息等)引用等）。</span></span><br><span class="line">        function.out2();  <span class="comment">//调用out2方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Function</span>&#123; <span class="comment">//运行时把加载之后的Function的信息存入方法区（类型信息、常量、静态变量、方法信息等）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了out1方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out2</span><span class="params">()</span>&#123;</span><br><span class="line">        out1();   <span class="comment">//这块调用out1主要是为了展示栈帧和栈帧中的动态链接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行了out2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>启动Java虚拟机进程，通过<a href="../%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">类加载机制</a>加载编译后的.class文件</p>
</li>
<li>
<p>JVM定位到方法区中静态方法Main()的字节码，将main方法转换为栈帧压入方法调用栈，并开始顺序执行它的指令：</p>
<blockquote>
<p>Function function = new Function();<br>
function.out2();</p>
</blockquote>
</li>
<li>
<p>Function function = new Function():</p>
<ol>
<li>加载Function类。 把Function类的相关信息存放在了方法区中</li>
<li>JVM在堆中为一个新的Function类的实例分配内存。该实例有着指向方法区的Function类的类型信息的引用（内存地址）</li>
<li>使function变量指向堆区中的Function实例。即function变量有指向Function类的实例的引用。变量function为局部变量，因此它会被JVM存放到执行main()方法的方法调用栈中</li>
</ol>
</li>
<li>
<p>function.out2():</p>
<ol>
<li>
<p>将根据局部变量function的引用，定位到堆中的Function类的实例，再根据Function类的实例的引用，定位到方法区中Function类的类型信息（包括类，静态变量，静态方法，常量和成员方法），从而获取out2()方法的字节码</p>
</li>
<li>
<p>将out2()方法压入方法调用栈，并顺序执行out2()方法中的指令</p>
<blockquote>
<p>out1();<br>
System.out.println(“我是Yi_ding的方法”);</p>
</blockquote>
<ol>
<li>out2()方法调用out1()方法。根据动态链接（在运行时期将常量池中指向方法的符号引用转换为直接引用）来获取out1()方法的直接引用，并将out1()方法压入方法调用栈，并顺序执行out1()方法中的指令</li>
<li>输出&quot;执行了out1方法&quot;</li>
<li>out1()方法执行完成，out1()方法出栈</li>
</ol>
</li>
<li>
<p>输出&quot;执行了out2方法&quot;</p>
</li>
<li>
<p>out2()方法执行完成，out2()方法出栈</p>
</li>
</ol>
</li>
<li>
<p>main()方法执行完成，main()方法出栈，程序执行结束</p>
</li>
</ol>
<img src="https://pic.imgdb.cn/item/63b2fb02be43e0d30e96d7da.jpg" style="zoom:150%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java加载及执行原理</title>
    <url>/post/Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2><span id="执行原理">执行原理</span></h2>
<p>编程人员编写.Java源文件，经过编译器编译(javac)成.class字节码文件，字节码文件通过JVM的类加载器加载至执行引擎，执行引擎执行(java)字节码文件并与操作系统交互。</p>
<span id="more"></span>
<p><img src="https://pic.imgdb.cn/item/6393113db1fccdcd36e17411.png" alt="执行过程"></p>
<h3><span id="编译阶段">编译阶段</span></h3>
<p>D:\下创建test01.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>在当前目录下进行编译，并在当前目录下生成test01.class字节码文件</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/130bf3bc382780ee.png" alt></p>
</li>
<li>
<p>在其他路径下通过绝对路径进行编译，仍在源码文件所在目录下生成字节码文件</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/782b383f69589ba7.png" alt></p>
</li>
<li>
<p>在1、2的基础上，使用-d 指定字节码文件生成目录</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/af54a909625867df.png" alt></p>
</li>
</ol>
<h3><span id="运行阶段">运行阶段</span></h3>
<ol>
<li>
<p>一般情况下，在当前目录下编译后会同时生成字节码文件，可通过当前路径执行</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/7f4e27cb96dcc047.png" alt></p>
</li>
<li>
<p>无法通过绝对路径找到类文件并执行</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/b2dce9cb62d3b626.png" alt></p>
</li>
</ol>
<h3><span id="执行不同路径下且存在调用的两个源文件">执行不同路径下且存在调用的两个源文件</span></h3>
<p>D:\下创建test01.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test02.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>D:\test\下创建test02.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>无论是通过绝对路径还是当前路径都无法独立编译test01.java</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/caf29fba40fbf402.png" alt></p>
</li>
<li>
<p>可通过两个文件的绝对路径同时进行编译（不适用声明了包的情况）</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/80e02d460eefa549.png" alt></p>
</li>
<li>
<p>配置CLASSPATH环境变量为两个文件的路径后，可以在不同路径下找到字节码文件并执行（不适用声明了包的情况）</p>
</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/6e6926b3fc5f7887.png" alt></p>
<p><strong>package与import</strong></p>
<ol>
<li>
<p>package：从项目路径到当前文件夹，文件夹间由 . 隔开</p>
</li>
<li>
<p>import：从项目路径到调用的类文件，（不在同一文件夹下的的源文件调用需要导入）</p>
<blockquote>
<p>不建议用*表示某个文件夹下的所有文件,当导入的包数量过多时，使用*容易发生类名冲突</p>
</blockquote>
</li>
<li>
<p>导入声明和包的声明必须从同一个项目路径开始</p>
</li>
</ol>
<p>在Test02.java中声明包，项目路径为包含了src的文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> src.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Test01.java中导入Test02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"><span class="keyword">import</span> src.main.Test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test02.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>必须在指定的项目路径下，通过绝对路径编译Test01.java（自动编译导入的文件）</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/8870e5d31d536773.png" alt></p>
</li>
<li>
<p>运行时在指定的项目路径下，通过包名.类名执行</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/02/2bf77240219f1aa9.png" alt></p>
</li>
<li>
<p>也可以通过-cp指定到项目路径下，通过包名.类名执行</p>
<p><img src="/post/Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/C:%5CUsers%5Cmomo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230202151851177.png" alt="image-20230202151851177"></p>
</li>
</ol>
<p><strong>静态导入</strong></p>
<p>访问不同路径下的源文件的静态成员，一般使用 类名.方法名或类名.属性名，使用静态导入即可直接使用方法名或属性名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> src;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> src.main.Test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        show();	<span class="comment">//直接通过方法名访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="类加载的过程">类加载的过程</span></h2>
<p><img src="https://pic.imgdb.cn/item/63d672baface21e9ef12a400.jpg" alt></p>
<p>加载、验证、准备、解析和初始化5个阶段</p>
<h3><span id="加载">加载</span></h3>
<ol>
<li>通过类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3><span id="验证">验证</span></h3>
<p>目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</p>
<h3><span id="准备">准备</span></h3>
<p>正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值</p>
<ul>
<li>
<p>从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但方法区本身是一个逻辑上的区域（在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了）</p>
</li>
<li>
<p>内存分配只包括类变量，而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li>
<p>初始值通常指数据类型的零值。赋值指令是程序被编译后，存放于类构造器()方法之中，所以赋值动作要到类的初始化阶段才会被执行。</p>
</li>
</ul>
<h3><span id="解析">解析</span></h3>
<p>所有目标方法都是通过符号引用（在Class文件的常量池中）来调用。在类加载的解析阶段，会将部分<strong>符号引用</strong>转化为<strong>直接引用</strong>。这些符号引用所属的方法在程序运行前就有一个可确定的调用版本，且在运行期不可改变（编译期可知，运行期不可变）。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。</p>
<p>主要指静态方法和私有方法，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</p>
<blockquote>
<p>符号引用：以一组符号来描述所引用的目标。符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</p>
<p>直接引用：直接引用是可以直接指向目标的指针。相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
</blockquote>
<ul>
<li>
<p>虚拟机实现时可以自行判断，是在类被加载器加载时，还是等到符号引用将被使用时，对常量池中的符号引用进行解析</p>
</li>
<li>
<p>解析阶段中对它们的可访问性（public、protected、 private、）进行检查</p>
</li>
</ul>
<h3><span id="初始化">初始化</span></h3>
<p>Java虚拟机真正开始执行类中编写的Java程序代码</p>
<ul>
<li>
<p>准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序代码来初始化类变量和其他资源</p>
</li>
<li>
<p>初始化阶段是执行类构造器&lt;clint&gt;()方法的过程。</p>
</li>
</ul>
<h3><span id="ltclintgt方法">&lt;clint&gt;()方法</span></h3>
<ol>
<li>
<p>&lt;clint&gt;()不是代码中程序员直接编写的方法，它是Javac编译器的自动生成物</p>
</li>
<li>
<p>&lt;clint&gt;()方法由编译器自动收集并合并类中的所有类变量的赋值动作和静态代码块中的语句，收集的顺序与语句在源文件中出现的顺序一致</p>
</li>
<li>
<p>JVM会保证在子类的&lt;clint&gt;()方法执行前，父类的&lt;clint&gt;()方法已经执行完毕。&lt;clint&gt;()方法与类的实例构造函数不同，它不需要显式地调用父类构造器，父类的&lt;clint&gt;()方法会优先先执行，也就意味着父类的静态语句块要优先于子类的变量赋值操作，具体查看<a href="../%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">类加载的初始化顺序</a></p>
</li>
<li>
<p>如果类中没有静态语句块、对变量的赋值操作，编译器可以不为这个类生成&lt;clint&gt;()方法</p>
</li>
<li>
<p>即使接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clint&gt;()方法。但接口与类不同的是，父接口的&lt;clint&gt;()方法不需要先于子接口的&lt;clint&gt;()方法执行，接口的实现类在初始化时也不会先执行接口的&lt;clint&gt;()方法。因为只有当父接口中定义的变量被使用时，父接口才会被初始化。</p>
</li>
</ol>
<h3><span id="源文件-类-字节码文件">源文件、类、字节码文件</span></h3>
<ul>
<li>源文件中可包含一个或多个类</li>
<li>源文件中至多有一个类被public修饰，当源文件中有public修饰类，原文件名必须与public修饰类名一致，当源文件中没有public修饰类，则源文件名与类名没有关系</li>
<li>在编译的过程中，对应每个类会生成相应的.class字节码文件，也就是说，当源文件中存在多个类时，编译完成后，会生成多个与类名一致的.class字节码文件</li>
<li>执行过程中，只需要指定字节码文件运行</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java文档注释</title>
    <url>/post/Java%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<ul>
<li>
<p>注释可以提高代码的可读性，清晰完整的注释便于程序调试的过程</p>
</li>
<li>
<p>于编程者而言，书写注释是编程路上必须具有的良好习惯</p>
</li>
<li>
<p>对代码的解释说明,就像产品的说明书一样,良好的注释会减少团队的沟通成本</p>
</li>
</ul>
<span id="more"></span>
<ul>
<li>单行注释	/注释文字/</li>
<li>多行注释    /<em>注释文字</em>/     多行注释中不能有多行注释嵌套</li>
</ul>
<h1><span id="文档注释">文档注释</span></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span>	指定java程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 自从哪个版本号开始就存在了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的程序的说明文档。</p>
<p>操作方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc –d mydoc –author –version FileName.java</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java语言概述</title>
    <url>/post/Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1><span id="介绍">介绍</span></h1>
<p>Java 是一种<strong>高级的、面向对象的、健壮的、多线程的、可跨平台的</strong>程序设计语言</p>
<span id="more"></span>
<h1><span id="java语言的特点">Java语言的特点</span></h1>
<h2><span id="简单">简单</span></h2>
<p>Java相较于C语言<strong>少了复杂的指针，仅支持单继承</strong></p>
<h2><span id="面向对象封装-继承-多态">面向对象（封装、继承、多态）</span></h2>
<h2><span id="健壮">健壮</span></h2>
<p>Java相较于C语言，<strong>无需开发人员对内存进行管理</strong>，Java本身预留一条线程监测内存并自动申请或释放（GC机制）</p>
<h2><span id="多线程">多线程</span></h2>
<p>Java支持<strong>多条线程并发进行</strong></p>
<h2><span id="跨平台">跨平台</span></h2>
<p>通过Java语言编写的应用程序可以在<strong>不同系统环境下运行</strong>（JVM）</p>
<h1><span id="java技术体系平台">Java技术体系平台</span></h1>
<h2><span id="javase">JavaSE</span></h2>
<p>Java标准版，主要面向<strong>桌面级应用程序</strong>的开发，为JavaEE、JavaME提供基础</p>
<h2><span id="javaee">JavaEE</span></h2>
<p>Java企业版，主要用于<strong>企业应用的、部署在服务器端的Java应用程序</strong>的开发</p>
<h2><span id="javame">JavaME</span></h2>
<p>Java微型版，支持Java在<strong>嵌入式等移动终端</strong>上运行</p>
<h2><span id="三者之间的关系">三者之间的关系</span></h2>
<p>JavaEE和JavaME都包含了JavaSE，因此学习JavaSE是学习JavaEE、JavaME的基础</p>
<img src="https://pic.imgdb.cn/item/6391cce1b1fccdcd36138138.png" alt="三者之间关系" style="zoom: 50%;">
<h1><span id="jvm-jre-jdk三者关系">JVM、JRE、JDK三者关系</span></h1>
<h2><span id="jvmjava-virtual-machine">JVM（Java Virtual Machine）</span></h2>
<p>Java虚拟机，Java源代码经过编译后生成的字节码需要通过Java虚拟机才能在不同的操作系统环境下运行。Java虚拟机是Java实现跨平台运行的关键。</p>
<p>JVM如何实现Java跨平台运行？</p>
<ul>
<li>对于不同的系统环境，提供了相对应的Java虚拟机</li>
<li>JVM接收源代码编译后的字节码，屏蔽了操作系统下的底层运行原理</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391d2a8b1fccdcd361c1520.png" alt="JVM实现原理" style="zoom: 50%;">
<h2><span id="jrejava-runtime-environment">JRE（Java Runtime Environment）</span></h2>
<p>Java运行环境，JRE包括JVM以及一些Java基本类库，JRE可满足运行Java应用程序的需求。</p>
<h2><span id="jdkjava-development-kit">JDK（Java Development Kit）</span></h2>
<p>Java开发工具包，JDK包括JRE以及Java开发工具，提供给开发人员使用</p>
<img src="https://pic.imgdb.cn/item/6391e28cb1fccdcd363743c4.png" style="zoom:50%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown 入门使用</title>
    <url>/post/Markdown%20%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2><span id="介绍">介绍</span></h2>
<p>Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。</p>
<span id="more"></span>
<h2><span id="标题">标题</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h1><span id="标题1">标题1</span></h1>
<h2><span id="标题2">标题2</span></h2>
<h3><span id="标题3">标题3</span></h3>
<h4><span id="标题4">标题4</span></h4>
<h5><span id="标题5">标题5</span></h5>
<h6><span id="标题6">标题6</span></h6>
</blockquote>
<h2><span id="列表">列表</span></h2>
<h3><span id="有序列表">有序列表</span></h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">把大象放进冰箱：</span><br><span class="line"><span class="bullet">1.</span> 打开冰箱</span><br><span class="line"><span class="bullet">2.</span> 把大象放进冰箱</span><br><span class="line"><span class="bullet">3.</span> 关上冰箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把大象放进冰箱:</p>
<ol>
<li>打开冰箱</li>
<li>把大象放进冰箱</li>
<li>关上冰箱</li>
</ol>
</blockquote>
<h3><span id="无序列表">无序列表</span></h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">无序列表：</span><br><span class="line"><span class="bullet">-</span> 所爱扥就</span><br><span class="line"><span class="bullet">-</span> 撒欧丹发腮</span><br><span class="line"><span class="bullet">-</span> 哦啊赛季反扒</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无序列表：</p>
<ul>
<li>所爱扥就</li>
<li>撒欧丹发腮</li>
<li>哦啊赛季反扒</li>
</ul>
</blockquote>
<h2><span id="任务列表">任务列表</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">明天要做的事：	</span><br><span class="line"><span class="bullet">-</span> [ ] 吃饭	//每个字符之间由空格隔开	</span><br><span class="line"><span class="bullet">-</span> [ ] 睡觉</span><br><span class="line"><span class="bullet">-</span> [ ] 打豆豆</span><br></pre></td></tr></table></figure>
<blockquote>
<p>明天要做的事：</p>
<ul>
<li>[ ] 吃饭</li>
<li>[ ] 睡觉</li>
<li>[ ] 打豆豆</li>
</ul>
</blockquote>
<h2><span id="代码块">代码块</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">``` c      //选择语言</span></span><br><span class="line"><span class="code">int main()&#123;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="数学公式">数学公式：</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;\partial f&#125;&#123;\partial x&#125; = 2\sqrt&#123;a&#125;x</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$$<br>
\frac{\partial f}{\partial x} = 2\sqrt{a}x<br>
$$</p>
</blockquote>
<h2><span id="表格">表格</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|姓名|年龄|成绩|</span><br><span class="line">|:--|--:|:-----:| </span><br><span class="line"><span class="code">			//冒号靠左为左对齐，靠右为右对齐，两边都有冒号为居中对齐</span></span><br><span class="line"><span class="code">|张三|18|90|</span></span><br><span class="line"><span class="code">|李四|20|89|</span></span><br></pre></td></tr></table></figure>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:right">年龄</th>
<th style="text-align:center">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">张三</td>
<td style="text-align:right">18</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:left">李四</td>
<td style="text-align:right">20</td>
<td style="text-align:center">89</td>
</tr>
</tbody>
</table>
</blockquote>
<h2><span id="脚注">脚注</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一条注释[^注释]</span><br><span class="line">[<span class="symbol">^注释</span>]:<span class="link">这是注释的注释。</span></span><br><span class="line"> ---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一条注释<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<hr>
</blockquote>
<h2><span id="超链接">超链接</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span>)</span><br><span class="line">[<span class="string">百度</span>][<span class="symbol">id</span>]</span><br><span class="line">[<span class="symbol">id</span>]:<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span></span><br><span class="line"></span><br><span class="line">请参考[<span class="string">标题1</span>](<span class="link">#标题</span>)</span><br><span class="line"></span><br><span class="line">URL：</span><br><span class="line">http://www.baidu.com</span><br><span class="line"></span><br><span class="line">![<span class="string">百度</span>](<span class="link">https://imgse.com/i/z2p2JH&quot;百度搜索&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.baidu.com" title="一个搜索引擎">百度</a><br>
<a href="http://www.baidu.com" title="一个搜索引擎">百度</a></p>
<p>请参考<a href="#%E6%A0%87%E9%A2%98">标题1</a></p>
<p>URL：<br>
<a href="http://www.baidu.com">http://www.baidu.com</a></p>
<p><img src="https://pic.imgdb.cn/item/63914551b1fccdcd36559921.png%22%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%22" alt="百度"></p>
</blockquote>
<h2><span id="字体变化">字体变化</span></h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="code">`行内代码printf()`</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">:smile:</span><br><span class="line">$\theta=x^2$</span><br><span class="line">H~2~O,x^2^</span><br><span class="line">==这是一段高亮文字==</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>斜体</em><br>
<strong>加粗</strong><br>
<code>行内代码printf()</code><br>
<u>下划线</u><br>
😄<br>
$\theta=x^2$<br>
H<sub>2</sub>O,x<sup>2</sup><br>
==这是一段高亮文字==</p>
</blockquote>
<h2><span id="参考视频">参考视频</span></h2>
<iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这是注释的注释。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Object类</title>
    <url>/post/Object%E7%B1%BB/</url>
    <content><![CDATA[<p>Object类是所有类的根类,如果一个类没有显示的继承其他类,默认继承Object</p>
<p>Object的类型变量可以指向任意类型的子类对象</p>
<span id="more"></span>
<h2><span id="int-hashcode">int hashCode()</span></h2>
<p>返回该对象的哈希码值 ，可以类似的看做虚拟内存地址</p>
<p>hashCode作用是用于散列表（hash算法）中的一个参数（寻找到一个数组下标位）【用于HashSet集合去重重复的关键参数之一】</p>
<ul>
<li>引用类型（注意是没有重写过hashCode）Object计算hashCode是以对象的地址为基本数据，进行二进制换算</li>
<li>String对象的字符序列一样，则hashCode一样</li>
<li>值类型的数值一旦一样，则hashCode一样</li>
<li>布尔的哈希值true=1231,false=1237</li>
</ul>
<p><strong>String对象的hashCode设计</strong></p>
<ul>
<li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li>
<li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1</li>
<li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li>
<li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为
<ul>
<li>即 $32 ∗h -h $</li>
<li>即 $2^5  ∗h -h$</li>
<li>即 $h≪5  -h$</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="classltgt-getclass">Class&lt;?&gt; getClass()</span></h2>
<p>返回此对象的运行时类。看创建对象是哪个类</p>
<table>
<thead>
<tr>
<th>getClass()</th>
<th>getClass().getName()</th>
<th>getClass().getSimpleName()</th>
</tr>
</thead>
<tbody>
<tr>
<td>class  包名.类名</td>
<td>包名.类名</td>
<td>类名</td>
</tr>
</tbody>
</table>
<h2><span id="string-tostring">String toString()</span></h2>
<p>返回该对象的字符串表示。</p>
<ul>
<li>
<p>默认实现 类的全限定名@hashcode的十六进制</p>
</li>
<li>
<p>自定义类如果不想按照上面的格式输出 需要重写toString()</p>
</li>
</ul>
<h2><span id="protected-void-finalize">protected void finalize()</span></h2>
<p>当对象不再被程序使用时，垃圾回收器将会将其回收</p>
<p>垃圾回收是在后台运行的，我们无法命令垃圾回收器马上回收资源，但是我们可 以告诉他，尽快回收资源（<strong>System.gc</strong> 和 Runtime.getRuntime().gc()）</p>
<p>垃圾回收器在回收某个对象的时候，首先会调用该对象的 finalize 方法</p>
<p>GC 主要针对堆内存 当垃圾收集器将要收集某个垃圾对象时将会调用 finalize，建议不要使用此方法，因为此方法的运行时间不确定，如果执行此方法出现错误，程序不会报告，仍然继续运行</p>
<h2><span id="boolean-equalsobject-obj">boolean equals(Object obj)</span></h2>
<p>指示其他某个对象是否与此对象“相等”。</p>
<h2><span id="和-equals-区别">== 和 equals 区别?</span></h2>
<table>
<thead>
<tr>
<th>== 比较运算符</th>
<th>equals是object中的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>既可以比较基本数据类型 也可以比较引用数据类型</td>
<td>只能比较引用数据类型</td>
</tr>
<tr>
<td>对于引用数据类型，比较的是地址</td>
<td>默认情况下equals方法底层使用==实现, 和 equals比较结果是一样</td>
</tr>
<tr>
<td></td>
<td>可重写成比较属性是否相等</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//存储在方法区同一地址下</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3.equals(str4));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>比较引用数据类型，使用equals更好</p>
<p>对于File、String、Date及包装类来说，是比较类型及内容而不考虑引用的是否是同一个对象；</p>
<p>原因：在这些类中重写了Object类的 equals()方法</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>SSM</title>
    <url>/post/SSM/</url>
    <content><![CDATA[<h2><span id="环境搭建">环境搭建</span></h2>
<h3><span id="导入依赖">导入依赖</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以统一的定义依赖的版本号，方便修改，避免版本号不一致;子标签名称自定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-version</span>&gt;</span>5.3.20<span class="tag">&lt;/<span class="name">spring-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">mybatis-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="springmvc">SpringMVC</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="servlet">Servlet</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--servlet原生技术的相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="spring">Spring</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring框架基础环境依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="comment">&lt;!--与spring-webmvc重复--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aop程序所需的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring框架和junit结合使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--junit单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="mybatis-数据库">Mybatis、数据库</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--spring和mybatis结合使用的依赖包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis框架的环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- DBUtils工具类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql数据库的驱动包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数据库连接池，阿里巴巴的德鲁伊连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 分页插件jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="其他">其他</span></h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- lombok，省略实体类中的相关的方法定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志相关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboss-vfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.16.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--json数据转换包，将其他数据类型，转换为String字符串(json字符串)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      src/main/java目录下默认情况下只对.java文件进行编译。</span></span><br><span class="line"><span class="comment">      该配置可以添加其它类型的文件也进行编译。</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="配置文件">配置文件</span></h3>
<h4><span id="springapplicationxml">SpringApplication.xml</span></h4>
<ol>
<li>IOC注解扫描</li>
<li>AOP注解驱动</li>
<li>mybatis.xml
<ol>
<li>导入外部资源文件</li>
<li>数据库连接池及连接配置</li>
<li>日志配置</li>
<li>SqlSessionFactory</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--IOC和DI的注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.service&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--AOP的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--从mybatis中转移过来的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入外部的资源文件  classpath: 表示路径，加入一个文件名即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提供一个数据源,连接池负责处理登录数据库的信息，可以把连接池对象交给具体操作数据库的那个工具类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configuration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.ibatis.session.Configuration&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--依然需要mybatis的SqlSessionFactory工厂的。负责获取连接对象,</span></span><br><span class="line"><span class="comment">    需要被MapperScannerConfigurer加载</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用一个数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置mybatis运行的日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configuration&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;configuration&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实体类类名简化,如果是多个包可以使用数组类型，如果是一个包可以使用字符串类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.pojo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--若mapper.xml配置在mapper文件夹的xml文件夹下，则需要声明以下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/bjpowernode/mapper/xml/*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--分页插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取mybatis框架的配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--统一配置mapper文件所在的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--读取上方配置好的工程对象,引用的是一个对象但是使用的是value,左边的变量是String类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--=======================使用AOP完成事务管理控制=========================--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用spring框架提供好类完成事务管理，此种写法称之为声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--针对事务管理的类DataSourceTransactionManager进行进一步的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--针对service中的方法进行细节化的事务管理配置</span></span><br><span class="line"><span class="comment">                区分CRUD</span></span><br><span class="line"><span class="comment">                写法支持通配模式；可以自己定义service中的方法哪些要添加事务管理，哪些不需要添加</span></span><br><span class="line"><span class="comment">                name:service中的方法名，add*表示以add开头的任意名称</span></span><br><span class="line"><span class="comment">                rollback-for:表示name中的方法要添加事务管理，如果发生异常需要回滚，爆出一个异常Exception</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;edit*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;del*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;abc*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transFer&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果是查询的方法，是不需要事务管理的</span></span><br><span class="line"><span class="comment">            read-only:表示事务只读，不添加事务管理</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通过AOP的方式完成最终的绑定，最终的效果--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--service方法的位置,使用切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..service..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="springmvc-configxml">SpringMVC-config.xml</span></h4>
<ol>
<li>注解扫描</li>
<li>注解驱动</li>
<li>请求静态资源</li>
<li>视图解析器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.web&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注解驱动:框架提供的一系列的简化写法,推荐不论用或不用，都添加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之前的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之后的扩展名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="webxml">web.xml</span></h4>
<ol>
<li>servlet添加SpringMVC配置</li>
<li>listener添加Spring配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置springMVC的核心控制器，可以让框架能够接收请求--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--读取springMVC的核心配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--添加一个监听器，目的是为了读取spring配置文件(spring中自动读取mybatis配置文件)--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--加载spring配置文件，自动的被上面的监听器读取--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springApplication.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--字符编码过滤器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="crud">CRUD</span></h2>
<p><a href="https://github.com/biyixia/java-code.git">https://github.com/biyixia/java-code.git</a></p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet过滤器</title>
    <url>/post/Servlet%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>过滤器/拦截器<br>
1、无论是请求还是响应都会被过滤器拦截<br>
2、需要等待过滤器放行</p>
<p>过滤器作用</p>
<p>过滤乱码<br>
限制资源访问<br>
过滤器的实现<br>
1、实现一个Filter接口（init()、destroy()的原理和执行时机和Servlet一样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter.destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain Chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截请求&quot;</span>);</span><br><span class="line">        Chain.doFilter(request,response);  <span class="comment">//放行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;拦截响应&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter.init&quot;</span>);</span><br><span class="line">    &#125;  <span class="comment">//第一个过滤器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在web.xml中配置过滤器，类似servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>my.student.filter.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--/*表示拦截一切请求--&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--/MyServlet表示只拦截特定请求--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--拦截HTTP请求--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--拦截请求转发请求--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通配符<br>
dispatcher请求方式：<br>
REQUEST：拦截HTTP请求<br>
FORWORD：只拦截 通过 请求转发方式的请求<br>
INCLUDE：只拦截通过request.getRequestDispatcher(“”).indeclude()、通过&lt;jsp:include page=“…”&gt;发出的请求<br>
ERROR：只拦截&lt;error - page&gt;发出的请求</p>
<p>通过doFilter()处理拦截，并且通过chain.doFilter(request，response)放行</p>
<p>Chain.doFilter(request,response);  //放行</p>
<p>注意：<br>
在过滤器中doFilter方法的参数：ServletRequest、ServletResponse<br>
而在Servlet中doGet方法的参数：HttpServletRequest、HttpServletResponse</p>
<p>过滤器链<br>
可以增加多个过滤器Filter，过滤器处理的顺序由web.xml中配置的filter-mapping顺序决定</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/post/SpringMVC/</url>
    <content><![CDATA[<h2><span id="导入依赖">导入依赖</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="配置文件">配置文件</span></h2>
<h3><span id="springmvc-configxml">SpringMVC-config.xml</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.web&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之前的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--响应结果的前缀，页面之后的扩展名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注解驱动:框架提供的一系列的简化写法,推荐不论用或不用，都添加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="webxml">web.xml</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置springMVC的核心控制器，可以让框架能够接收请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--讀取SpringMVC核心配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:SpringMVC-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--控制Servlet实例化時間--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="匹配优先级">匹配优先级</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/helloWorld&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestServlet运行了................&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/helloWorld&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorldController运行了................&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述Servlet与Controller对应的请求都是“/helloWorld”，但是由于@WebServlet注解相当于直接在web.xml中配置</p>
<p>当有一个“/helloWorld”请求时，先访问web.xml，其中的@WebServlet(“/helloWorld”)优先级高于 “/”，因此不会向下执行Controller中的hello01，而执行TestServlet中的doGet方法。</p>
<h2><span id="web-inf">WEB-INF</span></h2>
<ol>
<li>WEB-INF目录可以称之为是安全文件夹，此目录可以保护和限制前端页面；</li>
<li>此目录下的所有子目录以及所有的资源，不允许通过路径拼接访问，也不允许响应重定向跳转(限制)，只允许请求转发的方式跳转此页面(保护)。</li>
<li>推荐：后面可以将前端页面(不包含静态资源)，放入此文件夹。</li>
</ol>
<h2><span id="常用注解">常用注解</span></h2>
<h3><span id="controller">@Controller</span></h3>
<ol>
<li>@Component注解的别名</li>
<li>在类（控制器）上使用，将此类的实例交给spring容器管理</li>
</ol>
<h3><span id="requestmapping">@RequestMapping</span></h3>
<ol>
<li>在类和方法使用，确定访问路径和类及类中方法的映射关系</li>
<li>在类上使用时，value值作为一级路径(模块)存在，方便团队分模块开发</li>
<li>在方法上使用时，value值作为二级路径，表示模块中的不同功能</li>
<li>路径可以是uri变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址</li>
</ol>
<p><strong>常用属性</strong></p>
<ol>
<li>value***：一级或二级路径</li>
<li>method : 限定请求方式，只能使用指定的请求方式，没有该属性则表示不限制请求方式</li>
<li>params 指定请求的时候必须携带指定的参数(或者参数及其对应值)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello.html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能使用post方式来访问</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;hello2.html&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;hello2.html&quot;)</span> <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>;</span><br><span class="line">        <span class="comment">//使用视图解析器后可简写成 return &quot;success.jsp&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;hello3.html&quot;, params = &#123;</span></span><br><span class="line"><span class="meta">            &quot;username&quot;, // 必须携带username参数，不限制值</span></span><br><span class="line"><span class="meta">            &quot;type=1&quot;    // 必须携带type参数，值必须是1</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="requestparam">@RequestParam</span></h3>
<ol>
<li>@RequestParam:框架帮助程序接收请求参数（将参数封装成map集合）</li>
<li>属性“defaultValue”设置默认值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello06</span><span class="params">(<span class="meta">@RequestParam(defaultValue =&quot;女1&quot;)</span> String sex)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(sex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="cookievalue了解">@CookieValue(了解)</span></h3>
<p>获取指定cookie的值</p>
<h2><span id="springmvc的请求传统请求">SpringMVC的请求（传统请求）</span></h2>
<h3><span id="接收请求参数重点掌握">接收请求参数(重点掌握)</span></h3>
<h4><span id="简单类型">简单类型</span></h4>
<ol>
<li>8种基本数据类型(包括包装类型)和String类型</li>
<li>方法中的参数名和请求参数的名称保持一致</li>
<li>如果使用的是基本数据类型，必须有数据，否则因为默认值的原因，程序会出现500的异常</li>
<li>如果是String对象字符串，可以不赋值，使用null来表示</li>
<li>推荐写法: 将基本数据类型改为包装类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello02</span><span class="params">(Integer id,String name,Double score)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line">	<span class="comment">//http://localhost:8080/request02?id=123&amp;&amp;name=biyixia&amp;&amp;score=100</span></span><br><span class="line">    System.out.println(id);<span class="comment">//123</span></span><br><span class="line">    System.out.println(name);<span class="comment">//biyixia</span></span><br><span class="line">    System.out.println(score);<span class="comment">//100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="对象类型pojo">对象类型pojo</span></h4>
<p>对象类型数据(自定义类型数据)， 直接在方法中声明需要封装的pojo，请求参数名称需要和类中的属性名一致！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello03</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(account);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="数组类型">数组类型</span></h4>
<ol>
<li>
<p>请求参数名和数组的名称一致</p>
</li>
<li>
<p>请求参数的格式：</p>
<ol>
<li>
<p>常规写法： <code>http://127.0.0.1/request04?ids=1&amp;ids=2&amp;ids=234</code></p>
</li>
<li>
<p>简化写法(如需使用，需要添加框架的注解驱动)：<code>http://127.0.0.1/request04?ids=1,2,3,4,5,100,50,20</code></p>
<blockquote>
<p>注解驱动：框架提供的一系列的简化写法</p>
<p><code>&lt;mvc:annotation-driven/&gt;</code></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello04</span><span class="params">(Integer[] ids)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(ids));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="集合类型">集合类型</span></h4>
<ol>
<li>请求任意数量任意类型任意名称的参数，需要添加@RequestParam注解帮助程序接收请求参数</li>
<li>太灵活了，使用频率不高</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello05</span><span class="params">(<span class="meta">@RequestParam</span> Map map)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="时间类型">时间类型</span></h4>
<ol>
<li>
<p>默认格式：2023/06/13 16:19:50</p>
</li>
<li>
<p>其他方式：需要添加注解，单独定义时间格式模板(如果使用了注解定义了时间格式模板，默认的/不让使用)</p>
<blockquote>
<p>2023-06-13 16:19:50、2023年06月13日 16:19:50</p>
</blockquote>
</li>
<li>
<p>说明:在今后的程序中，针对时间格式一个项目只会存在一种规则，一种时间格式就够了。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello07</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:ss:mm&quot;)</span> Date date)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="post请求中文过滤器会使用">post请求中文过滤器（会使用）</span></h3>
<ol>
<li>POST方式请求中文参数时会出现乱码的情况（由于进行了数据处理），因此需要使用过滤器统一字符编码</li>
<li>spring已经提供了一个过滤器CharacterEncodingFilter,我们只需要去web.xml中配置即可</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置字符编码过滤器--&gt;</span></span><br><span class="line">&lt;**filter**&gt;</span><br><span class="line">  &lt;**filter-name**&gt;CharacterEncodingFilter&lt;/**filter-name**&gt;</span><br><span class="line">  &lt;**filter-class**&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/**filter-class**&gt;</span><br><span class="line">  &lt;**init-param**&gt;</span><br><span class="line">    <span class="comment">&lt;!--指定post请求的编码--&gt;</span></span><br><span class="line">    &lt;**param-name**&gt;encoding&lt;/**param-name**&gt;</span><br><span class="line">    &lt;**param-value**&gt;utf-8&lt;/**param-value**&gt;</span><br><span class="line">  &lt;/**init-param**&gt;</span><br><span class="line">&lt;/**filter**&gt;</span><br><span class="line">&lt;**filter-mapping**&gt;</span><br><span class="line">  &lt;**filter-name**&gt;CharacterEncodingFilter&lt;/**filter-name**&gt;</span><br><span class="line">  &lt;**url-pattern**&gt;/*&lt;/**url-pattern**&gt;</span><br><span class="line">&lt;/**filter-mapping**&gt;  </span><br></pre></td></tr></table></figure>
<h3><span id="获得原生servletapi重要">获得原生ServletAPI(重要)</span></h3>
<h4><span id="在目标方法中添加参数">在目标方法中添加参数</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello09</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response,</span></span><br><span class="line"><span class="params">        HttpSession session</span></span><br><span class="line"><span class="params">                      )</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//默认使用的请求转发跳转到一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="通过注入的方式">通过注入的方式</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*<span class="comment">// 一般web的组件在进行注入时，required改为false，防止注入不成功时报错！*</span></span><br><span class="line">  <span class="meta">@Autowired(required = **false**)</span></span><br><span class="line">  **<span class="keyword">private</span>** HttpServletRequest request;</span><br><span class="line">  <span class="meta">@Autowired(required = **false**)</span></span><br><span class="line">  **<span class="keyword">private</span>** HttpServletResponse response;</span><br><span class="line">  <span class="meta">@Autowired(required = **false**)</span></span><br><span class="line">  **<span class="keyword">private</span>** HttpSession session;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;request10&quot;)</span></span><br><span class="line">  **<span class="keyword">public</span>** String <span class="title function_">hello10</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    **<span class="keyword">return</span>** <span class="string">&quot;success&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="请求静态资源处理会用">请求静态资源处理(会用)</span></h3>
<p>每个web服务器都实现了servlet-api和jsp-api,提供了两个servlet(DefaultServlet和JspServlet)</p>
<ol>
<li>
<p>修改dispatcherservlet的匹配规则（web.xml）</p>
<blockquote>
<p>将 / 修改为 *.do,这样的话,页面中所有的连接都需要改成 xx.do.这样的话我们的前端控制器就只处理以&quot;.do&quot;结尾的请求了.其他的请求交给服务器来处理</p>
</blockquote>
</li>
<li>
<p>通过springMVC框架自定义映射关系（spring-mvc.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--建立静态资源映射关系</span></span><br><span class="line"><span class="comment">  mapping:虚拟路径，可以自己定义，用于页面中的编写路径(推荐使用真实路径)</span></span><br><span class="line"><span class="comment">  location:项目中资源的路径，真实路径，必须是静态资源的真实路径</span></span><br><span class="line"><span class="comment">  cache-period：在客户端（浏览器）缓存的时间</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/static/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;#&#123;3600*24*10&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开启静态资源servlet支持(spring-mvc.xml)</p>
<p>任意的目录，任意的静态资源都可以任意使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明:在服务器接收请求时，优先使用框架处理请求,如果遇到静态资源参与时，框架无法处理，服务器就会将请求交给tomcat的DefaultServlet来处理。</p>
</li>
</ol>
<h3><span id="与">/* 与 /**</span></h3>
<table>
<thead>
<tr>
<th></th>
<th>/*</th>
<th>/**</th>
</tr>
</thead>
<tbody>
<tr>
<td>web.xml(url-pattern)</td>
<td>所有的子目录以及所有子目录中的所有资源</td>
<td>无意义</td>
</tr>
<tr>
<td>SpringMVC-config.xml</td>
<td>目录中的所有资源,不包含子目录</td>
<td>表示所有的资源(所有的子目录以及所有子目录中的所有资源)</td>
</tr>
</tbody>
</table>
<h2><span id="springmvc的响应">SpringMVC的响应</span></h2>
<p>分为全局刷新与局部刷新两种情况</p>
<h3><span id="全局刷新拼接路径">全局刷新（拼接路径）</span></h3>
<ol>
<li>请求：超链接，表单，地址栏</li>
<li>响应：请求转发，响应重定向</li>
<li>整个浏览器被新的数据覆盖,浏览器需要加载，渲染页面</li>
</ol>
<p>全局刷新情况下，可使用3种不同的返回值，分别为String、ModelAndView和void</p>
<h4><span id="string类型">String类型</span></h4>
<ol>
<li>
<p>默认使用请求转发跳转到一个页面，可以结合试图解析器</p>
<p><code>return &quot;success&quot;;</code></p>
</li>
<li>
<p>使用请求转发跳转到一个页面，不能结合视图解析器；固定单词forward:</p>
<p><code>return &quot;forward:/WEB-INF/jsp/success.jsp&quot;;</code></p>
</li>
<li>
<p>使用响应重定向的方式跳转到一个页面，不能结合视图解析器；固定单词redirect:</p>
<p><code>return &quot;redirect:/WEB-INF/jsp/success.jsp&quot;;</code></p>
</li>
</ol>
<h4><span id="modelandview类型">ModelAndView类型</span></h4>
<ol>
<li>
<p>自动生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">hello02</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放键值对护具,实际上就是request对象作用域</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>);</span><br><span class="line">    <span class="comment">//存放一个页面名称(结合视图解析器)</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自己创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">hello04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放键值对护具,实际上就是request对象作用域</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>);</span><br><span class="line">    <span class="comment">//存放一个页面名称(结合视图解析器)</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4><span id="void类型">void类型</span></h4>
<p>使用servlet原生对象处理响应，没有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello02</span><span class="params">(HttpServletRequest request，HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line">    <span class="comment">//请求转发</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    <span class="comment">//响应重定向</span></span><br><span class="line">    <span class="comment">//response.sendRedirect(&quot;&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="model和modelmap不推荐">Model和ModelMap（不推荐）</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello05</span><span class="params">(Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>);</span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;request06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello06</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;DemoRequestController类接收到了请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>);</span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="局部刷新ajax请求">局部刷新（Ajax请求）</span></h3>
<ol>
<li>请求:jquery中的ajax函数发送任意的请求</li>
<li>响应:底层使用的是打印流返回结果，目前使用的是注解完成</li>
<li>在浏览器的内部，发起请求，获取数据，改变页面的部分内容。其余的页面无需加载和渲染，网络中的数据传输量少，给用户感觉好，通过Ajax实现</li>
</ol>
<p>可以使用任意类型的返回值，通过SpringMVC框架实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入jQuery--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/static/jquery-1.12.4.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 页面加载完成事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#sendBtn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&quot;/request_ajax_01&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#sendBtn2&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&quot;/request_ajax_02&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#sendBtn3&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&quot;request_ajax_03&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 发送json字符串时，必须使用post请求</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 内容的编码类型</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">contentType</span>:<span class="string">&quot;application/json;charset=utf-8&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// json字符串，键值必须使用双引号</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">data</span>:<span class="string">&#x27;&#123;&quot;aid&quot;:1001,&quot;name&quot;:&quot;admin&quot;,&quot;balance&quot;:500.0&#125;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// JSON.stringify可以将js对象转换为json字符串</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//data: JSON.stringify(&#123; aid: 1001, name: &quot;tom&quot;, balance: 500.0 &#125;),</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * jQuery会根据dataType对结果进行处理，</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * 如果后台设置了content-type为application/json，则此处可以不指定</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     * 但最好是明确指定为json，这样即便后台不设置content-type，jQuery也会处理</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                     */</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 打印对象，不能看出对象中包含哪些属性</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data);</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// JSON.stringify可以将js对象转换为json字符串，方便查看对象结构</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data) );</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data.<span class="property">success</span>);</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(data.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;原生的方式发送ajax请求&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;框架的方式发送ajax请求_@ResponseBody&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;框架的方式发送ajax请求_@RequestBody&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request_ajax_01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getRequestAjax01</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到了请求！！！！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回浏览器一个结果</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">    <span class="comment">//out.write(&quot;getRequestAjax01方法返回的结果&quot;);//返回一个字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="number">1000.5</span>);</span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(account);</span><br><span class="line">    out.write(json);<span class="comment">//返回的是一个对象(集合)</span></span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前提：若要使用RequestBody和ResponseBody必须导入jackson依赖</p>
<h4><span id="responsebody">@ResponseBody</span></h4>
<p>表示方法的返回值直接以Json格式写入Http response body中，而不是解析为跳转路径。</p>
<p>只处理局部刷新(完成打印流的输出，json数据的类型转换)</p>
<p>返回值类型没有任何限制了，可以是任意的返回值类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;request_ajax_02&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">getRequestAjax02</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到了请求！！！！！！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1002</span>,<span class="string">&quot;abcd&quot;</span>,<span class="number">2000.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="requestbody了解">@RequestBody(了解)</span></h4>
<ol>
<li>用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；</li>
<li>必须用POST方式进行提交</li>
<li>在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;request_ajax_03&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Map <span class="title function_">getRequestAjax03</span><span class="params">(<span class="meta">@RequestBody</span> Account account)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到了请求！！！！！！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;请求参数:&quot;</span>+account);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>()&#123;&#123;</span><br><span class="line">        put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;新增成功!!!!!!!!&quot;</span>);</span><br><span class="line">        put(<span class="string">&quot;flag&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="restful风格请求">RestFul风格请求</span></h2>
<p>所有的rest风格请求必须建立在局部刷新的基础上</p>
<p>传统请求与RestFul请求中都含有请求名称、请求方式、请求参数，但两者唯一区分请求的标准不同</p>
<table>
<thead>
<tr>
<th>传统请求</th>
<th>RestFul请求</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以出现&quot;?&quot; “&amp;” 键值对 “/”</td>
<td>仅 “/”</td>
</tr>
<tr>
<td>主要通过请求名称唯一区分不同请求(请求方式辅助)</td>
<td>主要通过请求方式唯一区分不同请求(请求参数辅助)</td>
</tr>
</tbody>
</table>
<h3><span id="pathvariable">@PathVariable</span></h3>
<p>映射 URL 绑定的占位符，将 URL中{xxx}占位符参数绑定到控制器处理方法的入参中</p>
<p>一般与@RequestMapping(method = RequestMethod.GET)一起使用</p>
<p>1、若方法参数名称和需要绑定的url中变量名称一致时,可以简写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUser/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.selectUser(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、若方法参数名称和需要绑定的url中变量名称不一致时，写成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUserById/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String userName)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.selectUser(userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="restcontroller">@RestController</span></h3>
<ol>
<li>等同于@Controller + @ResponseBody</li>
<li>若控制器中的所有方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。</li>
</ol>
<h3><span id="put请求无法获取数据">put请求无法获取数据</span></h3>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.FormContentFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="文件上传">文件上传</span></h2>
<h3><span id="导入依赖">导入依赖</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="配置springmvc">配置SpringMVC</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传配置：id必须为multiPartResolver--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multiPartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置单次上传文件总大小最大值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;50*1024*1024&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置单次上传每个文件大小的最大值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;1*1024*1024&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="前端请求">前端请求</span></h3>
<p>表单处理，必须为post请求</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;upload.do&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    导入：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;files&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span> &gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="后端接收">后端接收</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;upload.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile[] files)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile file : files) &#123;</span><br><span class="line">        <span class="comment">//获取上传文件名</span></span><br><span class="line">        System.out.println(file.getOriginalFilename());</span><br><span class="line">        <span class="comment">//为了避免上传文件名一致导致的已上传的文件被覆盖，需处理文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + file.getOriginalFilename();</span><br><span class="line">        System.out.println(fileName);</span><br><span class="line">        <span class="comment">//创建保存上传文件的目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\upload&quot;</span>+getPath(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">File</span>(path).mkdirs();</span><br><span class="line">        <span class="comment">//保存上传文件</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(path+<span class="string">&quot;\\&quot;</span>+fileName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;upload&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理目录的分离：</span></span><br><span class="line"><span class="comment"> *   level 目录深度:表示有几层</span></span><br><span class="line"><span class="comment"> *   count 目录数量:每一层的目录个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回生成的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPath</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        result.append(<span class="string">&quot;\\&quot;</span>);</span><br><span class="line">        result.append((random.nextInt(count) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>避免文件名重复：UUID随机数作为名称</li>
<li>避免文件夹文件过多：尽可能存放在不同的目录中(自己定义)</li>
</ol>
<h2><span id="统一异常处理与信息返回">统一异常处理与信息返回</span></h2>
<h3><span id="统一错误友好页面webxml">统一错误友好页面（web.xml）</span></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--友好错误页面配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="异常处理">异常处理</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//专门用于异常处理的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理空指针异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(NullPointerException.class)</span><span class="comment">//传入什么类型，处理什么类型的异常</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">NullPointException</span><span class="params">(Exception e,HttpServletRequest request)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springMVC_error&quot;</span>;<span class="comment">//跳转一个异常处理页面，结合视图解析器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理所有的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span><span class="comment">//传入什么类型，处理什么类型的异常</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">myException</span><span class="params">(Exception e,HttpServletRequest request)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springMVC_error02&quot;</span>;<span class="comment">//跳转一个异常处理页面，结合视图解析器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="拦截器interceptor">拦截器Interceptor</span></h2>
<p>类似于Filter过滤器，对处理器(方法)进行前置拦截 和 后置 拦截操作。</p>
<h3><span id="实现handlerinterceptor接口prehandle方法">实现HandlerInterceptor接口preHandle方法</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intercepter1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">// 拦截处理程序（Controller）的调用，返回false表示处理程序不会被调用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截到了请求：&quot;</span> + request.getRequestURI());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="配置拦截器springmvcxml">配置拦截器（springmvc.xml）</span></h3>
<ol>
<li>指定拦截哪些资源</li>
<li>放行拦截中的哪些资源</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  拦截器配置，当配置多个拦截器时</span></span><br><span class="line"><span class="comment">    1. 拦截顺序根据配置的顺序进行拦截</span></span><br><span class="line"><span class="comment">    2. 如果第一个拦截器中return false，则之后与请求路径匹配的拦截器不会执行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      /test/\  拦截/test目录下的资源</span></span><br><span class="line"><span class="comment">      /test/  拦截/test目录及其子目录下的资源</span></span><br><span class="line"><span class="comment">    --&gt;</span>*</span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/test/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.web.intercepter.Intercepter1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/test/test1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.web.intercepter.Intercepter2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h3><span id="过滤器和拦截器面试题">过滤器和拦截器(面试题)</span></h3>
<p>过滤器能够实现的功能，使用拦截器也可以实现</p>
<p><strong>关系（Filter、Servlet、Interceptor、Controller）图：</strong></p>
<p>web服务器组件：Filter、Servlet</p>
<p>SpringMVC的组件：Interceptor、Controller</p>
<p><img src="https://pic.imgdb.cn/item/6490f5fe1ddac507cc5b916d.jpg" alt></p>
<table>
<thead>
<tr>
<th></th>
<th>过滤器</th>
<th>拦截器</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行顺序</td>
<td>先执行过滤器Filter</td>
<td>再执行拦截器Intercepter</td>
</tr>
<tr>
<td>组件</td>
<td>web服务器的组件</td>
<td>SpringMVC的组件</td>
</tr>
<tr>
<td>处理请求</td>
<td>可以拦截所有请求</td>
<td>只能拦截SpringMVC核心处理器（DispatcherServlet）处理范围内的资源</td>
</tr>
<tr>
<td>使用场景</td>
<td>处理和数据相关的需求，字符集过滤器CharacterEncodingFilter（解决中文乱码）、FormContentFilter（解决put请求获取不到表单数据的问题）</td>
<td>用于权限的控制，例如某些功能需要登录才能访问！又如某些功能需要会员才能使用。</td>
</tr>
</tbody>
</table>
<h3><span id="登录权限拦截器案例">登录权限拦截器案例</span></h3>
<p>用户没有登录的情况下，除了登录页面和静态资源以外，不给访问！强制跳转到登录界面！</p>
<h2><span id="springmvc的执行流程面试题">SpringMVC的执行流程(面试题)</span></h2>
<p><img src="https://pic.imgdb.cn/item/6490f61d1ddac507cc5bb2b6.jpg" alt></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心控制器</td>
<td>整个流程控制的核心，调用其他组件处理用户的请求，简化Servlet共有行为的处理。</td>
</tr>
<tr>
<td>处理器映射器</td>
<td>根据请求对象(中的url)获取到对应的处理程序执行链对象，该对象中包括处理程序 Handler（Controller） 和拦截器 Interceptor</td>
</tr>
<tr>
<td>处理器适配器</td>
<td>执行处理程序 Handler 的对象，处理器映射器负责查找处理程序，而处理程序中的参数的封装，都是处理器适配器完成的，例如通过参数的声明直接获取参数</td>
</tr>
<tr>
<td>视图解析器</td>
<td>将逻辑视图解析为View对象（真实资源文件对象），对处理程序（Controller中的每个方法都是一个处理程序）的返回值（视图）进行解析！例如：方法返回String类型时，返回redirect:/路径表示重定向，这都是视图解析器在完成</td>
</tr>
<tr>
<td>处理程序</td>
<td>处理业务逻辑（特有行为），Controller中的每个方法都是一个处理程序</td>
</tr>
<tr>
<td>拦截器</td>
<td>类似过滤器，权限控制，例如登录权限</td>
</tr>
<tr>
<td>Model</td>
<td>存放渲染视图所需的数据</td>
</tr>
<tr>
<td>View</td>
<td>JSP、HTML，渲染 View</td>
</tr>
</tbody>
</table>
<h3><span id="执行流程">执行流程</span></h3>
<ol>
<li>用户发起请求到核心控制器 DispatcherServlet</li>
<li>处理器映射器 HandlerMapping 根据请求对象获取处理器执行链 HandlerExecutionChain。包括处理程序Handler和拦截器Interceptor数组</li>
<li>为处理程序查找合适的处理器适配器 HandlerAdapter，该对象用于真正的调用处理程序Handler</li>
<li>处理器适配器 HandlerAdapter 调用处理程序 Handler，返回模型和视图对象 ModelAndView</li>
<li>核心控制器请求视图解析器去进行视图解析（将逻辑视图转化成完整的视图地址）</li>
<li>核心控制器将Model交给View进行视图渲染</li>
<li>View将结果响应给浏览器</li>
</ol>
<p>我们需要做的事情:</p>
<ol>
<li>在web.xml中配置核心控制器DispatcherServlet</li>
<li>编写处理器（controller）和 视图（jsp）</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC拦截器</title>
    <url>/post/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h2><span id="什么是拦截器">什么是拦截器</span></h2>
<p>SpringMVC中的interceptor拦截器</p>
<p>依赖于web框架，基于Java的反射机制实现，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个 controller生命周期之内可以多次调用。</p>
<p>它主要的作用是拦截指定的用户请求，并进行相应的预处理与后处理。</p>
<p>使用的aop的思想，多个Controller中集中到拦截器统一处理</p>
<p><strong>应用场景</strong></p>
<ul>
<li>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。</li>
<li>权限检查：如登录检测，进入处理器检测是否登录，如果没有直接返回到登录页面；</li>
<li>性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）；</li>
<li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个Controller中的处理方法都需要的，我们就可以使用拦截器实现。</li>
</ul>
<h2><span id="拦截器执行时机">拦截器执行时机</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>preHandle</td>
<td>请求前（即控制类方法执行前）执行，通过返回true，拦截返回false</td>
</tr>
<tr>
<td>postHandle</td>
<td>请求结束（即控制类方法执行后），且此时仍未相应到界面时执行，可以改变响应结果</td>
</tr>
<tr>
<td>afterCompletion</td>
<td>请求结束（即控制类方法执行后），同时已经响应界面执行，可以用于清理对象、关闭资源</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/64141a80a682492fcc3f3a71.jpg" alt></p>
<h2><span id="拦截器实现">拦截器实现</span></h2>
<ol>
<li>实现HandlerInterceptor拦截器接口</li>
<li>在spring-mvc.xml配置文件注册</li>
</ol>
<h3><span id="注册拦截器">注册拦截器</span></h3>
<p><strong>拦截器支持的通配符</strong></p>
<ol>
<li>*	:包括当前路径所有   /admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截</li>
<li>/**  :包括路径及其子路径</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射要拦截的请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**/*.action&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置放行的请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/login.action&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/loginErr.action&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置拦截器的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.interceptor.MyInterceptor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="实现handlerinterceptor拦截器接口">实现HandlerInterceptor拦截器接口</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throw</span> Exception&#123;</span><br><span class="line">        <span class="comment">//准备请求地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle准备请求地址:&quot;</span>+request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截请求地址，检测是否登录</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();        <span class="comment">//可以从request对象获取HttpSession对象</span></span><br><span class="line">        <span class="keyword">if</span>(session!=<span class="literal">null</span> &amp;&amp; session.getAttribute(<span class="string">&quot;user&quot;</span>)!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//response.sendRedirect(&quot;/login.html&quot;);ajax则会请求失败，要使用其他的控制器周转</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/user/loginErr.action&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle请求结束准备响应界面：....................&quot;</span>+request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion请求响应结束：....................&quot;</span>+request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="拦截器链多拦截器">拦截器链（多拦截器）</span></h2>
<p>如果多个拦截器能够对相同的请求进行拦截，则多个拦截器会形成一个拦截器链，主要理解拦截器链中各个拦截器的执行顺序。拦截器链中多个拦截器的执行顺序，与拦截器的配置顺序有关，先配置的先执行。也可以通过@Order指定顺序。</p>
<h2><span id="拦截器与过滤器">拦截器与过滤器</span></h2>
<h3><span id="过滤器">过滤器</span></h3>
<p>依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例，只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作，比如：在过滤器中修改字符编码； 在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。</p>
<h3><span id="拦截器">拦截器</span></h3>
<p>在AOP（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。</p>
<blockquote>
<p>在 Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>拦截器</th>
<th>过滤器</th>
</tr>
</thead>
<tbody>
<tr>
<td>SpringMVC提供，SpringMVC容器中创建</td>
<td>servlet中的对象，tomcat服务器创建</td>
</tr>
<tr>
<td>实现HandlerInterceptor</td>
<td>继承HttpFilter</td>
</tr>
<tr>
<td>验证请求，拦截请求</td>
<td>设置request，response的参数，属性的，侧重对数据过滤的</td>
</tr>
<tr>
<td>三个执行时间点</td>
<td>一个执行时间点</td>
</tr>
<tr>
<td>侧重拦截对Controller方法，不会拦截jsp/html/css/image/js</td>
<td>可以处理jsp，js，html等等</td>
</tr>
<tr>
<td>通常对处理器Controller进行拦截，只能拦截dispatcherServlet处理的请求</td>
<td>几乎对所有请求过滤</td>
</tr>
<tr>
<td></td>
<td>过滤器是在拦截器之前先执行的</td>
</tr>
</tbody>
</table>
<p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>String类</title>
    <url>/post/String%E7%B1%BB/</url>
    <content><![CDATA[<h2><span id="创建对象">创建对象</span></h2>
<ol>
<li>new关键字创建对象，对象存储在堆中</li>
<li>赋值字面量（常量），字面量存储在字符串常量池中</li>
<li>赋值变量为地址引用，并没有创建新的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接new关键字创建对象</span></span><br><span class="line">String str1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzj&quot;</span>);</span><br><span class="line"><span class="comment">//直接赋值字面量</span></span><br><span class="line">String str2=<span class="string">&quot;hzj&quot;</span>;</span><br><span class="line"><span class="comment">//直接赋值变量</span></span><br><span class="line">String str3=str1;</span><br></pre></td></tr></table></figure>
<p><strong>字符串常量池</strong></p>
<ul>
<li>字符串常量唯一存储在字符串常量池中</li>
</ul>
<h3><span id="new关键字创建字符串对象">new关键字创建字符串对象</span></h3>
<ul>
<li>首先在堆中创建字符串对象实例，该对象实例持有字符串常量池中相应字面量的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzj&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzj&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false 不同引用指向同一个地址</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63d661ffface21e9eff0129a.jpg" alt="new关键字创建字符串对象"></p>
<p><strong>获取字面量地址</strong></p>
<p>通过字符串实例对象的intern（）方法可以获取存储在字符串常量池中的字面量地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hzj&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzj&quot;</span>);</span><br><span class="line"><span class="comment">//intern()方法改变字符串对象的地址指向常量池地址</span></span><br><span class="line">str2=str2.intern();</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>赋值字面量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzj&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzj&quot;</span>);</span><br><span class="line">str1=str1.intern();</span><br><span class="line">str2=str2.intern();</span><br><span class="line">System.out.println(str1==str2);	<span class="comment">//true  通过获取常量池中的地址直接指向字面量，相当于字面量赋值</span></span><br></pre></td></tr></table></figure>
<p><img src="/post/String%E7%B1%BB/D:%5C%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99%5Chzj%5Csz2212%5C008-String%5CString.assets%5Cimage-20230129121338872.png" alt="image-20230129121338872"></p>
<h3><span id="变量赋值">变量赋值</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzj&quot;</span>);</span><br><span class="line">str2=str1;</span><br><span class="line">System.out.println(str1==str2); 	<span class="comment">//true   同一对象同一引用指向同一个地址</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63d665adface21e9eff7c0d0.jpg" alt="变量赋值"></p>
<p><strong>为什么推荐使用字面量赋值的方式创建字符串对象，而不是通过new关键字创建</strong></p>
<ul>
<li>使用new关键字创建字符串内容相同的多个对象时，这些对象地址不同却有着一同指向字符串常量池的引用，造成了空间的浪费</li>
<li>使用字面量赋值的方式创建字符串对象，栈中的局部变量直接指向字符串常量池的同一个字面量</li>
</ul>
<h2><span id="运算符连接字符串">+运算符连接字符串</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hzj&quot;</span>;<span class="comment">//hzj</span></span><br><span class="line">String str2=<span class="string">&quot;hz&quot;</span>+<span class="string">&quot;j&quot;</span>;<span class="comment">//hzj</span></span><br><span class="line">String str3=<span class="string">&quot;hz&quot;</span>;<span class="comment">//hz</span></span><br><span class="line">String str4=str3+<span class="string">&quot;j&quot;</span>;</span><br><span class="line">System.out.println(str1==str2);		<span class="comment">//true</span></span><br><span class="line">System.out.println(str1==str4);		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么str2相当于str1字面量赋值</strong></p>
<ul>
<li>str2中为<strong>两个字面量</strong>通过+连接，由于字面量（常量）在程序执行过程中不会发生改变</li>
<li>因此在编译生成字节码文件中，编译器会自动去掉加号完成字符串的拼接</li>
<li>str2直接指向常量池&quot;hzj&quot;</li>
</ul>
<p><strong>同样使用+运算符，为什么str4不能等同str1的字面量赋值</strong></p>
<ul>
<li>
<p>str4中是<strong>变量和字面量</strong>通过+连接，由于变量在程序执行过程中可能发生改变</p>
</li>
<li>
<p>因此编译器不会自动完成字符串拼接，而是使用StringBuilder对象的append方法进行相加，最后通过toString返回结果</p>
<p>toString方法中会使用new关键字创建字符串对象</p>
</li>
<li>
<p>str4指向的是toString生成的字符串对象</p>
</li>
</ul>
<h3><span id="循环中使用拼接字符串">循环中使用+拼接字符串</span></h3>
<ul>
<li>通过查看字节码文件，循环中多次创建了StringBuilder和String对象，极大地浪费内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    <span class="comment">//String注意不要再循环的时候使用+号</span></span><br><span class="line">    str=str+i;</span><br><span class="line">&#125;        </span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63d670b9face21e9ef0e9bac.jpg" alt></p>
<h3><span id="直接使用stringbuilder或stringbuffer">直接使用StringBuilder或StringBuffer</span></h3>
<ol>
<li>StringBuffer是线程安全；StringBuilder是线程不安全</li>
<li>循环体外创建StringBuilder或StringBuffer对象，避免内存浪费</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">StringBuilder stringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    stringBuilder.append(i);</span><br><span class="line">&#125;</span><br><span class="line">str=stringBuilder.toString();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63d67062face21e9ef0ded1f.jpg" alt></p>
<h3><span id="查看字节码文件细节">查看字节码文件细节</span></h3>
<p><strong>javap命令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -v xxxx.class</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63d67201face21e9ef112b6a.jpg" alt></p>
<p><strong>idea插件jclasslib</strong></p>
<p><img src="https://pic.imgdb.cn/item/63d67227face21e9ef117b76.jpg" alt></p>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat安装与配置</title>
    <url>/post/Tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2><span id="下载与安装">下载与安装</span></h2>
<p><a href="https://tomcat.apache.org/download-90.cgi">Tomcat官网</a></p>
<p><img src="https://pic.imgdb.cn/item/64959f7a1ddac507cc218315.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/64959fd01ddac507cc222a69.jpg" alt></p>
<h2><span id="配置">配置</span></h2>
<p>JAVA_HOME</p>
<p>计算机右键 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量</p>
<ol>
<li>在系统环境变量中新建 <code>CATALINA_HOME</code> 环境变量，值为<code>D:\java\apache-tomcat-9.0.76</code>（安装目录）</li>
<li>修改 Path ，在 Path 后添加： <code>%CATALINA_HOME%\lib</code>、<code>%CATALINA_HOME%\bin</code>、<code>%CATALINA_HOME%\lib\servlet-api.jar</code></li>
</ol>
<p>注意：</p>
<ol>
<li>环境变量中变量名对大小写不敏感，可将CATALINA_HOME小写，但需要保持一致</li>
<li>在环境变量中，如果新建有两个相同仅大小写不同的的变量名，会覆盖设置。如：path和PATH</li>
</ol>
<h2><span id="tomcat文件目录">Tomcat文件目录</span></h2>
<ol>
<li>bin：可执行文件（启动文件startup.bat、关闭文件shutdown.bat）</li>
<li>conf：配置文件（修改端口号：server.xml，建议将server.xml备份）</li>
<li>lib：依赖的jar包</li>
<li>log：日志文件（记录出错等信息）</li>
<li>temp：临时文件</li>
<li>webapps：可执行的项目。默认作为存放开发项目的目录</li>
<li>work：存放由jsp翻译成的.java源文件,以及编译的.class字节码文件(jsp -&gt;java -&gt;class)<br>
其他文件</li>
</ol>
<h2><span id="启动tomcat">启动Tomcat</span></h2>
<ol>
<li>
<p>在.<code>D:\java\apache-tomcat-9.0.76\bin</code>目录下，双击<code>startup.bat</code>打开窗口，双击<code>shutdown.bat</code>关闭窗口。</p>
<p>如果点startup.bat窗口的×直接关闭，可能会造成关闭异常</p>
<p><img src="https://pic.imgdb.cn/item/6495aa681ddac507cc34bebf.jpg" alt></p>
</li>
<li>
<p>通过命令行窗口打开。<code>D:\java\apache-tomcat-9.0.76\bin</code>路径下打开命令行窗口，输入命令：<code>startup</code>，出现如下对话框，表明服务启动成功。<code>shutdown</code>关闭</p>
<p><img src="https://pic.imgdb.cn/item/6495ab3a1ddac507cc35f912.jpg" alt></p>
</li>
</ol>
<h2><span id="常见问题">常见问题</span></h2>
<h3><span id="闪退">闪退</span></h3>
<p>环境变量配置不正确</p>
<ol>
<li>JAVA_HOME中的路径不能用分号结尾，如C:\Program Files\Java\jdk1.8.0_121</li>
<li>JAVA_HOME的路径是JDK路径，而不是JRE的路径。</li>
<li>CATALINA_HOME中的路径不能以\结尾。</li>
<li>在环境变量中修改添加变量时，一定要注意分号、空格，是否有多余的字母。</li>
</ol>
<h3><span id="乱码">乱码</span></h3>
<p>打开startup.bat后汉字乱码</p>
<ol>
<li>在D:\java\apache-tomcat-9.0.76\conf下打开logging.properties文件</li>
<li>将java.util.logging.ConsoleHandler.encoding = UTF-8 替换为java.util.logging.ConsoleHandler.encoding = GBK</li>
<li>idea的输出窗口中不会产生乱码，如果输出乱码，参考文章：IDEA 控制台Tomcat Catalina Log 和 Tomcat Localhost Log乱码？</li>
</ol>
<h3><span id="与其他服务的端口号冲突">与其他服务的端口号冲突</span></h3>
<p>tomcat端口号默认8080，如果和其他服务的端口号冲突，则可对端口号进行修改</p>
<ol>
<li>
<p>在<code>D:\java\apache-tomcat-9.0.76\conf</code>下打开server.xml文件，在文件的69行左右，将port=&quot;8080&quot;修改为指定的某一端口号，重新启动。端口号：网络编程-传输层</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="访问tomcat">访问Tomcat</span></h2>
<p>先打开startup.bat，再打开浏览器，在地址栏中输入http://localhost:8080或localhost:8080回车，如果看到Tomcat自带的一个JSP页面，说明JDK和Tomcat已搭建成功。</p>
<h2><span id="常见状态码">常见状态码</span></h2>
<p>200：一切正常<br>
300/301：页面重定向 （跳转）<br>
404：资源不存在<br>
403：权限不足 （如果访问a目录，但是a目录设置 不可见）<br>
500：服务器内部错误（代码有误）<br>
其他编码：积累</p>
<h2><span id="卸载tomcat">卸载Tomcat</span></h2>
<p>直接删除Tomcat目录，并删除已配置的环境变量</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>ajax</title>
    <url>/post/ajax/</url>
    <content><![CDATA[<h2><span id="导入jqueryminjs">导入jquery.min.js</span></h2>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;static/js/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="jquery的ajax函数">jQuery的ajax函数</span></h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;路径&quot;</span>,</span><br><span class="line">	<span class="attr">type</span>: <span class="string">&quot;请求方式&quot;</span>, <span class="comment">//默认是get</span></span><br><span class="line">	<span class="attr">data</span>: <span class="string">&quot;name1=value1&amp;name2=value2&quot;</span> 或者 js对象&#123;<span class="attr">name1</span>: value1, <span class="attr">name2</span>: value2&#125;,</span><br><span class="line">  	<span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>, <span class="comment">// 可以省略不写！默认根据响应头&quot;content-type&quot;来动态决定</span></span><br><span class="line">	<span class="comment">// 成功，data就是返回来的数据</span></span><br><span class="line">	<span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="ajax的语法糖">ajax的语法糖</span></h2>
<p>语法不同，代码简化，效果相同，底层还是$.ajax，只能指定4个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">post</span>(url, [data], [fn], [dataType]);</span><br><span class="line">$.<span class="title function_">get</span>(url, [data], [fn], [dataType]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>ajax请求</title>
    <url>/post/ajax%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/DictionaryValue/getAll.action&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">beforeSend</span>: <span class="keyword">function</span> (<span class="params">XHR</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求发送了！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data, textStatus, jqXHR</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求发送成功！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&quot;#infoTable tbody&quot;</span>).<span class="title function_">empty</span>();</span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&quot;#infoTable tbody&quot;</span>).<span class="title function_">append</span>(<span class="string">&#x27;                    &lt;tr&gt;\n&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;                        &lt;th&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/th&gt;\n&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;                        &lt;td&gt;183&lt;/td&gt;\n&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;                        &lt;td&gt;John Doe&lt;/td&gt;\n&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;                        &lt;td&gt;AAA&lt;/td&gt;\n&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;                        &lt;td&gt;AAA&lt;/td&gt;\n&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;                        &lt;td&gt;AAA&lt;/td&gt;\n&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;                    &lt;/tr&gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">XHR, textStatus, errorThrown</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求发送失败！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">complete</span>: <span class="keyword">function</span> (<span class="params">XHR, TS</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求发送结束！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>关于配置servlet的url-pattern的问题</title>
    <url>/post/servlet%20url-pattern%E7%9A%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2><span id="servlet-url-pattern的匹配问题">servlet url-pattern的匹配问题</span></h2>
<p>url-pattern 有三种匹配模式，分别是路径匹配、精确匹配、后缀匹配</p>
<h3><span id="精确匹配">精确匹配</span></h3>
<p>url-pattern 中配置的项必须与url完全精确匹配。 代码举例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Kata/detail.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/table<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当在浏览器中输入如下几种url时，都会被匹配到该servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/Kata/detail.html</span><br><span class="line">http://localhost:8080/demo.html</span><br><span class="line">http://localhost:8080/table </span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><code>http://localhost:8080/table/</code> 是非法的url，不会被当作<code>http://localhost:8080/table</code> 识别</li>
<li>另外上述url后面可以跟任意的查询条件，都会被匹配，如 <code>http://localhost:8080/table?hello</code> 这个请求就会被匹配到MyServlet。</li>
</ol>
<h3><span id="路径匹配">路径匹配</span></h3>
<p>以“/”字符开头，并以“/*”结尾的字符串用于路径匹配</p>
<p>代码举例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>路径以/user/开始，后面的路径可以任意。比如下面的url都会被匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/user/users.html </span><br><span class="line">http://localhost:8080/user/admin/addUser.action </span><br></pre></td></tr></table></figure>
<p>/* 为优先级最低的路径匹配，匹配所有请求(所有的后台请求和所有的前端请求)</p>
<h3><span id="后缀匹配">后缀匹配</span></h3>
<p>以“ *. ”开头的字符串被用于后缀匹配</p>
<p>代码举例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则任何扩展名为jsp或action的url请求都会匹配，比如下面的url都会被匹配</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/user/users.jsp </span><br><span class="line">http://localhost:8080/toHome.action</span><br></pre></td></tr></table></figure>
<p>注意：路径和后缀匹配无法同时设置 ,如果设置，启动tomcat服务器会报错</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>user*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="url-pattern的优先级问题">url-pattern的优先级问题</span></h2>
<ol>
<li>当配置了多个Servlet的url-pattern同时匹配同一个请求时，会将请求匹配给优先级高的Servlet</li>
<li>精确匹配&gt;路径匹配（/*）&gt;扩展名匹配&gt;缺省匹配</li>
</ol>
<h2><span id="url-pattern中-和-的区别">url-pattern中 / 和 /* 的区别</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em><em>web.xml中配置dispatcherServlet， /</em> 不能访问jsp而 / 可以访问jsp</em>*</p>
<p>/* 能匹配所有请求 ， / 当所有其他匹配都不合适时匹配</p>
<ol>
<li>
<p>在tomcat/conf/web.xml里 面单独配置了 *.jsp 的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>/*作为路径匹配优先级高于tomcat里的后缀匹配，因此匹配，jsp不再交给tomcat中的JspServlet处理导致jsp文件无法访问</p>
</li>
<li>
<p>/ 是最低优先级的匹配，因此匹配tomcat中的JspServlet</p>
</li>
</ol>
<p><em><em>web.xml中配置dispatcherServlet， /</em> 和 / 都不能访问html</em>*</p>
<ol>
<li>
<p>在tomcat/conf/web.xml里 面单独配置了 / （缺省）的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>/*作为路径匹配优先级高于tomcat里的缺省匹配，因此匹配，jsp不再交给tomcat中的DefaultServlet处理导致无法访问</p>
</li>
<li>
<p>/ 与 tomcat中的DefaultServlet同优先级导致无法访问html</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>/*</th>
<th>/</th>
</tr>
</thead>
<tbody>
<tr>
<td>范围</td>
<td>最广，所有的请求都符合它的要求（jsp、servlet、Controller等）</td>
<td>当所有其他匹配都不合适时匹配</td>
</tr>
<tr>
<td>匹配优先级</td>
<td>它是路径匹配的一种，相对 / 较高</td>
<td>最低，当一个url和所有的 url-pattern 匹配都不合适时匹配</td>
</tr>
</tbody>
</table>
<p><strong>根路径 / 的匹配问题</strong></p>
<p>/ 访问<code>http://localhost:8080/</code>可以自动转发到<code>http://localhost:8080/index.html</code></p>
<p>而/*不能自动转发，只能直接访问<code>http://localhost:8080/index.html</code>（spring容器里面配置了<code>&lt;mvc:default-servlet-handler/&gt;</code>）</p>
<p><code>http://localhost:8080/</code>会被url-pattern为/*的匹配，但他不会被url-pattern为/匹配。</p>
<p>在tomcat中，/默认是属于会被defaultservlet匹配，但是其优先级低于路径匹配，所以当某一个servlet的url-pattern为/*时，/就 会被这个servlet匹配，从而不被defaultservlet匹配。 <code>http://localhost:8080/</code>自动转发到<code>http://localhost:8080/index.html</code>的前提是/必须被defaultservlet匹配。</p>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>html学习</title>
    <url>/post/html%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTML">HTML</a>（HyperText Markup Language，超文本标记语言）是一种用来告知浏览器如何组织页面的<em>标记语言</em>。HTML 可复杂、可简单，一切取决于 web 开发者。</p>
<ul>
<li>语法不严谨</li>
<li>不区分大小写</li>
<li>自动填充没有编写的语法</li>
</ul>
<h2><span id="元素">元素</span></h2>
<ul>
<li><strong>开始标签</strong>（Opening tag）：包含元素的名称（本例为 <em>p</em>），被左、右角括号所包围。开头标签标志着元素开始或开始生效的地方。在这个示例中，它在段落文本的开始之前。</li>
<li><strong>内容</strong>（Content）：元素的内容，本例中就是段落的文本。</li>
<li><strong>结束标签</strong>（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这标志着该元素的结束。没有包含关闭标签是一个常见的初学者错误，它可能会产生奇特的结果。</li>
</ul>
<p>整个元素即指开始标签、内容、结束标签三部分组成的整体。</p>
<h3><span id="嵌套元素">嵌套元素</span></h3>
<p>My cat is <strong>very</strong> grumpy.</p>
<h3><span id="元素分类">元素分类</span></h3>
<ul>
<li>块级元素在页面中以块的形式展现。一个块级元素出现在它前面的内容之后的新行上。任何跟在块级元素后面的内容也会出现在新的行上。块级元素通常是页面上的结构元素。例如，一个块级元素可能代表标题、段落、列表、导航菜单或页脚。一个块级元素不会嵌套在一个内联元素里面，但它可能嵌套在另一个块级元素里面。</li>
<li>内联元素通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行。它通常与文本一起使用，例如，<a>元素创建一个超链接，<strong>等元素创建强调。</strong></a></li>
</ul>
<p><em>第一</em><em>第二</em><em>第三</em></p>
<p>第四</p><p>第五</p><p>第六</p>
<blockquote>
<p>在这篇文章中提到的“块”和“内联”，不应该与 CSS 盒子的类型中的同名术语相混淆。尽管它们默认是相关的，但改变 CSS 显示类型并不会改变元素的分类，也不会影响它可以包含和被包含于哪些元素。防止这种混淆也是 HTML5 摒弃这些术语的原因之一。</p>
</blockquote>
<h3><span id="空元素">空元素</span></h3>
<img src="https://roy-tian.github.io/learning-area/extras/getting-started-web/beginner-html-site/images/firefox-icon.png" alt="Firefox 图标">
<h2><span id="属性">属性</span></h2>
<p>属性包含元素的额外信息，这些信息不会出现在实际的内容中。</p>
<p>属性必须包含：</p>
<ul>
<li>一个空格，它在属性和元素名称之间。如果一个元素具有多个属性，则每个属性之间必须由空格分隔。</li>
<li>属性名称，后面跟着一个等于号。</li>
<li>一个属性值，由一对引号（“”）引起来。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mozilla.org/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;The Mozilla homepage&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>mozila<span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>href：声明超链接的 web 地址</li>
<li>title：超链接声明额外的信息，当鼠标悬停在超链接上面时，这部分信息将以工具提示的形式显示。</li>
<li>target：指定链接如何呈现出来。例如，<code>target=&quot;_blank&quot;</code> 将在新标签页中显示链接。如果你希望在当前标签页显示链接，忽略这个属性即可。</li>
</ul>
<h3><span id="布尔属性">布尔属性</span></h3>
<p>有时你会看到没有值的属性，这也是完全可以接受的。这些属性被称为布尔属性。布尔属性只能有一个值，这个值一般与属性名称相同。例如，考虑 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input#attr-disabled"><code>disabled</code></a> 属性，你可以将其分配给表单输入元素。用它来禁用表单输入元素，这样用户就不能输入了。被禁用的元素通常有一个灰色的外观。示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 disabled 属性来防止终端用户输入文本到输入框中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面这个输入框不包含 disabled 属性，所以用户可以向其中输入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="属性引号">属性引号</span></h3>
<ul>
<li>
<p>建议不省略包围属性的引号</p>
</li>
<li>
<p>可以使用单引号或双引号，但不能在一个属性值里混用</p>
</li>
<li>
<p>可以在一种引号中嵌套另一种引号，若想在引号中嵌套同种引号，必须使用 HTML 实体引用 ：' (&amp;apos;)</p>
</li>
<li>
<p>连续多个空格最多显示一个，也需要使用实体引用 </p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/XML%E4%B8%8EHTML%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8#HTML%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8">XML与HTML字符实体引用列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://www.example.com&#x27;</span> <span class="attr">title</span>=<span class="string">&#x27;Isn<span class="symbol">&amp;apos;</span>t this fun?&#x27;</span>&gt;</span>示例站点链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2><span id="html文档">HTML文档</span></h2>
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <title>我的测试站点</title>
  </head>
  <body>
    <h1><span id="经典回忆">经典回忆</span></h1>
    <p>
     相思无用，惟别而已。别期若有定，千般煎熬又何如？莫道黯然销魂，何处<strong>柳暗花明</strong>？<br>
     ——《<a href="https://zh.wikipedia.org/zh-hans/神鵰俠侶">神雕侠侣</a>》
    </p>
    <img src="https://roy-tian.github.io/learning-area/extras/tools/playable-code/images/sdxl.jfif" alt="《神雕侠侣》作品图片">
    <div>
      <input type="text">
    </div>
	<div>
      <input type="text" disabled>
    </div>
  </body>
</html>
<ol>
<li><code>&lt;!DOCTYPE html&gt;</code>: 声明文档类型。早期的 HTML（大约 1991-1992 年）文档类型声明类似于链接，规定了 HTML 页面必须遵从的良好规则，能自动检测错误和其他有用的东西。文档类型是一个历史遗留问题，需要包含它才能使其他东西正常工作。现在，只需要知道 <code>&lt;!DOCTYPE html&gt;</code> 是html第五个版本的声明</li>
<li><code>&lt;html&gt;&lt;/html&gt;</code>: <html>元素。这个元素包裹了页面中所有的内容，有时被称为根元素。</html></li>
<li><code>&lt;head&gt;&lt;/head&gt;</code>: <head>元素。这个元素是一个容器，它包含了所有你想包含在 HTML 页面中但<strong>不在 HTML 页面中显示</strong>的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述、CSS 样式、字符集声明等等。以后的章节中会学到更多相关的内容。</head></li>
<li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>: <meta>元素。这个元素代表了不能由其他 HTML 元相关元素表示的元数据，比如<base><link><script><style><title>。charset属性将你的文档的字符集设置为 UTF-8，其中包括绝大多数人类书面语言的大多数字符。有了这个设置，页面现在可以处理它可能包含的任何文本内容。没有理由不对它进行设置，它可以帮助避免以后的一些问题。</li>
<li><code>&lt;title&gt;&lt;/title&gt;</code>: <title> 元素。这设置了页面的标题，也就是出现在该页面加载的浏览器标签中的内容。当页面被加入书签时，页面标题也被用来描述该页面。</li>
<li><code>&lt;body&gt;&lt;/body&gt;</code>: <body> 元素。包含了你访问页面时<em>所有</em>显示在页面上的内容，包含文本、图片、视频、游戏、可播放音频轨道等等。</li>
</ol>
<h2 id="格式">格式</h2>
<ul>
<li>无论你在 HTML 元素的内容中使用多少空格（包括一个或多个空白字符或换行），当渲染这些代码的时候，HTML 解释器会将连续出现的空白字符减少为一个单独的空格符。</li>
<li>在我们的HTML中，每个嵌套元素都比它所在的元素多缩进了两个空格。</li>
</ul>
<h2 id="注释">注释</h2>
<!--内容-->
<h2 id="HTML头部">HTML头部</h2>
<p>HTML 头部包含 HTML&lt;head&gt;元素的内容，与&lt;body&gt;元素内容不同，页面在浏览器加载后它的内容不会在浏览器中显示，它的作用是保存页面的一些元数据</p>
<h3 id="添加标题-title">添加标题 title</h3>
<ul>
<li>&lt;h1&gt; 元素在页面加载完毕时显示在页面中，通常只出现一次，为 body 添加顶级标题、用来标记页面内容的标题（故事名称、新闻摘要等等）。</li>
<li>&lt;title&gt;元素是一项元数据，用于表示整个 HTML 文档的标题（而不是文档内容）为head添加标题。</li>
</ul>
<h3 id="元数据-meta">元数据 meta</h3>
<ul>
<li>指定文档字符编码</li>
</ul>
<meta charset="utf-8" />
<ul>
<li>添加作者和描述</li>
</ul>
<p><meta
  name="description"
  content="The MDN Web Docs site
  provides information about Open Web technologies
  including HTML, CSS, and APIs for both Web sites and
  progressive web apps." /></p>
<p><img src="https://pic.imgdb.cn/item/63f6d267f144a01007a898af.jpg" alt=""></p>
<ul>
<li>其他类型</li>
</ul>
<h3 id="应用css和JavaScript">应用css和JavaScript</h3>
<ul>
<li>&lt;link&gt;元素经常位于文档的头部，它有 2 个属性，<code>rel=&quot;stylesheet&quot;</code> 表明这是文档的样式表，而 <code>href</code> 包含了样式表文件的路径：</li>
</ul>
<link rel="stylesheet" href="my-css-file.css" />
<ul>
<li>&lt;script&gt;元素也应当放在文档的头部，并包含 <code>src</code> 属性来指向需要加载的 JavaScript 文件路径，同时最好加上 <code>defer</code> 以告诉浏览器在解析完成 HTML 后再加载 JavaScript。这样可以确保在加载脚本之前浏览器已经解析了所有的 HTML 内容。这样你就不会因为 JavaScript 试图访问页面上不存在的 HTML 元素而产生错误。实际上有很多方法来处理在你的页面上加载 JavaScript，但对于现代浏览器来说，这是最可靠的方法</li>
</ul>
<script src="my-js-file.js" defer></script>
<h2><span id="html文本">HTML文本</span></h2>
<table>
<thead>
<tr>
<th>标签</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>双标签</td>
<td>段落</td>
</tr>
<tr>
<td>title</td>
<td>双标签</td>
<td>标题</td>
</tr>
<tr>
<td>ol（li）</td>
<td>双标签</td>
<td>有序列表</td>
</tr>
<tr>
<td>ul（li）</td>
<td>双标签</td>
<td>无序列表</td>
</tr>
<tr>
<td>strong</td>
<td>双标签</td>
<td>强调</td>
</tr>
<tr>
<td>em</td>
<td>双标签</td>
<td>斜体</td>
</tr>
<tr>
<td>br</td>
<td>单标签</td>
<td>强制换行</td>
</tr>
<tr>
<td>hr</td>
<td>单标签</td>
<td>水平线</td>
</tr>
<tr>
<td>blockquote</td>
<td>双标签</td>
<td>块引用</td>
</tr>
<tr>
<td>cite</td>
<td>双标签</td>
<td>行引用</td>
</tr>
</tbody>
</table>
<h3><span id="列表">列表</span></h3>
<ul>
<li>
<p>有序列表</p>
<ol>
  <li>沿着条路走到头</li>
  <li>右转</li>
  <li>直行穿过第一个十字路口</li>
  <li>在第三个十字路口处左转</li>
  <li>继续走 300 米，学校就在你的右手边</li>
</ol>
</li>
<li>
<p>无序列表</p>
<ul>
  <li>豆浆</li>
  <li>油条</li>
  <li>豆汁</li>
  <li>焦圈</li>
</ul>
</li>
<li>
<p>嵌套列表</p>
<ol>
  <li>先用蛋白一个、盐半茶匙及淀粉两大匙搅拌均匀，调成“腌料”，鸡胸肉切成约一厘米见方的碎丁并用“腌料”搅拌均匀，腌渍半小时。</li>
  <li>用酱油一大匙、淀粉水一大匙、糖半茶匙、盐四分之一茶匙、白醋一茶匙、蒜末半茶匙调拌均匀，调成“综合调味料”。</li>
  <li>鸡丁腌好以后，色拉油下锅烧热，先将鸡丁倒入锅内，用大火快炸半分钟，炸到变色之后，捞出来沥干油汁备用。</li>
  <li>在锅里留下约两大匙油，烧热后将切好的干辣椒下锅，用小火炒香后，再放入花椒粒和葱段一起爆香。随后鸡丁重新下锅，用大火快炒片刻后，再倒入“综合调味料”继续快炒。
    <ul>
      <li>如果你采用正宗川菜做法，最后只需加入花生米，炒拌几下就可以起锅了。</li>
      <li>如果你在北方，可加入黄瓜丁、胡萝卜丁和花生米，翻炒后起锅。</li>
    </ul>
  </li>
</ol>
</li>
</ul>
<h3><span id="强调">强调</span></h3>
<p>This liquid is <strong>highly toxic</strong> —
if you drink it, <b>you may <em>die</em></b>.</p>
<p>仅仅影响表象而且没有语义，被称为<strong>表象元素</strong>（presentational elements）并且不应该再被使用。因为正如我们在之前看到的，语义对无障碍、SEO（搜索引擎优化）等非常重要。</p>
<ul>
<li><code>&lt;b&gt;</code>、<code>&lt;i&gt;</code> 或 <code>&lt;u&gt;</code> 来表达传统上的粗体、斜体或下划线</li>
</ul>
<h3><span id="描述列表">描述列表</span></h3>
<p>目的是标记一组项目及其相关描述，例如术语和定义，或者是问题和答案等。让我们看一组术语和定义的示例：</p>
<p>描述列表使用与其他列表类型不同的闭合标签<dl>；此外，每一项都用 <dt>（description term）元素闭合。每个描述都用<dd>（description definition）元素闭合。</dd></dt></dl></p>
<dl>
  <dt>内心独白</dt>
    <dd>戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。</dd>
  <dt>语言独白</dt>
    <dd>戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。</dd>
  <dt>旁白</dt>
    <dd>戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。</dd>
</dl>
<p>一个术语可以同时有多个描述</p>
<h3><span id="引用">引用</span></h3>
<p><strong>块引用</strong></p>
<p>你应该把它用<blockquote>元素包裹起来表示，并且在cite属性里用 URL 来指向引用的资源。</blockquote></p>
<p>Here is a blockquote:</p>
<blockquote cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote">
  <p>
    The <strong>HTML <code>&lt;blockquote&gt;</code> Element</strong> (or
    <em>HTML Block Quotation Element</em>) indicates that the enclosed text is
    an extended quotation.
  </p>
</blockquote>
<p><strong>行内引用</strong></p>
<q>
<p>The quote element — <code>&lt;q&gt;</code> — is <q cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q">intended
for short quotations that don't require paragraph breaks.</q></p>
<p>
  According to the
  <a href="/en-US/docs/Web/HTML/Element/blockquote">
    <cite>MDN blockquote page</cite></a>:
</p>
<blockquote cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote">
  <p>The <strong>HTML <code>&lt;blockquote&gt;</code> Element</strong> (or <em>HTML Block
  Quotation Element</em>) indicates that the enclosed text is an extended quotation.</p>
</blockquote>
<h3><span id="引文cite">引文cite</span></h3>
<p>The quote element — <code>&lt;q&gt;</code> — is <q cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q">intended
for short quotations that don't require paragraph breaks.</q> — <a href="/en-US/docs/Web/HTML/Element/q">
<cite>MDN q page</cite></a>.</p>
<h3><span id="水平线">水平线</span></h3>
<hr color="red" size="100px" width="700px"> 
<h2><span id="html超链接ltagt">HTML超链接&lt;a&gt;</span></h2>
<h3><span id="属性">属性</span></h3>
<ul>
<li>href：指向链接</li>
<li>title：关于链接的补充信息</li>
</ul>
<h3><span id="url-path">URL、PATH</span></h3>
<ul>
<li>
<p>URL（统一资源定位符）是一个定义了在网络上的位置的一个文本字符串。例如https://www.mozilla.org/zh-CN/`.</p>
</li>
<li>
<p>指向当前： href=“contacts.html”</p>
</li>
<li>
<p>指向子目录：href=&quot;projects/index.html</p>
</li>
<li>
<p>指向上级目录：href=“…/pdfs/project-brief.pdf”</p>
</li>
</ul>
<h3><span id="链接文档特定部分">链接文档特定部分</span></h3>
<h2><span id="邮寄地址">邮寄地址</span></h2>
<p>要提供意见和建议，请将信件邮寄至<a href="contacts.html#Mailing_address">我们的地址</a>。</p>
<ul>
<li>组件设置id</li>
<li>通过href:&quot;URL#id&quot;链接到特定的id</li>
</ul>
<p><strong>绝对 URL</strong>：指向由其在 Web 上的绝对位置定义的位置，包括<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_name">域名</a>。像下面的例子，如果 <code>index.html</code> 页面上传到了 <code>projects</code> 这一个目录。并且 <code>projects</code> 目录位于 web 服务站点的根目录，web 站点的域名为 <code>http://www.example.com</code>，那么这个页面就可以通过 <code>http://www.example.com/projects/index.html</code> 访问（或者通过 <code>http://www.example.com/projects/</code> 来访问，因为在没有指定特定的 URL 的情况下，大多数 web 服务器会默认访问加载 <code>index.html</code> 这类页面）</p>
<p><strong>相对 URL</strong>：指向与你链接的文件相关的位置，更像我们在前面一节中所看到的位置。例如，如果我们想从示例文件链接 <code>http://www.example.com/projects/index.html</code> 转到相同目录下的一个 PDF 文件，URL 就是文件名（例如 <code>project-brief.pdf</code>），没有其他的信息要求。如果 PDF 文件能够在 <code>projects</code> 的子目录 <code>pdfs</code> 中访问到，相对路径就是 <code>pdfs/project-brief.pdf</code>（对应的绝对 URL 是 <code>http://www.example.com/projects/pdfs/project-brief.pdf</code>）</p>
<p>一个相对 URL 将指向不同的位置，这取决于它所在的文件所在的位置</p>
<p><a href="https://www.example.com/large-report.pdf">
  下载销售报告（PDF, 10MB）
</a></p>
<p><a href="https://www.example.com/video-stream/" target="_blank">
  观看视频（将在新标签页中播放，HD 画质）
</a></p>
<p><a href="https://www.example.com/car-game">
  进入汽车游戏（需要 Flash 插件）
</a></p>
<h3><span id="download属性">download属性</span></h3>
<p>当你链接到要下载的资源而不是在浏览器中打开时，你可以使用 download 属性来提供一个默认的保存文件名。下面是一个 Firefox 的 Windows 最新版本下载链接的示例：</p>
<p><a href="https://download.mozilla.org/?product=firefox-latest-ssl&os=win64&lang=zh-CN" download="firefox-latest-64bit-installer.exe"><br>
下载最新的 Firefox 中文版 - Windows（64 位）<br>
</a></p>
</q></li></ol>]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Spring学习</title>
    <url>/post/spring%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2><span id="spring能做什么">Spring能做什么</span></h2>
<ul>
<li>IOC【依赖反转/控制反转】【Inversion of Control】
<ul>
<li>类产生对象的过程交给Spring去管理，不用程序员创建类的对象</li>
<li>把类交给Spring容器</li>
<li>把对象从Spring容器拿出来</li>
<li>依赖Spring容器里面的对象</li>
</ul>
</li>
<li>AOP</li>
</ul>
<h3><span id="传统mapper-service实现">传统Mapper、Service实现</span></h3>
<p>Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mapper实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperImplA</span> <span class="keyword">implements</span> <span class="title class_">StuMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAAAAAAAAAAAAStuMapperImplA is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">	<span class="type">Mapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mapper</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="依赖">依赖</span></h2>
<p><strong>主要依赖context</strong></p>
<ul>
<li>org.springframework:spring-aop:5.3.25</li>
<li>org.springframework:spring-beans:5.3.25</li>
<li>org.springframework:spring-core:5.3.25</li>
<li>org.springframework:spring-expression:5.3.25</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="实战">实战</span></h2>
<h3><span id="xml配置方式">xml配置方式</span></h3>
<p><strong>把类交给Spring容器</strong></p>
<ul>
<li>在resource文件夹下创建spring.xml配置文件</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/63f872e4f144a0100733bdb9.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63f872fff144a0100733e016.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63f8730af144a0100733f069.jpg" alt></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans 						  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--    使用bean标签把需要的类交给Spring--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperImplA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.mapper.MapperImplA&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperImplB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.mapper.MapperImplB&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceImplA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.service.ServiceImplA&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Mapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mapperImplA&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring采用注入手法，让业务的Mapper属性等于引用了Spring容器里面的对象--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--属性必须要求getting,setting--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImplB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.service.ServiceImplB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Mapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mapperImplB&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用bean标签把需要的类交给Spring</li>
<li>Spring采用注入手法，让业务的Mapper属性等于引用了Spring容器里面的对象</li>
<li>此时可以通过修改spring.xml文件来修改mapper注入的实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    Mapper mapper;	<span class="comment">//业务层的mapper不需创建对象，而是作为类的属性，在刚刚的spring.xml文件中注入了mapperImplA</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mapper <span class="title function_">getMapper</span><span class="params">()</span> &#123;	<span class="comment">//实现getting,setting方法</span></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapper</span><span class="params">(Mapper mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplB</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    Mapper mapper;	<span class="comment">//业务层的mapper不需创建对象，而是作为类的属性，在刚刚的spring.xml文件中注入了mapperImplB</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mapper <span class="title function_">getMapper</span><span class="params">()</span> &#123;	<span class="comment">//实现getting,setting方法</span></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapper</span><span class="params">(Mapper mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性必须要求实现getting,setting方法</li>
<li>此时的接口无需创建对象，根据刚刚的spring.xml文件自动指向对应的实现类</li>
</ul>
<p><img src="/post/spring%E5%AD%A6%E4%B9%A0/C:%5CUsers%5Cmomo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230224170715705.png" alt="image-20230224170715705"></p>
<p><strong>获取Spring容器里的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建ClassPathXmlApplicationContext对象，导入spring.xml配置文件</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">classPathXmlApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:spring.xml&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取外部配置文件，用于byName指定接口</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> MyApp.class.getResourceAsStream(<span class="string">&quot;/my.properties&quot;</span>);</span><br><span class="line">properties.load(resourceAsStream);</span><br><span class="line"><span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;dbc.Service&quot;</span>);</span><br><span class="line"><span class="comment">//3.通过getBean方法获取实现类</span></span><br><span class="line"><span class="comment">//Service service = classPathXmlApplicationContext.getBean(Service.class);</span></span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> classPathXmlApplicationContext.getBean(property, Service.class);</span><br><span class="line">service.doing();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>创建ClassPathXmlApplicationContext对象，导入spring.xml配置文件</p>
</li>
<li>
<p>通过getBean方法获取实现类</p>
<blockquote>
<p>getBean方法有两种传参方式：getBean(class&lt;T&gt;)、getBean(String name,class&lt;T&gt;)</p>
<p>对应两种取出对象方式：byType、byName</p>
<p>byType：根据类类型找到实现类，当Service接口有多个实现类，必然报错，只能用于Service接口唯一实现类的情况</p>
<p>byName：根据类类型以及类名查找实现类，适用Service接口有多个实现类，从而达到开闭原则【对修改关闭，对扩展开放】</p>
</blockquote>
</li>
<li>
<p>当Service接口有多个实现类时，可以从外部配置文件获取类名，用于byName指定接口</p>
</li>
<li>
<p>my.properties文件</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dbc.Service</span>=<span class="string">serviceImplA  #此时可以通过修改外部文件来改变Service实现类</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时可以通过修改外部文件来改变Service实现类</li>
</ul>
<h3><span id="注解配置方式">注解配置方式</span></h3>
<p>spring.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans 						  http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>把类交给Spring容器</strong></p>
<ul>
<li>@Component：所有mapper实现类、Service实现类</li>
<li>@Autowired：自动属性注入，即byType方式</li>
<li>@Qualifier：配合@Autowired实现byName</li>
</ul>
<p>注意：</p>
<ul>
<li>
<p>注解方式可以不实现属性的getting,setting方法</p>
</li>
<li>
<p>注解方式不适用HttpServlet的控制子类，因为tomcat会优先于Spring，因此需要整合tomcat</p>
<p><img src="https://pic.imgdb.cn/item/63f8894ef144a0100757b815.jpg" alt></p>
</li>
</ul>
<p>以ServiceImplA为例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;mapperImplA&quot;)</span></span><br><span class="line">    Mapper mapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        mapper.doing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63f8815bf144a010074ab58a.jpg" alt></p>
<p><strong>获取Spring容器里的对象</strong></p>
<p>与xml方式一致</p>
<table>
<thead>
<tr>
<th></th>
<th>xml配置</th>
<th>注解配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mapper有多个实现类</td>
<td>spring.xml中注入</td>
<td>@Autowired配合@Qualifier</td>
</tr>
<tr>
<td>Service有多个实现类</td>
<td>通过外部资源文件，getBean的ByName方式</td>
<td>与xml配置一致</td>
</tr>
</tbody>
</table>
<h3><span id="整合第三方依赖">整合第三方依赖</span></h3>
<p>通过&lt;bean&gt;方式把第三方类放入到|Spring进行管理，并把第三方类的对象取出使用</p>
<p><strong>导入第三方依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-context.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.xml配置文件（原spring.xml）</strong></p>
<p>原mybatis.xml文件会有删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载外部文件jdbc.properties    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> <span class="attr">ignore-resource-not-found</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--JDBC和连接池的管理 数据库连接池配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis的配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--dao接口在哪【接口本身】？数据层的dao接口在哪个包    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--basePackage属性值必须是你的mapper接口目录        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bjpowernode.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis的SqlSessionFactoryBean类交给Spring管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载mybatis mapper接口实现类文件的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载原mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63f88856f144a010075686f7.jpg" alt></p>
<h3><span id="spring环境下的单元测试">Spring环境下的单元测试</span></h3>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-test --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-context.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter-engine --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-jupiter-params --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-params<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-vintage-engine --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit-platform-launcher --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-launcher<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建单元测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:application.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StuServices stuServices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>    <span class="comment">//必须是org.junit.jupiter.api.Test类，绝对不能是org.junit.Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Stu&gt; all = stuServices.getAll();</span><br><span class="line">        <span class="keyword">for</span> (Stu stu : all) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ClassroomMapper classroomMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Classroom&gt; all = classroomMapper.getAll();</span><br><span class="line">        <span class="keyword">for</span> (Classroom classroom : all) &#123;</span><br><span class="line">            System.out.println(classroom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="springmvc整合tomcat">SpringMVC整合tomcat</span></h3>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-context.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-mvc.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描控制器包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.bjpowernode.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打开springMVC注解    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图解析器ViewResolver【目前解析JSP视图】 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  prefix【前缀】指的是视图放在哪个目录     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--WEB-INF为安全目录只有通过控制器的跳转才能访问【req.getRequestDispatcher】        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  suffix【后缀】指的是视图文件的扩展名     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>扫描控制器包</li>
<li>—打开springMVC注解</li>
<li>视图解析器ViewResolver【目前解析JSP视图】</li>
<li>WEB-INF为安全目录只有通过控制器的跳转才能访问【req.getRequestDispatcher】</li>
<li>prefix【前缀】指的是视图放在哪个目录</li>
<li>suffix【后缀】指的是视图文件的扩展名</li>
</ul>
<p><strong>web.xml配置文件</strong></p>
<ul>
<li>tomcat通过tomcat服务启动监听器，来启动Spring</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1——利用tomcat启动监听器，并启动Spring    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局变量设置Spring的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:application.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启Spring【监听器】--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tomcat通过注册Servlet来注册SpringMVC中的DispatcherServlet</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2——springMVC本身是一个Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化springMVC，主要目的是为了加载SpringMVC的配置文件        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务器启动时创建核心处理器实例--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet本身是在第一次请求的时候才会实例化，且只有一个对象【懒汉式（懒加载）（节约内存，但效率低）】--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在tomcat启动的时候直接Servlet实例化对象【饿汉式（耗费内存，但效率高）】--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Spring代劳做了一个字符集过滤器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--3——SpringMVC编写的过滤器，主要过滤编码--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--乱码处理--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC自带的CharacterEncodingFilter过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>控制器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/stu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StuServices stuServices;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;view.action&quot;)</span></span><br><span class="line">    <span class="comment">//使用org.springframework.ui.Model传递参数</span></span><br><span class="line">    <span class="keyword">public</span> String  <span class="title function_">getAll</span><span class="params">(Model model)</span>&#123;<span class="comment">//方法返回值String</span></span><br><span class="line">        ArrayList&lt;Stu&gt; all = stuServices.getAll();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;stus&quot;</span>,all);</span><br><span class="line">        <span class="comment">//1——代表跳转</span></span><br><span class="line">        <span class="comment">//2——return的字符串代表文件名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;stuView&quot;</span>;<span class="comment">//如果返回的字符串要代表重定向，可以使用redirect: return &quot;redirect:/index.html&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="controller注解">@Controller注解</span></h3>
<p>在一个类上添加@Controller注解，表明了这个类是一个控制器类。但想要让这个类成为一个处理请求的处理器光有@Controller注解是不够的，他还需要进一步修炼才能成为一个处理器。</p>
<p>1.在spring容器中创建该类的实例。创建实例的方式有两种：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;test.controller.MyController&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述这种方式是在spring容器中注入单个bean，当项目比较大，控制器类比较多时，用这种方式向Spring容器中注入bean非常的让人苦恼，索性有第二种方式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-scan</span>=<span class="string">&quot;test.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式会扫描指定包中的所有类，并生成相应的bean注入到spring容器中。使用这种方式当然能够极大提高我们的开发效率，但是有时候我们不想某一类型的类注入到spring容器中。这个时候第二种方式也可以解决。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;test&quot;</span>&gt;</span>　　</span><br><span class="line">	<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码表示扫描test包中除有@Service注解之外的类。</p>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>static、final关键字、代码块</title>
    <url>/post/static%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<h1><span id="static">static</span></h1>
<h2><span id="修饰属性">修饰属性</span></h2>
<p>static修饰的属性称为：静态变量、全局变量、静态属性、全局属性、类变量、类属性，非static修饰的属性可称为实例变量</p>
<span id="more"></span>
<ul>
<li>静态属性随类的加载而加载，先于对象存在</li>
<li>静态属性仅存放JVM方法区的静态域中，所有对象共享</li>
</ul>
<p>静态属性常用于所有对象属性值唯一的属性，即属性值与对象无关</p>
<p><img src="https://pic.imgdb.cn/item/63a97c1608b6830163f144a1.png" alt></p>
<h2><span id="修饰方法">修饰方法</span></h2>
<p>static修饰的方法称为：静态方法，非static修饰的方法可称为实例方法</p>
<ul>
<li>静态方法随着类的加载而加载，先于对象存在</li>
<li>静态方法常通过 类名.方法名 调用</li>
<li>静态方法无法访问非静态属性、非静态方法，他们需要实例才可以访问</li>
<li>实例方法既可以访问静态属性、静态方法，也可以访问非静态属性、非静态方法</li>
</ul>
<p>静态方法常用于</p>
<p>1.工具类（直接使用  类名.方法名 调用，Math.random() ）</p>
<p>2.处理静态属性的方法</p>
<p><strong>main()方法</strong>也是静态方法，在main()方法中不能直接访问该类中的非静态成员，需要创建实例对象，通过实例对象访问该类中的非静态成员</p>
<p>main()方法中的关键字</p>
<ul>
<li>Java虚拟机需要访问main()方法，访问权限使用public</li>
<li>main()方法无需创建实例对象，使用static</li>
<li>接收个String类型的数组参数，可通过java指令传参   <strong>java 类名  “XXX” “XXX” “XXX”</strong></li>
</ul>
<h2><span id="修饰代码块">修饰代码块</span></h2>
<p>static修饰的代码块，当类被载入时，静态代码块被执行，且只被执行一次，常用于初始化静态属性</p>
<ul>
<li>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">    System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="静态代码块-静态方法区别">静态代码块 静态方法区别</span></h3>
<table>
<thead>
<tr>
<th>静态代码块</th>
<th>静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>在类加载时自动执行，且只执行一次</td>
<td>在类加载时加载到方法区,其他程序来调用时,无需创建对象,通过类名.方法名执行</td>
</tr>
</tbody>
</table>
<h2><span id="修饰内部类">修饰内部类</span></h2>
<h3><span id="为什么静态方法无法直接访问非静态成员">为什么静态方法无法直接访问非静态成员</span></h3>
<ol>
<li>静态方法在类加载的解析阶段实现了符号引用转换成直接引用，在类加载后就能通过类名.方法名访问</li>
<li>而非静态成员要等到符号引用被使用时（即类加载后的初始化阶段），才会对常量池中指向非静态成员的符号引用进行解析，因为非静态成员可能在运行期间发生改变（变量赋值、方法重写）</li>
<li>在静态方法解析完成时，非静态成员可能仍未开始解析，因此静态方法获取不了非静态成员的直接引用，即无法访问非静态成员</li>
<li>在静态方法中定义非静态成员所属类的实例对象，通过对象可以访问类的非静态成员</li>
</ol>
<h3><span id="为什么非静态成员为什么无法容纳静态成员">为什么非静态成员为什么无法容纳静态成员</span></h3>
<h4><span id="实例方法无法定义静态属性">实例方法无法定义静态属性</span></h4>
<ol>
<li>静态属性是属于类的，在类加载阶段就加载到方法区的静态域中</li>
<li>实例方法等到它被调用时，它的符号引用才被解析，然后被JVM压入方法调用栈</li>
<li>如果实例方法中定义了静态属性，实例方法被调用时才被解析，无法满足其静态变量在类加载阶段就被解析；</li>
<li>而且实例方法中的属性会随着方法压入栈中，而静态变量唯一存放在方法区的静态域中</li>
</ol>
<h4><span id="实例内部类无法访问静态成员属性-静态方法-静态代码块">实例内部类无法访问静态成员（属性、静态方法、静态代码块）</span></h4>
<p>假设实例内部类中定义了静态成员，在类加载时，静态成员就应被初始化，定义了静态成员的实例内部类作为外部类的成员之一，还需要通过外部类实例对象被调用才会被初始化，因此无法实现在类加载时实现实例内部类的静态初始化。(JDK16以后可以)</p>
<p>但是实例内部类中可以定义static、final常量，常量在编译期就是确定的，加载常量不需要加载它所属的实例内部类</p>
<h1><span id="代码块">代码块</span></h1>
<p>代码块只能有static关键字来修饰，其中static修饰的称为静态代码块，否则称为实例代码块，代码块是为了对Java类或对象进行初始化</p>
<table>
<thead>
<tr>
<th>静态代码块</th>
<th>非静态代码块</th>
</tr>
</thead>
<tbody>
<tr>
<td>随着类的加载而加载，仅执行一次</td>
<td>每次创建对象都执行一次，先于构造器执行</td>
</tr>
<tr>
<td>静态代码块先于非静态代码块执行</td>
<td></td>
</tr>
<tr>
<td>静态代码块间顺序执行</td>
<td>非静态代码块间顺序执行</td>
</tr>
<tr>
<td>不可以调用非静态的属性和方法。</td>
<td>既能调用非静态成员，还能调用静态成员</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Order&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    	orderId = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    	orderId = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;<span class="comment">//同级别顺序执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">        System.out.print(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();      <span class="comment">//BCEF</span></span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();      <span class="comment">//BCEF</span></span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Father</span>();   <span class="comment">//BC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ADG************************</span><br><span class="line">BCEF************************</span><br><span class="line">BCEF************************</span><br><span class="line">BC</span><br></pre></td></tr></table></figure>
<h1><span id="final">final</span></h1>
<ol>
<li>使用final修饰的类不能被继承</li>
<li>使用final修饰的方法不能被重写</li>
<li>使用final标记的变量称为常量。名称大写，且只能被赋值一次。</li>
</ol>
<p>final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</p>
<ul>
<li>final修饰基本数据类型的变量，值不能改变</li>
<li>修饰引用型数据类型的变量时，地址不能改变</li>
</ul>
<p>final、static同时修饰的属性为：全局唯一常量</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>super</title>
    <url>/post/super/</url>
    <content><![CDATA[<p>super	超类的</p>
<span id="more"></span>
<h2><span id="子类对象实例化过程">子类对象实例化过程</span></h2>
<ul>
<li>
<p>不断向上查找直至到达顶层父类Object，然后不断向下依次调用父类的构造器进行父特征的初始化</p>
</li>
<li>
<p>整个过程只产生了一个对象</p>
</li>
</ul>
<p>super代表的就是父特征</p>
<h2><span id="使用">使用</span></h2>
<blockquote>
<p>super()</p>
</blockquote>
<p>继承体系中,一定会调用<strong>父类的构造器</strong>初始化父特征，super()是子类构造器默认的第一行</p>
<blockquote>
<p>super.成员</p>
</blockquote>
<p>调用<strong>父类的属性和方法</strong></p>
<h3><span id="调用父类的构造器">调用父类的构造器</span></h3>
<ol>
<li>子类中所有的构造器默认都会访问父类中无参数的构造器（默认有super()）</li>
<li>若父类中没有无参数的构造器，子类构造器必须调用本类或者父类中相应的构造器。即通过this(参数列表)或者super(参数列表)语句，且必须放在构造器的首行</li>
<li>若父类中没有无参数的构造器，且子类构造器中既未显式调用父类或本类的构造器，则编译出错</li>
</ol>
<h3><span id="super大多情况可省略">super（大多情况可省略）</span></h3>
<ul>
<li>当<strong>父类和子类的属性名称相同</strong>，必须使用super.属性指定父类的属性</li>
<li>当<strong>方法重写需要调用父类的同名属性或者方法</strong>的时候,super不能省略</li>
</ul>
<h3><span id="this和super">this和super</span></h3>
<table>
<thead>
<tr>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/post/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>当一个事物的内部，有一个完整、复杂部分不能简单使用属性或者方法来描述时，且该结构只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</p>
<p>在Java中，允许一个类的定义位于另一个类的内部，该类称为内部类，被定义的类称为外部类</p>
<p>内部类一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</p>
<p>内部类的名字不能与包含它的外部类类名相同；</p>
<p>内部类按照声明位置又分为成员内部类和局部内部类</p>
<span id="more"></span>
<h2><span id="成员内部类">成员内部类</span></h2>
<p>成员内部类声明在外部类的成员位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">TestPojo</span> <span class="keyword">implements</span> <span class="title class_">TestInterface</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我正在跑！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testf</span><span class="params">()</span> &#123;<span class="comment">//重写的接口方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;实现接口！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法里面调用内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.testf(); <span class="comment">// 掉用重写接口方法</span></span><br><span class="line">        b.run(); 　<span class="comment">// 调用自己的方法</span></span><br><span class="line">        b.testpojo(); <span class="comment">// 调用继承父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// main 方法测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() ;</span><br><span class="line">        a.test() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义了一个接口 ，方法为testf()</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TestInterface</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testf</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义了一个普通类 方法testpojo()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestPojo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testpojo</span><span class="params">()</span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;我是简单的pojo类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 调用内部类里面的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Textone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>().<span class="keyword">new</span> <span class="title class_">B</span>() ; <span class="comment">//调用类A里面的内部类B</span></span><br><span class="line">        <span class="comment">/** 等同于 下面代码</span></span><br><span class="line"><span class="comment">        * A a = new A() ;</span></span><br><span class="line"><span class="comment">        * A.B b = a.new B() ;</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        b.testf() ; <span class="comment">// 掉用重写接口方法</span></span><br><span class="line">        b.run() ; <span class="comment">// 调用自己的方法</span></span><br><span class="line">        b.testpojo() ; <span class="comment">// 调用继承父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="特点">特点</span></h3>
<h4><span id="作为类的成员">作为类的成员</span></h4>
<table>
<thead>
<tr>
<th>类的成员</th>
<th>成员内部类</th>
</tr>
</thead>
<tbody>
<tr>
<td>可被static、final修饰，abstract可修饰方法</td>
<td>可被static、abstract、final修饰</td>
</tr>
<tr>
<td>可被4种访问权限修饰符修饰</td>
<td>可被(public default protected private) 访问权限修饰符修饰，，类一般只能被public、default修饰</td>
</tr>
<tr>
<td>方法可直接访问类的其他成员(包括private成员)</td>
<td>实例内部类可直接访问外部类的所有成员(包括private成员)；静态内部类只能访问外部类的静态成员(类似静态方法只能访问静态成员)</td>
</tr>
<tr>
<td>存在同名成员则编译报错</td>
<td>实例内部类和外部类有同名成员，可使用<code>外部类名.this.成员名</code> 访问外部类成员；静态内部类和外部静态成员同名，使用<code>类名.静态成员名</code>访问</td>
</tr>
</tbody>
</table>
<h4><span id="作为类">作为类</span></h4>
<table>
<thead>
<tr>
<th>类</th>
<th>成员内部类</th>
</tr>
</thead>
<tbody>
<tr>
<td>类的成员</td>
<td>可定义类的所有成员（属性、方法、构造器、代码块、内部类）</td>
</tr>
<tr>
<td>创建实例对象</td>
<td>构建内部类对象（静态内部类、实例内部类构建方式不同）</td>
</tr>
<tr>
<td>编译生成字节码文件</td>
<td>编译后生成独立字节码文件(<code>外部类名$内部类名.class</code>)（也适用于局部内部类）</td>
</tr>
</tbody>
</table>
<h4><span id="静态内部类和实例内部类">静态内部类和实例内部类</span></h4>
<table>
<thead>
<tr>
<th></th>
<th>静态内部类(有static修饰)</th>
<th>实例内部类(没有static修饰)</th>
</tr>
</thead>
<tbody>
<tr>
<td>构建内部类对象</td>
<td><code>new 外部类名.内部类名()</code></td>
<td><code>new 外部类名().new 内部类名()) </code></td>
</tr>
<tr>
<td>外部类访问内部类成员</td>
<td>静态成员:<code>静态内部类完整类名.静态成员</code>实例成员：先创建静态内部类对象<code>静态内部类对象.实例成员</code></td>
<td>先创建实例内部类对象<code>实例内部类对象.成员</code></td>
</tr>
<tr>
<td>内部类访问外部来成员</td>
<td>只能访问外部类的静态成员(类似静态方法只能访问静态成员)</td>
<td>可直接访问外部类的所有成员(包括private成员)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>实例内部类中不能声明静态成员，只有在外部类或静态内部类中 才可声明static成员</td>
</tr>
</tbody>
</table>
<h4><span id="为什么实例内部类不能声明静态成员">为什么实例内部类不能声明静态成员？</span></h4>
<p>在类加载的时候，static变量就会被初始化，内部类对象在没有外部类这个对象时便生成了，这样这个成员内部类就脱离了外部类的掌控，不需要外部类的对象就可以生成内部类的对象，这与成员内部类的定义就相驳了，因为我们知道成员内部类的对象必须是现有外部类的对象才能创建</p>
<h2><span id="局部内部类">局部内部类</span></h2>
<p>局部内部类声明在外部类的方法内，类似于局部变量，有效范围在方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">// 定义一个方法</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Ne</span>&#123; <span class="comment">// 定义一个方法内部类</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fle</span><span class="params">()</span>&#123; <span class="comment">// 定义方法内部类的方法</span></span><br><span class="line">            	System.out.println(<span class="string">&quot;我正在飞翔！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     	&#125; ;</span><br><span class="line">     	<span class="keyword">new</span> <span class="title class_">Ne</span>().fle() ; <span class="comment">//调用内部类的方法</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PerTest</span>().test() ; <span class="comment">//测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>权限修饰符修饰：不能使用static abstract</p>
</li>
<li>
<p>字节码名称:外部类名$标号内部类名.class</p>
</li>
<li>
<p>局部内部类使用的外部局部变量会自动将该变量识别为final的</p>
</li>
</ul>
<ol>
<li>方法内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化</li>
</ol>
<h4><span id="方法内部类对象不能使用该内部类所在方法的非final局部变量">方法内部类对象不能使用该内部类所在方法的非final局部变量。</span></h4>
<p>因为方法的局部变量位于栈上，只存在于该方法的生命期内。当一个方法结束，其栈结构被删除，局部变量成为历史。但是该方法结束之后，在方法内创建的内部类对象可能仍然存在于堆中！例如，如果对它的引用被传递到其他某些代码，并存储在一个成员变量内。正因为不能保证局部变量的存活期和方法内部类对象的一样长，所以内部类对象不能使用它们。</p>
<h3><span id="匿名内部类匿名抽象类-匿名实现类">匿名内部类(匿名抽象类 匿名实现类)</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)、抽象匿名内部类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">//方法为test</span></span><br><span class="line">        <span class="type">TestA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestA</span>()&#123; <span class="comment">//实现抽象类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//实现抽象类的方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;我正在使用抽象匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        a.run() ; <span class="comment">//调用内部类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbstractClass</span>().test() ; <span class="comment">//测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个抽象类 TestA 抽象方法为run()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestA</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>)、接口匿名内部类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnonymous</span> &#123;</span><br><span class="line">    <span class="type">MyInterface</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>()&#123; <span class="comment">//实现接口</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">//重写MyInterface 接口方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;我正在吃饭！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; ;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ss</span><span class="params">()</span>&#123; <span class="comment">//方法ss</span></span><br><span class="line">        m.eat() ; <span class="comment">//调用重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">TestAnonymous</span>().ss() ; <span class="comment">//测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个接口 方法为 eat</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：匿名内部类可以定义在方法内也可以定义在类的成员中，不管是那种匿名内部类都不能被外部类直接调用</p>
<h3><span id="内部类的作用">内部类的作用</span></h3>
<p>每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。</p>
<h4><span id="内部类如何实现多继承">内部类如何实现多继承</span></h4>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/post/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1><span id="单例模式">单例模式</span></h1>
<p>保证整个系统中一个类只有一个对象的实例，实现这种功能的方式就叫单例模式</p>
<ol>
<li>构造私有: 如果要保证一个类不能多次被实例化，那么我肯定要阻止对象被new 出来，所以需要把 类的所有构造方法私有化。</li>
<li>以静态方法返回实例。 因为外界就不能通过new来获得对象，所以我们要通过提供类的方法来让外界获取对象实例。</li>
<li>确保对象实例只有一个。 只对类进行一次实例化，以后都直接获取第一次实例化的对象。</li>
</ol>
<h2><span id="懒汉模式">懒汉模式</span></h2>
<p>先不创建类的对象实例，等你需要的时候我再创建，线程不安全 节省资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstence</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="饿汉模式">饿汉模式</span></h2>
<p>我先把对象（面包）创建好，等我要用（吃）的直接直接来拿就行了，浪费资源  线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要求</strong></p>
<ul>
<li>掌握五种单例模式的实现方式</li>
<li>理解为何 DCL 实现时要使用 volatile 修饰静态变量</li>
<li>了解 jdk 中用到单例的场景</li>
</ul>
<p><strong>饿汉式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例对象不能重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法抛出异常是防止反射破坏单例</li>
<li><code>readResolve()</code> 是防止反序列化破坏单例</li>
</ul>
<p><strong>枚举饿汉式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举饿汉式能天然防止反射、反序列化破坏单例</li>
</ul>
<p><strong>懒汉式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Singleton3.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步</li>
<li>因此有了下面的双检锁改进</li>
</ul>
<p><strong>双检锁懒汉式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 可见性，有序性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何必须加 volatile：</p>
<ul>
<li><code>INSTANCE = new Singleton4()</code> 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造</li>
<li>如果线程1 先执行了赋值，线程2 执行到第一个 <code>INSTANCE == null</code> 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象</li>
</ul>
<p><strong>内部类懒汉式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton5()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免了双检锁的缺点</li>
</ul>
<p><strong>JDK 中单例的体现</strong></p>
<ul>
<li>Runtime 体现了饿汉式单例</li>
<li>Console 体现了双检锁懒汉式单例</li>
<li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li>
<li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li>
<li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li>
</ul>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>变量</title>
    <url>/post/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>由于变量能够把程序中准备使用的每一段数据都赋给一个简短、易于记忆的名字，因此它们十分有用。变量可以保存程序运行时用户输入的数据、特定运算的结果以及要在窗体上显示的一段数据等。简而言之，变量是用于跟踪几乎所有类型信息的简单工具。</p>
<span id="more"></span>
<h1><span id="数据">数据</span></h1>
<p>字面量即数据</p>
<h2><span id="数据类型">数据类型</span></h2>
<h1><span id="变量">变量</span></h1>
<h2><span id="变量使用">变量使用</span></h2>
<h3><span id="声明变量">声明变量</span></h3>
<p>int var;</p>
<h3><span id="变量的赋值">变量的赋值</span></h3>
<p>var = 10;</p>
<h3><span id="声明和赋值变量">声明和赋值变量</span></h3>
<p>int var = 10; （数据类型，存储范围）</p>
<ul>
<li>Java可以在一行声明多个变量,例如: int a,b,c; long a,b,c=100</li>
<li>局部变量声明后必须赋值才能使用</li>
</ul>
<h3><span id="变量的作用域局部变量">变量的作用域（局部变量）</span></h3>
<p>变量的作用域在前后花括号{}之间，作用域外相当于没有声明过该变量</p>
<p>作用域内只能有一个同名变量</p>
<h2><span id="变量分类">变量分类</span></h2>
<p>变量可按照声明位置、数据类型分类</p>
<h3><span id="按声明位置">按声明位置</span></h3>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量。</li>
<li>二者都有生命周期，但局部变量除形参外，需初始化。</li>
</ul>
<h3><span id="按数据类型">按数据类型</span></h3>
<p>变量的类型必须与数据的类型一致</p>
<img src="https://pic.imgdb.cn/item/639332ffb1fccdcd36247b54.png" alt="数据类型" style="zoom: 67%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>常用文本编辑快捷键</title>
    <url>/post/%E5%B8%B8%E7%94%A8%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>掌握一些最基本的快捷方式，对快速编辑有很好的效果。下面列举一些常用的快捷方式，如下所示：</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ctrl+c</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">ctrl+v</td>
<td style="text-align:center">粘贴</td>
</tr>
<tr>
<td style="text-align:center">ctrl+x</td>
<td style="text-align:center">剪切</td>
</tr>
<tr>
<td style="text-align:center">ctrl+s</td>
<td style="text-align:center">保存</td>
</tr>
<tr>
<td style="text-align:center">ctrl+z</td>
<td style="text-align:center">撤销</td>
</tr>
<tr>
<td style="text-align:center">ctrl+y</td>
<td style="text-align:center">重做</td>
</tr>
<tr>
<td style="text-align:center">ctrl+a</td>
<td style="text-align:center">全选</td>
</tr>
<tr>
<td style="text-align:center">ctrl + f</td>
<td style="text-align:center">查找</td>
</tr>
<tr>
<td style="text-align:center">home 键</td>
<td style="text-align:center">光标回到行首</td>
</tr>
<tr>
<td style="text-align:center">end 键</td>
<td style="text-align:center">光标回到行尾</td>
</tr>
<tr>
<td style="text-align:center">ctrl + home 键</td>
<td style="text-align:center">光标回到文章开始</td>
</tr>
<tr>
<td style="text-align:center">ctrl + end 键</td>
<td style="text-align:center">光标回到文章末尾</td>
</tr>
<tr>
<td style="text-align:center">shift + home 或 end 键</td>
<td style="text-align:center">选中一行</td>
</tr>
<tr>
<td style="text-align:center">ctrl + shift +右箭头或左箭头</td>
<td style="text-align:center">选中一个单词</td>
</tr>
<tr>
<td style="text-align:center">鼠标双击</td>
<td style="text-align:center">选中一个单词</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>基本数据类型与包装类</title>
    <url>/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<p>赋值变量的过程中，不仅需要注意变量类型与数据类型是否一致，还需观察数据大小是否在数据类型的范围中。所以灵活使用数据类型能使我们更好的运用数据，根据数值大小将变量分配在合理的类型范围中，能有效减少存储空间。</p>
<p>针对八种基本数据类型定义相应的引用类型—包装类</p>
<p>首先,Java语言是一个面向对象的语言,但是Java中的基本数据类型却是不面向对象的，为了实现一 切皆对象,将每个基本数据类型设计一个对应的类进行代表，这种方式增强了Java面向对象的性质。</p>
<p>其次，如果仅仅有基本数据类型，那么在实际使用时将存在很多的不便，很多地方都需要使用对象。比如，在集合类中，我们是无法将int 、double等类型放进去的，因为集合的容器要求元素是Object类型。而包装类型的存在使得向集合中传入数值成为可能，包装类的存在弥补了基本数据类型的不足。</p>
<p>此外，包装类还为基本类型添加了属性和方法，丰富了基本类型的操作。如当我们想知道int取值 范围的最小值，我们需要通过运算，如下面所示，但是有了包装类，我们可以直接使Integer.MAX_VALUE即可。</p>
<p>注意:为什么要保留基本数据类型？Java种创建的对象都是存储在堆里的，使用的时候需要通过栈中的引用， 所以常用的基本数据类型，不需要使用new在堆上创建，而是直接在栈内存中存储不创建对象，就会比较高效。</p>
<span id="more"></span>
<h1><span id="基本数据类型">基本数据类型</span></h1>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">占用字节</th>
<th style="text-align:center">表数范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127(-2<sup>7</sup> ~2<sup>7</sup> -1 )</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-32768~32767(-2<sup>15</sup> ~ 2<sup>15</sup>-1 )</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center">约21亿(-2<sup>31</sup> ~ 2<sup>31</sup> -1)</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2<sup>63</sup> ~ 2<sup>63</sup> -1</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">范围大于long(-3.403E38 ~ 3.403E38)</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1.798E308 ~ 1.798E308</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">1</td>
<td style="text-align:center">true,false</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0~65535</td>
</tr>
</tbody>
</table>
<p><strong>byte</strong></p>
<ul>
<li>byte类型占用1个字节（B）即8位（bit），一共可以表示2的八次方个数即256个，其中首位为符号位，因此可以表示最大最小的数分别为：0111 1111(127)、1111 1111(-127)，从-127到127只有255个数，其中还有1000 0000（-0）表示成-128</li>
</ul>
<p><strong>float、double</strong></p>
<ul>
<li>浮点类型不能精确表示数据</li>
<li>浮点类型表数范围大于long类型，3.404*10<sup>38</sup>&gt;8<sup>38</sup>&gt;2<sup>114</sup>&gt;2<sup>63</sup>-1</li>
</ul>
<p><strong>boolean</strong></p>
<p>boolean类型数据不能参与运算，不过Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都 使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。</p>
<p><strong>char</strong></p>
<p>三种表示：</p>
<ol>
<li>
<p>单引号括起的单个字符 ‘a’</p>
</li>
<li>
<p>转义字符： \</p>
<blockquote>
<p>Java中存在一些无法直接表示的特殊字符，如：换行(\n),	Unicode编码(\u4e2d)</p>
</blockquote>
</li>
<li>
<p>直接使用Unicode编码’\u000a’</p>
</li>
</ol>
<p><strong>使用转义字符来表示这些特殊的字符,那么如何输出“\”本身呢？</strong></p>
<ul>
<li>
<p>“\”本身由“\\”表示,同理“\\”由“\\\\”表示，“\u”由“\\u”表示，将“\\”看作一个整体</p>
</li>
<li>
<p>如果出现“\\\”多出一个转义字符无法形成新的整体，则会报错</p>
</li>
</ul>
<h2><span id="基本数据类型的转换">基本数据类型的转换</span></h2>
<ul>
<li>自动转换：表数范围小的数据类型变量转换成表述范围大的数据类型变量（小水杯的水倒入大水桶，水不会溢出）</li>
<li>强制转换：表数范围大的数据类型变量转换成表述范围小的数据类型变量（小水杯中的水可能无法装下大水桶中的水，即发生数据溢出）</li>
</ul>
<h2><span id="字面量的类型">字面量的类型</span></h2>
<ul>
<li>整数
<ol>
<li>默认为int类型</li>
<li>L结尾为long类型，建议大写，小写不好区分</li>
</ol>
</li>
<li>小数
<ol>
<li>默认为double类型</li>
<li>F或f结尾为float类型</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span>; <span class="comment">//int类型</span></span><br><span class="line"><span class="number">3300L</span>; <span class="comment">//long类型</span></span><br><span class="line"><span class="number">123.56f</span>;<span class="comment">//float类型</span></span><br><span class="line"><span class="number">3.14</span>;<span class="comment">//double类型</span></span><br></pre></td></tr></table></figure>
<h2><span id="字面量赋值">字面量赋值</span></h2>
<ol>
<li>
<p>字面量类型必须与变量类型匹配或能自动转换成变量类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1L</span>;	<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字面量大小必须在自身类型表数范围内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> Long.MAX_VALUE;<span class="comment">//9223372036854775807</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">9223372036854775808L</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>特殊地，对于<strong>byte、short、char</strong>，虽然字面量类型不能自动转换成变量类型，但只需要字面量大小在变量类型的表述范围内则合法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>; 	<span class="comment">//字面量使用+运算符会在编译期间直接对值相加</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>为什么在变量赋值中将整数类型的变量赋值给byte、short、char会报错</strong>（变量在它们的表数范围内）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> i;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在编译过程中，如果赋值的是常数，JVM能直接判断是否在表数范围内，确定不会溢出数据后进行强行数据类型转换；</li>
<li>而变量在程序执行过程中可能发生变化，无法直接判断变量中的值是否在表数范围内，从而报错</li>
</ol>
<h2><span id="多种基本数据类型运算">多种基本数据类型运算</span></h2>
<ol>
<li>
<p>JVM会将所有数据类型转换成运算过程中表数范围最大的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">x4</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">x5</span> <span class="operator">=</span> <span class="number">1.0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x3 + x4 + x5 + x6;	<span class="comment">//x1、x2、x3、x4、x5相加，因此至少需要用float类型接收</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>byte、short、charr之间不会相互转换，他们三者在计算时首先转换为int类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">x7</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x7;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>乘除法同样符合上述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1.0</span>*x3;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>难点</strong>(byte、short、char)</p>
<ol>
<li>
<p><code>short s1 = 1;	</code></p>
<p>编译正确：int字面量若在short范围内,则可以再编译时强行转换成short</p>
</li>
<li>
<p><code>short s2 = s1 + 1;	</code></p>
<p>编译错误：即使等式右边结果在short范围内，由于有变量的存在（不确定），也无法在编译时强行转换成short</p>
</li>
<li>
<p><code>s1 = s1 + 1;</code></p>
<p>编译错误：可以将上述代码拆分成两步：</p>
<ol>
<li><code>short result = s + 1;</code></li>
<li><code>short s = result;</code></li>
</ol>
<p>由于赋值中存在变量，即使等式右边结果在short范围内，也无法在编译时强行转换成short，同2</p>
</li>
<li>
<p><code>s1 += 1;</code></p>
<p>编译正确：此时不不等于s1=s1+1，而等于s1=(short)(s1+1)，JVM会自动采用i2s指令，强行转换成short</p>
</li>
</ol>
<h2><span id="总结">总结</span></h2>
<h3><span id="字面量赋值">字面量赋值</span></h3>
<ol>
<li>先观察字面量<strong>类型</strong>，观察是否超过<strong>字面量类型表数范围</strong></li>
<li>字面量为常数且int类型时，被赋值变量类型为<strong>byte、short、char</strong>，字面量大小在byte、short、char的表数范围内，则可以直接赋值</li>
<li>表数范围小的类型可以赋值给表数范围大的类型（自动转换），反之报错</li>
</ol>
<h3><span id="多种类型变量运算">多种类型变量运算</span></h3>
<ol>
<li>byte、short、char三者在计算时首先转换为int类型</li>
<li>观察等号右边的最大表数范围的数据类型是否小于左边变量类型的表数范围</li>
<li>乘除法同样符合上述规则</li>
</ol>
<h1><span id="包装类">包装类</span></h1>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<h2><span id="装箱">装箱</span></h2>
<p>基本数据类型转换为包装类</p>
<ol>
<li>
<p>通过构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Byte</span>(<span class="string">&quot;123&quot;</span>); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过包装类的valueOf()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Interger</span> <span class="variable">t</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK5后出现自动装箱(推荐)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; 	</span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> i; <span class="comment">//Integer = 10;	底层还是通过包装类的valueof（）方法</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="拆箱">拆箱</span></h2>
<p>包装类转换为基本数据类型</p>
<ol>
<li>
<p>调用包装类实例对象的.xxxValue()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> obj.booleanValue(); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK5后出现自动拆箱(推荐)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer;	<span class="comment">//底层还是通过包装类实例的xxxValue（）方法</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="字符串转换成基本数据类型">字符串转换成基本数据类型</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;12&quot;</span>);<span class="comment">//通过包装类的构造器实现：</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.valueOf(<span class="string">&quot;123&quot;</span>);<span class="comment">//通过包装类的valueOf()实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(<span class="string">&quot;12.1&quot;</span>);<span class="comment">//通过包装类的parseXxx(String s)静态方法：</span></span><br></pre></td></tr></table></figure>
<h2><span id="基本数据类型转换成字符串">基本数据类型转换成字符串</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= String.valueOf(<span class="number">2.34f</span>);<span class="comment">//调用字符串重载的valueOf()方法：</span></span><br><span class="line"></span><br><span class="line">String str= <span class="number">5</span> + “”<span class="comment">//使用+做字符串连接</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类</th>
<th>字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本数据类型转换成</td>
<td>\</td>
<td>包装类构造器、包装类.valueOf(X)、自动</td>
<td>包装类.valueOf(X)、字符串拼接</td>
</tr>
<tr>
<td>包装类转换成</td>
<td>包装类实例对象.XXXValue()、自动</td>
<td>\</td>
<td>包装类.toString()</td>
</tr>
<tr>
<td>字符串转换成</td>
<td>包装类构造器、包装类.valueOf(X)、包装类.parseXxx(X)</td>
<td>包装类构造器、包装类.valueOf(X)</td>
<td>\</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63aaec6708b6830163fb2d26.png" alt></p>
<h2><span id="包装类中的缓存机制">包装类中的缓存机制</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//Integer num1 = 10;</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println((num1 == num2) +<span class="string">&quot;\t&quot;</span>+ num1.equals(num2));<span class="comment">//true	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line">System.out.println((num3 == num4) +<span class="string">&quot;\t&quot;</span>+ num3.equals(num4));<span class="comment">//false	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println((num5 == num6) +<span class="string">&quot;\t&quot;</span>+ num5.equals(num6));<span class="comment">//false	true</span></span><br></pre></td></tr></table></figure>
<p>Integer类第一次被使用时，Integer的静态内部类就被加载，加载的时候会创建-128到127的 Integer对象，同时创建一个数组cache来缓存这些对象。</p>
<ul>
<li>当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，不会再新建对象；</li>
<li>当使用new关键字或者使用valueOf()方法创建小于-128大于 127的值对象时，就会创建新对象。</li>
</ul>
<table>
<thead>
<tr>
<th>Character、Byte、Short、Integer、Long</th>
<th>Boolean</th>
<th>Float、Double</th>
</tr>
</thead>
<tbody>
<tr>
<td>有缓存区，且实现方式基本一样，都是-128到127的缓存范围（Character 0-127）</td>
<td>没有缓存区，但在成员变量中就创建了两个相应的对象true、false</td>
<td>没有缓存区，即使在0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</td>
</tr>
</tbody>
</table>
<p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p>
<h2><span id="基本数据类型与包装类区别">基本数据类型与包装类区别</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类（引用数据类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员</td>
<td>\</td>
<td>可调用各种属性及方法</td>
</tr>
<tr>
<td>实例化</td>
<td>不需要实例化</td>
<td>必须实例化后才能使用</td>
</tr>
<tr>
<td>存储方式</td>
<td>直接存储数据值</td>
<td>实际是对象的引用</td>
</tr>
<tr>
<td>默认值</td>
<td>有默认值</td>
<td>默认值是null</td>
</tr>
<tr>
<td>空指针异常</td>
<td>不会发生空指针异常</td>
<td>可能发生空指针异常</td>
</tr>
<tr>
<td>强制转换</td>
<td>可以强制转换为其他类型</td>
<td>不能强制转换为其他类型</td>
</tr>
</tbody>
</table>
<h1><span id="运算规则">运算规则</span></h1>
<ul>
<li>包装类和值类型一起运算，则包装类会拆箱成值类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//比较的是值</span></span><br><span class="line"><span class="comment">//两个值类型比较的是数值</span></span><br><span class="line"><span class="comment">//f1==f2，包装类和值类型进行运算，则包装类会拆箱</span></span><br><span class="line"><span class="type">int</span> g1=<span class="number">1000</span>;</span><br><span class="line">Integer g2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line">System.out.println(g1==g2);</span><br></pre></td></tr></table></figure>
<h1><span id="大数字处理">大数字处理</span></h1>
<p>大数字实际上是采用字符串存储</p>
<ol>
<li>
<p>BigInteger处理整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bigInteger=<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;10000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>);</span><br><span class="line">System.out.println(bigInteger.toString());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>BigDecimal处理小数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bigDecimal1=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000000000000000000000000000000000000000000000000000000000000000000.123&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(BigDecimal b)</td>
<td>加法</td>
</tr>
<tr>
<td>subtract(BigDecimal b)</td>
<td>减法</td>
</tr>
<tr>
<td>multiply(BigDecimal b)</td>
<td>乘法</td>
</tr>
<tr>
<td>divide(BigDecimal b)</td>
<td>除法</td>
</tr>
<tr>
<td>toString(BigDecimal b)</td>
<td>转换成字符串</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h1><span id="数字格式化">数字格式化</span></h1>
<p>DecimalFormat</p>
<ol>
<li>#:表示数字格式，如果有数字则显示，没有则不显示<br>
如果数字少了，则不处理，不会补“0”，也不会补“#”<br>
如果数字多了，就切掉，但只切小数的末尾，整数不能切<br>
同时被切掉的小数位会进行四舍五入处理</li>
<li>0:表示占位符，如果没有该数位则用0表示<br>
如果数字少了，就会补“0”，小数和整数都会补；<br>
如果数字多了，就切掉，但只切小数的末尾，整数不能切；<br>
同时被切掉的小数位会进行四舍五入处理。</li>
<li>.:表示小数点</li>
<li>,:表示钱个格式</li>
<li>其它字符：直接显示</li>
</ol>
<p><strong>格式化人民币</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;￥###,###.00&quot;</span>);</span><br><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> decimalFormat.format(a);</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(format);</span><br></pre></td></tr></table></figure>
<p><strong>格式化操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">123.1512134567</span>;</span><br><span class="line"><span class="comment">// 取整数部分</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi);</span><br><span class="line">System.out.println(<span class="string">&quot;取整数：&quot;</span> + s1);<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取小数点后1位,四舍五入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.0&quot;</span>).format(pi);</span><br><span class="line">System.out.println(s2);<span class="comment">//123.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取小数点后3位，不足部分取0</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.000&quot;</span>).format(pi);</span><br><span class="line">System.out.println(s3);<span class="comment">//123.150</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 百分比</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.0%&quot;</span>).format(pi);</span><br><span class="line">System.out.println(s4);<span class="comment">// 12315.0%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00E0&quot;</span>).format(pi);</span><br><span class="line"></span><br><span class="line">System.out.println(s5);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1234567</span>;</span><br><span class="line"><span class="comment">// 每三位以逗号分开</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,000&quot;</span>).format(d);</span><br><span class="line">System.out.println(s6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//小数点后3位，如果是0则不显示</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.###&quot;</span>).format(<span class="number">123.300</span>);</span><br><span class="line">System.out.println(s7);<span class="comment">//123.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数字也可以格式化</span></span><br><span class="line">BigDecimal bigDecimal1=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000000000000000000000000000000000000000000000000000000000000000000.123&quot;</span>);</span><br><span class="line">BigDecimal bigDecimal2=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">subtract</span> <span class="operator">=</span> bigDecimal1.subtract(bigDecimal2);</span><br><span class="line">System.out.println(subtract.toString());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;￥###,###.00&quot;</span>).format(subtract));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/post/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>当我们使用代码描述主人喂养宠物的场景，首先在这个场景当中应该有“宠物对象” ，宠物对象应该有吃的行为，另外还需要一个“主人对象” ，主人对象应该有一个喂的行为。然而对于不同的宠物，吃的行为也不相同，或许是吃的东西不同，也或许是吃的方式不同，此时每当出现新的宠物时，我们就需要修改对于宠物吃行为的描述，这不符合OCP原则。对于需要更改的“宠物对象”，应当将其“封装”起来，在新的模块中对宠物不同的吃行为进行描述，而无需修改原本“宠物对象”的描述。</p>
<span id="more"></span>
<h1><span id="多态polymorphism">多态(polymorphism)</span></h1>
<p>编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)多态情况</p>
<h2><span id="前提">前提</span></h2>
<p>继承或实现</p>
<p>重写</p>
<h2><span id="现象">现象</span></h2>
<ol>
<li>父类引用类型变量指向多种子类对象(父父new子)</li>
<li>该变量不能再访问子类中新添加的属性和方法（局限）</li>
<li>属性没有多态，即使子类有同名属性，编译期和运行期也访问的是父类的属性，但可以通过子类重写的方法调用子类的属性</li>
<li>子类重写父类的方法，编译期看到的是父类中的方法,运行期执行的是子类重写后的方法(编译期看左边 运行期看右边)</li>
</ol>
<h2><span id="原理">原理</span></h2>
<h3><span id="虚拟方法调用多态情况下">虚拟方法调用(多态情况下)</span></h3>
<p>子类中定义了与父类同名同参数的方法,此时父类的方法称为<strong>虚拟方法</strong>(Virtual Method Invocation)</p>
<ul>
<li>
<p>在编译期，对象还没有创建出出来，只能看到父类的虚拟方法</p>
</li>
<li>
<p>直到运行期,真正的子类对象被创建出来,父类引用变量得到具体的子类对象地址，并动态调用子类重写的该方法。（动态绑定）</p>
</li>
</ul>
<h3><span id="静态绑定与动态绑定">静态绑定与动态绑定</span></h3>
<p>重载，允许存在多个同名不同参数方法。编译器根据方法不同的参数列表，对同名方法的名称做修饰。同名方法就成了不同的方法。 它们的调用地址在编译期就绑定了。因此，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定” ；</p>
<p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或 “动态绑定 ” 。</p>
<h2><span id="作用">作用</span></h2>
<p>提高了代码的通用性、提高软件的扩展性、实现软件设计的解耦</p>
<h2><span id="应用">应用</span></h2>
<p>当方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</p>
<h2><span id="类型转换casting">类型转换(Casting)</span></h2>
<h3><span id="基本数据类型">基本数据类型</span></h3>
<ul>
<li>
<p>自动类型转换：小的数据类型可以自动转换成大的数据类型</p>
</li>
<li>
<p>强制类型转换：可以把大的数据类型强制转换成小的数据类型</p>
</li>
</ul>
<h3><span id="引用数据类型">引用数据类型</span></h3>
<p>对Java对象的强制类型转换称为<strong>造型</strong></p>
<ul>
<li>
<p>向上转型：从子类到父类的类型转换可以自动进行(多态)</p>
</li>
<li>
<p>向下转型：从父类到子类的类型转换必须通过造型(强制类型转换)实现</p>
</li>
<li>
<p>无继承关系的引用类型间的转换是非法的</p>
</li>
</ul>
<p>多态情况下，当我们需要访问子类中新添加的属性和方法时，需要向下转型（强转）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);		<span class="comment">//调用的是子类重写父类的方法	sub_1</span></span><br><span class="line">    <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> (Sub)base;		<span class="comment">//造型</span></span><br><span class="line">    s.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);			<span class="comment">//调用的是子类独有的方法	sub_2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="instanceof-操作符">instanceof 操作符</span></h3>
<p>在造型前可以使用instanceof操作符测试一个对象的类型</p>
<p>x instanceof A：</p>
<ul>
<li>
<p>检验x是否为类A的对象，返回值为boolean型。 x是A类对象返回true，反之返回false</p>
</li>
<li>
<p>如果x属于类A的子类B，返回值也为true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;…&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graduate</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;…&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(Person e)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Person) <span class="comment">// 处理Person类及其子类对象 </span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) <span class="comment">//处理Student类及其子类对象 </span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Graduate) <span class="comment">//处理Graduate类及其子类对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x所属的类与A类对象没有继承关系，则编译错误。</p>
<h2><span id="验证多态是运行时行为">验证：多态是运行时行为</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            animal = <span class="keyword">new</span> <span class="title class_">Cat</span> ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            animal = <span class="keyword">new</span> <span class="title class_">Dog</span> ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    animal.eat();<span class="comment">//运行时才能确定animal引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; animal eat food&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; cat eat fish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog eat bone &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/post/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1><span id="异常">异常</span></h1>
<ul>
<li>java程序运行的时候或编译的时候可能引发异常
<ul>
<li>编译的时候引发的异常会导致无法编译</li>
<li>运行时引发的异常会到导致程序终止</li>
</ul>
</li>
<li>异常在java中也是面向对象的，Java通过API中Throwable类的众多子类描述各种不同的异常。描述了出现在一段编码中的错误条件。当条件生成时，错误将引发异常。</li>
</ul>
<h2><span id="结构">结构</span></h2>
<img src="https://pic.imgdb.cn/item/63bfed14be43e0d30e1d66cd.jpg">
<h3><span id="throwable">Throwable</span></h3>
<p>异常的父类</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>getCause()</td>
<td>返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</td>
</tr>
<tr>
<td>getMessage()</td>
<td>返回异常的消息信息。</td>
</tr>
<tr>
<td>printStackTrace()</td>
<td>对象的堆栈跟踪输出至错误输出流</td>
</tr>
</tbody>
</table>
<h3><span id="exception">Exception</span></h3>
<p>是程序本身可以处理的异常。异常需要捕获和处理，否则无法编译。</p>
<h3><span id="error">Error</span></h3>
<p>错误，是程序无法处理的错误，表示运行应用程序中较严重问题。</p>
<p>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题，JVM一般会选择线程终止。。例如，</p>
<ol>
<li>Java虚拟机运行错误（Virtual MachineError）</li>
<li>JVM不再有继续执行操作所需的内存资源（OutOfMemoryError）。</li>
<li>Java虚拟机运行错误（Virtual MachineError）</li>
<li>类定义错误（NoClassDefFoundError）</li>
</ol>
<p>这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况</p>
<h3><span id="runtimeexception">RuntimeException</span></h3>
<p>Exception的子类，运行时异常，无需要捕获和处理，也能编译，但是运行时发生错误，则程序会终断，因此运行时异常还是需要捕获和处理</p>
<p>通常表示“JVM 常用操作”引发的错误。例如，</p>
<ol>
<li>
<p>若试图使用空值对象引用（NullPointerException）</p>
</li>
<li>
<p>除数为零（ArithmeticException）</p>
</li>
<li>
<p>数组越界（ArrayIndexOutOfBoundException）</p>
<p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
</li>
</ol>
<h2><span id="分类">分类</span></h2>
<p>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</p>
<h3><span id="可查异常">可查异常</span></h3>
<ul>
<li>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常</li>
<li>可查异常在一定程度上可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</li>
<li>Java编译器会检查它，当程序中可能出现这类异常，必须用try-catch语句捕获或throws子句声明抛出，否则编译不会通过</li>
</ul>
<h3><span id="不可查异常">不可查异常</span></h3>
<ol>
<li>包括运行时异常（RuntimeException与其子类）和错误（Error）</li>
<li>编译器不要求强制处置，可以不用try-catch语句捕获、不用throws子句声明抛出，编译可通过</li>
</ol>
<h2><span id="处理异常机制">处理异常机制</span></h2>
<p>在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常</p>
<h3><span id="抛出异常">抛出异常</span></h3>
<p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行</p>
<p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常</p>
<h3><span id="捕获异常">捕获异常</span></h3>
<p>在方法抛出异常之后，运行时系统将转为寻找处理的异常类型与方法抛出的异常类型相符的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
<p>捕捉异常通过try-catch语句或者try-catch-finally语句实现</p>
<p>总结：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>
<h2><span id="try-catch语句">try、catch语句</span></h2>
<ol>
<li>
<p>try括号中为可能发生异常的语句</p>
</li>
<li>
<p>若发生异常，与之匹配的catch括号中的语句将被执行，没发生异常则跳过catch语句</p>
<blockquote>
<p>匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与catch块捕获的异常类型相匹配。</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a = scanner.nextInt();    <span class="comment">//捕获异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">    <span class="comment">//InputMismatchException类型的参数e。InputMismatchException就是try代码块传递给catch代码块的变量类型，e就是变量名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);    <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="try-catch-catch-">try-catch-catch-…</span></h2>
<ul>
<li>多路catch</li>
</ul>
<p>一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</p>
<p>使用多路catch语句时，应尽量把捕获底层类异常的catch子句放在前面，将相对高层的子句放在后面，否则底层子句很可能不执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a = scanner.nextInt();            <span class="comment">//捕获异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);            <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;出现了未知名的错误&quot;</span>);            <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    a[index] = scanner.nextInt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InputMismatchException e) &#123;</span><br><span class="line">    <span class="comment">//打印错误堆栈</span></span><br><span class="line">    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//打印错误消息</span></span><br><span class="line">    <span class="comment">//e.getMessage();</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你输入的下标超标&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">    System.out.println(<span class="string">&quot;不知名错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="try-catch-finally语句">try、catch、finally语句</span></h2>
<p>无论是否发生异常，都会执行finally语句</p>
<ul>
<li>若没发生异常，在try语句执行后执行finally语句</li>
<li>若发生了异常，在catch语句执行后执行finally语句</li>
</ul>
<blockquote>
<p>在以下4种特殊情况下，finally块不会被执行：<br>
1）在finally语句块中发生了异常。<br>
2）在前面的代码中用了System.exit()退出程序。<br>
3）程序所在的线程死亡。<br>
4）关闭CPU。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//捕获异常</span></span><br><span class="line">    a = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</p>
<p>2)当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</p>
<p>3)当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</p>
<h2><span id="try-catch-finally-return">try、catch、finally、return</span></h2>
<p>当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。</p>
<h3><span id="try-catch-finally中都有return">try、catch、finally中都有return</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;        <span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;        <span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MyApp3.fun1();</span><br><span class="line">    System.out.println(i);<span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会将try或catch中的return语句”覆盖“掉，直接执行finally中的return语句，得到返回值</p>
<h3><span id="finally中没有return">finally中没有return</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;        <span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;        <span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MyApp3.fun1();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行finally中的语句后，从try或catch中返回</p>
<h3><span id="finally中没有return但修改了返回值">finally中没有return但修改了返回值</span></h3>
<p>无论是try还是catch里面的return返回规则为：</p>
<ul>
<li>值类型：return会第一次记录值，然后finally，然后再return（finally无法修改return结果）</li>
<li>引用类型：return会第一次记地址，然后finally，然后再return（finally可以修改return结果）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        b=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;<span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        b=<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">        b=<span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MyApp3.fun1();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> Stu <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    Stu stu=<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="number">1000</span>,<span class="string">&quot;hzj1&quot;</span>);</span><br><span class="line">    Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//捕获异常</span></span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;try***********&quot;</span>);</span><br><span class="line">        stu.setId(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//这里先执行return，然后在执行finally,然后再执行return</span></span><br><span class="line">        <span class="comment">//这里return会记录地址（引用类型）</span></span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">        <span class="comment">//处理异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch***********&quot;</span>);</span><br><span class="line">        stu.setId(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally永远会运行&quot;</span>);</span><br><span class="line">        stu.setId(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">i</span> <span class="operator">=</span> MyApp4.fun1();</span><br><span class="line">    System.out.println(i);	<span class="comment">//5000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="throw">throw</span></h2>
<ol>
<li>throw用来抛出一个Throwable类型的异常。程序会在throw语句后立即终止</li>
<li>然后在包含它的所有try块中从里向外寻找含有与其匹配的catch子句的try块</li>
</ol>
<p>可创建异常类的实例对象通过throw语句抛出。该语句的语法格式为：</p>
<blockquote>
<p>throw new EXCEPTIONNAME;</p>
</blockquote>
<ul>
<li>
<p>如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</p>
</li>
<li>
<p>如果所有方法都层层上抛获取的异常，最终JVM会进行处理，打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。</p>
</li>
</ul>
<p>Throws抛出异常的规则：</p>
<ol>
<li>不可查异常即使不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li>
<li>可查异常必须用try-catch语句捕获或用throws子句声明将它抛出，否则会导致编译错误</li>
<li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出</li>
<li>调用方法若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li>
</ol>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>同步与异步</title>
    <url>/post/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>抽象类和接口</title>
    <url>/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象时，这样的类往往被称为抽象类。</p>
<p>抽象类是为了把<strong>相同的但不确定</strong>的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象方法。</p>
<p>当然，随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。父类足够抽象时，以至于它没有具体的实例。</p>
<p>然而，有时必须从几个类中抽象出共同的行为特征，继承它们所有的属性和方法。但是，Java不支持多重继承。这时，使用接口可以达到多重继承的效果。 例如：鼠标、键盘、打印机、扫描 仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须 能…”的思想。继承是一个&quot;是不是&quot;的关系，而接口实现则是 &quot;能不能&quot;的关系。</p>
<span id="more"></span>
<h1><span id="abstract">abstract</span></h1>
<h2><span id="抽象类">抽象类</span></h2>
<p>abstract修饰的类称为抽象类，命名规范:xxxxAbstract  Abstractxxxx  xxxxBase</p>
<ul>
<li>抽象类不能被实例化，抽象类就是用来继承并实现的，但是有构造器</li>
<li>抽象类中可以有抽象方法，供继承类重写，若继承类还是抽象类，可以不重写抽象方法</li>
<li>最多只能继承一个抽象类（单继承）</li>
</ul>
<h2><span id="抽象方法">抽象方法</span></h2>
<p>abstract修饰的方法称为抽象方法</p>
<ul>
<li>抽象方法没有方法体，抽象方法就是供子类重写的（抽象子类不需要重写）</li>
<li>含有抽象方法的类一定是抽象类或接口</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>类</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>不能被继承</td>
<td>不能被重写</td>
</tr>
<tr>
<td>abstract</td>
<td>供子类继承实现</td>
<td>供继承类重写</td>
</tr>
<tr>
<td>static</td>
<td></td>
<td>需要方法体随类加载而加载</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td>对子类不可见</td>
</tr>
</tbody>
</table>
<p>因此，final不能修饰抽象类和抽象方法</p>
<p>static、private不能修饰抽象方法</p>
<h2><span id="匿名抽象类">匿名抽象类</span></h2>
<p>如果抽象类没有实现类，仍然要获取抽象类的实例对象时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>;</span><br><span class="line">    abstrect <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;think&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接构造抽象类对象，需要在<strong>构造函数后面的花括号实现抽象方法</strong>。</p>
<h2><span id="模板方法设计模式templatemethod">模板方法设计模式(TemplateMethod)</span></h2>
<p>当功能内部一部分实现步骤是固定、通用的，一部分实现是不确定的。这时可以把不确定的、易变部分暴露出去， 让子类去实现。 由此定义出功能算法的骨架，子类不改变算法的结构，且无需重复固定的代码，只需要重定义算法的某些特定步骤。</p>
<p>银行的营业厅办理业务需要 以下步骤：</p>
<ol>
<li>取号 2.办业务 3.评价。</li>
</ol>
<p>三个步骤中取号和评价都是 <strong>固定的流程</strong>，每个人要做的 事儿都是一样的。但是办业 务这个步骤根据每个人要办 的事情不同所以需要有<strong>不同的实现</strong>。我们可以将整个办业务这件事儿封装成一个抽象类：取号和评价为模板方法，而办业务为供子类重写的抽象方法。</p>
<h1><span id="接口">接口</span></h1>
<p>interface，特殊的、轻量级的抽象类，接口名称和类名一样 符合标识符的规则和规范(首字母大写)</p>
<h2><span id="接口实现">接口实现</span></h2>
<p>接口不能被实例化，供实现类使用，没有构造器</p>
<p>如果一个类实现了接口，则需要实现接口中所有方法，抽象类则不用</p>
<h3><span id="jdk8前">JDK8前</span></h3>
<p>接口中包含	公共的静态常量、公共的抽象方法</p>
<h3><span id="jdk8后">JDK8后</span></h3>
<h2><span id="接口和类">接口和类</span></h2>
<p>一个类可以实现多个接口</p>
<p>一个接口可以继承多个接口</p>
<table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象级别</td>
<td>抽象类不能被实例化，供继承并实现</td>
<td>接口不能被实例化，供实现类使用，接口抽象级别高于抽象类</td>
</tr>
<tr>
<td>构造器</td>
<td>有构造器</td>
<td>没有构造器</td>
</tr>
<tr>
<td>继承</td>
<td>实现类最多继承一个抽象类</td>
<td>类可实现多个接口，接口可继承多个接口</td>
</tr>
<tr>
<td>成员</td>
<td>除了含有抽象方法，其余和普通类相差不大</td>
<td>只能是公共的静态常量、公共的抽象方法、（静态方法、默认方法为JDK8后）</td>
</tr>
<tr>
<td></td>
<td>继承类必须实现抽象方法，或本身为抽象类</td>
<td>实现类必须实现抽象方法，或本身为抽象类</td>
</tr>
<tr>
<td>没有实现类时</td>
<td>匿名抽象类</td>
<td>匿名实现类对象</td>
</tr>
<tr>
<td>设计模式</td>
<td>模板方法</td>
<td>简单工厂、工厂方法、代理模式</td>
</tr>
<tr>
<td></td>
<td>作为模板</td>
<td>作为标准或某种特性</td>
</tr>
</tbody>
</table>
<p>抽象类、接口都通过对象的多态性产生实例化对象，但由于抽象类单继承的局限，接口使用更为广泛</p>
<h2><span id="匿名实现类对象">匿名实现类对象</span></h2>
<p>如果接口没有实现类，仍要得到接口的实现时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;think&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>排序与查找</title>
    <url>/post/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1><span id="排序">排序</span></h1>
<h2><span id="冒泡排序">冒泡排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>依次比较相邻两个元素的大小，将大的元素放在后面</li>
<li>两两都比较过为一轮排序，每轮排序都会确定一个最大元素的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;		<span class="comment">//n-1趟可决定n-1个元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<ol>
<li>
<p>每轮排序都将确定一个最大元素的位置（最后），在下轮排序中无需再比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>-i; j++) &#123;	<span class="comment">//每执行一轮排序，内层循环可以少执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在一轮排序中，若没有元素交换，则说明元素序列已经有序，可提前结束排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">//检查每轮是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>-i; j++) &#123;	<span class="comment">//每执行一轮排序，内层循环可以少执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!swapped)&#123;		<span class="comment">//没有元素交换，可提前结束排序</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后一次交换索引的右侧都是确定最终位置的元素，下轮排序中无需比较；当最后一次交换索引的位置为0，说明没有交换元素，综合上述进一步优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble1</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                last = j;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="选择排序">选择排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>
<p>将数组分为有序与无序的两个子集，每轮排序中从无序中选择最小的元素放入有序子集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;	<span class="comment">//最小元素插入的位置，最后的位置不用处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;	<span class="comment">//从无序子序列中找到最小的元素</span></span><br><span class="line">            min = a[min] &lt; a[j] ? min : j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>稳定性</strong></p>
</li>
</ol>
<img src="https://pic.imgdb.cn/item/63d72bf9face21e9ef3198f3.jpg" style="zoom:80%;">
<h2><span id="插入排序">插入排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>将数组分为有序与无序两个子集，每轮排序从无序数组中取出第一个元素插入有序子集中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;    <span class="comment">//无序子序列要插入的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;  <span class="comment">//有序子序列最右边的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];  <span class="comment">//要插入元素的值</span></span><br><span class="line">        <span class="keyword">for</span> (;j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= a[j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>大部分情况下，插入都略优于选择</p>
</li>
<li>
<p>有序集合插入的时间复杂度为 $O(n)$</p>
</li>
</ol>
<h2><span id="希尔排序">希尔排序</span></h2>
<p>插入排序适合小数据量，可以先将数组分割，再使用插入排序</p>
<p><strong>算法描述</strong></p>
<ol>
<li>
<p>首先选取一个间隙序列，如 (n/2，n/4 … 1)，n 为数组长度</p>
</li>
<li>
<p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p>
<p>① 少量元素插入排序速度很快</p>
<p>② 让组内值较大的元素更快地移动到后方</p>
</li>
<li>
<p>当间隙逐渐减少，直至为 1 时，即可完成排序</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;	<span class="comment">//设置间隙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gap; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + gap; j &lt; a.length; j += gap) &#123;		<span class="comment">//要插入的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> j - gap;  <span class="comment">//要插入元素下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[j];   <span class="comment">//要插入元素值</span></span><br><span class="line">                <span class="keyword">for</span> (; m &gt;= <span class="number">0</span>; m -= index) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value &gt;= a[m]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        a[m + index] = a[m];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[m + gap] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<ol>
<li>上述代码先将数组按照等间隙分为多个子序列进行排序，因此在不同间隙下分为多个子序列分别进行插入排序</li>
<li>实际上我们可以只关心数组中要插入的单个结点，通过不断减去间隙来计算要插入的有序子序列，而不用先求得多个子序列，再找插入元素以及子序列中的有序部分</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;	<span class="comment">//设置间隙</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; a.length; i++) &#123;<span class="comment">//要插入元素下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];   <span class="comment">//要插入元素的值</span></span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value &gt;= a[j]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        a[j + gap] = a[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + gap] = value;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="快速排序">快速排序</span></h2>
<p><strong>算法描述</strong></p>
<ol>
<li>每一轮排序选择一个基准点（pivot）进行分区
<ol>
<li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li>
<li>当分区完成时，基准点元素的位置就是其最终位置</li>
</ol>
</li>
<li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li>
<li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li>
</ol>
<p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p>
<ol>
<li>
<p>选择最右元素作为基准点元素</p>
<blockquote>
<p>为了不对数组进行删除修改操作，将交换元素调整数组，使基准点左侧均小于基准点，右侧均大于基准点</p>
</blockquote>
</li>
<li>
<p>从左往右遍历元素，逐步确定基准点的最终位置</p>
<blockquote>
<p>最终位置需要和大于基准点的第一个元素交换</p>
</blockquote>
</li>
<li>
<p>当前结点前不存在大于基准点的结点时：</p>
<ol>
<li>
<p>若小于基准点，则最终位置右移，继续向右查找</p>
</li>
<li>
<p>若大于基准点，则暂定最终位置为此处，余下结点前出现了大于基准点的结点</p>
</li>
</ol>
</li>
<li>
<p>当前结点前为大于基准点的结点时：</p>
<ol>
<li>
<p>若大于基准点，则不改变最终位置（大于基准点的第一个元素）</p>
</li>
<li>
<p>若小于基准点，将当前结点与最终位置的结点交换，交换后最终位置右移，重新调整为最终位置左侧均小，右侧均大</p>
</li>
</ol>
</li>
<li>
<p>当遍历到最后的基准点时，与最终位置的结点交换</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partion(a, low, high);  <span class="comment">//获取索引，并调整索引位置</span></span><br><span class="line">    Quick(a, <span class="number">0</span>, index - <span class="number">1</span>);</span><br><span class="line">    Quick(a, index + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">//最右元素作为基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt;= high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= a[high]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">            a[j] = a[index];</span><br><span class="line">            a[index] = temp;</span><br><span class="line">            <span class="keyword">if</span> (j != high) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p>
<ol>
<li>
<p>选择最左元素作为基准点元素</p>
<blockquote>
<p>最终位置为小于基准点的最后一个元素，先j后i</p>
</blockquote>
</li>
<li>
<p>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</p>
</li>
<li>
<p>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</p>
<blockquote>
<p>对于递增有序序列的快排，基准点最终位置在最左不变，i从最左开始</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[low];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> low + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> high;</span><br><span class="line">    <span class="keyword">while</span> (index != j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; index != j &amp;&amp; j &gt; low + <span class="number">1</span>; j--) &#123;    <span class="comment">//最终位置为小于基准点的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; index != j &amp;&amp; index &lt; high; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[index] &gt;= pivot) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">            a[index] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[index] &lt; pivot) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[low];</span><br><span class="line">        a[low] = a[index];</span><br><span class="line">        a[index] = temp;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;     <span class="comment">//当右侧均大时，最终位置即最左</span></span><br><span class="line">        <span class="keyword">return</span> --index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partion2</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[low];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> high;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; index) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; index &amp;&amp; a[j] &gt; pivot) &#123;       <span class="comment">//最终位置为小于基准点的最后一个元素</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; index &amp;&amp; a[index] &lt;= pivot) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">        a[index] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[low];</span><br><span class="line">    a[low] = a[index];</span><br><span class="line">    a[index] = temp;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快排效率</strong></p>
<ol>
<li>
<p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$，平均空间复杂度为$O(log_2⁡n )$，最坏空间复杂度为$O(n)$</p>
<blockquote>
<p>时间复杂度= $O(n*递归层数)$ ：	快排中递归调用Quick方法，每次Quick方法的时间复杂度为$O(n)$</p>
<p>若将每次划分确定最终位置的结点作为根节点，再递归划分他的左右子序列，数组最终会被组织成一颗二叉树</p>
<ol>
<li>二叉树的层数即递归调用的层数</li>
<li>n个结点的二叉树的最小高度为$logn（向下取整） + 1$，最大高度为$n$</li>
</ol>
</blockquote>
</li>
<li>
<p>最好情况与最坏情况</p>
<blockquote>
<p>最坏情况：数组序列为有序递增序列，二叉树所有结点集中在其中一侧，此时二叉树的层数即结点个数</p>
<img src="https://pic.imgdb.cn/item/63d9075be90d1c00980a5c6a.jpg" style="zoom:67%;">
<p>最好情况：数组序列基准点将待排序列均匀划分为左右两个序列，二叉树平衡性最高，递归深度最小</p>
<img src="https://pic.imgdb.cn/item/63d90ae1e90d1c00981351ff.jpg" style="zoom:67%;">
<p>优化思路：选择值大小适中的元素作为基准点</p>
<ol>
<li>随机选取</li>
<li>从头中尾三个位置中选择适中大小的结点</li>
</ol>
</blockquote>
</li>
<li>
<p>不稳定</p>
<p><img src="https://pic.imgdb.cn/item/63d8fff3e90d1c0098f92473.jpg" alt></p>
</li>
</ol>
<p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p>
<ul>
<li>霍尔的移动次数平均来讲比洛穆托少3倍</li>
<li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li>
</ul>
<blockquote>
<p><em><strong>补充代码说明</strong></em></p>
<ul>
<li>day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少</li>
<li>day01.sort.QuickSortHoare 演示了霍尔分区的实现</li>
<li>day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较</li>
</ul>
</blockquote>
<h2><span id="归并排序">归并排序</span></h2>
<h2><span id="基数排序">基数排序</span></h2>
<h2><span id="堆排序">堆排序</span></h2>
<p><strong>稳定排序与不稳定排序</strong></p>
<p>稳定排序：排序后不改变同值元素的顺序</p>
<table>
<thead>
<tr>
<th></th>
<th>冒泡排序</th>
<th>选择排序</th>
<th>插入排序</th>
<th>希尔排序</th>
<th>快速排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>取决于间隙</td>
<td>$O(nlog_2⁡n )$</td>
</tr>
<tr>
<td>适用</td>
<td>有序时交换次数少</td>
<td>无序时交换次数少</td>
<td>小数据量</td>
<td>数组</td>
<td>数据量较大</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定</td>
<td>不稳定</td>
<td>稳定</td>
<td>不稳定</td>
<td>不稳定</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>$O(log_2n)$</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>日期类</title>
    <url>/post/%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    <content><![CDATA[<h2><span id="jdk8日期架构">JDK8日期架构</span></h2>
<ul>
<li>
<p>JDK8日期架构重做，JDK8之前的日期已经废除</p>
<blockquote>
<p>JDK8之前使用的日期框架:java.util.Date日期时间类、java.util.Calendar日历类</p>
<p>DateFormat：本地时间指计算机的操作系统的区域（例如中文版window，则本地时间为北京时间）</p>
<ol>
<li>JDK8整个日期架构的目的让程序员能使用javaAPI直接操作时间，而不需要关心格林威治</li>
</ol>
</blockquote>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/63d8b3feface21e9ef1e33ec.jpg" alt></p>
<p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>
<ul>
<li>本地日期和时间：<code>LocalDateTime</code>（年月日时分秒），<code>LocalDate</code>（年月日），<code>LocalTime</code>（时分秒）</li>
<li>带时区的日期和时间：<code>ZonedDateTime</code></li>
<li>时刻：<code>Instant</code></li>
<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code></li>
<li>时间间隔：<code>Duration</code></li>
<li>时间格式：取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code></li>
</ul>
<h2><span id="存储方式">存储方式</span></h2>
<p><strong>时间戳</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.currentTimeMillis();	<span class="comment">//格林威治1970至今经过的毫秒，以long类型存储</span></span><br></pre></td></tr></table></figure>
<p><strong>常用于计算某段程序的运行时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以简单的利用时间戳之差，计算程序大致运行时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">st</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;<span class="number">1000</span> ; k++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MyApp</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">et</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(et-st);</span><br></pre></td></tr></table></figure>
<h2><span id="本地时间">本地时间</span></h2>
<h3><span id="创建日期对象">创建日期对象</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();  <span class="comment">//2023-01-31T11:27:56.391</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();          	<span class="comment">//2023-01-31</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();          	<span class="comment">//11:27:56.391</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>now()</td>
<td>从默认时区的系统时钟获取当前日期</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>now(Clock clock)</td>
<td>从指定时钟获取当前日期</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>now(ZoneId zone)</td>
<td>从指定时区的系统时钟获取当前日期</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>from(TemporalAccessor temporal)</td>
<td>从指定时间对象中获取日期</td>
</tr>
</tbody>
</table>
<p><strong>自定义日期创建：of</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime=LocalDateTime.of(<span class="number">2023</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">22</span>,<span class="number">32</span>,<span class="number">30</span>);<span class="comment">//自定义日期2023-05-01T22:32:30</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>of(int year, Month month, int dayOfMonth, int hour, int minute)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>of(int year, Month month, int dayOfMonth, int hour, int minute, int second)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>of(int year, int month, int dayOfMonth, int hour, int minute)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>of(int year, int month, int dayOfMonth, int hour, int minute, int second)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>of(LocalDate date, LocalTime time)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>ofInstant(Instant instant, ZoneId zone)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset)</td>
</tr>
</tbody>
</table>
<p><strong>字符串创建日期</strong></p>
<p>严格按照ISO 8601的格式</p>
<blockquote>
<p>日期和时间分隔符是<code>T</code>。标准格式如下：</p>
<ul>
<li>日期：yyyy-MM-dd</li>
<li>时间：HH:mm:ss</li>
<li>带毫秒的时间：HH:mm:ss.SSS</li>
<li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li>
<li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>parse(CharSequence text)</td>
<td>从给定的文本字符串获取日期</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>parse(CharSequence text, DateTimeFormatter formatter)</td>
<td>从给定的格式、文本字符串获取日期</td>
</tr>
</tbody>
</table>
<h3><span id="格式化">格式化</span></h3>
<p><strong>DateTimeFormatter</strong></p>
<blockquote>
<p>因为<code>SimpleDateFormat</code>不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而<code>DateTimeFormatter</code>可以只创建一个实例，到处引用。</p>
</blockquote>
<p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成<code>LocalDateTime</code>，可以使用新的<code>DateTimeFormatter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dtf1=DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf2</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 EE HH:mm&quot;</span>, Locale.US);<span class="comment">//根据字符串、指定的地区创建格式</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> dtf1.format(localDateTime);	<span class="comment">//2022年01月27日 10:10:47 星期四</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format2</span> <span class="operator">=</span> dtf2.format(localDateTime);	<span class="comment">//2022年01月27日 Thu 10:12</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2019年11月30日 15:16:17 星期六&quot;</span>, dtf1);<span class="comment">//自定义格式解析:</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DateTimeFormatter</td>
<td>ofPattern(String pattern)</td>
<td>根据字符串创建格式</td>
</tr>
<tr>
<td>DateTimeFormatter</td>
<td>ofPattern(String pattern, Locale locale)</td>
<td>根据字符串、指定的地区创建格式</td>
</tr>
</tbody>
</table>
<h3><span id="获取部分">获取部分</span></h3>
<p><strong>创建实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>get(TemporalField field): 获取指定字段的int值（推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime.get(ChronoField.YEAR);</span><br><span class="line">localDateTime.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">localDateTime.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">localDateTime.get(ChronoField.DAY_OF_WEEK);</span><br><span class="line">localDateTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">localDateTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">localDateTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>
</li>
<li>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>getYear()</td>
<td>获取年份</td>
</tr>
<tr>
<td>int</td>
<td>getDayOfYear()</td>
<td>获取一年中的第几天。它可以返回从 1 到 365 或 366 (闰年)。</td>
</tr>
<tr>
<td>Month</td>
<td>getMonth()</td>
<td>从这个日期获取一年中的月份</td>
</tr>
<tr>
<td>int</td>
<td>getMonthValue()</td>
<td>获取月份</td>
</tr>
<tr>
<td>int</td>
<td>getDayOfMonth()</td>
<td>获取一个月中的第几号</td>
</tr>
<tr>
<td>DayOfWeek</td>
<td>getDayOfWeek()</td>
<td>获取星期字段</td>
</tr>
<tr>
<td>Chronology</td>
<td>getChronology()</td>
<td>获取该日期格式，例如：ISO</td>
</tr>
<tr>
<td>Long</td>
<td>getLong(TemporalField field)</td>
<td>获取指定字段的值</td>
</tr>
<tr>
<td>Era</td>
<td>getEra()</td>
<td>获取在此日期适用的时代。&quot;CE &quot;从第一年开始，&quot;BCE &quot;从零年开始。</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p><strong>枚举ChronoUnit与枚举ChronoField</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th>ChronoUnit</th>
<th>ChronoField</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现接口</td>
<td>TemporalUnit</td>
<td>TemporalField</td>
</tr>
<tr>
<td>作用</td>
<td>用于计算的日期部分</td>
<td>用于获取日期部分</td>
</tr>
</tbody>
</table>
<p>NANOS（纳秒）、MICROS（微秒）、MILLIS（毫秒）、SECONDS（秒）、MINUTES（分）、HOURS（时）、HALF_DAYS（半天）、DAYS（天）、WEEKS（周）、MONTHS（月）、YEARS（年）、DECADES（十年）、CENTURIES（百年）、MILLENNIA（千年）、ERAS（十亿年，即纪元）、FOREVER（永远）</p>
<h3><span id="加减">加减</span></h3>
<ul>
<li>
<p>月份加减、修改会自动调整日期，即把<code>2019-10-31</code>的月份调整为<code>9</code>时，日期也自动变为<code>30</code>。</p>
</li>
<li>
<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt2</span> <span class="operator">=</span> dt.plusDays(<span class="number">5</span>).minusHours(<span class="number">3</span>);	<span class="comment">// 加5天减3小时:2019-10-31T17:30:59</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dt3</span> <span class="operator">=</span> dt2.minusMonths(<span class="number">1</span>);	<span class="comment">// 减1月:2019-09-30T17:30:59</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>创建实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">DateTimeFormatter dateTimeFormatter=DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss E&quot;</span>);</span><br><span class="line">System.out.println(dateTimeFormatter.format(localDateTime));	<span class="comment">//2023年01月31日 16:13:35 星期二</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>plus(long amountToAdd, TemporalUnit unit):</strong> 通过增加给定的数量返回<code>LocalDate</code>实例。</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime2 = localDateTime2.plus(<span class="number">345</span>, ChronoUnit.SECONDS);<span class="comment">//加345秒之后</span></span><br><span class="line">System.out.println(dateTimeFormatter.format(localDateTime2));	<span class="comment">//2023年01月31日 16:19:20 星期二</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><strong>minus(long amountToSubtract, TemporalUnit unit):</strong> 通过减去给定的数量返回<code>LocalDate</code>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//localDateTime = localDateTime.minusYears(1);	</span></span><br><span class="line">localDateTime=localDateTime.minus(<span class="number">1</span>, ChronoUnit.YEARS);		<span class="comment">//去年的今天</span></span><br><span class="line">System.out.println(dateTimeFormatter.format(localDateTime));<span class="comment">//2022年01月31日 16:13:35 星期一</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>with(TemporalField field, long newValue):</strong> 将指定字段的<code>LocalDate</code>实例返回到一个新值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">localDateTime3 = localDateTime3.with(ChronoField.MONTH_OF_YEAR, <span class="number">3</span>);	<span class="comment">//修改成3月份</span></span><br><span class="line">System.out.println(dateTimeFormatter.format(localDateTime3));<span class="comment">//2022年03月31日 16:13:35 星期四</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>plus</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>plus(long amountToAdd, TemporalUnit unit)</td>
<td>例：plus(15, ChronoUnit.DAYS);</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plus(TemporalAmount amountToAdd)</td>
<td>例：localDateTime.plus(Period.ofDays(14));</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusYears(long years)</td>
<td>添加指定年</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusMonths(long months)</td>
<td>添加指定月</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusWeeks(long weeks)</td>
<td>添加指定周</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusDays(long days)</td>
<td>添加指定天</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusHours(long hours)</td>
<td>添加指定小时</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusMinutes(long minutes)</td>
<td>添加指定分钟</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusSeconds(long seconds)</td>
<td>添加指定秒</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>plusNanos(long nanos)</td>
<td>添加指定纳秒</td>
</tr>
</tbody>
</table>
<p><strong>minus</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>minus(long amountToSubtract, TemporalUnit unit)</td>
<td>例：minus(15, ChronoUnit.DAYS);</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minus(TemporalAmount amountToSubtract)</td>
<td>例：localDateTime.minus(Period.ofDays(14));</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusYears(long years)</td>
<td>删除指定年</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusMonths(long months)</td>
<td>删除指定月</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusWeeks(long weeks)</td>
<td>删除指定周</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusDays(long days)</td>
<td>删除指定天</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusHours(long hours)</td>
<td>删除指定小时</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusMinutes(long minutes)</td>
<td>删除指定分钟</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusSeconds(long seconds)</td>
<td>删除指定秒</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>minusNanos(long nanos)</td>
<td>删除指定纳秒</td>
</tr>
</tbody>
</table>
<p><strong>with</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>with(LocalDate newDate, LocalTime newTime)</td>
<td>根据LocalDate 、LocalTime 修改</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>with(TemporalAdjuster adjuster)</td>
<td>例：localDateTime.with(DayOfWeek.SUNDAY);</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>with(TemporalField field, long newValue)</td>
<td>例：localDateTime.with(ChronoField.YEAR, 2017);</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withYear(int year)</td>
<td>修改为指定年</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withMonth(int month)</td>
<td>修改为指定月</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withDayOfMonth(int dayOfMonth)</td>
<td>修改为一个月中的第几天</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withDayOfYear(int dayOfYear)</td>
<td>修改为一年中的第几天</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withHour(int hour)</td>
<td>修改为指定小时</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withMinute(int minutes)</td>
<td>修改为指定分钟</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withSecond(int seconds)</td>
<td>修改为指定秒</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>withNano(int nanos)</td>
<td>修改为指定纳秒</td>
</tr>
</tbody>
</table>
<p><strong>TemporalAdjusters工具类</strong></p>
<p><code>LocalDateTime</code>的<code>with(TemporalAdjuster adjuster)</code>方法允许我们做更复杂的运算</p>
<p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本月第一天0:00时刻:</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">firstDay</span> <span class="operator">=</span> LocalDate.now().withDayOfMonth(<span class="number">1</span>).atStartOfDay();</span><br><span class="line"><span class="comment">// 本月最后1天:</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lastDay</span> <span class="operator">=</span> LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line"><span class="comment">// 下月第1天:</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextMonthFirstDay</span> <span class="operator">=</span> LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line"><span class="comment">// 本月第1个周一:</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">firstWeekday</span> <span class="operator">=</span> LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TemporalAdjuster</td>
<td>firstDayOfMonth()</td>
<td>本月的第一天</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>lastDayOfMonth()</td>
<td>本月的最后一天</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>firstDayOfNextMonth()</td>
<td>下个月的第一天</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>firstDayOfYear()</td>
<td>本年中的第一天</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>lastDayOfYear()</td>
<td>本年中的最后一天</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>firstDayOfNextYear()</td>
<td>明年的第一天</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>firstInMonth(DayOfWeek dayOfWeek)</td>
<td>本月的第一个星期几</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>lastInMonth(DayOfWeek dayOfWeek)</td>
<td>本月的最后一个星期几</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</td>
<td>本月中的第几个星期几</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>next(DayOfWeek dayOfWeek)</td>
<td>下一个星期几</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>nextOrSame(DayOfWeek dayOfWeek)</td>
<td>本日符合参数返回本日</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>previous(DayOfWeek dayOfWeek)</td>
<td>上一个星期几</td>
</tr>
<tr>
<td>TemporalAdjuster</td>
<td>previousOrSame(DayOfWeek dayOfWeek)</td>
<td>本日符合参数返回本日</td>
</tr>
</tbody>
</table>
<h3><span id="转换">转换</span></h3>
<p><strong>LocalDate 转化为 LocalDateTime</strong></p>
<ol>
<li>
<p>LocalDate实例方法atTime()，结合给定时间返回 LocalDateTime 实例。</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>atTime(int hour, int minute)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>atTime(int hour, int minute, int second)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>atTime(int hour, int minute, int second, int nanoOfSecond)</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>atTime(LocalTime time)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>atStartOfDay()将LocalDate与00:00的时间结合起来，在这个日期的开始创建LocalDateTime实例。</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalDateTime</td>
<td>atStartOfDay()</td>
</tr>
<tr>
<td>ZonedDateTime</td>
<td>atStartOfDay(ZoneId zone)</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3><span id="比较">比较</span></h3>
<p>LocalDate、LocalTime、LocalDateTime</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">target</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(now.isBefore(target));</span><br><span class="line">System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>)));</span><br><span class="line">System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class="string">&quot;08:15:00&quot;</span>)));</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>isAfter(ChronoLocalDateTime other)</td>
<td>检查此日期是否在给定日期之后</td>
</tr>
<tr>
<td>boolean</td>
<td>isBefore(ChronoLocalDateTime  other)</td>
<td>检查此日期是否在给定日期之前</td>
</tr>
<tr>
<td>boolean</td>
<td>isEqual(ChronoLocalDateTime other)</td>
<td>检查此日期是否等于给定日期</td>
</tr>
<tr>
<td>boolean</td>
<td>equals(Object obj)</td>
<td>检查此日期是否等于指定日期</td>
</tr>
<tr>
<td>int</td>
<td>compareTo(ChronoLocalDate other)</td>
<td>将此日期与指定日期进行比较</td>
</tr>
</tbody>
</table>
<h3><span id="检查">检查</span></h3>
<p>LocalDate、LocalTime、LocalDateTime</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>isSupported(TemporalField field)</td>
<td>检查是否支持给定字段。可在从日期获取任何字段之前使用</td>
</tr>
<tr>
<td>boolean</td>
<td>isSupported(TemporalUnit unit)</td>
<td>检查是否支持给定的单位。可在使用加减之前使用</td>
</tr>
<tr>
<td>ValueRange</td>
<td>range(TemporalField field)</td>
<td>返回字段有效值的范围</td>
</tr>
</tbody>
</table>
<p><strong>仅LocalDate有的方法</strong></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>isLeapYear()</td>
<td>检查年份是否为闰年</td>
</tr>
<tr>
<td>int</td>
<td>lengthOfMonth()</td>
<td>返回当前月份的总天数</td>
</tr>
<tr>
<td>int</td>
<td>lengthOfYear()</td>
<td>返回点前年份的总天数</td>
</tr>
</tbody>
</table>
<h3><span id="距离">距离</span></h3>
<p>LocalDateTime、LocalTime</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>long</td>
<td>until(Temporal endExclusive, TemporalUnit unit)</td>
<td>返回指定单位相差的时间量</td>
</tr>
</tbody>
</table>
<p>LocalDate</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Period</td>
<td>until(ChronoLocalDate endDateExclusive)</td>
<td>返回相差的时间量</td>
</tr>
<tr>
<td>long</td>
<td>until(Temporal endExclusive, TemporalUnit unit)</td>
<td>返回指定单位相差的时间量</td>
</tr>
</tbody>
</table>
<p><strong>Period</strong></p>
<p>两个<code>LocalDate</code>之间的差值用<code>Period</code>表示(年月日)</p>
<blockquote>
<p><code>P1M21D</code>，表示1个月21天</p>
</blockquote>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Period</td>
<td>Period.between(LocalDate l1,LocalDate l2)</td>
<td>返回相差的时间量,等同于LocalDate的until</td>
</tr>
</tbody>
</table>
<p><strong>Duration</strong></p>
<p>两个<code>LocalDateTime</code>之间的差值使用<code>Duration</code>表示</p>
<blockquote>
<p><code>PT1235H10M30S</code>，表示1235小时10分钟30秒</p>
</blockquote>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Duration</td>
<td>between(LocalDateTime l1,LocalDateTime l2)</td>
<td>返回相差的时间量</td>
</tr>
</tbody>
</table>
<p><code>Duration</code>和<code>Period</code>的表示方法也符合ISO 8601的格式，它以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。</p>
<h2><span id="时区时间">时区时间</span></h2>
<p><strong>ZoneDateTime</strong></p>
<p>带时区的日期和时间</p>
<h3><span id="创建">创建</span></h3>
<ol>
<li>now()方法获取默认时区下的当前时间</li>
<li>new(ZoneId zone)放方法获取指定时区的当前时间</li>
<li>相当于当前时间添加时区数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zsh</span> <span class="operator">=</span> ZonedDateTime.now(); <span class="comment">// 默认时区	2023-02-02T20:46:25.322+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zny</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>)); </span><br><span class="line">				<span class="comment">// 用指定时区获取当前时间               2023-02-02T07:46:25.323-05:00[America/New_York]</span></span><br></pre></td></tr></table></figure>
<h3><span id="localdatetime转换">LocalDateTime转换</span></h3>
<ol>
<li>LocalDateTime对象的<code>atZone(ZoneId zone)</code>方法</li>
<li>相当于当前时间添加时区数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();		<span class="comment">//2023-02-02T20:52:20.756</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> localDateTime.atZone(ZoneId.systemDefault());</span><br><span class="line"><span class="comment">//2023-02-02T20:52:20.756+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zny</span> <span class="operator">=</span> localDateTime.atZone(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line"><span class="comment">//2023-02-02T20:52:20.756-05:00[America/New_York]</span></span><br></pre></td></tr></table></figure>
<h3><span id="时区转换时区运算">时区转换（时区运算）</span></h3>
<ol>
<li><code>ZonedDateTime</code>对象的<code>withZoneSameInstant(ZoneId zone)</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整</li>
<li>涉及不同时区下的时间转换运算</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以中国时区获取当前时间:2023-02-02T20:59:30.408+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zbj</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line"><span class="comment">// 转换为纽约时间:2023-02-02T07:59:30.408-05:00[America/New_York]</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zny</span> <span class="operator">=</span> zbj.withZoneSameInstant(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3><span id="转换为localdatetime">转换为LocalDateTime</span></h3>
<ol>
<li>ZonedDateTime对象的 <code>atLocalDateTime()</code>方法</li>
<li>直接丢弃时区数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2023-02-02T21:03:03.682+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line"><span class="comment">//2023-02-02T21:03:03.682</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> now.toLocalDateTime();</span><br></pre></td></tr></table></figure>
<p><strong>某航线从北京飞到纽约需要13小时20分钟，根据北京起飞日期和时间计算到达纽约的当地日期和时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title function_">arriveTime</span> <span class="params">(ZonedDateTime flyTime)</span>&#123;</span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">plus</span> <span class="operator">=</span> flyTime.plus(<span class="number">13</span>, ChronoUnit.HOURS).plus(<span class="number">20</span>, ChronoUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> plus.withZoneSameInstant(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="机器时间">机器时间</span></h2>
<p><strong>JDK8以下</strong></p>
<ol>
<li>
<pre><code class="language-java">long l = System.currentTimeMillis();	        //获取当前日期的机器时间【毫秒】
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ~~~java</span><br><span class="line">   Date date = new Date();			//自定义时间java.util.Date[jdk8之前的时间]</span><br><span class="line">   long time = date.getTime();		//获取当前日期的机器时间【毫秒】</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<p><strong>JDK8及以上</strong></p>
<p><strong>Instant</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();		<span class="comment">//获取当前时间戳，相比System.currentTimeMillis()多了更高精度的纳秒</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>LocalDateTime转成时区时间ZonedDateTime再转换成Instant</p>
<blockquote>
<p><code>LocalDateTime</code>无法直接转换成时间戳，因为<code>LocalDateTime</code>没有时区，无法确定某一时刻</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//LocalDateTime转成时区时间ZonedDateTime【需要时区支持】</span></span><br><span class="line"><span class="comment">//ZoneId.systemDefault()获取当前操作系统时区</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.of(localDateTime, ZoneId.systemDefault());</span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> zonedDateTime.toInstant();		<span class="comment">//ZonedDateTime转成成机器时间Instant【需要时区支持】</span></span><br><span class="line">System.out.println(instant.toEpochMilli());		<span class="comment">//秒+毫秒的部分</span></span><br><span class="line">System.out.println(instant.getEpochSecond());		<span class="comment">//秒的部分</span></span><br><span class="line">System.out.println(instant.getNano());		<span class="comment">//纳秒部分</span></span><br></pre></td></tr></table></figure>
<p><strong>Date转换成LocalDateTime</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">dateOld</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();		<span class="comment">//Date创建</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instantNew</span> <span class="operator">=</span> dateOld.toInstant();		<span class="comment">//Date转机器时间Instant</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTimeNew</span> <span class="operator">=</span> instantNew.atZone(ZoneId.systemDefault());		<span class="comment">//机器时间Instant转ZonedDateTime</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTimeNew</span> <span class="operator">=</span> zonedDateTimeNew.toLocalDateTime();		<span class="comment">//ZonedDateTime转LocalDateTime</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>标识符</title>
    <url>/post/%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>标识符是指用来标识某个实体的一个符号，在不同的应用环境下有不同的含义。.在计算机 编程语言 中，标识符是用户编程时使用的名字，用于给变量、 常量 、 函数 、语句块等命名，以建立起名称与使用之间的关系。标识符通常由字母和数字以及其它字符构成。</p>
<span id="more"></span>
<p>Java源程序中，凡是程序员能够自己命名的都是标识符</p>
<h1><span id="标识符规则">标识符规则</span></h1>
<ol>
<li>标识符由26个英文字母、0-9数字、_$字符组成；不能出现#@！￥%&amp;等其它字符</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字、保留字，但可以包含它们，不能是if，可以是wifi</li>
<li>标识符中不能包含空格，不能是HelloWord</li>
</ol>
<p>区分源文件命名：<a href="../Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">源文件名与类名</a></p>
<h1><span id="标识符命名规范">标识符命名规范</span></h1>
<table>
<thead>
<tr>
<th style="text-align:center">标识符</th>
<th style="text-align:center">命名规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">包名</td>
<td style="text-align:center">全部英文字母小写</td>
</tr>
<tr>
<td style="text-align:center">类名、接口名</td>
<td style="text-align:center">每个英文单词首字母大写</td>
</tr>
<tr>
<td style="text-align:center">变量名、方法名</td>
<td style="text-align:center">首个英文单词首字母小写，之后每个单词首字母大写</td>
</tr>
<tr>
<td style="text-align:center">常量名</td>
<td style="text-align:center">全部英文字母大写，单词之间由分隔符隔开</td>
</tr>
</tbody>
</table>
<h1><span id="关键字">关键字</span></h1>
<table>
<thead>
<tr>
<th style="text-align:left">作用</th>
<th style="text-align:left">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">用于定义数据类型的关键字</td>
<td style="text-align:left">class interface enum byte short int long float double char boolean void</td>
</tr>
<tr>
<td style="text-align:left">用于定义流程控制的关键字</td>
<td style="text-align:left">if else switch case default while do for break continue return</td>
</tr>
<tr>
<td style="text-align:left">用于定义访问权限修饰符的关键字</td>
<td style="text-align:left">private protected public</td>
</tr>
<tr>
<td style="text-align:left">用于定义类，函数，变量修饰符的关键字</td>
<td style="text-align:left">abstract final static synchronized</td>
</tr>
<tr>
<td style="text-align:left">用于定义类与类之间关系的关键字</td>
<td style="text-align:left">extends implements</td>
</tr>
<tr>
<td style="text-align:left">用于定义建立实例及引用实例，判断实例的关键字</td>
<td style="text-align:left">new this super instanceof</td>
</tr>
<tr>
<td style="text-align:left">用于异常处理的关键字</td>
<td style="text-align:left">try catch finally throw throws</td>
</tr>
<tr>
<td style="text-align:left">用于包的关键字</td>
<td style="text-align:left">package import</td>
</tr>
<tr>
<td style="text-align:left">其他修饰符关键字</td>
<td style="text-align:left">native strictfp transient volatile assert</td>
</tr>
<tr>
<td style="text-align:left">用于定义数据类型值的字面值</td>
<td style="text-align:left">true false null</td>
</tr>
</tbody>
</table>
<h1><span id="保留字">保留字</span></h1>
<p>现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字</p>
<p>goto，const</p>
<h1><span id="总结">总结</span></h1>
<h2><span id="一个java源文件可以有名称相同大小写不同的两个类吗">一个java源文件可以有名称相同，大小写不同的两个类吗?</span></h2>
<p>Java源文件可以有名称相同，大小写不同的两个类；</p>
<p>因为Java标识符严格区分大小写</p>
<p>不过在编译过程中，由于window系统不区分大小写，windows将前后编译生成的字节码文件视为同一个（即使这两个文件的命名一个是大写，一个是小写），后编译的类产生的字节码文件将替换掉先编译的类产生的字节码文件。</p>
<h2><span id="java可不可以使用中文命名">java可不可以使用中文命名?</span></h2>
<p>可以 因为jdk使用的是unicode编码(全球统一编码),能够识别中文</p>
<h2><span id="java源文件可以不可以数字开头">java源文件可以不可以数字开头?</span></h2>
<p>可以 java源文件不用遵循命名规则（public的类不行）</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>校验注解</title>
    <url>/post/%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2><span id="导入依赖">导入依赖</span></h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bval<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bval-jsr<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用以下注解时，必须在控制层的参数加上@Valid才能生效</p>
<h2><span id="notnull">@NotNull</span></h2>
<ul>
<li>不能为 null，但可以为 empty</li>
<li>一般用在 Integer 类型的基本数据类型的非空校验上，而且被其标注的字段可以使用 @size、@Max、@Min 对字段数值进行大小的控制</li>
<li>一个 BigDecimal 的字段使用字段校验标签应该为 @NotNull</li>
</ul>
<h2><span id="notempty">@NotEmpty</span></h2>
<ul>
<li>不能为 null，且长度必须大于 0</li>
<li>一般用在集合类上或者数组上</li>
</ul>
<h2><span id="notblank">@NotBlank</span></h2>
<ul>
<li>只能作用在接收的 String 类型上，不能为 null，而且调用 trim() 后，长度必须大于 0即：必须有实际字符</li>
</ul>
<h2><span id="size">@Size</span></h2>
<p>一般用在 String 类型上可对字段数值进行最大长度限制的控制</p>
<h2><span id="max-min">@Max @Min</span></h2>
<p>一般用在 Integer 类型上可对字段数值进行大小范围的控制</p>
<table>
<thead>
<tr>
<th></th>
<th>@NotNull</th>
<th>@NotEmpty</th>
<th>@NotBlank</th>
</tr>
</thead>
<tbody>
<tr>
<td>String name = null;</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>String name = “”;</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>String name = &quot; &quot;;</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String name = “Hello World！”;</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
<h2><span id="常用的校验注解">常用的校验注解</span></h2>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>限制只能为null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>限制必须不能为null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>限制必须为true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>限制必须为false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被限制的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被限制的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max,min)</td>
<td>限制字符长度必须在min到max的指定范围内</td>
</tr>
<tr>
<td>@Digits(integer,fraction)</td>
<td>限制必须为一个小数，且整数部分的位数不能超过integer、小数部分的位数不能超过fraction的在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被限制的元素(日期类型)必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被限制的元素(日期类型)必须是一个将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>限制必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Email</td>
<td>被限制的元素值为是电子邮件地址，也可以通过正则表达式和flag指定自定义的email</td>
</tr>
<tr>
<td>@Length</td>
<td>被限制的字符串的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被限制的字符串必须非空(不为null且不为空)</td>
</tr>
<tr>
<td>@Range</td>
<td>被限制的元素必须在合适的范围内</td>
</tr>
<tr>
<td>@JsonFormat</td>
<td>使用 @JsonFormat 注解时，查到的时间可能会比数据库中的时间少八个小时，这是由于时区差引起的，JsonFormat 默认的时区是 Greenwich Time， 默认的是格林威治时间，而我们是在东八区上，所以时间会比实际我们想得到的时间少八个小时。需要在后面加上一个时区:@JsonFormat(pattern=“yyyy-MM-dd”,timezone=“GMT+8”) private Date date;</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第三阶段</category>
      </categories>
  </entry>
  <entry>
    <title>流程控制</title>
    <url>/post/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(b = <span class="literal">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        从键盘分别输入年、月、日，判断这一天是当年的第几天</span></span><br><span class="line"><span class="comment">        注：判断一年是否是闰年的标准：</span></span><br><span class="line"><span class="comment">        1）可以被4整除，但不可被100整除、或</span></span><br><span class="line"><span class="comment">        2）可以被400整除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入月份：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入几号：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">month2</span> <span class="operator">=</span> <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year %<span class="number">100</span> != <span class="number">0</span> ||year % <span class="number">400</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    month2 = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        day += month2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        day += date;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的月份不合法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(day);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>树</title>
    <url>/post/%E6%A0%91/</url>
    <content><![CDATA[<h1><span id="二叉排序树">二叉排序树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>也称二叉查找树，一棵空树，或者是具有下列特性的二叉树:</p>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值</li>
<li>左、右子树也分别是一棵二叉排序树</li>
</ol>
<p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值</p>
<p>对二叉排序树进行中序遍历可以得到一个递增的有序序列</p>
<h2><span id="操作">操作</span></h2>
<h3><span id="二叉树的结构">二叉树的结构</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*二叉树的二叉链表结点结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;	<span class="comment">//结点数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="查找操作">查找操作</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="comment">//如果递归过程中T为空，则查找结果返回NULL；或者查找成功，返回指向该关键字的指针</span></span><br><span class="line">	<span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; T-&gt;data != key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data) T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBSTNode</span><span class="params">(BSTreee T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBSTNode(T-&gt;lchild,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBSTNode(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="插入操作">插入操作</span></h3>
<p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data == key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &gt; key) T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data &lt; key) T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTree b = (BSTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BSTree));</span><br><span class="line">    b-&gt;data = key;</span><br><span class="line">    b-&gt;rchild = b-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T = b;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertBST</span><span class="params">(BSTree T,KeyType key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        BiTree b = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Bitree));</span><br><span class="line">        b-&gt;data = key;</span><br><span class="line">        b-&gt;lchild = b-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = b;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> InsertBST(T-&gt;lchild,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InsertBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="构建操作">构建操作</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    InsertBST(T,a[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3><span id="删除操作">删除操作</span></h3>
<ol>
<li>叶子结点：删除该结点不需要做其他操作；</li>
<li>仅有左或右子树的结点：删除后让被删除结点的直接后继接替它的位置；</li>
<li>左右子树都有的结点：遍历得到被删除结点的直接前驱或者直接后继来接替它的位置，然后再删除</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/63be79c8be43e0d30ec4aff5.jpg" alt></p>
<p>删除Z结点：</p>
<ol>
<li>用左孩子结点代替被删除结点，若该左孩子结点有右子树，则无法满足二叉排序树定义，没有右子树则直接替换，删除该元素</li>
<li>用左孩子的右孩子代替被删除的结点，若该节点有右子树，则无法满足二叉排序树定义</li>
<li>用左孩子的右孩子的右孩子的…右孩子的结点代替删除的结点，该节点没有右子树，代替可满足二叉排序树定义</li>
<li>且该节点有左子树或是叶子结点，删除同上述，由此得到直接前驱的概念</li>
</ol>
<ul>
<li>直接前驱：Z结点左孩子的右孩子的右孩子的…右孩子的结点，直到该节点没有右子树，即左子树中最右下的结点</li>
<li>直接后继：同理，是Z结点右子树中最坐下的结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> *<span class="title function_">DeleteBST</span><span class="params">(BSTNode *p)</span>&#123;</span><br><span class="line">    BSTree q,s;</span><br><span class="line">    <span class="keyword">if</span>(*p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; (*p)-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;   </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;    </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        q = *p;							<span class="comment">//递归更加直观</span></span><br><span class="line">        s = (*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q != *p)&#123;</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="comment">/*s = (*p)-&gt;lchild;</span></span><br><span class="line"><span class="comment">        while(s-&gt;rchild != NULL)&#123;</span></span><br><span class="line"><span class="comment">            s = s-&gt;rchild;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        (*p)-&gt;data = s-&gt;data;</span></span><br><span class="line"><span class="comment">        DeleteBST(s);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="查找效率">查找效率</span></h2>
<p>平均查找长度ASL（Average Search Length）：需要对比关键字的次数</p>
<ol>
<li>
<p>查找成功的ASL</p>
<img src="https://pic.imgdb.cn/item/63be996bbe43e0d30e01cf1e.jpg" style="zoom:50%;">
</li>
<li>
<p>查找失败的ASL</p>
<img src="https://pic.imgdb.cn/item/63be99b9be43e0d30e0272f7.jpg" style="zoom:50%;">
</li>
</ol>
<h2><span id="引申出平衡二叉树">引申出平衡二叉树</span></h2>
<p>二叉排序树的优点明显，插入删除的时间性能比较好。</p>
<p>而对于二叉排序树的查找，其比较次数等于给定值的结点在二叉排序树的层数，即树的高</p>
<p>最好情况：n个结点的二叉树最小高度为 log<sub>2</sub>n（向下取整）+1</p>
<p>最坏情况：每个结点1个分支，树高=节点数=n</p>
<p>也就是说，我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，那么查找的时间复杂也就为O(logn)，近似于折半查找</p>
<h1><span id="平衡二叉树">平衡二叉树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>平衡二叉树(AVL)是一种二叉排序树，其中每一个节点的左子树和右子树的高度差不超过1</p>
<p>结点的平衡因子：二叉树上结点的左子树深度减去右子树深度的值称为平衡因子</p>
<p>平衡二叉树上所有结点的平衡因子只能是-1、0和1</p>
<p>假设n<sub>h</sub>为深度为h的平衡树中含有的最少结点数，n<sub>0</sub>=0，n<sub>1</sub>=1，n<sub>2</sub>= 2 ，平衡二叉树中有n<sub>h</sub> = n<sub>h-1</sub> + n<sub>h-2</sub> +1可证明最大深度和平均查找长度O(long<sub>2</sub>n)</p>
<h2><span id="操作">操作</span></h2>
<h3><span id="平衡二叉树的结构">平衡二叉树的结构</span></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">rchild</span>, *<span class="title">lchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure>
<h3><span id="查找操作">查找操作</span></h3>
<h3><span id="插入操作">插入操作</span></h3>
<p>当我们在二叉排序树中插入(或删除)一个结点时，可能导致其插入路径上的结点不平衡（平衡因子绝对值大于1）</p>
<p>若导致了不平衡，须将最小不平衡子树调整平衡，则其他结点都会恢复平衡</p>
<p>最小不平衡子树：从插入结点王辉找到第一个不平衡结点，以该结点为根的子树</p>
<h4><span id="ll平衡旋转右单旋转">LL平衡旋转(右单旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea349be43e0d30e12a52e.jpg" alt></p>
<p>在结点A的左孩子(L)的左子树(L)上插入了新结点</p>
<p>将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树</p>
<h4><span id="rr平衡旋转左单旋转">RR平衡旋转(左单旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bf666ebe43e0d30e2ce419.jpg" alt="image-20230111195440307"></p>
<p>在结点A的右孩子®的右子树®上插入了新结点</p>
<p>将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树</p>
<h4><span id="lr平衡旋转先左后右双旋转">LR平衡旋转(先左后右双旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea837be43e0d30e1d7d44.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63bea87abe43e0d30e1ddaf3.jpg" alt></p>
<p>在A的左孩子(L)的右子树®上插入新结点</p>
<p>先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置,即进行一次RR平衡旋转(左单旋转），然后再把该C结点向右上旋转提升到A结点的位置,即进行一次LL平衡旋转(右单旋转)</p>
<h4><span id="rl平衡旋转先右后左双旋转">RL平衡旋转(先右后左双旋转)</span></h4>
<p><img src="https://pic.imgdb.cn/item/63bea8b2be43e0d30e1e2b37.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63bea8ddbe43e0d30e1e681a.jpg" alt></p>
<p>在A的右孩子®的左子树(L)上插入新结点</p>
<p>先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置,即进行一次LL平衡旋转(右单旋转)，然后再把该C结点向左上旋转提升到A结点的位置,即进行一次RR平衡旋转(左单旋转)</p>
<p>新结点插入C的左子树还是插入C的右子树不影响旋转过程</p>
<p><img src="https://pic.imgdb.cn/item/63beaaafbe43e0d30e2182c7.jpg" alt></p>
<ul>
<li>插入操作导致的最小不平衡子树（此时插入前平衡）：高度加1，经过调整后最小不平衡子树的高度恢复，从而其祖先结点也恢复</li>
</ul>
<h2><span id="查找效率">查找效率</span></h2>
<ul>
<li>若树高为h，最坏情况下，查找一个关键字最多需要比较h次，即查找操作的时间复杂度不可能超过O(h)</li>
</ul>
<h1><span id="红黑树">红黑树</span></h1>
<h2><span id="定义">定义</span></h2>
<p>红黑树也是二叉排序树，与普通BST相比：左根右，根叶黑 ，不红红，黑路同，左子孙结点值小于根节点值小于右子孙结点值</p>
<ol>
<li>每个结点或是红色，或是黑色的</li>
<li>根节点是黑色的</li>
<li>叶结点（外部结点、NULL结点、失败结点）均是黑色的</li>
<li>不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</li>
<li>对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</li>
</ol>
<ul>
<li>平衡二叉树 AVL：插入/删除 很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不 平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行 LL/RR/LR/RL 调整</li>
<li>红黑树 RBT：插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一 般都可以在常数级时间内完成 平衡二叉树：适用于以查为主、很少插入/删除的场景 红黑树：适用于频繁插入、删除的场景，实用性更强 性能逐渐优秀</li>
</ul>
<h2><span id="红黑树的结构">红黑树的结构</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    RBNode* parent;</span><br><span class="line">    RBNode* lchild;</span><br><span class="line">    RBNode* rchild;</span><br><span class="line">    <span class="type">int</span> color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="性质">性质</span></h2>
<ol>
<li>结点的黑高（bh）：从某结点出发（<strong>不含该节点</strong>）到达任一<strong>空叶结点</strong>的<strong>路径上黑结点总数</strong></li>
<li>从根节点到叶结点的最长路径不大于最短路径的2倍</li>
<li>有n个内部节点的红黑树高度 h ≤ 2log<sub>2</sub>(n+1)</li>
<li>查找效率与AVL 树同等数量级 红黑树查找操作时间复杂度 = O(log<sub>2</sub>n)</li>
</ol>
<h2><span id="操作">操作</span></h2>
<h3><span id="插入操作java">插入操作（java）</span></h3>
<ol>
<li>
<p>先查找，确定插入位置（原理同二叉排序树），插入新结点</p>
</li>
<li>
<p>新结点是根——染为黑色</p>
<img src="https://pic.imgdb.cn/item/63d4df2dface21e9efde7f4d.jpg" style="zoom:67%;">
</li>
<li>
<p>新结点非根——染为红色</p>
<img src="https://pic.imgdb.cn/item/63d4df0aface21e9efde2e14.jpg" style="zoom:67%;">
</li>
<li>
<p>若插入新结点后依然满足红黑树定义，则插入结束，若不满足红黑树定义，则通过叔叔结点的颜色调整</p>
<ol>
<li>
<p>黑叔：旋转+染色</p>
<ol>
<li>
<p>LL型：右单旋，父换爷+染色</p>
<p><img src="https://pic.imgdb.cn/item/63d4df9fface21e9efdf9503.jpg" alt></p>
</li>
<li>
<p>RR型：左单旋，父换爷+染色</p>
</li>
<li>
<p>LR型：左、右双旋，儿换爷+染色</p>
<p><img src="https://pic.imgdb.cn/item/63d4df60face21e9efdeef6c.jpg" alt></p>
</li>
<li>
<p>RL型：右、左双旋，儿换爷+染色</p>
</li>
</ol>
</li>
<li>
<p>红叔：染色+变新</p>
<ol>
<li>
<p>叔父爷染色，爷变为新结点</p>
<p><img src="https://pic.imgdb.cn/item/63d4deedface21e9efdde5f1.jpg" alt></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;	<span class="comment">//获取根结点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;	<span class="comment">//遍历树结点</span></span><br><span class="line">        <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)	<span class="comment">//插入左子树</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)	<span class="comment">//插入右子树</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))	<span class="comment">//键key相等</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));	<span class="comment">//插入平衡</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="构建操作java">构建操作（java）</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;		<span class="comment">//构建红黑树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;	<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;	<span class="comment">//遍历结点数组</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;	<span class="comment">//将结点转换成树结点</span></span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;	<span class="comment">//初始化根节点</span></span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;	<span class="comment">//遍历红黑树，找到结点要插入的位置</span></span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)		<span class="comment">//当前结点的哈希小于树节点的哈希，往左子树中查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)		<span class="comment">//当前结点的哈希大于树节点的哈希，往右子树中查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;		<span class="comment">//当前结点与树结点的哈希相等</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;	<span class="comment">//插入当前结点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);	<span class="comment">//插入后的平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.red = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//xp：父节点	 xpp：爷结点	xppl：爷结点的左孩子	xppr：爷结点的右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;	<span class="comment">//根节点</span></span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)	<span class="comment">//父节点为黑或爷结点为空</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;	<span class="comment">//父节点为左孩子</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;	<span class="comment">//爷结点的右孩子不为空且为红色（叔为红）</span></span><br><span class="line">                xppr.red = <span class="literal">false</span>;	<span class="comment">//叔父爷染色，爷结点作为新结点</span></span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;					<span class="comment">//爷结点的右孩子为空或黑色（叔为黑）</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;	<span class="comment">//lr类型</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);	<span class="comment">//左旋</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;	</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;		<span class="comment">//ll</span></span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);	<span class="comment">//右旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;							<span class="comment">//父节点为右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;		<span class="comment">//爷结点的左孩子不为空且为红色（叔为红）</span></span><br><span class="line">                xppl.red = <span class="literal">false</span>;	<span class="comment">//叔父爷染色，爷结点作为新结点</span></span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;				<span class="comment">//爷结点的左孩子为空或黑色（叔为黑）</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/63d5054aface21e9ef34ef9e.jpg" style="zoom:67%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="comment">//r：p的右结点	rl：p的右结点的左结点</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)	<span class="comment">//处理r的左孩子</span></span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)	<span class="comment">//将p左旋</span></span><br><span class="line">            (root = r).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic.imgdb.cn/item/63d506efface21e9ef38ae81.jpg" style="zoom:67%;">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            (root = l).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除操作java">删除操作（java）</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment"> * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment"> * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment"> * successor that is pinned by &quot;next&quot; pointers that are accessible</span></span><br><span class="line"><span class="comment"> * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment"> * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment"> * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment"> * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="literal">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="literal">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.right == <span class="literal">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="literal">null</span> || rl.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="literal">null</span> &amp;&amp; pr != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="literal">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="literal">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="literal">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="literal">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="literal">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="literal">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="literal">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多</p>
<p><img src="https://pic.imgdb.cn/item/63bf6956be43e0d30e315a52.jpg" alt="不严格平衡的红黑树"></p>
<p>​    <strong>Answer 1：</strong></p>
<ol>
<li>
<p>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</p>
</li>
<li>
<p>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</p>
</li>
<li>
<p>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</p>
</li>
<li>
<p>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多</p>
</li>
<li>
<p>功能、性能、空间开销的折中结果。<br>
AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。<br>
红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。</p>
<p><strong>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</strong></p>
</li>
</ol>
<p>​    <strong>1 好处 及 用途</strong></p>
<p>​    红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。</p>
<p>​    红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。当然，还有一些更好的，但实现起来更复杂的<a href="http://lib.csdn.net/base/datastructure">数据结构</a> 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的<a href="http://lib.csdn.net/base/datastructure">算法</a>时间复杂度和AVL相同，但统计性能比AVL树更高。</p>
<p>​    当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>​     在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。</p>
<p>​     典型的用途是实现关联数组</p>
<p>​    <strong>2. AVL树是最先发明的自平衡二叉查找树。</strong></p>
<p>​    在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。引入二叉树的目的是为了提高二叉树的搜索的效率, 减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度.</p>
<p>​    AVL树的定义:<br>
​    一棵AVL树满足以下的条件:<br>
​    1&gt;它的左子树和右子树都是AVL树<br>
​    2&gt;左子树和右子树的高度差不能超过1<br>
​    从条件1可能看出是个递归定义,如GNU一样.</p>
<p>​    性质:<br>
​    1&gt;一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1)<br>
​    2&gt;一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)).<br>
​    3&gt;一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).</p>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/post/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2><span id="安装mysql">安装MySql</span></h2>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/e74255282ff5da9b.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/ef5b33c7ad593eff.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/64e39bddd1a902aa.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/472607774d81bf74.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/1a137450e9c0ec6e.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/821c5a4b337ed56f.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/c846391409d30e41.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/909df66f9bf3c443.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/268f40b1c611ce87.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/2045461d92bf6f9c.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/5fc1dbf469fd495b.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/0e42147cc13e9916.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/d090c84b4339c86e.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/8fc3f1b80630ac98.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/eec7ce722143c841.png" alt></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/06/a2dc187199daff4b.png" alt></p>
<p><img src="https://pic.imgdb.cn/item/63e0f2cf4757feff3388143a.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63e0f2da4757feff33882809.jpg" alt></p>
<p><img src="https://pic.imgdb.cn/item/63e0f2e64757feff33883a24.jpg" alt></p>
<h2><span id="概述">概述</span></h2>
<p>数据查询语言<strong>DQL</strong>，数据操纵语言<strong>DML</strong>，数据定义语言<strong>DDL</strong>，数据控制语言<strong>DCL</strong>。</p>
<blockquote>
<p>DQL：数据库查询语言。关键字：SELECT … FROM … WHERE。</p>
<p><a href="https://baike.baidu.com/item/DDL/21997?fromModule=lemma_inlink">DDL</a> ：数据库模式定义语言。关键字：CREATE，DROP，ALTER。</p>
<p><a href="https://baike.baidu.com/item/DML/10035808?fromModule=lemma_inlink">DML</a>：数据操纵语言。关键字：INSERT、UPDATE、DELETE。</p>
<p><a href="https://baike.baidu.com/item/DCL/6524388?fromModule=lemma_inlink">DCL</a>：数据控制语言 。关键字：GRANT、REVOKE。</p>
<p>TCL：事务控制语言。关键字：COMMIT、ROLLBACK、SAVEPOINT。</p>
<p>DDL,DML,DCL,DQL,TCL共同组成数据库的完整语言。</p>
</blockquote>
<h2><span id="关系数据库">关系数据库</span></h2>
<p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">class_id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">gender</th>
<th style="text-align:left">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">M</td>
<td style="text-align:left">90</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">F</td>
<td style="text-align:left">95</td>
</tr>
</tbody>
</table>
<p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p>
<h3><span id="主键">主键</span></h3>
<p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p>
<blockquote>
<p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。</p>
</blockquote>
<ol>
<li>记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</li>
<li>不使用任何业务相关的字段作为主键。</li>
</ol>
<blockquote>
<p>如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p>
<p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p>
</blockquote>
<p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p>
<ol>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li>
<li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li>
</ol>
<p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p>
<blockquote>
<p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p>
</blockquote>
<h3><span id="联合主键">联合主键</span></h3>
<p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p>
<p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id_num</th>
<th style="text-align:left">id_type</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">A</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">A</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">B</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p>
<p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p>
<h3><span id="小结">小结</span></h3>
<p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p>
<p>可以使用多个列作为联合主键，但联合主键并不常用</p>
<h3><span id="外键">外键</span></h3>
<p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">一班</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">二班</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p>
<p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p>
<p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">class_id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2</td>
<td style="text-align:left">小白</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p>
<p>例如：</p>
<ul>
<li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li>
</ul>
<p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p>
<p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure>
<p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p>
<p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p>
<p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p>
<p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_class_id;</span><br></pre></td></tr></table></figure>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p>
<h3><span id="多对多">多对多</span></h3>
<p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p>
<p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p>
<p><code>teachers</code>表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">张老师</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">王老师</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">李老师</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">赵老师</td>
</tr>
</tbody>
</table>
<p><code>classes</code>表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">一班</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">二班</td>
</tr>
</tbody>
</table>
<p>中间表<code>teacher_class</code>关联两个一对多关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">teacher_id</th>
<th style="text-align:left">class_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">4</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p>
<ul>
<li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li>
<li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li>
<li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li>
<li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li>
</ul>
<p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p>
<ul>
<li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li>
<li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li>
</ul>
<p>因此，通过中间表，我们就定义了一个“多对多”关系。</p>
<h3><span id="一对一">一对一</span></h3>
<p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p>
<p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">student_id</th>
<th style="text-align:left">mobile</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">135xxxx6300</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
<td style="text-align:left">138xxxx2209</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">5</td>
<td style="text-align:left">139xxxx8086</td>
</tr>
</tbody>
</table>
<p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p>
<p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p>
<p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p>
<h3><span id="小结">小结</span></h3>
<p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p>
<h3><span id="索引">索引</span></h3>
<ol>
<li>
<p>查询成千上万条记录时，使用索引可以提高查询速度</p>
<blockquote>
<p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度</p>
</blockquote>
</li>
<li>
<p>索引的效率与索引列的值是否散列有关</p>
<blockquote>
<p>该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p>
<p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p>
</blockquote>
</li>
<li>
<p>索引对于用户和应用程序来说都是透明的</p>
<blockquote>
<p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p>
</blockquote>
</li>
<li>
<p>可以对一张表创建多个索引</p>
</li>
<li>
<p>在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢</p>
</li>
</ol>
<p><strong>唯一索引</strong></p>
<ol>
<li>
<p>可以保证某一列的值具有唯一性</p>
</li>
<li>
<p>具有业务含义的列适合唯一索引</p>
<blockquote>
<p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p>
<p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。</p>
</blockquote>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);		<span class="comment">-- 唯一索引</span></span><br></pre></td></tr></table></figure>
<p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);		<span class="comment">-- 唯一约束，此时name列没有索引，但仍具有唯一性保证</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>需要在examination_info表创建以下索引，在duration列创建普通索引idx_duration、在exam_id列创建唯一性索引uniq_idx_exam_id、在tag列创建全文索引full_idx_tag。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_duration <span class="keyword">ON</span> examination_info (duration);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uniq_idx_exam_id <span class="keyword">ON</span> examination_info (exam_id); </span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX full_idx_tag <span class="keyword">ON</span> examination_info (tag);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>创建索引</strong></p>
<ol>
<li>
<p>CREATE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="comment">-- 唯一索引</span></span><br><span class="line"><span class="operator">|</span> FULLTEXT <span class="comment">-- 全文索引</span></span><br><span class="line">] INDEX index_name <span class="keyword">ON</span> table_name <span class="comment">-- 不指定唯一或全文时默认普通索引</span></span><br><span class="line">(column1[(length) [<span class="keyword">DESC</span><span class="operator">|</span><span class="keyword">ASC</span>]] [,column2,...]) <span class="comment">-- 可以对多列建立组合索引 </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ALTER</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_name </span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT] [INDEX] index_content (column1)	[,column2,...])<span class="comment">-- index_content索引名 content索引列</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>删除索引</strong></p>
<ol>
<li>
<p>DROP</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ALTER</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p>删除examination_info表上的唯一索引uniq_idx_exam_id和全文索引full_idx_tag。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX uniq_idx_exam_id <span class="keyword">ON</span> examination_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX full_idx_tag <span class="keyword">ON</span> examination_info;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用</p>
<ol>
<li>索引使用时满足最左前缀匹配原则，即对于组合索引(col1, col2)，在不考虑引擎优化时，条件必须是col1在前col2在后，或者只使用col1，索引才会生效；</li>
<li>索引不包含有NULL值的列</li>
<li>一个查询只使用一次索引，where中如果使用了索引，order by就不会使用</li>
<li>like做字段比较时只有前缀确定时才会使用索引</li>
<li>在列上进行运算后不会使用索引，如year(start_time)&lt;2020不会使用start_time上的索引</li>
</ol>
<h2><span id="dql数据查询">DQL数据查询</span></h2>
<h3><span id="书写顺序">书写顺序</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	[<span class="keyword">distinct</span>]<span class="operator">|</span>[<span class="keyword">ALL</span>] 列<span class="number">1</span>[, 列<span class="number">2</span>, 列<span class="number">3</span>] 		</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	<span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">JOIN</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	<span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>	</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	<span class="operator">&lt;</span>包含聚合函数的条件表达式<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">	子句 <span class="keyword">asc</span>（默认）<span class="operator">|</span><span class="keyword">desc</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span>N<span class="operator">&gt;</span> <span class="keyword">OFFSET</span> <span class="operator">&lt;</span>M<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="基本查询">基本查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb01c07d5ca72068acda0.jpg" alt></p>
<p>可以没有<code>FROM</code>子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">+</span><span class="number">200</span></span><br><span class="line"><span class="comment">-- 计算出表达式的结果，但不常用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- 用来判断当前到数据库的连接是否有效</span></span><br></pre></td></tr></table></figure>
<h3><span id="投影查询">投影查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>[, 列<span class="number">2</span>, 列<span class="number">3</span>] <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> </span><br><span class="line"><span class="comment">-- 如果列名或者表名与关键字冲突，需要使用撇号包裹</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从`students`表中返回`id`、`score`和`name`这三列：</span></span><br><span class="line"><span class="keyword">SELECT</span> id, score, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb20a07d5ca72068f76d9.jpg" alt></p>
<p><strong>AS</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span> (<span class="keyword">AS</span>) 别名<span class="number">1</span>, 列<span class="number">2</span> (<span class="keyword">AS</span>) 别名<span class="number">2</span>, 列<span class="number">3</span> (<span class="keyword">AS</span>) 别名<span class="number">3</span> <span class="keyword">FROM</span> ...</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，可以设置结果集显示的列名</li>
<li>AS可以省略</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用投影查询，并将列名重命名：</span></span><br><span class="line"><span class="keyword">SELECT</span> id, score points, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb23a07d5ca72069010ea.jpg" alt></p>
<p><strong>DISTINCT</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>]<span class="operator">|</span>[<span class="keyword">ALL</span>] 列<span class="number">1</span>[，列<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DISTINCT用来查询修饰字段不重复记录的条数,它将每个不同(唯一)值返回的行数限制为一个任意行。</p>
<p>如果未指定<code>DISTINCT</code>子句，则默认情况下显示满足选择条件的所有行。与指定ALL子句相同</p>
</blockquote>
<ol>
<li>为修饰字段的每个不重复组合返回一行。可以指定一个或多个修饰字段</li>
<li>在SELECT语句中使用DISTINCT，必须放在第一个要查询字段的开头</li>
<li>不能在DML语句（ INSERT, DELETE, UPDATE） 中使用</li>
<li>聚合函数也可以使用DISTINCT，COUNT(DISTINCT 列1，列2)可以实现查询不重复分组后每组的行数</li>
</ol>
<h3><span id="条件查询">条件查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="operator">|</span>列 <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>条件表达式</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">条件</th>
<th>符号</th>
<th style="text-align:left">表达式举例1</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">判断相等</td>
<td>=</td>
<td style="text-align:left">score = 80</td>
<td style="text-align:left">字符串需要用单引号括起来</td>
</tr>
<tr>
<td style="text-align:left">判断大于</td>
<td>&gt;</td>
<td style="text-align:left">score &gt; 80</td>
<td style="text-align:left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr>
<td style="text-align:left">判断大于或相等</td>
<td>&gt;=</td>
<td style="text-align:left">score &gt;= 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断小于</td>
<td>&lt;</td>
<td style="text-align:left">score &lt; 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断小于或相等</td>
<td>&lt;=</td>
<td style="text-align:left">score &lt;= 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断不相等</td>
<td>&lt;&gt;</td>
<td style="text-align:left">score &lt;&gt; 80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断包含于</td>
<td>IN</td>
<td style="text-align:left">score in(60,70,80,90)</td>
<td style="text-align:left">score = 60 OR score = 70 OR score = 80 OR score = 90</td>
</tr>
<tr>
<td style="text-align:left">判断在-之间</td>
<td>BETWEEN</td>
<td style="text-align:left">score between 60 and 100</td>
<td style="text-align:left">score &gt;= 60 AND score &lt;= 100</td>
</tr>
<tr>
<td style="text-align:left">判断空</td>
<td>IS NULL</td>
<td style="text-align:left">score IS NULL</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断非空</td>
<td>IS NOT NULL</td>
<td style="text-align:left">score IS NOT NULL</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断相似</td>
<td>LIKE</td>
<td style="text-align:left">name LIKE ‘ab%’</td>
<td style="text-align:left">%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td>
</tr>
<tr>
<td style="text-align:left">判断正则表达式</td>
<td>RLIKE</td>
<td style="text-align:left">name RLIKE ‘<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>+$’</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">判断存在</td>
<td>EXISTS</td>
<td style="text-align:left">EXISTS 查询子句</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><strong>LIKE</strong></p>
<ol>
<li>% 通配多个任意字符或者没有任意字符</li>
<li>_ 通配必须有一个任意字符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询姓刘的同学</span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span> stu</span><br><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;刘%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓刘的同学,且必须三个字</span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span> stu</span><br><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;刘__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名含有H的同学</span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span>  <span class="keyword">from</span> stu</span><br><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;%H%&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>RLIKE</strong></p>
<blockquote>
<p>后接正则表达式 （<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>+$）</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>表示匹配的字符必须在最前边</td>
<td>^A不匹配“an A”中的‘A’，但匹配“An A”中最前面的‘A’</td>
</tr>
<tr>
<td>$</td>
<td>与^类似，匹配最末的字符</td>
<td>t$不匹配“eater”中的‘t’，但匹配“eat”中的‘t’</td>
</tr>
<tr>
<td>[0-9]</td>
<td>字符列表，匹配列出中的任一个字符。你可以通过连字符-指出字符范围</td>
<td>[abc]跟[a-c]一样。它们匹配“brisket”中的‘b’和“ache”中的‘c’</td>
</tr>
<tr>
<td>+</td>
<td>匹配+号前面的字符1次及以上。等价于{1,}</td>
<td>a+匹配“candy”中的‘a’和“caaaaaaandy”中的所有‘a’</td>
</tr>
</tbody>
</table>
<p>来源:<a href="https://www.yulucn.com/question/4866556442">https://www.yulucn.com/question/4866556442</a></p>
<p><strong>EXISTS</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXISTS</span> (查询子句)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False</p>
</blockquote>
<ul>
<li>UNION搭配EXISTS可以实现复杂的条件查询</li>
</ul>
<p><strong>AND</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>条件<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span>条件<span class="number">2</span><span class="operator">&gt;</span>					<span class="comment">-- 表达满足条件1并且满足条件2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,gender,score <span class="keyword">FROM</span> students  <span class="comment">-- 查找及格的男同学</span></span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">AND</span> gender <span class="operator">=</span> &quot;M&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb7e707d5ca72069a274a.jpg" alt></p>
<p><strong>OR</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>条件<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">OR</span> <span class="operator">&lt;</span>条件<span class="number">2</span><span class="operator">&gt;</span>					<span class="comment">-- 表达满足条件1、条件2其中一个</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,gender,score <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">2</span>				<span class="comment">-- 查询学号是1和2的同学</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63dcb8af07d5ca72069bca88.jpg" alt></p>
<p><strong>NOT</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">NOT</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>						<span class="comment">-- 表示“不符合该条件”的记录</span></span><br></pre></td></tr></table></figure>
<h3><span id="排序">排序</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句 <span class="keyword">asc</span>（默认）<span class="operator">|</span><span class="keyword">desc</span> 		<span class="comment">-- 默认按照子句的从低到高排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照成绩排序（降序）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">-- 按照年龄降序排序，同岁的学生按照分数降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">year</span>(age) <span class="keyword">desc</span> ,score <span class="keyword">desc</span> </span><br></pre></td></tr></table></figure>
<h3><span id="分页查询">分页查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT <span class="operator">&lt;</span>N<span class="operator">&gt;</span> <span class="keyword">OFFSET</span> <span class="operator">&lt;</span>M<span class="operator">&gt;</span>				<span class="comment">-- 从结果集中的第M号记录开始取出N条记录</span></span><br><span class="line"><span class="comment">-- N：每页的数量	M：当前页数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>					<span class="comment">-- 第1页从0号记录开始,OFFSET 0 可以省略</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>					<span class="comment">-- 第2页从3号记录开始</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">6</span>					<span class="comment">-- 第3页从6号记录开始</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">9</span>					<span class="comment">-- 第4页从9号记录开始</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/a1ffbb51822fa121.png" alt></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">20</span>					<span class="comment">-- 超过记录，得到一个空的结果集</span></span><br></pre></td></tr></table></figure>
<h3><span id="聚合查询">聚合查询</span></h3>
<ul>
<li>多行数据变成一个数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">聚合函数([<span class="keyword">DISTINCT</span>]列名<span class="operator">|</span>表达式)		 				<span class="comment">-- 列名可以为 * 表示所有列</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>聚合函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT</td>
<td>计算某一列的总数</td>
</tr>
<tr>
<td>AVG</td>
<td>计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td>SUM</td>
<td>计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td>MAX</td>
<td>计算某一列的最大值，对于字符型字符类型返回排序最后的字符</td>
</tr>
<tr>
<td>MIN</td>
<td>计算某一列的最小值，对于字符型字符类型返回排序最前的字符</td>
</tr>
</tbody>
</table>
<p>如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code></p>
<p><strong>分组聚合</strong></p>
<ul>
<li>按照指定列拆分，列数据相同的数据被合并，最终多行数据分为若干行</li>
<li>分组指定的列能与聚合函数一起显示，而显示非聚合的列也非分组的列没有实际意义</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>					<span class="comment">-- 可以是单列，也可以是多列</span></span><br></pre></td></tr></table></figure>
<p><strong>如何对聚合函数的列进行条件查询</strong></p>
<ul>
<li>
<p>WHERE子句不能使用聚合函数，一般在分组后使用HAVING关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span>包含聚合函数的条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以根据聚合函数列排序（order by 子句能使用聚合函数）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询男同学和女同学的平均年龄,且只显示平均年龄大于23岁的</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	gender,</span><br><span class="line">	<span class="built_in">avg</span>(age)</span><br><span class="line"><span class="keyword">from</span>  </span><br><span class="line">	user_profile</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">	gender </span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line">	<span class="built_in">avg</span>(age)<span class="operator">&gt;</span><span class="number">23</span></span><br></pre></td></tr></table></figure>
<p>聚合查询应用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    tag,</span><br><span class="line">    difficulty,</span><br><span class="line">    ROUND((<span class="built_in">SUM</span>(score) <span class="operator">-</span> <span class="built_in">MAX</span>(score) <span class="operator">-</span> <span class="built_in">MIN</span>(score)) <span class="operator">/</span> (<span class="built_in">COUNT</span>(score) <span class="number">-2</span>),<span class="number">1</span>) clip_avg_score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    exam_record er,</span><br><span class="line">    examination_info ei</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    ei.exam_id <span class="operator">=</span> er.exam_id</span><br><span class="line">    <span class="keyword">AND</span> submit_time <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">    <span class="keyword">AND</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br></pre></td></tr></table></figure>
<h3><span id="多表查询">多表查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>别名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>表名<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>别名<span class="number">2</span><span class="operator">&gt;</span>	</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>返回结果为表1和表2的“乘积”</p>
<blockquote>
<p>即表1的每一行与表2的每一行都两两拼在一起返回</p>
<p>结果集的列数是表1和表2的列数之和</p>
<p>行数是表1和表2的行数之积</p>
</blockquote>
</li>
<li>
<p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p>
</li>
</ul>
<h3><span id="连接查询">连接查询</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INNER</span><span class="operator">|</span><span class="keyword">LEFT</span> <span class="keyword">OUTER</span><span class="operator">|</span><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>连接条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>内连接</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/f893d48c7c951a76.png" alt></p>
<p>只返回同时存在于两张表的行数据</p>
<p><code>students</code>表的<code>class_id</code>包含1，2，3，<code>classes</code>表的<code>id</code>包含1，2，3，4</p>
<p>INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/ffe3367a85280dab.png" alt></p>
<p><strong>左外连接</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/fb563ac69a54d9d9.png" alt></p>
<p>LEFT OUTER JOIN则返回左表都存在的行</p>
<p>如果给students表增加一行，并添加class_id=5，classes表并不存在id=5的行</p>
<p>LEFT OUTER JOIN的结果会增加一行，对应的<code>class_name</code>是<code>NULL</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/481c20f1e19c820f.png" alt></p>
<p><strong>右外连接</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/5ebf76c465113c6d.png" alt></p>
<p>RIGHT OUTER JOIN返回右表都存在的行</p>
<p>如果某一行仅在右表存在，那么结果集就会以<code>NULL</code>填充剩下的字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/03/47439395f20cd95e.png" alt></p>
<p><strong>USING</strong></p>
<blockquote>
<p>sql/92标准可以使用using关键字来简化连接查询，但是只是在查询满足以下条件时<br>
1.查询必须是等值连接<br>
2.等值连接中的列必须具有相同的名称和数据类型</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">USING</span> (列<span class="number">1</span>，列<span class="number">2</span>，...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> a (<span class="keyword">AS</span> 别名a) <span class="keyword">JOIN</span> (b 别名b) <span class="keyword">ON</span> 别名a.列<span class="number">1</span> <span class="operator">=</span> 别名b.列<span class="number">1</span></span><br><span class="line">	<span class="keyword">AND</span> 别名a.列<span class="number">2</span> <span class="operator">=</span> 别名b.列<span class="number">2</span> </span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<ul>
<li>可以一次指定多个相同名称、数据类型的列</li>
<li>不能指定表的别名</li>
<li>不能 AND 附加别的连接限制条件</li>
</ul>
<h3><span id="日期函数">日期函数</span></h3>
<p><strong>数据类型</strong></p>
<ul>
<li>DATE - 格式 YYYY-MM-DD</li>
<li>DATETIME - 格式: YYYY-MM-DD HH:MM:SS</li>
<li>TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS</li>
<li>YEAR - 格式 YYYY 或 YY</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的学生，且需要查看其实际年龄（多少岁）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,(<span class="keyword">year</span>(curdate())<span class="operator">-</span><span class="keyword">year</span>(age)) <span class="keyword">as</span> 岁数 <span class="keyword">from</span> stu</span><br></pre></td></tr></table></figure>
<p><strong>日期格式化</strong></p>
<p>DATE_FORMAT(date,format)</p>
<blockquote>
<p>用format 格式化date，format 为格式化字符串</p>
<p>‘%Y-%m-%d %H:%i:%s’  2021-08-17 14:42:31</p>
<p>‘%Y%m’	202108</p>
</blockquote>
<table>
<thead>
<tr>
<th>格式化标识符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Y</td>
<td>年，4位</td>
</tr>
<tr>
<td>%y</td>
<td>年，2位</td>
</tr>
<tr>
<td>%M</td>
<td>月，月名称，如January</td>
</tr>
<tr>
<td>%m</td>
<td>月，2位（01-12）</td>
</tr>
<tr>
<td>%D</td>
<td>日，如1st，2nd</td>
</tr>
<tr>
<td>%d</td>
<td>日，2位（01-31）</td>
</tr>
<tr>
<td>%H</td>
<td>时，2位，24小时制</td>
</tr>
<tr>
<td>%h</td>
<td>时，12小时制</td>
</tr>
<tr>
<td>%i</td>
<td>分，2位（00-59）</td>
</tr>
<tr>
<td>%S或%s</td>
<td>秒，2位（00-59）</td>
</tr>
<tr>
<td>%p</td>
<td>PM 或AM</td>
</tr>
<tr>
<td>%r</td>
<td>HH:mm:ss PM形式时间</td>
</tr>
<tr>
<td>%W</td>
<td>周，周名，如Tuesday</td>
</tr>
<tr>
<td>%w</td>
<td>周，0-6，0为周日</td>
</tr>
<tr>
<td>%j</td>
<td>当前日期所在一年中的天数，3位（001-366）</td>
</tr>
</tbody>
</table>
<p><strong>距离</strong></p>
<ol>
<li>
<p>TIMESTAMPDIFF(interval, time_start, time_end)</p>
<blockquote>
<p>可计算time_start、time_end的时间差，单位以指定的interval为准，常用可选：</p>
<ul>
<li>SECOND 秒</li>
<li>MINUTE 分钟（返回秒数差除以60的整数部分）</li>
<li>HOUR 小时（返回秒数差除以3600的整数部分）</li>
<li>DAY 天数（返回秒数差除以3600*24的整数部分）</li>
<li>MONTH 月数</li>
<li>YEAR 年数</li>
</ul>
</blockquote>
</li>
<li>
<p>DATEDIFF(time_end,time_start)</p>
<blockquote>
<p>计算time_start、time_end之间的天数</p>
</blockquote>
</li>
</ol>
<p><strong>运算</strong></p>
<p>DATE_ADD(date,	INTERVAL expr unit)</p>
<blockquote>
<p>日期加上指定单位的时间，第二参数interval 后支持负数，date_add既可以加也可以减</p>
</blockquote>
<table>
<thead>
<tr>
<th>interval</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>interval 1 day</td>
<td>1天</td>
</tr>
<tr>
<td>interval 1 hour</td>
<td>1小时</td>
</tr>
<tr>
<td>interval 1 minute</td>
<td>1分钟</td>
</tr>
<tr>
<td>interval 1 second</td>
<td>1秒</td>
</tr>
<tr>
<td>interval 1 microsecond</td>
<td>1毫秒</td>
</tr>
<tr>
<td>interval 1 week</td>
<td>1周</td>
</tr>
<tr>
<td>interval 1 month</td>
<td>1月</td>
</tr>
<tr>
<td>interval 1 quarter</td>
<td>1季</td>
</tr>
<tr>
<td>interval 1 year</td>
<td>1年</td>
</tr>
</tbody>
</table>
<p><strong>计算某个月的天数</strong></p>
<ol>
<li>
<pre><code class="language-sql">DATEDIFF(DATE_ADD(time,INTERVAL 1 MONTH),time)		-- 距离下个月同天的天数
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ~~~sql</span><br><span class="line">   day(last_day(time))						   		-- 获取本月最后一天</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<p><strong>MySQL Date 函数</strong></p>
<p>涉及时分秒一般为DATETIME的函数</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_now.asp">NOW()</a></td>
<td style="text-align:left">返回当前的日期和时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR(列名)</td>
<td style="text-align:left">返回当前的时间的年</td>
</tr>
<tr>
<td style="text-align:left">MONTH(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的月</td>
</tr>
<tr>
<td style="text-align:left">DAY(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的天</td>
</tr>
<tr>
<td style="text-align:left">HOUR(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的小时</td>
</tr>
<tr>
<td style="text-align:left">MINUTE(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的分钟</td>
</tr>
<tr>
<td style="text-align:left">SECOND(列名)</td>
<td style="text-align:left">以整数形式返回当前的时间的秒</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_curdate.asp">CURDATE()</a></td>
<td style="text-align:left">返回当前的日期</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_curtime.asp">CURTIME()</a></td>
<td style="text-align:left">返回当前的时间</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date.asp">DATE()</a></td>
<td style="text-align:left">提取日期或日期/时间表达式的日期部分</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_extract.asp">EXTRACT()</a></td>
<td style="text-align:left">返回日期/时间按的单独部分</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date_add.asp">DATE_ADD()</a></td>
<td style="text-align:left">给日期添加指定的时间间隔</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date_sub.asp">DATE_SUB()</a></td>
<td style="text-align:left">从日期减去指定的时间间隔</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_datediff_mysql.asp">DATEDIFF()</a></td>
<td style="text-align:left">返回两个日期之间的天数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.w3school.com.cn/sql/func_date_format.asp">DATE_FORMAT()</a></td>
<td style="text-align:left">用不同的格式显示日期/时间</td>
</tr>
</tbody>
</table>
<p><strong>时间戳-日期格式转化</strong></p>
<ol>
<li>from_unixtime(列名,字符串格式)：将时间戳转换成日期</li>
<li>unix_timestamp():将日期转换回时间戳</li>
</ol>
<h3><span id="条件函数">条件函数</span></h3>
<p><strong>IF 条件函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if(x<span class="operator">=</span>n,a,b)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x=n代表判断条件，如果x=n时，那么结果返回a，否则返回b</p>
</blockquote>
<p><strong>Case when 条件函数</strong></p>
<p>按照多个条件更换列中的内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> 测试表达式							<span class="comment">-- 测试表达式可省略，此时为搜索CASE函数</span></span><br><span class="line"><span class="keyword">WHEN</span> 简单表达式<span class="number">1</span> <span class="keyword">THEN</span> 结果表达式<span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> 简单表达式<span class="number">2</span> <span class="keyword">THEN</span> 结果表达式<span class="number">2</span> …</span><br><span class="line"><span class="keyword">WHEN</span> 简单表达式n <span class="keyword">THEN</span> 结果表达式n</span><br><span class="line">[ <span class="keyword">ELSE</span> 结果表达式n<span class="operator">+</span><span class="number">1</span> ]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>若没有测试表达式</p>
<ol>
<li>从上到下判断WHEN子句的简单表达式的值</li>
<li>若简单表达式的值为TRUE，则返回WHEN子句所对应的结果表达式的值</li>
<li>如果所有简单表达式的值为FALSE
<ol>
<li>若指定了ELSE子句,则返回ELSE子句中指定的结果表达式的值</li>
<li>若没有指定ELSE子句，则返回NULL</li>
</ol>
</li>
</ol>
<p>若有测试表达式</p>
<blockquote>
<ol>
<li>从上到下判断测试表达式的值与每个WHEN子句的简单表达式是否相等</li>
<li>如果某个简单表达式的值与测试表达式的值相等，则返回第一个与之匹配的WHEN子句所对应的结果表达式的值</li>
<li>如果所有简单表达式的值与测试表达式的值都不相等</li>
<li>若指定了ELSE子句,则返回ELSE子句中指定的结果表达式的值</li>
<li>若没有指定ELSE子句，则返回NULL</li>
</ol>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    device_id,</span><br><span class="line">    gender,</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">25</span> <span class="keyword">then</span> <span class="string">&#x27;25岁及以上&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;20-24岁&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age<span class="operator">&lt;</span><span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;20岁以下&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="string">&#x27;其他&#x27;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">as</span> age_cut</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="文本函数">文本函数</span></h3>
<p><strong>CONCAT函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> CONCAT(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>,<span class="string">&#x27;ff&#x27;</span>)	<span class="comment">-- 返回结果为 ‘abcbcdff&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CONCAT函数用于将两个或多个字符串连接起来，形成一个单一的字符串</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GROUP_CONCAT([<span class="keyword">DISTINCT</span>] 要连接的字段 [<span class="keyword">Order</span> <span class="keyword">BY</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span> 排序字段] [Separator <span class="string">&#x27;分隔符&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><strong>SUBSTRING_INDEX</strong></p>
<p>将字符串依据某个指定分隔符进行切分，并返回指定位置分隔符前的字符。(字段分割符,位置）</p>
<p>从 ‘180,78kg,male’ 分别取出身高体重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(<span class="string">&#x27;180,78kg,male&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;1&#x27;</span>) <span class="keyword">as</span> height	<span class="comment">-- 返回身高: &#x27;180&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(<span class="string">&#x27;180,78kg,male&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;2&#x27;</span>) <span class="keyword">as</span> height	<span class="comment">-- 返回&#x27;180,78kg&#x27;	多取出身高的信息</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在上述的基础上嵌套一层查询，负数位置代表从后向前取，-1代表最后一位，相当于取出’180,78kg&#x27;的最后一个逗号后的字符</span></span><br><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(SUBSTRING_INDEX(<span class="string">&#x27;180,78kg,male&#x27;</span>,<span class="string">&#x27;,’,&#x27;</span><span class="number">2</span>’),’,’,<span class="number">-1</span>) <span class="keyword">as</span> height</span><br></pre></td></tr></table></figure>
<p><strong>INSTR函数</strong></p>
<ul>
<li>instr(substr,str)：返回substr字符串在str里第一次出现的位置，从1开始，没有返回0</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;bacd&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) 	<span class="comment">-- 从bacd字符串中寻找字符a首次出现的位置，输出值为2</span></span><br></pre></td></tr></table></figure>
<p><strong>substring函数</strong></p>
<ul>
<li>
<p>substr（string A，int start，int len）,返回字符串A从下标start位置开始，长度为len的字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(‘bacda’,<span class="number">2</span>,<span class="number">2</span>)	<span class="comment">-- 输出：’ac’，代码表示返回从第2个字符起后2个字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>substring（string A，int start）,在不指定返回字符串长度的情况下，返回字符串A从下标start位置到结尾的字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(‘bacda’,<span class="number">2</span>)		<span class="comment">-- 输出：’acda’，代码表示返回从第2个字符起到末尾所有的字符串</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>大小写转换</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UPPER(str)</td>
<td>将参数转换为大写</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将参数转换为小写</td>
</tr>
<tr>
<td>LENGTH(str)</td>
<td>返回文本字段中值的长度</td>
</tr>
<tr>
<td>CHAR_LENGTH(str)</td>
<td>返回文本字段中字符的长度</td>
</tr>
<tr>
<td>CONCAT(str1,str2,…)</td>
<td>将多个字符串连接成一个字符串</td>
</tr>
<tr>
<td>SUBSTRING_INDEX(str,分隔符,index)</td>
<td>字符串依据某个分隔符进行切分，第index个分隔符前的字符</td>
</tr>
<tr>
<td>INSTR(substr,str)</td>
<td>返回substr字符串在str里第一次出现的位置，从1开始，没有返回0</td>
</tr>
<tr>
<td>SUBSTRING(str,int start,int len)</td>
<td>返回字符串从下标start位置开始，长度为len的字符串，从1开始，没有返回0</td>
</tr>
<tr>
<td>SUBSTRING(str,int start)</td>
<td>返回字符串从下标start位置到结尾的字符串</td>
</tr>
</tbody>
</table>
<h3><span id="窗口函数">窗口函数</span></h3>
<p><strong>使用场景</strong></p>
<ol>
<li>排名问题：每个部门按业绩来排名</li>
<li>topN问题：找出每个部门排名前N的员工进行奖励</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>用于分组的列名<span class="operator">&gt;</span>					       <span class="comment">-- 窗口函数可以是专用窗口函数或聚合函数</span></span><br><span class="line">                 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>用于排序的列名<span class="operator">&gt;</span> <span class="keyword">RANGE</span><span class="operator">|</span><span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> 边界规则<span class="number">1</span> <span class="keyword">AND</span> 边界规则<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>窗口函数与GROUP BY</strong></p>
<table>
<thead>
<tr>
<th>窗口函数</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody>
<tr>
<td>同时分组和排序</td>
<td>分组</td>
</tr>
<tr>
<td>不减少原表的行数（特殊DENSE_RANK）</td>
<td>汇总后改变了表的行数，一行只有一个类别</td>
</tr>
<tr>
<td>在where或者group by子句处理后的结果上操作，原则上只能写在select子句中</td>
<td>指定的书写位置</td>
</tr>
<tr>
<td>Mysql从8.0版本才开始支持窗口函数</td>
<td></td>
</tr>
<tr>
<td>对于每行数据都有新的标记（与使用的窗口函数有关）</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>窗口函数中的ORDER BY</strong></p>
<p><a href="https://www.cnblogs.com/lihaoyang/p/6756956.html">SQL开窗函数 - 我俩绝配 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>用于排序的列名<span class="operator">&gt;</span> [<span class="keyword">RANGE</span><span class="operator">|</span><span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> 边界规则<span class="number">1</span> <span class="keyword">AND</span> 边界规则<span class="number">2</span>] <span class="comment">-- 定位计算范围，这个子句又被称为定位框架</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>RANGE表示按照值的范围进行范围的定义</p>
<p>ROWS表示按照行的范围进行范围的定义</p>
</blockquote>
<table>
<thead>
<tr>
<th>边界规则</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CURRENT ROW</td>
<td>当前行</td>
</tr>
<tr>
<td>N PRECEDING</td>
<td>前N行</td>
</tr>
<tr>
<td>UNBOUNDED PRECEDING</td>
<td>一直到第一条记录</td>
</tr>
<tr>
<td>N FOLLOWING</td>
<td>后N行</td>
</tr>
<tr>
<td>UNBOUNDED FOLLOWING</td>
<td>一直到最后一条记录</td>
</tr>
</tbody>
</table>
<p>查询从第一行到当前行为一组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(fsalary) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> fsalary [<span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>]）	<span class="comment">-- 可以省略定位框架声明部分</span></span><br></pre></td></tr></table></figure>
<p>row换成range，按照值范围进行定位</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(fsalary) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> fsalary <span class="keyword">range</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) 到当前行工资求和</span><br></pre></td></tr></table></figure>
<p><img src="https://images2015.cnblogs.com/blog/702434/201704/702434-20170424155347381-935401731.png" alt="img"></p>
<p>处理并列排序的情况：Lily、Swing、Bill这三个人的工资都是2000元</p>
<ol>
<li>“ROWS”进行行的范围定位，则计算从第一条到当前行的累积和</li>
<li>“RANGE”进行值的范围定位，则计算从第一个值1000到当前值的累计和，由于等于2000元的工资有三个人，所以对 Lily、Swing、Bill这三个人进行开窗函数聚合计算的时候得到的都是7000（ “ 1000+2000+2000+2000 ”）</li>
</ol>
<p>查询前两行和后两行为一组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(FSalary) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> FSalary <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> PRECEDING <span class="keyword">AND</span> <span class="number">2</span> FOLLOWING)  <span class="comment">-- 前二后二和</span></span><br></pre></td></tr></table></figure>
<p><img src="https://images2015.cnblogs.com/blog/702434/201704/702434-20170424155602225-1292657393.png" alt="img"></p>
<ol>
<li>按照FSalary进行排序，然后计算从当前行前两行（2 PRECEDING）到当前行后两行（2 FOLLOWING）的工资和</li>
<li>第一、第二条的“前两行”不存在，最后两行数据的“后两行”也不存在，因此计算时候按照前两行不存在进行计算，结果为空值NULL而非0</li>
</ol>
<p><strong>分类</strong></p>
<ol>
<li>专用窗口函数</li>
<li>聚合函数</li>
</ol>
<p><strong>专用窗口函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score,RANK<span class="operator">|</span>DENSE_RANK<span class="operator">|</span><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>([<span class="keyword">PARTITION</span> <span class="keyword">BY</span>] <span class="keyword">ORDER</span> <span class="keyword">BY</span> score)rank</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e49a844757feff3306d93f.jpg" alt></p>
<ul>
<li>RANK、DENSE_RANK、ROW_NUMBER使用时遇到重复字段的标号规则不同</li>
</ul>
<p><strong>特殊窗口函数</strong></p>
<p><strong>PERCENT_RANK</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score,<span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span>([<span class="keyword">PARTITION</span> <span class="keyword">BY</span>] <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>)percent_ranking</span><br><span class="line"><span class="keyword">FROM</span> practice_record</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e49c5a4757feff330b7e27.jpg" alt></p>
<ul>
<li>PERCENT_RANK会将排序后的标号均匀分布在[0,1]上</li>
<li>常用于查询有序下的前百分之几的数据</li>
</ul>
<p><strong>LEAD</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lead</span>(列名, 行数, 默认值) <span class="keyword">over</span> (		<span class="comment">-- 行数可省略，默认为1，默认值也可省略，默认为null</span></span><br><span class="line">    <span class="keyword">partition</span> <span class="keyword">by</span> 分组指定列</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> 排序指定列</span><br><span class="line">) 新列名 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先按照指定列分组，在每组内取<strong>该列</strong>该行下的<strong>第几行</strong>数据 作为新列在本行的数据，<strong>无法获取行下数据时再补充默认值</strong></p>
<p>和表的连接一样新增列</p>
<p>使用与查找与每一列都相关的数据，如第二天的相关数据</p>
</blockquote>
<p><strong>聚合函数作为窗口函数</strong></p>
<p>聚合函数后面括号不能为空，需要指定聚合的列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    score,</span><br><span class="line">    <span class="built_in">sum</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_sum,</span><br><span class="line">    <span class="built_in">avg</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_avg,</span><br><span class="line">    <span class="built_in">count</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_count,</span><br><span class="line">    <span class="built_in">max</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_max,</span><br><span class="line">    <span class="built_in">min</span>(score) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score) <span class="keyword">as</span> current_min</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	practice_record</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e4ad154757feff332cefa9.jpg" alt></p>
<ul>
<li>每组中，都是在自身数据及上方的数据范围使用聚合函数</li>
<li>可以看到截止本行数据，对于本行及以上的数据范围内的变化过程</li>
<li>使用聚合函数的显著特点就是分组排序后不改变列的行数</li>
</ul>
<h3><span id="暂存表">暂存表</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> 暂存表名 <span class="keyword">as</span>(</span><br><span class="line">	</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>无需重复书写 查找相同表的代码</li>
</ul>
<h3><span id="保留位数">保留位数</span></h3>
<p>小数点和保留位数</p>
<p><strong>ROUND</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ROUND(被操作数，保留小数点后几位数字)</span><br></pre></td></tr></table></figure>
<ol>
<li>四舍五入</li>
<li>保留位数</li>
</ol>
<p><strong>NUMERIC</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">numeric</span> (数据长度，小数点后位数)</span><br></pre></td></tr></table></figure>
<ol>
<li>与Decimal类似</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;12.56&#x27;</span> <span class="keyword">AS</span> <span class="type">NUMERIC</span>(<span class="number">10</span>,<span class="number">8</span>))<span class="comment">--==&gt;12.56000000 -- 小数点后位数最大为8</span></span><br></pre></td></tr></table></figure>
<p><strong>CAST</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CAST</span>(被操作数 <span class="keyword">AS</span> <span class="type">Decimal</span><span class="operator">|</span><span class="type">NUMERIC</span>(数据长度，小数点后位数))</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="string">&#x27;12.362222&#x27;</span> <span class="keyword">as</span>  <span class="type">decimal</span>(<span class="number">32</span>,<span class="number">3</span>))	<span class="comment">-- 》12.362 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;12&#x27;</span> <span class="keyword">AS</span> <span class="type">int</span>)<span class="comment">--&gt;12</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;12.0&#x27;</span> <span class="keyword">AS</span> <span class="type">int</span>)<span class="comment">--&gt;报错,double类型的字符串不能转成int</span></span><br></pre></td></tr></table></figure>
<p><strong>FLOOR</strong></p>
<p>FLOOR（x）返回小于等于x的最大整数（向下取整）</p>
<p><strong>CEILING</strong></p>
<p>CEILING（x）返回大于等于x的最小整数（向上取整）</p>
<h3><span id="其他">其他</span></h3>
<p><strong>UNION与UNION ALL</strong></p>
<p><strong>数据汇总</strong></p>
<p>COALESCE(expression_1, expression_2, …,expression_n)</p>
<ul>
<li>增加列，可用于数据汇总</li>
</ul>
<blockquote>
<p>依次参考各参数表达式，遇到非null值即停止并返回该值。</p>
<p>表达式为NULL时继续往下查询，不为NULL返回当前表达式的值</p>
</blockquote>
<p>WITH ROLLUP</p>
<ul>
<li>增加列，可用于数据汇总</li>
</ul>
<blockquote>
<p>定义在group by之后</p>
<p>对于聚合列相当于在分组前聚合，对于非聚合列相当于取最后一行的值，对于分组列设为NULL</p>
</blockquote>
<p>注意：低版本下使用WITH ROLLUP与COALESCE</p>
<p>若GROUP BY子句中不为数据库表中的列，而是经过运算存储在内存中的列</p>
<p>WITH ROLLUP会覆盖COALESCE中运算暂存列本来为NULL的值，导致COALESCE判断该表达式永远为非NULL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">COALESCE</span>(<span class="keyword">month</span>(submit_time))</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	practice_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	<span class="keyword">month</span>(submit_time) <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span> </span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e1c8b74757feff33b7067c.jpg" alt></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">COALESCE</span>(submit_month,<span class="string">&#x27;2021汇总&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		<span class="keyword">month</span>(submit_time) submit_month</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">			practice_record</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">			<span class="keyword">month</span>(submit_time) <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span> </span><br><span class="line">) a</span><br><span class="line"><span class="comment">-- 可以通过子查询解决WITHROLLUP覆盖COALESCE表达式NULL</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63e1c9924757feff33b847fe.jpg" alt></p>
<h4><span id="mysql高版本">MySQL高版本</span></h4>
<p><strong>解决最新的SQL版本中ONLY_FULL_GROUP_BY报错</strong></p>
<blockquote>
<p>ONLY_FULL_GROUP_BY的语义就是确定select 中的所有列的值要么是来自于聚合函数（sum、avg、max等）的结果，</p>
<p>要么是来自于group by 子句中的表达式。</p>
<p>MySQL提供了any_value()函数来抑制ONLY_FULL_GROUP_BY值被拒绝。</p>
</blockquote>
<p>所以只需要在非group by的列上加any_value()就可以了</p>
<h2><span id="dml数据操作">DML数据操作</span></h2>
<h3><span id="添加数据">添加数据</span></h3>
<ol>
<li>
<p>普通插入（全字段）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>普通插入（限定字段）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1, value2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多条一次性插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从另一个表导入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name2 [<span class="keyword">WHERE</span> key<span class="operator">=</span><span class="keyword">value</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>带更新的插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (value1, value2, ...) </span><br><span class="line"><span class="comment">-- 注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>新表exam_record_before_2021用来备份2021年之前的试题作答记录，结构和exam_record表一致，请将2021年之前的已完成了的试题作答纪录导入到该表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span></span><br><span class="line">    exam_record_before_2021</span><br><span class="line">    (uid,exam_id,start_time,submit_time,score)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    uid,exam_id,start_time,submit_time,score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    exam_record</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    <span class="keyword">year</span>(submit_time) <span class="operator">&lt;</span> <span class="number">2021</span></span><br></pre></td></tr></table></figure>
<p>现在有一套ID为9003的高难度SQL试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表examination_info（其表结构如下图），不管该ID试卷是否存在，都要插入成功，请尝试插入它。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> </span><br><span class="line">    examination_info(exam_id,tag,difficulty,duration,release_time) <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">9003</span>, &quot;SQL&quot;, &quot;hard&quot;, <span class="number">90</span>, &quot;2021-01-01 00:00:00&quot;);</span><br></pre></td></tr></table></figure>
<h3><span id="修改数据">修改数据</span></h3>
<ol>
<li>
<p>设置为新值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column_name<span class="operator">=</span>new_value [, column_name2<span class="operator">=</span>new_value2] [<span class="keyword">WHERE</span> column_name3<span class="operator">=</span>value3]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据已有值替换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> key1<span class="operator">=</span>replace(key1, <span class="string">&#x27;查找内容&#x27;</span>, <span class="string">&#x27;替换成内容&#x27;</span>) [<span class="keyword">WHERE</span> column_name3<span class="operator">=</span>value3]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info</span><br><span class="line"><span class="keyword">set</span> tag <span class="operator">=</span> REPLACE(tag,<span class="string">&#x27;PYTHON&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info</span><br><span class="line"><span class="keyword">set</span> tag <span class="operator">=</span> REPLACE(tag,<span class="string">&#x27;PYTHON&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="删除数据">删除数据</span></h3>
<ol>
<li>
<p>根据条件删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> options] [ [ <span class="keyword">ORDER</span> <span class="keyword">BY</span> fields ] LIMIT n ]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>全部删除（表清空，包含自增计数器重置）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> table_name</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span></span><br><span class="line">    exam_record</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span></span><br><span class="line">    TIMESTAMPDIFF(<span class="keyword">MINUTE</span>,start_time,submit_time) <span class="operator">&lt;</span> <span class="number">5</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time</span><br><span class="line">LIMIT <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2><span id="ddl数据定义">DDL数据定义</span></h2>
<h3><span id="创建数据库">创建数据库</span></h3>
<h3><span id="创建数据库表格">创建数据库表格</span></h3>
<ol>
<li>直接创建表</li>
</ol>
   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">[IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] tb_name <span class="comment">-- 不存在才创建，存在就跳过</span></span><br><span class="line">(column_name1 data_type1 <span class="comment">-- 列名和类型必选</span></span><br><span class="line">    [ <span class="keyword">PRIMARY</span> KEY <span class="comment">-- 可选的约束，主键</span></span><br><span class="line">     <span class="operator">|</span><span class="keyword">FOREIGN</span> KEY <span class="comment">-- 外键，引用其他表的键值</span></span><br><span class="line">     <span class="operator">|</span>AUTO_INCREMENT <span class="comment">-- 自增ID</span></span><br><span class="line">     COMMENT comment <span class="comment">-- 列注释（评论）</span></span><br><span class="line">     <span class="keyword">DEFAULT</span> default_value <span class="comment">-- 默认值</span></span><br><span class="line">     <span class="keyword">UNIQUE</span> <span class="comment">-- 唯一性约束，不允许两条记录该列值相同</span></span><br><span class="line">     <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="comment">-- 该列非空</span></span><br><span class="line">    ], ...</span><br><span class="line">) [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset] <span class="comment">-- 字符集编码</span></span><br><span class="line">[<span class="keyword">COLLATE</span> collate_value] <span class="comment">-- 列排序和比较时的规则（是否区分大小写等）</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>从另一张表复制表结构创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">LIKE</span> tb_name_old</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从另一张表的查询结果创建表</p>
</li>
</ol>
   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_name_old <span class="keyword">WHERE</span> options</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> user_info_vip (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;自增ID&#x27;</span>,</span><br><span class="line">    uid <span class="type">int</span> <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    nick_name <span class="type">varchar</span>(<span class="number">64</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">    achievement <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;成就值&#x27;</span>,</span><br><span class="line">    `level` <span class="type">int</span> COMMENT <span class="string">&#x27;用户等级&#x27;</span>,</span><br><span class="line">    job <span class="type">varchar</span>(<span class="number">32</span>) COMMENT <span class="string">&#x27;职业方向&#x27;</span>,</span><br><span class="line">    register_time datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span></span><br><span class="line">) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
<h3><span id="修改数据库表格">修改数据库表格</span></h3>
<p><code>ALTER TABLE 表名 修改选项</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&#123; <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span> after <span class="operator">&lt;</span>位置<span class="operator">&gt;</span> <span class="comment">-- 增加列</span></span><br><span class="line"><span class="operator">|</span> CHANGE <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>旧列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新列类型<span class="operator">&gt;</span> <span class="comment">-- 修改列名或类型，直接替换为新列，以下均为修改某个属性</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> &#123; <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span> &#125; <span class="comment">-- 修改/删除 列的默认值</span></span><br><span class="line"><span class="operator">|</span> MODIFY <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span> <span class="comment">-- 修改列类型</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="comment">-- 删除列</span></span><br><span class="line"><span class="operator">|</span> RENAME <span class="keyword">TO</span> <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span> <span class="comment">-- 修改表名</span></span><br><span class="line"><span class="operator">|</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span> <span class="comment">-- 修改字符集</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span> &#125; <span class="comment">-- 修改校对规则（比较和排序时用到）</span></span><br></pre></td></tr></table></figure>
<h3><span id="删除数据库表格">删除数据库表格</span></h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名<span class="number">1</span> [ ,表名<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3><span id="创建查询命令">创建查询命令</span></h3>
<h3><span id="修改查询命令">修改查询命令</span></h3>
<h3><span id="删除查询命令">删除查询命令</span></h3>
<h3><span id="删除数据表内容">删除数据表内容</span></h3>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>0-9 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>0-9 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
  <entry>
    <title>类加载的初始化顺序</title>
    <url>/post/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2><span id="静态代码块">静态代码块</span></h2>
<ul>
<li>
<p>随着类的加载而运行，只执行一次</p>
</li>
<li>
<p>当出现多个静态代码块(包括静态属性赋值）时，按顺序执行</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(Order.i);		<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="构造代码块">构造代码块</span></h2>
<ul>
<li>随着对象的创建而运行，且先于构造函数的执行</li>
<li>有多个构造代码块时，也按顺序执行</li>
</ul>
<h2><span id="构造器">构造器</span></h2>
<ul>
<li>与类名同名的，通过new运算符来新建一个类的实例的函数。可以同时拥有多个不同参数类型顺序的构造器</li>
<li>当未定义任何构造器时，编译器会默认提供一个无参的构造器</li>
</ul>
<span id="more"></span>
<h2><span id="执行顺序">执行顺序</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Order();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">静态代码块</span><br><span class="line">构造代码块</span><br><span class="line">构造器</span><br><span class="line">===============</span><br><span class="line">构造代码块</span><br><span class="line">构造器</span><br></pre></td></tr></table></figure>
<p>可以看出</p>
<ol>
<li>静态代码块&gt;&gt;构造代码块&gt;&gt;构造器</li>
<li>不管new几次对象，静态代码块都只执行一次，而构造代码块和构造器每次创建对象时都会执行</li>
</ol>
<h2><span id="继承的情况">继承的情况</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Inheritance</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> GrandChild();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> GrandChild();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;父类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Child</span> <span class="title">extends</span> <span class="title">Parent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;子类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GrandChild</span> <span class="title">extends</span> <span class="title">Child</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    GrandChild()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;孙子类的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">父类的静态代码块</span><br><span class="line">子类的静态代码块</span><br><span class="line">孙子类的静态代码块</span><br><span class="line">父类的构造代码块</span><br><span class="line">父类的构造器</span><br><span class="line">子类的构造代码块</span><br><span class="line">子类的构造器</span><br><span class="line">孙子类的构造代码块</span><br><span class="line">孙子类的构造器</span><br><span class="line">===============</span><br><span class="line">父类的构造代码块</span><br><span class="line">父类的构造器</span><br><span class="line">子类的构造代码块</span><br><span class="line">子类的构造器</span><br><span class="line">孙子类的构造代码块</span><br><span class="line">孙子类的构造器</span><br></pre></td></tr></table></figure>
<h3><span id="子类对象实例化过程">子类对象实例化过程</span></h3>
<ol>
<li>
<p>首先不断向上查找直至到达顶层父类Object，然后不断向下依次调用父类的构造器进行父特征的初始化</p>
</li>
<li>
<p>然后向下依次执行静态代码块（静态代码块随着类的加载执行且执行一次，再次创建对象无需加载类）</p>
</li>
<li>
<p>接着依次创建对象，依次执行构造代码块、构造器</p>
</li>
<li>
<p>直到创建完所有子类对象</p>
<p><a href="../super/#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">若父类定义了有参构造器而没定义无参构造器，此时子类的构造器会报错</a></p>
</li>
</ol>
<h2><span id="静态内部类">静态内部类</span></h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;外部类构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticInnerClass</span>&#123;</span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的构造器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的静态代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的构造代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span>()</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;静态内部类的静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">class</span> <span class="title">InnerClass</span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;实例内部类的构造器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*static void testMethod()&#123;					//编译报错</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;实例内部类静态方法&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        static&#123;									   //编译报错</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;实例内部类静态代码块&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;实例内部类的构造代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="外部类执行顺序">外部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类构造代码块</span><br><span class="line">外部类构造器</span><br></pre></td></tr></table></figure>
<h3><span id="外部类静态方法执行顺序">外部类静态方法执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.testMethod();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类静态方法</span><br></pre></td></tr></table></figure>
<ul>
<li>执行静态方法时，先加载类和静态代码块</li>
<li>不创建类实例对象，直接访问静态方法</li>
</ul>
<h3><span id="静态内部类执行顺序">静态内部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticInnerClass();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">静态内部类的静态代码块</span><br><span class="line">静态内部类的构造代码块</span><br><span class="line">静态内部类的构造器</span><br></pre></td></tr></table></figure>
<ul>
<li>首先加载外部类以及外部类静态代码块，但没有创建外部类实例对象</li>
<li>接着顺序执行构造静态内部类实例对象</li>
</ul>
<h3><span id="静态内部类静态方法执行顺序">静态内部类静态方法执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.StaticInnerClass.testMethod();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">静态内部类的静态代码块</span><br><span class="line">静态内部类的静态方法</span><br></pre></td></tr></table></figure>
<ul>
<li>同样加载了外部类及外部类静态代码块，但没有创建外部类实例对象</li>
<li>加载了当前内部类及静态代码块，但没有创建内部类实例对象</li>
</ul>
<h3><span id="实例内部类执行顺序">实例内部类执行顺序</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">--------------------------------------------</span><br><span class="line">外部类静态代码块</span><br><span class="line">外部类构造代码块</span><br><span class="line">外部类构造器</span><br><span class="line">实例内部类的构造代码块</span><br><span class="line">实例内部类的构造器</span><br></pre></td></tr></table></figure>
<ul>
<li>先后创建了外部类、内部类的实例对象</li>
</ul>
<p><strong>结论</strong>：<br>
静态内部类并不会随着外部类的初始化而被初始化，而是当静态内部类的方法被调用时，静态内部类才被初始化。反之，静态内部类被调用时，仅加载了外部类及外部类静态代码块，并没有创建外部类实例对象</p>
<table>
<thead>
<tr>
<th></th>
<th>类的执行顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>不含继承关系、不含内部类</td>
<td>静态代码块&gt;&gt;构造代码块&gt;&gt;构造器，静态代码块随类的加载只执行一次</td>
</tr>
<tr>
<td>含继承关系</td>
<td>访问子类对象时，从上向下依次加载类和静态代码块，再依次创建对象（构造代码块&gt;&gt;构造器）</td>
</tr>
<tr>
<td>含内部类</td>
<td>访问内部类对象时，无论静态或非静态，都先加载外部类及外部类静态代码块，不创建外部实例对象，然后创建内部类对象</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot统一异常处理与信息返回</title>
    <url>/post/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E8%BF%94%E5%9B%9E/</url>
    <content><![CDATA[<h2><span id="异常处理">异常处理</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(value = &#123;Exception.class&#125;)</span><span class="comment">//value=&#123;&#125;可省略</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Resp&lt;T&gt; <span class="title function_">exceptionHandler</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//这里先判断拦截到的Exception是不是我们自定义的异常类型</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> AppException)&#123;</span><br><span class="line">            <span class="type">AppException</span> <span class="variable">appException</span> <span class="operator">=</span> (AppException)e;</span><br><span class="line">            <span class="keyword">return</span> Resp.error(appException.getCode(),appException.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果拦截的异常不是我们自定义的异常(例如：数据库主键冲突)</span></span><br><span class="line">        <span class="keyword">return</span> Resp.error(<span class="number">500</span>,<span class="string">&quot;服务器端异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Resp&lt;String&gt; <span class="title function_">demo1</span><span class="params">(String name)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;ok&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> Resp.success(<span class="string">&quot;succ&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;err&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="comment">//抛业务相关的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(AppExceptionCodeMsg.USERNAME_NOT_EXISTS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;errcode&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(AppExceptionCodeMsg.INVALID_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;0&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查用户积分是否足够，如果不够，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;notenough&quot;</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(AppExceptionCodeMsg.USER_CREDIT_NOT_ENOUTH);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Resp.success(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Resp&lt;List&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Resp.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="信息返回">信息返回</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resp</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端返回的错误码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//服务端返回的错误信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="comment">//我们服务端返回的数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Resp</span><span class="params">(<span class="type">int</span> code,String msg,T data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">success</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(<span class="number">200</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">success</span><span class="params">(String msg,T data)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(<span class="number">200</span>,msg, data);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">error</span><span class="params">(AppExceptionCodeMsg appExceptionCodeMsg)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(appExceptionCodeMsg.getCode(), appExceptionCodeMsg.getMsg(), <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Resp <span class="title function_">error</span><span class="params">(<span class="type">int</span> code,String msg)</span>&#123;</span><br><span class="line">        <span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resp</span>(code,msg, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="枚举">枚举</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个枚举类中定义的都是跟业务有关的异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AppExceptionCodeMsg</span> &#123;</span><br><span class="line"></span><br><span class="line">    INVALID_CODE(<span class="number">10000</span>,<span class="string">&quot;验证码无效&quot;</span>),</span><br><span class="line">    USERNAME_NOT_EXISTS(<span class="number">10001</span>,<span class="string">&quot;用户名不存在&quot;</span>),</span><br><span class="line">    USER_CREDIT_NOT_ENOUTH(<span class="number">10002</span>,<span class="string">&quot;用户积分不足&quot;</span>);</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code ;</span><br><span class="line">    <span class="keyword">private</span> String msg ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    AppExceptionCodeMsg(<span class="type">int</span> code, String msg)&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="自定义异常类">自定义异常类</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;服务器异常&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(AppExceptionCodeMsg appExceptionCodeMsg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.code = appExceptionCodeMsg.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = appExceptionCodeMsg.getMsg();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(<span class="type">int</span> code,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id></span></h2>
]]></content>
      <categories>
        <category>第四阶段</category>
      </categories>
  </entry>
  <entry>
    <title>继承</title>
    <url>/post/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>is a”代表的是类之间的继承关系，比如PC机是计算机，工作站也是计算机。PC机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java语言实现时，应该将PC机和工作站定义成两种类，均继承计算机类。</p>
<p>“has a”代表的是对象和它的成员的从属关系。同一种类的对象，通过它们的属性的不同值来区别。比如一台PC机的操作系统是Windows，另一台PC机的操作系统是Linux。操作系统是PC机的一个成员变量，根据这一成员变量的不同值，可以区分不同的PC机对象。</p>
<p>is a 是如果A是B，那么B就是A的基类。比如：等边三角形是使是三角形，那么，三角形就是等边三角形的基类。<br>
has a 是如果A中有B，那么，B就是A的组成部分</p>
<p>如果你确定两件对象之间是is-a的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承而不是聚合。<br>
如果你确定两件对象之间是has-a的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类，而不是从电脑类继承。</p>
<span id="more"></span>
<p>如果多个类有着共同的属性,并且类之间符合is a 的关系，可以将共性的抽取到一个类中,作为父类,</p>
<p>别的类通过使用extends继承它,进而获取它的所有的成员(处理构造器)</p>
<h2><span id="意义">意义</span></h2>
<p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个 类无需再定义这些属性和行为，只要继承那个类即可。</p>
<h2><span id="使用">使用</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类:继承其他类的类,又叫派生类</li>
<li>父类:被继承的类,又叫基类或者超类</li>
</ul>
<ol>
<li>Java只支持单继承,不能多继承,支持多级继承</li>
<li>如果继承了一个类,那么就拥有了除了构造方法之外的父类的所有的成员(属性和方法)</li>
<li>私有成员(private)不能被继承的,引用了私有成员的方法可以被子类继承的</li>
</ol>
<p>静态成员也是被继承的(没有意义)</p>
<h2><span id="方法的重写">方法的重写</span></h2>
<p>当子类从父类中继承过来的方法不满足自身的要求的时，在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将代替父类的方法执行。</p>
<table>
<thead>
<tr>
<th></th>
<th>子类重写后的方法、父类被重写的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法名称、参数列表</td>
<td>相同</td>
</tr>
<tr>
<td>异常、返回值类型</td>
<td>小于等于</td>
</tr>
<tr>
<td>访问权限</td>
<td>大于等于</td>
</tr>
</tbody>
</table>
<ul>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>
<li>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)， 或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法重写属于父类的方法。</li>
</ul>
<h3><span id="重载overload和重写override">重载(Overload)和重写(Override)</span></h3>
<table>
<thead>
<tr>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>在一个类中</td>
<td>在子类和父类中</td>
</tr>
<tr>
<td>同名方法的参数列表不同(参数类型，参数个数以及参数顺序)</td>
<td><strong>同名方法的参数列表都必须相同</strong></td>
</tr>
<tr>
<td>返回类型没有要求</td>
<td><strong>返回类型与父类一致（引用类型要能向上转型）</strong></td>
</tr>
<tr>
<td>访问权限没有要求</td>
<td>相比于重写前的方法，<strong>访问权限不能更低</strong></td>
</tr>
<tr>
<td>异常没有要求</td>
<td>相比于重写前的方法，不能申明更加宽泛的检查型异常</td>
</tr>
<tr>
<td>实现类中的多态（编译时的多态性）</td>
<td>多态的前提（运行时的多态性）</td>
</tr>
</tbody>
</table>
<h2><span id="访问权限修饰符">访问权限修饰符</span></h2>
<p>在类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<p>（public&gt;protected&gt;default&gt;private)</p>
<table>
<thead>
<tr>
<th>访问权限修饰符</th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>类内部</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>同包</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>不同包子类</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>同一个工程</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>其中，对于class的权限修饰只可以用public和default(缺省)。</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>编码与数制</title>
    <url>/post/%E7%BC%96%E7%A0%81%E4%B8%8E%E6%95%B0%E5%88%B6/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<p>1、2、3、4……，我们从小便学习这么计数，并使用到现在。但是这样的计数方式从何而来呢？又如何发展成如今计算机的计数方式？</p>
<span id="more"></span>
<p>罗马人从使用手指计数到在羊皮上画出Ⅰ、Ⅱ、Ⅲ来代替手指的字符，他们定义出了能够表示不同个数的符号，并随后引出了X(十)、C(百)、(M)千等等符号。随着要表示的数量越来越多，他们不得不引出更多的符号。</p>
<p>印度人发明了如今成为国际通用的阿拉伯数字，与罗马人的计数方式相比，阿拉伯数字不需要不断引出新的符号，而是用数字的位置来表示，高位在左，低位在右，传入欧洲后，加上逢十进一，演变成如今人们使用的数字计数，即十进制计数法（D)。</p>
<h1><span id="进位计数法">进位计数法</span></h1>
<h2><span id="r进制计数法">r进制计数法</span></h2>
<p>r进制计数法是从十进制计数法中抽象出来的概念，r可以表示任何整数，逢r进一</p>
<p>相比于传统计数方法，r进制计数法</p>
<ul>
<li>
<p>利用了数字位置的信息</p>
<p>每个数位表示不同的常数，第0位表示r<sup>0</sup>,第1位表示r<sup>1</sup>……</p>
<p>（从0开始）第i位表示r<sup>i</sup>，r<sup>i</sup>就是第i位的<strong>位权</strong></p>
</li>
<li>
<p>每个数位使用r种不同数码</p>
<p>r就是<strong>基数</strong></p>
<p>真实的数字 = 累加 （每个数位的数字	乘以	该位的位权）</p>
<blockquote>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
</li>
</ul>
<h2><span id="二进制计数法">二进制计数法</span></h2>
<p>在计算机中使用高电平和低电平两种稳定状态的电子器件，因而使用二进制来表示计算机中的数据</p>
<p>二进制中的1、0对应了逻辑中的真、假，为逻辑运算提供便利条件</p>
<p>常用的还有<strong>八进制计数法（O）、十六进制计数法（H）</strong></p>
<h1><span id="不同进制间的转换">不同进制间的转换</span></h1>
<p>为了深入了解不同进制表示的数据，还需分析不同进制间的转换</p>
<h2><span id="任意进制-gt-十进制">任意进制 -&gt; 十进制</span></h2>
<h3><span id="按权展开相加法">按权展开相加法</span></h3>
<p>累加 （每个数位的数字	乘以	该位的位权）</p>
<h2><span id="二进制-gt-八进制-十六进制">二进制 -&gt; 八进制 、十六进制</span></h2>
<ul>
<li>二进制的3个数位最多能表示8个数字</li>
<li>二进制的4个数位最多能表示16个数字</li>
</ul>
<p>二进制 -&gt; 八进制 ：</p>
<ol>
<li>小数点左边：3位1组-&gt;最左边补0凑3位</li>
<li>小数点右边：3位1组-&gt;最右边补0凑3位</li>
<li>每组转化成八进制数</li>
</ol>
<p>二进制 -&gt; 十六进制：</p>
<ol>
<li>小数点左边：4位1组-&gt;最左边补0凑4位</li>
<li>小数点右边：4位1组-&gt;最右边补0凑4位</li>
<li>每组转化成十六进制数</li>
</ol>
<h2><span id="八进制-十六进制-gt-二进制">八进制 、十六进制 -&gt; 二进制</span></h2>
<p>八进制 -&gt; 二进制 ：1位 -&gt; 3位二进制数</p>
<p>十六进制 -&gt; 二进制：1位 -&gt; 4位二进制数</p>
<p>最后去掉最高位最小位的0</p>
<h2><span id="八进制-gt-十六进制">八进制 -&gt; 十六进制</span></h2>
<p>以二进制为桥梁  八进制-&gt;二进制-&gt;十六进制</p>
<h2><span id="十进制-gt-二进制">十进制 -&gt; 二进制</span></h2>
<h3><span id="基数乘除法">基数乘除法</span></h3>
<p>进位计数法有效利用了数码的位置信息，如何借助数字位置信息实现进制转换呢？</p>
<blockquote>
<p>对于一个r进制数：K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
<p>乘以基数r</p>
<blockquote>
<p>r*(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)</p>
<p>=r*(K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)</p>
<p>=K<sub>n</sub>*r<sup>n+1</sup>+K<sub>n-1</sub>*r<sup>n</sup>+…+K<sub>2</sub>*r<sup>3</sup>+K<sub>1</sub>*r<sup>2</sup>+K<sub>0</sub>*r<sup>1</sup>+K<sub>-1</sub>*r<sup>0</sup>+K<sub>-2</sub>*r<sup>-1</sup>+…+K<sub>-m</sub>*r<sup>-m+1</sup>+0*r<sup>m</sup></p>
<p>=K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>0</p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生左移，并在最右边一位补0</p>
<p>除以基数r</p>
<blockquote>
<p>(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)\r</p>
<p>= (K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)\r</p>
<p>=0*r<sup>n</sup>+K<sub>n</sub>*r<sup>n-1</sup>+K<sub>n-1</sub>*r<sup>n</sup>-2+…+K<sub>2</sub>*r<sup>1</sup>+K<sub>1</sub>*r<sup>0</sup>+K<sub>0</sub>*r<sup>-1</sup>+K<sub>-1</sub>*r<sup>-2</sup>+K<sub>-2</sub>*r<sup>-3</sup>+…+K<sub>-m</sub>*r<sup>-m-1</sup></p>
<p>=0K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生右移，并在最左边一位补0</p>
<table>
<thead>
<tr>
<th></th>
<th>第n+1位</th>
<th>第n位</th>
<th>第n-1位</th>
<th>…</th>
<th>第2位</th>
<th>第1位</th>
<th>第0位</th>
<th>第-1位</th>
<th>…</th>
<th>第-(m-1)</th>
<th>第-m位</th>
<th>第-(m+1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>原数</td>
<td></td>
<td>Kn</td>
<td>Kn-1</td>
<td>…</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>…</td>
<td>K-(m-1)</td>
<td>K-m</td>
<td></td>
</tr>
<tr>
<td>乘以基数r</td>
<td>Kn</td>
<td>Kn-1</td>
<td>Kn-2</td>
<td>…</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>K-2</td>
<td>…</td>
<td>K-m</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>除以基数r</td>
<td></td>
<td>0</td>
<td>Kn</td>
<td>…</td>
<td>K3</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>…</td>
<td>K-(m-2)</td>
<td>K-(m-1)</td>
<td>K-m</td>
</tr>
</tbody>
</table>
<h4><span id="对于整数除基取余法">对于整数：除基取余法</span></h4>
<p>将数字除以基数，相当于右移了数字，小数点右边的为余数，先除得的余数为低位，即二进制的最低位</p>
<p>继续将商除以基数，继续右移，直到商为0，后除得的余数为高位</p>
<p><strong>除基取余，先余为低，后余为高，商0结束</strong></p>
<h4><span id="对于小数乘基取整法">对于小数：乘基取整法</span></h4>
<p>将数字乘以基数，相当于左移了数字，小数点左边的为高位</p>
<p>此时乘积的结构为： 高位数码（整数部分） + 剩余数  (**.**K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)*r =  K<sub>-1</sub> <strong>.</strong> K<sub>-2</sub>…K<sub>-m</sub></p>
<p>乘积减去高位数码得到剩余数，再将剩余数继续乘基数，重复以上步骤，直到高位数码为0</p>
<p><strong>乘基取整，先整为高，后整为低，整0结束</strong></p>
<p>注意：不是每个小数都能用二进制表示</p>
<h3><span id="拼凑法">拼凑法</span></h3>
<p>在十进制转换为二进制中，大小适中的数字，可以通过位权凑出数字</p>
<table>
<thead>
<tr>
<th style="text-align:left">2<sup>-4</sup></th>
<th style="text-align:left">2<sup>-3</sup></th>
<th style="text-align:left">2<sup>-2</sup></th>
<th style="text-align:left">2<sup>-1</sup></th>
<th style="text-align:left">2<sup>0</sup></th>
<th style="text-align:left">2<sup>1</sup></th>
<th style="text-align:left">2<sup>2</sup></th>
<th style="text-align:left">2<sup>3</sup></th>
<th style="text-align:left">2<sup>4</sup></th>
<th style="text-align:left">2<sup>5</sup></th>
<th style="text-align:left">2<sup>6</sup></th>
<th style="text-align:left">2<sup>7</sup></th>
<th style="text-align:left">2<sup>8</sup></th>
<th style="text-align:left">2<sup>9</sup></th>
<th style="text-align:left">2<sup>10</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0.0625</td>
<td style="text-align:left">0.125</td>
<td style="text-align:left">0.25</td>
<td style="text-align:left">0.5</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">4</td>
<td style="text-align:left">8</td>
<td style="text-align:left">16</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64</td>
<td style="text-align:left">128</td>
<td style="text-align:left">256</td>
<td style="text-align:left">512</td>
<td style="text-align:left">1024</td>
</tr>
</tbody>
</table>
<p>75.325D = 64 + 8 + 2 + 1 + 0.25 + 0.125 = 2<sup>6</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> + 2<sup>-2</sup> + 2<sup>-3</sup> = 1001011.011B</p>
<p>在了解了计算机的进位计数法及不同进制的转换后，便可以学习如何将生活中的数存入计算机</p>
<h1><span id="整数的表示">整数的表示</span></h1>
<p>在日常生活中带正负号的数，我们通常称为 <strong>真值</strong></p>
<p>将数据<strong>符号数字化</strong>后并能够存储到计算机中的数称为 <strong>机器数</strong>。</p>
<p>先看简化的无符号整数（以下都是二进制计数）</p>
<h2><span id="无符号整数">无符号整数</span></h2>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub></p>
<ul>
<li>没有符号位，默认为正号</li>
<li>最大值为：2<sup>n+1</sup>-1，最小值为0</li>
</ul>
<h3><span id="加法运算">加法运算</span></h3>
<blockquote>
<p>1+1 = 0001 + 0001 = 0010B = 2D</p>
</blockquote>
<h3><span id="减法运算">减法运算</span></h3>
<p>减法只考虑正数减正数：</p>
<ol>
<li>正数减负数、负数减正数本质上是加法，</li>
<li>负数减负数其实也就是正数减正数</li>
</ol>
<blockquote>
<p>2-1 = 0010 - 0001 = 0001 =1D</p>
</blockquote>
<p>实际上，早期的计算机中设有关于减法的相关电路，复杂的电路伴随着高昂的成本，因此如今的计算机逻辑运算单元中，只有加法器进行加法的运算，减法的运算也是通过加法器实现。那么如何通过加法运算实现减法呢？</p>
<h3><span id="钟表时针">钟表时针</span></h3>
<p>类似于钟表的时针：如果说现在时针现在停在10点钟，那么什么时候时针会停在8点钟呢？</p>
<p>时针倒拨2小时，或是正拨10小时，超过12小时后，时针将走第二圈，并最终停在8点钟</p>
<blockquote>
<p>10 - 2 = 8，10 + 10 = 20 = 12 + 8</p>
<p>即 (10 - 2) mod 12 = 8</p>
<p>​	(10 + 10) mod 12 = 8</p>
</blockquote>
<ul>
<li>
<p>mod就是<strong>取模运算</strong>，它们除以整数12，并计算最后的余数</p>
</li>
<li>
<p>8和20对于模12<strong>同余</strong>(有着相同的余数)，它们将共同停在余数8点钟</p>
</li>
</ul>
<h3><span id="取模运算">取模运算</span></h3>
<p>对整数a、b，取模运算就是a除以b，并计算余数（模余），记作</p>
<blockquote>
<p>a Mod b = a - [a/b]*b，[a/b]为向下取整</p>
</blockquote>
<p>如：20 Mod 12 = 20 - [20/12]*12 = 20 - 1*12 = 8</p>
<h3><span id="同余">同余</span></h3>
<p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余,记作</p>
<blockquote>
<p>a Mod r =  b Mod r =&gt; a ≡ b (mod m)</p>
<p>性质：<strong>a、b满足a-b为r的整数倍</strong></p>
</blockquote>
<h3><span id="思考">思考</span></h3>
<p>与钟表时针相比，计算机计数也有相似的地方：</p>
<table>
<thead>
<tr>
<th style="text-align:left">钟表时针</th>
<th style="text-align:left">计算机计数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">钟表时针取值只有[0-11]，超过12后会从0重新开始</td>
<td style="text-align:left">计算机作二进制表示的数位有限，超过一定数值也会重新开始计数</td>
</tr>
<tr>
<td style="text-align:left">将时针倒拨可以通过正拨等价实现</td>
<td style="text-align:left">计算机减法也可以使用加法等价实现</td>
</tr>
<tr>
<td style="text-align:left">(10-2) mod 12 = (10+10) mod 12</td>
<td style="text-align:left">(x - a) Mod r = (x + b) Mod r</td>
</tr>
<tr>
<td style="text-align:left">(10-2) ≡ (10+10) (mod 12)</td>
<td style="text-align:left">(x-a) ≡ (x+ b) (mod r)</td>
</tr>
</tbody>
</table>
<ul>
<li>x - a与x + b同余</li>
<li>根据<a href="#%E5%90%8C%E4%BD%99">同余的性质</a>，(x+ b) - (x-a) = r*Z，化简得 b = r*Z - a	（Z为整数、r为模）</li>
</ul>
<p>为了方便计算，可以只找离模最近的数，取Z = 1，即 b = r - a</p>
<p>也就是说，减法中减去a与加上 <strong>r - a</strong>等价，但r - a中仍存在减法，</p>
<p>这时需要利用计算机中的取反操作：</p>
<blockquote>
<p><strong>r  = a + ~a +1</strong>	（~为取反符号）</p>
</blockquote>
<p>二进制中任何一个数与它取反后的数相加，都会得到每个位为1的数，此时加上1就能得到该位下的模</p>
<blockquote>
<p>b = r - a = ~a +1</p>
</blockquote>
<p>x减去a 可以等价成 x 加上取反后的a加1，即</p>
<blockquote>
<p><strong>x - a = x + b =  x + ~a + 1</strong></p>
</blockquote>
<p>至此，减法运算可以仅通过加法、取反来实现</p>
<h2><span id="带符号整数">带符号整数</span></h2>
<h3><span id="原码">原码</span></h3>
<p>接着引入符号位的概念，最高位为符号位，正数为0，负数为1</p>
<p>符号位与真值的绝对值构成了原码</p>
<blockquote>
<p>[1]<sub>原</sub> = 0001	[-1]<sub>原</sub> = 1001</p>
</blockquote>
<p>8位的原码表示范围为：</p>
<blockquote>
<p>​	1111 1111 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4><span id="原码的运算">原码的运算</span></h4>
<ul>
<li>原码中的符号位仅用来表示数的正、负，不参加运算，只有数值部分参与运算</li>
<li>原码运算时，先比较两个数的符号，若两个数的符号相同，则将两个数的相加，最后加上符号</li>
<li>若两数的符号不同，则需比较两数的数值大小，然后将数值较大的数减去数值较小的数，并将数值较大的数的符号作为最后结果的符号。</li>
</ul>
<h3><span id="补码">补码</span></h3>
<p>回顾<a href="#%E6%80%9D%E8%80%83">无符号整数的减法运算</a>，x减去a 可以等价成 x 加上取反后的a加1</p>
<h4><span id="补码引言">补码引言</span></h4>
<p>无符号4位2进制的模为2<sup>4</sup></p>
<blockquote>
<ol>
<li>被减数-减数 = 0：1 - 1 = 0001 + 1111 = 1)0000B = 0D</li>
<li>被减数-减数 &gt; 0：2 - 1 = 0010 + 1111 = 1)0001B = 1D</li>
<li>被减数-减数 &lt; 0：1 - 2 = 0001 + 1110 = 1111B = 15D(16 - 1)</li>
</ol>
</blockquote>
<p>结果都比原来多了2<sup>4</sup>,都多加了一个模</p>
<ol>
<li>对于被减数 - 减数 &gt;= 0，忽视溢出位，数值位等于实际值</li>
<li>对于被减数 - 减数 &lt; 0，还需减去一个模，a - r = a - (a + ~a + 1) = -(~a + 1)，数值位才等于实际值</li>
</ol>
<p>我们继续整合符号位，当符号位中0表示负号，1表示正号时，符号位参与运算后为1</p>
<ul>
<li>对于被减数 - 减数 &gt;= 0，溢出位参与符号位的运算恰好使得结果的符号为正</li>
<li>对于被减数 - 减数&lt; 0，符号位不变表示结果小于0，恰好表示了 -(~a + 1)中的负号</li>
<li>对于减数，将x - a = x+ b 看作 x -a = x + [-a]<sub>新的形式</sub>，- a = [-a]<sub>新的形式</sub></li>
</ul>
<h4><span id="小结">小结</span></h4>
<p>加上符号位的减法运算，我们可以总结出：</p>
<ol>
<li>减法变加法，减数看成负数，数值位为按位取反后加1，符号位为1</li>
<li>符号位应为数值位高一位，参与加法运算</li>
<li>结果如果符号位为0则不变，如果符号为1，符号位不变，作 取反加1 的变换</li>
</ol>
<p>至此，补码的定义逐渐清晰起来</p>
<h4><span id="定义">定义</span></h4>
<ul>
<li>补码的符号位为数值位高一位，0表示负，1表示正</li>
<li>正数的补码与原码一致，负数的补码符号位不变，数值位作 取反加1</li>
</ul>
<p>8位的补码表示范围为：</p>
<p>​	1111 1111 ~ 0111 1111，补码没有-0的结果，补码中的1000 0000表示-128</p>
<p>(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub> + [1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub> = -128D</p>
<p>表示范围：-128 ~ 127</p>
<h4><span id="补码的加法">补码的加法</span></h4>
<p>最低位开始，按位相加，并往高位进位（符号位参与运算）</p>
<h4><span id="补码的减法">补码的减法</span></h4>
<p>减法变加法，减数看成负数，被减数的补码加上减数的负数的补码，，减数符号位为1不变，数值位为按位取反后加1</p>
<p>有符号5位2进制的模为2<sup>5</sup>，第5位为符号位</p>
<blockquote>
<p><strong>[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></strong></p>
</blockquote>
<ol>
<li>被减数-减数 = 0	[1]<sub>补</sub> - [1]<sub>补</sub> = [1]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0000]<sub>补</sub> = 0D</li>
<li>被减数-减数 &gt; 0	[2]<sub>补</sub> - [1]<sub>补</sub> = [2]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0010 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0001]<sub>补</sub> = 1D</li>
<li>被减数-减数 &lt; 0	[1]<sub>补</sub> - [2]<sub>补</sub> = [1]<sub>补</sub> + [-2]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1110]<sub>补</sub> = [<u>1</u>1111]<sub>补</sub>= -1D</li>
</ol>
<p>结果还是补码，计算机内，所有带符号整数的加减法都先转换为补码</p>
<h4><span id="补码lt-gt原码">补码&lt;-&gt;原码</span></h4>
<ol>
<li>
<p>在补码减法运算中，[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub>；根据原码、补码定义，[b]<sub>补</sub> = [b]<sub>原</sub>，-[b]<sub>原</sub> = [-b]<sub>原</sub>，</p>
<blockquote>
<p>[a]<sub>原</sub> + [-b]<sub>原</sub> = [a]<sub>原</sub> - [b]<sub>原</sub> =  [a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></p>
</blockquote>
</li>
</ol>
<p>也就是 [-b]<sub>原</sub>到 [-b]<sub>补</sub>的转换，[-b]<sub>原</sub>的符号位为1不变，数值位按位取反后加1</p>
<ol start="2">
<li>而被减数-减数 &lt; 0，结果为补码，要转换成原码，符号位为1不变，还需将数值位按位取反后加1</li>
</ol>
<p>总结：补码与原码之间的转换相同，正数不变，负数符号位为1不变，数值位按位取反后加1</p>
<h3><span id="反码">反码</span></h3>
<p>在使用补码作减法运算中，对于正数用不到按位取反的操作，而多次将负数的数值位按位取反再加一，将数值位按位取反也定义成新的形式，这个新的形式就是反码</p>
<h4><span id="定义">定义</span></h4>
<ul>
<li>反码的最高位为符号位，符号位为1为负数，符号位为0则为负数</li>
<li>正数的反码与原码相同，负数的反码符号位为1不变，数值位按位取反</li>
</ul>
<p>8位的反码表示范围为：</p>
<blockquote>
<p>​	1000 0000 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4><span id="反码-gt-补码">反码 -&gt; 补码</span></h4>
<p>[X]<sub>补</sub> = [X]<sub>反</sub> + 1</p>
<h3><span id="移码">移码</span></h3>
<p>移码的符号位用“1”表示正数，用“0”表示负数，数值部分与补码相同。</p>
<p>常用于表示浮点数的阶码</p>
<h2><span id="总结">总结</span></h2>
<table>
<thead>
<tr>
<th>n + 1 bit</th>
<th>无符号整数</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
<th>移码</th>
</tr>
</thead>
<tbody>
<tr>
<td>表示范围</td>
<td>0 ~ 2<sup>n+1</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最大值</td>
<td>11…11=2<sup>n+1</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11=2<sup>n</sup>-1</td>
<td>1,11…11=2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最小值</td>
<td>00…00 = 0</td>
<td>1,11…11 = -(2<sup>n</sup>-1)</td>
<td>1,00…00 = -(2<sup>n</sup>-1)</td>
<td>1,00…00=-(2<sup>n</sup>)</td>
<td>0,00…00=-(2<sup>n</sup>)</td>
</tr>
<tr>
<td>0的表示</td>
<td>00…00</td>
<td>[+0]<sub>原</sub>=0,00…00,[-0]<sub>原</sub>=1,00…00</td>
<td>[+0]<sub>反</sub>=0,00…00[-0]<sub>反</sub>=1,11…11</td>
<td>[0]<sub>补</sub>=0,00…00</td>
<td>[0]<sub>移</sub>=1,00…00</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63993b6ab1fccdcd36b1b146.png" alt="相互转换"></p>
<h1><span id="定点数的表示">定点数的表示</span></h1>
<p>定点数约定小数点的位置不变，定点纯整数约定了小数点在数值位的最后。定点纯小数约定了数值位的最高位在小数点后面。</p>
<h2><span id="定点小数的原码-反码表示">定点小数的原码、反码表示</span></h2>
<p>​	整数符号位后接，号，小数符号位接.号</p>
<h2><span id="定点小数的补码">定点小数的补码</span></h2>
<p>​	定点小数的补码加减法运算同带符号整数的补码加减法运算</p>
<h2><span id="位数扩展">位数扩展</span></h2>
<p>定点小数与定点整数做时，扩展位置不同</p>
<ul>
<li>定点小数右边扩展</li>
<li>定点整数在符号位后一位扩展</li>
</ul>
<h1><span id="浮点数的表示">浮点数的表示</span></h1>
<p>浮点数是与定点数相对的概念，定点数约定小数点的位置不变。</p>
<p>使用定点数表示时，当定点数占用的字长多而有效数字少时，就会造成存储空间的浪费；使用浮点数表示，合理改变小数点的位置，仅存储有效数字和2次幂信息，在位数有限的情况下，既扩大了数的表示范围，又保留了数的有效精度</p>
<h2><span id="浮点数的形式">浮点数的形式</span></h2>
<p>浮点数由尾数M和阶码E构成。基数为2的数F的浮点数表示为：</p>
<blockquote>
<p>F = M*2<sup>E</sup></p>
</blockquote>
<ul>
<li>尾数M存储有效数字，尾数反映数字的精度</li>
<li>阶码E存储2次幂信息，阶码反映表示范围，以及小数点的位置</li>
</ul>
<h3><span id="浮点数编码规则">浮点数编码规则</span></h3>
<table>
<thead>
<tr>
<th>阶符</th>
<th>阶码</th>
<th>数符</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>k位</td>
<td>1位</td>
<td>n位</td>
</tr>
<tr>
<td>阶码的正负</td>
<td>数值大小</td>
<td>浮点数的正负</td>
<td>数值精度</td>
</tr>
</tbody>
</table>
<ul>
<li>尾数M必须为<strong>小数</strong>，用n+1位有符号定点小数表示，可采用的原码，补码。</li>
<li>阶码E必须为<strong>整数</strong>，用k+1位有符号定点整数表示，可采用原码，补码，移码。</li>
<li>浮点数编码的位数m=(n+1)+(k+1)</li>
</ul>
<h2><span id="非规格化浮点数">非规格化浮点数</span></h2>
<p>当对尾数M只要求是小数而无其他限制时，此时的浮点数被称为非规格化浮点数。</p>
<p>假设阶码和尾数都用原码表示，则非规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th>阶码和尾数</th>
<th>数值</th>
<th>阶码和尾数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶码最小值</td>
<td>- (2<sup>k</sup>-1)</td>
<td>阶码最大值</td>
<td>2<sup>k</sup>-1</td>
</tr>
<tr>
<td>尾数最小负值</td>
<td>-(1- 2<sup>-n</sup>)</td>
<td>尾数最大负值</td>
<td>-2<sup>-n</sup></td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>2<sup>-n</sup></td>
<td>尾数最大正值</td>
<td>1-2<sup>-n</sup></td>
</tr>
</tbody>
</table>
<p>以8位数值位，一位符号位的阶码为例子： 由于用原码表示，</p>
<p>阶码的最小值：1 11111111 即 -(2^8 - 1) = -255</p>
<p>阶码的最大值：0 0000000 即   2^8 - 1  =  255</p>
<p>尾数也是8位数值位，1为符号位原码的形式：</p>
<p>由于我们限定了浮点数的尾数只能是小数，所以我们当成定点纯小数的形式进行分析：</p>
<p>尾数的最小负值：1.11111111	即-(1- 2<sup>-8</sup>)</p>
<p>尾数的最大负值：1.0000001	即-2<sup>8</sup></p>
<p>尾数的最大正值：0.11111111	即1- 2<sup>-8</sup></p>
<p>尾数的最小正值	0.0000001	即2<sup>8</sup></p>
<h2><span id="规格化浮点数">规格化浮点数</span></h2>
<p>假如一个尾数M用原码表示为0.00000001，那么这8位尾数的前7位都是0，这7个0实际上是无效数值位，我们完全可以改写成：</p>
<blockquote>
<p>0.1XXXXXXX×2<sup>-7</sup></p>
</blockquote>
<p>当1左移到最高位时，尾数后面多出来了7位可以多表示7个有效位来提高精度</p>
<p>规格化浮点数，就是调整一个非规格化浮点数的位数和阶码的大小，使非零的浮点数在尾数的最高位上保证是一个有效值</p>
<p>规格化浮点数使尾数存储空间能表示更多的有效数位</p>
<h3><span id="规范">规范</span></h3>
<p>若尾数M用原码表示，</p>
<ul>
<li>
<p>当M ≥0时，[M]<sub>原</sub> = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M]<sub>原</sub> = 1.1XXXXXXX</p>
<p>若尾数M用补码表示，</p>
</li>
<li>
<p>当M ≥0时，[M] 补 = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M] 补 = 1.0XXXXXXX</p>
</li>
</ul>
<h3><span id="表示范围">表示范围</span></h3>
<p>尾数用原码表示，则规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>数值</th>
<th></th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>尾数最小负值</td>
<td>-(1-2<sup>n</sup>)</td>
<td>尾数最大负值</td>
<td>-1/2</td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>1/2</td>
<td>尾数最大正值</td>
<td>1-2<sup>n</sup></td>
</tr>
</tbody>
</table>
<p>因此规格化浮点数将尾数M的绝对值限定在规定的数值范围之内，即</p>
<blockquote>
<p>1/2 ≤ ∣ M ∣ &lt; 1 （原码）</p>
</blockquote>
<p>要使尾数的绝对值在此范围内，通过改变小数点的位置（相应地改变阶码）就可以做到。</p>
<h3><span id="操作">操作</span></h3>
<table>
<thead>
<tr>
<th>非规格化浮点数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>当运算结果最高位不是有效位时</td>
<td>尾数每左移一位，阶码减一</td>
</tr>
<tr>
<td>当运算结果的尾数的有效位进到小数点前面时</td>
<td>尾数每右移一位，阶码加一</td>
</tr>
</tbody>
</table>
<ul>
<li>判断浮点数是否规格化：尾数最高位是否是有效位</li>
<li>正数补码（原码）而言，有效位都为1；而对于负数补码而言，有效位为0，对于负数原码，有效位为1</li>
<li>特别地，补码表示中，-1/2（1.100000000）不是规格化形式，-1（1.00000000）是规格化形式；，注意不要与原码规格化判定的绝对值范围混淆</li>
</ul>
<h2><span id="ieee-754标准浮点数">IEEE 754标准浮点数</span></h2>
<h3><span id="单精度浮点数">单精度浮点数</span></h3>
<p>IEEE 754规定单精度浮点数的真值N一般表示为：</p>
<blockquote>
<p>N = (-1)<sup>S</sup> * 2<sup>e-127</sup> * 1.f</p>
</blockquote>
<table>
<thead>
<tr>
<th>数符S</th>
<th>阶码e</th>
<th>尾数f</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>8位</td>
<td>23位</td>
</tr>
<tr>
<td>浮点数的正负</td>
<td>含1位阶符，采用移码表示，偏移量127</td>
<td>浮点数的精度，采用原码表示</td>
</tr>
</tbody>
</table>
<ul>
<li>IEEE 754中的阶码采用移码来表示，但对于单精度浮点数来说，移码的偏移量不是2<sup>7</sup>而是2<sup>7</sup> − 1 = 127 ,这是因为IEEE 754将移码编码的全0和全1作为了特殊标识。</li>
<li>IEEE 754浮点数是规格化浮点数，为了能够更多地表示尾数的有效数位，规定尾数真值的整数部分必须为1，尾数编码时整数1隐去，小数部分f用原码表示。</li>
</ul>
<table>
<thead>
<tr>
<th>真值D</th>
<th>补码</th>
<th>移码</th>
<th>阶码真值</th>
</tr>
</thead>
<tbody>
<tr>
<td>-128</td>
<td>1000 0000</td>
<td>0000 0000</td>
<td>/</td>
</tr>
<tr>
<td>-127</td>
<td>1000 0001</td>
<td>0000 0001</td>
<td>1111 1110</td>
</tr>
<tr>
<td>-126</td>
<td>1000 0010</td>
<td>0000 0010</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>-1</td>
<td>1111 1111</td>
<td>0111 1111</td>
<td>0000 0000</td>
</tr>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>1000 0000</td>
<td>0000 0001</td>
</tr>
<tr>
<td>1</td>
<td>0000 0001</td>
<td>1000 0001</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>125</td>
<td>0111 1101</td>
<td>1111 1101</td>
<td></td>
</tr>
<tr>
<td>126</td>
<td>0111 1110</td>
<td>1111 1110</td>
<td></td>
</tr>
<tr>
<td>127</td>
<td>0111 1111</td>
<td>1111 1111</td>
<td></td>
</tr>
</tbody>
</table>
<h4><span id="阶码e全0和全1时的特殊含义">阶码e全0和全1时的特殊含义</span></h4>
<ol>
<li>当阶码全0，且尾数f不全0时，表示该浮点数不是规格化浮点数，尾数实际为：0.XXXXXXXX 次正规数,而不是规定形式的：1.XXXXXXXX</li>
<li>当阶码e全1，且尾数f全为0时，则该浮点数表示正无穷大或负无穷大，当数符s为1时，表示负无穷大，当数符s为0时，表示正无穷大。</li>
<li>当阶码e全1，且尾数f不全为0时，则该浮点数表示非数值数据（NaN）。</li>
</ol>
<h4><span id="为什么ieee-754使用移码表示阶码e">为什么IEEE 754使用移码表示阶码e</span></h4>
<h5><span id="保证浮点数的机器零的阶码为全0">保证浮点数的机器零的阶码为全0</span></h5>
<p>机器零：机器数表示0的形式</p>
<p>​	IEEE 754标准下，浮点数尾数真值的整数部分隐藏了真值1，因此无法通过尾数全0来表示机器0；使用阶符表示机器0时，当阶码的真值趋向负无穷时，即指数趋于负无穷，此时浮点真值也趋于0，因此规定使用阶码中真值为负数且最小的数来表示机器0；假设使用8位补码来表示阶码，此时机器0表示为1000 0000B（-127D)，若使用8位移码，则使用 0000 0000 ；使用移码更直观，因此规定<strong>尾数、阶码同时全为0来表示机器0</strong>。（阶码全0，尾数不全0时，表示浮点数非规格化）</p>
<h5><span id="移码全部位于正轴上随真值增大而增大">移码全部位于正轴上，随真值增大而增大</span></h5>
<p>​	移码是对于某一个系列或集合的数使它们都映射到正数轴上去，即在数轴上把数都统一往右移动n位，使得所有的数都不为负数。IEEE 754标准下，移码E=e+偏移量，因此对于所有的E都有E大于等于0。由于移码都是从0开始的正数，所以即使是二进制的表示形式，也能直接<strong>比较阶码对应数值的大小</strong>(而补码之间的比较要观察符号位，同时转换成原码对数值位进行比较)。</p>
<h5><span id="移码也能减法变加法">移码也能减法变加法</span></h5>
<p>移码相对于补码仅符号位取反，进行减法运算时，也能加法变减法，只是符号位代表的含义不同，0表示负数，1表示正数，使用移码减法运算和补码减法运算得到的结果真值相同。</p>
<h5><span id="总结">总结</span></h5>
<p>对于单精度浮点数：<br>
(1)阶码的真值E=e-127，并且0&lt;e&lt;255，-126&lt;E&lt;127。</p>
<p>(2)当e=0或255时，在IEEE 754中表示特殊的数。</p>
<p>(3)所能表示的范围为：</p>
<ul>
<li>正数为：+2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到+2 <sup>−126</sup> ×(1+0)</li>
<li>负数为：−2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到−2 <sup>−126</sup> ×(1+0)</li>
</ul>
<h3><span id="双精度浮点数">双精度浮点数</span></h3>
<p>简要说明双精度浮点数（与单精度浮点数相类似）：</p>
<p>（1)阶码的真值E的取值范围为：-1022 ~ +1023,偏移量为+1023,阶码移码编码e为：<br>
+1 ~ + 2046</p>
<p>（2）双精度浮点数的规格化数表示为：N=(−1) s ×2 e−1023 ×1.f</p>
<p>（3）所能表示的规格化数范围：<br>
正数为：+2 +1023 ×(1+1−2 −52 )到+2 −1022 ×(1+0)</p>
<p>负数为：−2 +1023 ×(1+1−2 −52 )到−2 −1022 ×(1+0)</p>
<p>（4）当e=0或e=2047时，在IEEE 754标准中表示特殊的数</p>
<h3><span id="舍入模式">舍入模式</span></h3>
<p>我们在进行对阶或者右规格化的时候，阶数较小的操作数在进行右移的时候，会造成尾数部分的低位丢失，从而会造成误差。因此我们才需要根据需求，采取四种舍入模式中的一种对尾数进行舍入操作以减少误差。</p>
<p>二、IEEE754标准中的4种舍入模式<br>
1、就近舍入：</p>
<p>即十进制下的四舍五入。但是也会出现以下几种情况：</p>
<p>多余数字是1001，它大于0.5，故最低位进1。<br>
多余数字是0111，它小于0.5，则直接舍掉多余数字。<br>
多余数字是1000，正好是等于0.5的特殊情况；那么此时最低位为0则舍掉多余位，最低位为1则进位1。<br>
注意这里说明的数位都是指二进制数。因为这是尾数，所以在计算这些二进制和0.5的关系的时候，也即转为10进制的时候，我们用每一位的权重乘以2^(-i)然后求和即可。</p>
<p>2、朝0舍入：即朝数轴零点方向舍入，所以我们直接截尾即可。</p>
<p>3、朝正无穷舍入：对正数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；负数的话不管多余位是多少直接截尾即可。</p>
<p>4、朝负无穷舍入：对负数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；正数的话不管多余位是多少直接截尾即可。</p>
]]></content>
      <categories>
        <category>计算机组成与原理</category>
      </categories>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/post/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1><span id="引言">引言</span></h1>
<span id="more"></span>
<h1><span id="算数运算符">算数运算符</span></h1>
<h2><span id="加法-取正">+:	 加法 、取正</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>，b = <span class="number">2</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(a + b + str);<span class="comment">//3hello</span></span><br><span class="line">System.out.println(str + a + b);<span class="comment">//hello12</span></span><br><span class="line">System.out.println(str + (a + b));<span class="comment">//hello3</span></span><br><span class="line">System.out.println(a + str + b);<span class="comment">//1hello2</span></span><br></pre></td></tr></table></figure>
<p>从左向右执行：</p>
<ul>
<li>符号两边有任意一边是字符串 做的是字符串拼接</li>
<li>符号两边都是数字 做的是加法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;<span class="comment">//48</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">System.out.println(x + y + c);<span class="comment">//52</span></span><br><span class="line">System.out.println(s + y + c);<span class="comment">//030</span></span><br><span class="line">System.out.println(y + c + s);<span class="comment">//510</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;*	*&quot;</span>);<span class="comment">//*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//数字</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//数字*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));<span class="comment">//*	*</span></span><br></pre></td></tr></table></figure>
<h2><span id="-减法-取负">-  :	减法 、 取负</span></h2>
<h2><span id="乘法">* :	乘法</span></h2>
<h2><span id="除法">\ :	除法</span></h2>
<p>​		<code>System.out.println(10/3*3);//9</code></p>
<h2><span id="取余">%：取余</span></h2>
<ul>
<li>
<p>任意数字和n取余结果是[0，n-1]</p>
</li>
<li>
<p>取余结果符号和被除数符号一致</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(a  + <span class="string">&quot; % &quot;</span> + b  + <span class="string">&quot; = &quot;</span> + (a % b));</span><br><span class="line">System.out.println(-a + <span class="string">&quot; % &quot;</span> + b  + <span class="string">&quot; = &quot;</span> + (-a % b));</span><br><span class="line">System.out.println(a  + <span class="string">&quot; % &quot;</span> + -b + <span class="string">&quot; = &quot;</span> + (a % -b));</span><br><span class="line">System.out.println(-a + <span class="string">&quot; % &quot;</span> + -b + <span class="string">&quot; = &quot;</span> + (-a % -b));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	随意给出一个整数，打印显示它的个位数，十位数，百</span></span><br><span class="line"><span class="comment">	位数的值，例如:数字345的情况如下：</span></span><br><span class="line"><span class="comment">	个位数：5 十位数：4 百位数：3</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">345</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;个位数:&quot;</span> + number%<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;十位数:&quot;</span> + number/<span class="number">10</span>%<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;百位数:&quot;</span> + number/<span class="number">100</span>);<span class="comment">//number/10/10</span></span><br></pre></td></tr></table></figure>
<h2><span id="前-后-前-后">前++ 、 后++、前–、后–</span></h2>
<h3><span id>++</span></h3>
<ul>
<li>同:运算结果相同 都是减1</li>
<li>异:前++：先加1 再赋值     后++：先赋值 再加1</li>
</ul>
<h2><span id>–</span></h2>
<ul>
<li>同:运算结果相同 都是减1</li>
<li>异:前–：先减1 再赋值     后–：先赋值 再减</li>
<li>++ – 不改变自身数据类型 所以 byte b = 3 ;b++;不报错，区别于<a href="../%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型中的常数赋值</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//b = b + 1;//报错</span></span><br><span class="line">b++;<span class="comment">//++b  === (byte)(b + 1)</span></span><br></pre></td></tr></table></figure>
<h1><span id="赋值运算符">赋值运算符</span></h1>
<h2><span id="基本运算符">基本运算符： =</span></h2>
<h2><span id="扩展运算符-">扩展运算符： += -= *= /= %=</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给一个数加1 有几种方式</span></span><br><span class="line">i = i + <span class="number">1</span>;<span class="comment">//方式1</span></span><br><span class="line">i++;<span class="comment">//++i; 方式2</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">//方式3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不改变自身数据类型 byte b = 5; b += 1; 不报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//b = b + 1; //报错</span></span><br><span class="line">b += <span class="number">1</span>;	<span class="comment">//不报错 b = (byte)(b + 1)	底层发生了强制转换类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">ii *= <span class="number">0.1</span>;<span class="comment">//不报错 ii = (int)(ii * 0.1) </span></span><br></pre></td></tr></table></figure>
<h1><span id="关系运算符">关系运算符</span></h1>
<h1><span id="逻辑运算符">逻辑运算符</span></h1>
<p>操作数是boolean 运算结果也是boolean类型</p>
<h2><span id="逻辑与-短路与">逻辑与、短路与</span></h2>
<ul>
<li>有一假结果是假</li>
<li>同:运算结果相同</li>
<li>当运算符左侧是false,&amp;右侧继续运算 &amp;&amp; 发生短路 右侧不运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp; 和 &amp;&amp;短路与的区别</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">//boolean result = sex == &#x27;女&#x27; &amp; age++ == 10;	//age = 11</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> sex == <span class="string">&#x27;女&#x27;</span> &amp;&amp; age++ == <span class="number">10</span>;		<span class="comment">//age = 10</span></span><br></pre></td></tr></table></figure>
<h2><span id="逻辑或-短路或">逻辑或、短路或</span></h2>
<ul>
<li>有一真结果为真</li>
<li>运算结果相同</li>
<li>当运算符左侧是true,|右侧继续运算 || 发生短路 右侧不运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//| 和 || 的区别</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">//boolean result = sex == &#x27;男&#x27; | age++ == 10;	//age = 11</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> sex == <span class="string">&#x27;男&#x27;</span> || age++ == <span class="number">10</span>;		<span class="comment">//age = 10</span></span><br></pre></td></tr></table></figure>
<h2><span id="逻辑非">逻辑非</span></h2>
<ul>
<li>！取反</li>
</ul>
<h2><span id="逻辑异或">逻辑异或</span></h2>
<ul>
<li>^ :相同为假 不同为真</li>
</ul>
<h1><span id="位运算符">位运算符</span></h1>
<p>操作的是数值,得到数值的补码然后进行位运算</p>
<h2><span id="移位运算一元运算符">移位运算(一元运算符)</span></h2>
<h3><span id="左移-ltlt">左移 &lt;&lt;</span></h3>
<p>每移动一位相当于* 2 空位补0</p>
<h3><span id="右移-gtgt">右移 &gt;&gt;</span></h3>
<p>每移动一位相当于/ 2 最高位是0就补0 是1就补1</p>
<h3><span id="无符号右移-gtgtgt">无符号右移 &gt;&gt;&gt;</span></h3>
<p>每移动一位相当于/ 2 最高位补0</p>
<h2><span id="逻辑运算二元运算符">逻辑运算(二元运算符)</span></h2>
<p>每一位上如果是1 看做true 如果是0 看做false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3><span id="逻辑与-amp">逻辑与 &amp;</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x &amp; y;<span class="comment">//4</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000100 4</span></span><br></pre></td></tr></table></figure>
<h3><span id="逻辑或">逻辑或 |</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = x | y;<span class="comment">//13</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001101 13</span></span><br></pre></td></tr></table></figure>
<h3><span id="逻辑非-~">逻辑非 ~</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = ~x;<span class="comment">//-13</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11110011 补码</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11110010 反码	补码减去1得到反码</span></span><br><span class="line"><span class="comment">//10000000 00000000 00000000 00001101 源码 	符号位不变其他位取反得到源码	- 13</span></span><br></pre></td></tr></table></figure>
<h3><span id="逻辑异或">逻辑异或 ^</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = x ^ y;<span class="comment">//9</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001001 9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>m = (m^^<sup>n)</sup>^^n</li>
</ul>
<h3><span id="3种变量交换">3种变量交换</span></h3>
<h4><span id="临时变量">临时变量</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br></pre></td></tr></table></figure>
<h4><span id="累加消除">累加消除</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = a + b;</span><br><span class="line">a = b - a;</span><br><span class="line">b = b - a;</span><br></pre></td></tr></table></figure>
<ol>
<li>少定义一个变量</li>
<li>有局限，可能超过int类型</li>
</ol>
<h4><span id="异或消除">异或消除</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br></pre></td></tr></table></figure>
<ol>
<li>少定义一个变量</li>
<li>没有局限</li>
<li>m = (m^^<sup>n)</sup>^^n</li>
</ol>
<h1><span id="三元运算符">三元运算符</span></h1>
<ul>
<li>
<p>boolean表达式 ? 表达式1 : 表达式2</p>
</li>
<li>
<p>boolean表达式返回true  表达式1的结果作为整个表达式的结果</p>
</li>
<li>
<p>boolean表达式返回false 表达式2的结果作为整个表达式的结果</p>
</li>
</ul>
<p>注意:</p>
<ol>
<li>表达式1 和 表达式2 结果类型必须保持一致</li>
<li>表达式结果会发生自动类型转换，转换成范围大的数据类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span> ? <span class="string">&quot;已成年&quot;</span> : <span class="number">1.0</span>;<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="number">1</span> : <span class="number">1.0</span>;	<span class="comment">//不报错 发生自动类型转换 1.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);<span class="comment">//发生自动类型转换</span></span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/post/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<span id="more"></span>
<!-- toc -->
<ul>
<li><a href="#%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB">集合和数组的区别</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">集合框架</a>
<ul>
<li><a href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE">集合类图</a></li>
<li><a href="#collection%E6%96%B9%E6%B3%95">Collection方法</a></li>
<li><a href="#%E5%AD%90%E6%8E%A5%E5%8F%A3%E7%89%B9%E7%82%B9">子接口特点</a></li>
</ul>
</li>
<li><a href="#arraylist%E9%9B%86%E5%90%88">ArrayList集合</a>
<ul>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a>
<ul>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
</ul>
</li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0">遍历元素</a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">底层实现</a>
<ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B">添加元素过程</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B">删除元素过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#linkedlist">LinkedList</a>
<ul>
<li><a href="#linkedlist-%E4%B8%8E-arraylist">LinkedList 与 ArrayList</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86">遍历原理</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95">迭代器删除方法</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E5%8E%9F%E7%90%86">迭代器删除原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hashset">HashSet</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E7%89%B9%E7%82%B9-1">特点</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B-1">添加元素过程</a></li>
<li><a href="#%E5%88%A4%E9%87%8D">判重</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95-1">方法</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0-1">遍历元素</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8eclipseidea%E5%A4%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95%E6%9C%8931%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97">为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#treeset">TreeSet</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0-1">概述</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95-2">方法</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0-2">遍历元素</a></li>
<li><a href="#%E7%89%B9%E7%82%B9-2">特点</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%99%A8">比较器</a>
<ul>
<li><a href="#%E5%86%85%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8">内部比较器</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E6%AF%94%E8%BE%83%E5%99%A8">外部比较器</a></li>
</ul>
</li>
<li><a href="#treeset%E5%8E%BB%E9%87%8D">TreeSet去重</a></li>
<li><a href="#%E7%89%B9%E7%82%B9-3">特点</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98">排序问题</a>
<ul>
<li><a href="#treeset%E6%8E%92%E5%BA%8F%E4%BD%86%E4%B8%8D%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D">TreeSet排序但不去除重复</a></li>
<li><a href="#arraylist%E7%BB%93%E5%90%88collections%E6%96%B9%E6%A1%88%E6%8E%92%E5%BA%8F%E4%BD%86%E4%B8%8D%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D">ArrayList结合Collections方案排序但不去除重复</a></li>
<li><a href="#collections%E5%B7%A5%E5%85%B7%E7%B1%BB">Collections工具类</a>
<ul>
<li><a href="#sort%E6%96%B9%E6%B3%95">sort()方法</a></li>
<li><a href="#arrayssort">Arrays.sort()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#map%E6%8E%A5%E5%8F%A3%E9%94%AEkey%E5%80%BCvalue%E5%AF%B9">Map接口【键（key）值(value)对】</a>
<ul>
<li><a href="#map%E6%8E%A5%E5%8F%A3%E7%BB%93%E6%9E%84">Map接口结构</a></li>
<li><a href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E7%BB%93%E6%9E%84">键值对的结构</a></li>
<li><a href="#hashset%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">HashSet和TreeSet实现方案</a></li>
</ul>
</li>
<li><a href="#hashmap">HashMap</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3">初始化</a></li>
<li><a href="#%E6%96%B9%E6%B3%95-3">方法</a></li>
<li><a href="#%E9%81%8D%E5%8E%86">遍历</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">基本数据结构</a></li>
<li><a href="#key%E7%9A%84%E8%AE%BE%E8%AE%A1">key的设计</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">执行原理</a>
<ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B-2">添加元素过程</a></li>
<li><a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F">调整数组大小</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96threshold">构造时初始化threshold</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97">索引计算</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E">哈希碰撞</a></li>
<li><a href="#%E5%88%A4%E9%87%8D-1">判重</a></li>
<li><a href="#%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%84%E7%90%86">重复元素的处理</a></li>
<li><a href="#%E6%A0%91%E5%8C%96">树化</a></li>
<li><a href="#%E9%93%BE%E5%8C%96">链化</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B-1">删除元素过程</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">并发问题</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="集合和数组的区别">集合和数组的区别</span></h1>
<ol>
<li>数组的长度是固定的，集合的长度无限制</li>
<li>数组里面的每个元素都必须是相同类型，集合里面的元素可以是任意类型</li>
<li>集合里面的元素往往在很多时候是需要统一的，集合采用了泛型的方法来统一元素类型</li>
<li>数组拥有固定的算法，集合有很多种类，已经实现了各种算法</li>
</ol>
<h1><span id="集合框架">集合框架</span></h1>
<p>集合所在的包java.util</p>
<h2><span id="集合类图">集合类图</span></h2>
<img src="https://pic.imgdb.cn/item/63bb70bbbe43e0d30e6e3441.jpg" alt="image-20230105103228912" style="zoom: 50%;">
<ol>
<li>集合的元素长度无需固定，属于动态增长和缩小</li>
<li>集合的元素类型可以是任意，也可以用泛型统一。在 Java5 之前,Java 集合会丢失容器中所有对象的数据类型,把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后,Java集合可以记住容器中对象的数据类型</li>
<li>遍历的时候无法删除元素【遍历的时候不能改变集合的长度，删除和修改都会报错】</li>
</ol>
<h2><span id="collection方法">Collection方法</span></h2>
<table>
<thead>
<tr>
<th>Collection</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回集合元素个数</td>
<td>int size()</td>
</tr>
<tr>
<td>清空集合</td>
<td>void clear()</td>
</tr>
<tr>
<td>是否是空集合</td>
<td>boolean isEmpty()</td>
</tr>
<tr>
<td>是否包含指定集合中的所有元素</td>
<td>boolean containsAll(Collection c)（调用元素的equals方法比较）</td>
</tr>
<tr>
<td>删除指定集合中的元素（差集）</td>
<td>boolean removeAll(Collection coll)</td>
</tr>
<tr>
<td>保留指定集合中的元素（交集）</td>
<td>boolean retainAll(Collection c)</td>
</tr>
<tr>
<td>集合是否相等</td>
<td>boolean eqauls(Object o)</td>
</tr>
<tr>
<td>转成对象数组</td>
<td>Object[] toArray()</td>
</tr>
<tr>
<td>返回迭代器对象</td>
<td>iterator()</td>
</tr>
</tbody>
</table>
<h2><span id="子接口特点">子接口特点</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>List</th>
<th>Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序</td>
<td>插入顺序</td>
<td>值顺序</td>
</tr>
<tr>
<td>重复</td>
<td>元素可以重复</td>
<td>不支持重复</td>
</tr>
<tr>
<td>下标</td>
<td>有下标</td>
<td>无下标</td>
</tr>
</tbody>
</table>
<h1><span id="arraylist集合">ArrayList集合</span></h1>
<h2><span id="特点">特点</span></h2>
<ul>
<li>自然顺序</li>
<li>有下标</li>
<li>可以重复（地址一样）</li>
</ul>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用泛型规定集合里面的元素统一数据类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>ArrayList</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>add(E e)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>根据下标添加元素</td>
<td>add(int index,E e)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>添加集合元素</td>
<td>addAll(Collection&lt;? extends E&gt; c)</td>
<td>boolean</td>
<td>添加元素个数为0返回false，否则返回true</td>
</tr>
<tr>
<td>根据下标添加集合元素</td>
<td>addAll(int index,Collection&lt;? extends E&gt; c)</td>
<td>boolean</td>
<td>添加元素个数为0返回false，否则返回true</td>
</tr>
<tr>
<td>直接删除元素</td>
<td>remove(E e)</td>
<td>boolean</td>
<td>删除成功返回true，失败返回false</td>
</tr>
<tr>
<td>根据下标删除元素</td>
<td>remove(int index)</td>
<td>Object</td>
<td>返回被删除的元素</td>
</tr>
<tr>
<td>根据下标修改元素</td>
<td>set(int index, E e)</td>
<td>Object</td>
<td>返回被修改元素</td>
</tr>
<tr>
<td>根据下标查找元素</td>
<td>get(int index)</td>
<td>Object</td>
<td>下标不存在，或超标，返回异常</td>
</tr>
<tr>
<td>查找是否包含某个元素</td>
<td>contains(E e)</td>
<td>boolean</td>
<td>包含返回true，不包含返回false</td>
</tr>
<tr>
<td>查找是否包含某个元素</td>
<td>indexOf(E e)</td>
<td>int</td>
<td>包含返回该元素的下标，不包含则返回-1</td>
</tr>
</tbody>
</table>
<h3><span id="注意">注意</span></h3>
<ul>
<li>
<p><strong>使用remove方法删除int类型值时，会优先将int值看作index参数</strong>，即调用remove(int index)根据下标删除元素方法。若需要删除int型元素，还需将int值装箱成Integer类型<code>arrayList.remove(Integer.valueOf(1));</code></p>
</li>
<li>
<p><strong>遍历的时候无法直接删除元素</strong>【遍历的时候不能改变集合的长度，删除和修改都会报错】，如需便利时删除，可使用<strong>迭代器的删除方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (next.equals(<span class="string">&quot;hzj4&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(next);</span><br><span class="line">        iterator.remove(); 		<span class="comment">//迭代器遍历删除方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>remove(Object o)方法通过equals(o)方法找到第一个元素并删除</strong>，若想将equal(o)的所有元素删除</p>
<p><code> while (arrayList.remove(Object o));</code></p>
</li>
</ul>
<h2><span id="遍历元素">遍历元素</span></h2>
<ul>
<li>迭代器迭代元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用下标遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    System.out.println(arrayList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用foreach遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String s : arrayList) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="底层实现">底层实现</span></h2>
<ol>
<li>
<p>ArrayList底层实现是数组</p>
</li>
<li>
<p>使用空构造器初始化时，数组长度为0</p>
</li>
<li>
<p>使用带参构造器初始化时</p>
<p><code>ArrayList&lt;String&gt; temp=new ArrayList&lt;&gt;(50);//初始化底层数组容量是50</code></p>
<p><code>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</code></p>
</li>
</ol>
<h3><span id="添加元素过程">添加元素过程</span></h3>
<h4><span id="add">add</span></h4>
<ol>
<li>
<p>假设使用空构造初始化，数组长度为0，此时往ArrayList集合中添加元素：</p>
</li>
<li>
<p><strong>数组长度将扩容至10</strong>，并往数组中逐个添加元素</p>
</li>
<li>
<p>当数组存储元素个数已满（再添加元素将超过数组长度）时，<strong>数组长度将扩容至原数组的1.5倍  （向上取整）</strong>，再往集合中逐个添加元素</p>
</li>
<li>
<p>当数组扩容1.5倍后长度超过数组最大长度时，扩容至数组最大值</p>
<p>（MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8）部分JVM在数组中保留一些字头信息</p>
<ol>
<li>即使扩容至数组最大值，也无法再添加元素（再添加将超过数组长度），扩容至int最大值</li>
<li>即使扩容至int最大值，也无法再添加元素（再添加将溢出int类型），产生OutOfMemoryError()异常</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;	<span class="comment">//空数组添加扩容至10</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;								<span class="comment">//修改次数，添加、删除时加1</span></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)	<span class="comment">//当前数组长度小于添加元素后的长度，意味着旧数组需要扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);	<span class="comment">//扩容后新数组长度为旧数组长度的一半</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)		<span class="comment">//addAll可能调用</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)	<span class="comment">//0x7fffffff-8</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="addall">addAll</span></h4>
<ol>
<li>将要添加的集合转换成数组</li>
<li>被添加的数组加上转换后的数组元素
<ol>
<li>被添加的数组没有元素时 扩容为Math.max(10, 实际元素个数)</li>
<li>被添加的数组中有元素时 扩容为Math.max(原容量 1.5 倍, 实际元素个数)</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// 增加修改次数</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);	<span class="comment">//被添加的数组加上转换后的数组元素</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除元素过程">删除元素过程</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)		<span class="comment">//删除索引不存在</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);		<span class="comment">//获取要删除的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;		<span class="comment">//移动次数</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>删除索引不超过数组非空元素的长度</li>
<li>删除该索引下的值，并将之后的元素都前移一次，最后一个元素置空（底层C语言实现）</li>
</ol>
<h4><span id="缩容">缩容</span></h4>
<ul>
<li>删除元素的时底层数组不会缩放，需要手动调用trimToSize()缩小底层数组长度（缩放到当前元素大小的长度）</li>
<li>删除元素的时候都会将被删除元素以后的所有元素前移，原来的下标指向的元素会改变，因此不能在遍历的时候删除，需要使用迭代器删除</li>
</ul>
<h1><span id="linkedlist">LinkedList</span></h1>
<h2><span id="linkedlist-与-arraylist">LinkedList 与 ArrayList</span></h2>
<table>
<thead>
<tr>
<th>LinkedList</th>
<th>ArrayList</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于双向链表，无需连续内存</td>
<td>基于数组，需连续内存</td>
</tr>
<tr>
<td>随机访问慢（要沿着链表遍历）</td>
<td>随机访问快（指根据下标访问）</td>
</tr>
<tr>
<td>头尾插入删除性能高</td>
<td>尾部插入、删除性能高，其它部分插入、删除都会移动数据，因此性能会低</td>
</tr>
<tr>
<td>占用内存多</td>
<td>可利用 cpu 缓存，局部性原理</td>
</tr>
</tbody>
</table>
<h1><span id="迭代器">迭代器</span></h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = i.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;		<span class="comment">//遍历所有非空元素</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="遍历原理">遍历原理</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cursor;       <span class="comment">// 游标,指向迭代当前元素的游标，在获取完当前元素后指向下一个元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 指向上一个元素的下标，没有元素为-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;	<span class="comment">//期望修改的次数，modCount记录当前集合中的增加或删除次数</span></span><br></pre></td></tr></table></figure>
<ol>
<li>遍历所有非空元素</li>
<li>检查迭代期间的修改次数、游标是否超过数组非空元素、是否超过数组长度</li>
<li>获取当前游标指向的元素，并让游标指向下一个元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)			<span class="comment">//游标已经超过了数组中非空数据元素的下标</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;<span class="comment">//获取当前数组</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)	<span class="comment">//游标超过了数组长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;<span class="comment">//游标指向下一个</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];	<span class="comment">//lastRet就指向当前对象，返回当前元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)	<span class="comment">//是否使用了集合的增加或删除方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器遍历时，为什么不能使用集合的增加或删除方法</p>
<p>在迭代器迭代过程中，游标会逐个指向下个元素的下标，当使用集合的增加或删除方法时，可能改变元素在数组中的存储位置，即下标指向的元素可能不是修改前所指向的元素，因此无法按照原顺序遍历元素</p>
<h2><span id="迭代器删除方法">迭代器删除方法</span></h2>
<p>迭代器删除方法调用集合的删除方法来删除lastRet指向的旧元素的位置，并将cursor退回到lastRet的位置实现遍历删除</p>
<h3><span id="迭代器删除原理">迭代器删除原理</span></h3>
<ol>
<li>至少遍历过一次且未连续使用迭代器删除</li>
<li>检查迭代期间是否修改</li>
<li>调用集合删除方法删除，游标回到原来位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)	<span class="comment">//还没开始遍历，或一次迭代中重复使用迭代器删除方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    checkForComodification();	<span class="comment">//修改次数与预期不符合，迭代期间进行了增加或删除操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;			<span class="comment">//游标回到原来位置</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;				<span class="comment">//设置lastRet为初始值，避免在一次迭代中重复使用迭代器删除方法</span></span><br><span class="line">        expectedModCount = modCount;		<span class="comment">//更新expectedModCount值</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="hashset">HashSet</span></h1>
<h2><span id="概述">概述</span></h2>
<ol>
<li>HashSet是Set接口的典型实现，元素可以是null</li>
<li>HashSet按Hash算法来存储集合中的元素</li>
<li>底层是数组，初始容量为16，当如果使用率超过0.75，（即超过16*0.75=12）就会扩大容量为原来的2倍</li>
</ol>
<h2><span id="特点">特点</span></h2>
<ul>
<li>由哈希值以及数组长度来决定在数组中的存储位置
<ol>
<li>元素没有明确的排列顺序（遍历输出无序）</li>
<li>不支持重复的元素</li>
<li>没有下标</li>
</ol>
</li>
</ul>
<h2><span id="添加元素过程">添加元素过程</span></h2>
<img src="https://pic.imgdb.cn/item/63bbba7dbe43e0d30ef34746.jpg" style="zoom:80%;">
<ol>
<li>
<p>当向HashSet 集合中添加一个元素时，会调用该对象的 hashCode() 方法获得该对象的hashCode值</p>
</li>
<li>
<p>然后根据hashCode值，通过某种散列函数决定该对象在HashSet底层数组中的存储位置</p>
<blockquote>
<p>该散列函数根据hashCode值与底层数组的长度相计算，得到在数组中的下标，该函数计算将尽可能均匀存储元素，即越是散列分布，代表该散列函数设计的越好</p>
</blockquote>
</li>
<li>
<p>若要添加元素的hashCode与集合中某个元素的hashCode值相等（即存储位置一致），会再调用equals方法判断两元素是否相等</p>
</li>
<li>
<p>若equals方法判断两元素相等，则添加元素重复，添加失败；若不相等，由于原数组位置上已经有元素(哈希冲突)，则将新添加元素通过链表的方式连接到数组同一位置上</p>
</li>
<li>
<p>若要添加元素与集合中某个元素的hashCode值不相等，无论两元素equals方法判断是否相等，都会把它们存储在不同的位置，即添加成功。</p>
</li>
</ol>
<h2><span id="判重">判重</span></h2>
<ul>
<li>
<p>HashSet判断两个元素相等规则：<strong>hashCode() 相等 &amp;&amp; equals相等</strong></p>
<ol>
<li>
<p>先判断hashCode是否相等，若hashCode不相等直接判断不重复，若hashCode相等还要看equals是否相等</p>
</li>
<li>
<p>若equals不相等，则判断不重复，若equals相等，则判断重复</p>
<p><a href="../Object%E7%B1%BB">hashCode、equals方法</a></p>
</li>
</ol>
</li>
<li>
<p>往HashSet添加的重复数据会被丢弃</p>
</li>
<li>
<p>相等的对象必须具有相等的散列码，对于引用型对象，需重写equals()和hashCode()方法，以实现对象相等规则</p>
<ul>
<li>对象中用作equals()方法比较的Field，都应该用来计算hashCode值</li>
<li>equals()方法比较返回true时，hashCode()方法的返回值也应相等</li>
</ul>
</li>
</ul>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;E&gt; strings=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>HashSet</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>add(Object o)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>直接删除元素</td>
<td>remove(Object o)</td>
<td>boolean</td>
<td>删除成功返回true，失败返回false</td>
</tr>
<tr>
<td>查找某个元素是否存在</td>
<td>contains(Object o)</td>
<td>boolean</td>
<td>包含返回true，不包含返回false</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>优点：HashSet增加、删除、查找某个元素是否存在时,通过元素哈希值直接确定位置，不需要调整数组位置</li>
<li>缺点：HashSet不能通过指定条件返回某个元素，只能根据指定条件遍历HashSet来获取</li>
</ul>
<h2><span id="遍历元素">遍历元素</span></h2>
<ul>
<li>foreach循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (E temp : hashset) &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代器遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; iterator = hashset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>HashSet没有下标，不能通过下标遍历</li>
<li>HashSet只能通过遍历返回集合中的某个元素。因为没有下标无法定位到指定位置的元素</li>
<li>HashSet集合遍历输出的顺序与添加顺序无关</li>
</ul>
<h3><span id="为什么用eclipseidea复写hashcode方法有31这个数字">为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object a[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="literal">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>31是一个质数，带入公式具有良好的散列特性</li>
<li>用移位和减法来代替乘法。31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机可以自动完成相关优化（提高算法效率）</li>
</ol>
<h1><span id="treeset">TreeSet</span></h1>
<h2><span id="概述">概述</span></h2>
<ol>
<li>TreeSet 的元素必须实现Comparable接口的 compareTo(Object obj) 方法或Comparator接口的compare(Object obj1,Object obj2)</li>
</ol>
<p>包装类已经实现了Comparable ：</p>
<table>
<thead>
<tr>
<th>包装类</th>
<th>compareTo(Object obj) 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有的数值型对应的包装类</td>
<td>按对应的数值大小进行比较</td>
</tr>
<tr>
<td>Character</td>
<td>按字符的 unicode值来进行比较</td>
</tr>
<tr>
<td>Boolean</td>
<td>true对应的包装类实例大于 false对应的包装类实例</td>
</tr>
<tr>
<td>String</td>
<td>按字符串中字符的 unicode 值进行比较</td>
</tr>
<tr>
<td>Date、Time</td>
<td>后边的时间、日期比前面的时间、日期大</td>
</tr>
</tbody>
</table>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;E&gt; e = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>TreeSet</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>add(Object o)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>直接删除元素</td>
<td>remove(Object o)</td>
<td>boolean</td>
<td>删除成功返回true，失败返回false</td>
</tr>
<tr>
<td>查找某个元素是否存在</td>
<td>contains(Object o)</td>
<td>boolean</td>
<td>包含返回true，不包含返回false</td>
</tr>
<tr>
<td>获取第一个元素</td>
<td>first()</td>
<td>Object</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>获取最后一个元素</td>
<td>last()</td>
<td>Object</td>
<td>返回最后一个元素</td>
</tr>
<tr>
<td>拿出第一个元素</td>
<td>pollFirst()</td>
<td>Object</td>
<td>返回第一个元素【原集合第一个元素删除】</td>
</tr>
<tr>
<td>拿出最后一个元素</td>
<td>pollLast()</td>
<td>Object</td>
<td>返回最后一个元素【原集合最后一个元素删除】</td>
</tr>
<tr>
<td>大于等于</td>
<td>ceiling(Object o)</td>
<td>Object</td>
<td>返回比指定元素大的元素（含相等）【找不到元素返回null】</td>
</tr>
<tr>
<td>大于</td>
<td>higher(Object o)</td>
<td>Object</td>
<td>返回比指定元素大的元素（不含相等）【找不到元素返回null】</td>
</tr>
<tr>
<td>小于等于</td>
<td>floor(Object o)</td>
<td>Object</td>
<td>返回比指定元素小的元素（含相等）【找不到元素返回null】</td>
</tr>
<tr>
<td>小于</td>
<td>lower(Object o)</td>
<td>Object</td>
<td>返回比指定元素小的元素（不含相等）【找不到元素返回null】</td>
</tr>
</tbody>
</table>
<h2><span id="遍历元素">遍历元素</span></h2>
<ul>
<li>
<p>foreach循环</p>
</li>
<li>
<p>迭代器遍历</p>
</li>
</ul>
<h2><span id="特点">特点</span></h2>
<ul>
<li>支持重复元素</li>
<li>没有下标</li>
<li>拥有升降序</li>
</ul>
<h2><span id="比较器">比较器</span></h2>
<ul>
<li>
<p>添加元素时，TreeSet 会调用集合元素的 compareTo(Object obj) 方法或compare(Object obj1,Object obj2) 来比较元素之间的大小关系（相等为0,大于或者小于使用正整数或者负数，但是官方建议使用1或者-1）， 然后将集合元素按升序(默认情况)排列</p>
</li>
<li>
<p>通常情况下，应保证当两个对象通过equals()方法比较返回true，则通过compareTo(Object obj)方法比较也应返回0</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>内部比较器</th>
<th>外部比较器</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用场景</td>
<td>只能按照一个规则比较，一般用于默认排序规则</td>
<td>可以按照不同的规则比较，创建多个比较规则对象</td>
</tr>
<tr>
<td>实现接口</td>
<td>java.lang.Comparable</td>
<td>java.util.Comparator</td>
</tr>
<tr>
<td>实现</td>
<td>实体类中实现接口，重写int compareTo(Object o)方法</td>
<td>创建实现类实现接口，重写int compare(Object o1,Object o2)方法</td>
</tr>
<tr>
<td>TreeSet构造</td>
<td>无参构造TreeSet</td>
<td>实现类实例作为形参传入TreeSet构造器</td>
</tr>
</tbody>
</table>
<h3><span id="内部比较器">内部比较器</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Stu&gt; &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.getScore()==o.getScore())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.getScore()&gt;o.getScore())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="外部比较器">外部比较器</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建按照学生年龄比较的规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuAgeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Stu&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Stu o1, Stu o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1.getAge()== o2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getAge()&gt;o2.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="treeset去重">TreeSet去重</span></h2>
<ul>
<li>判断两元素相等的标准：实现比较器中比较方法判断</li>
<li>TreeSet去重依然丢弃重复</li>
</ul>
<h2><span id="特点">特点</span></h2>
<ul>
<li>支持重复元素</li>
<li>没有下标</li>
<li>拥有升降序</li>
</ul>
<h1><span id="排序问题">排序问题</span></h1>
<ul>
<li>TreeSet排序可以通过重写比较方法灵活操作相等的元素</li>
</ul>
<h2><span id="treeset排序但不去除重复">TreeSet排序但不去除重复</span></h2>
<p>使用内部比较器重写compareTo方法，其中判断相等时不返回0，从而实现不去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.getAge()==o.getAge())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getAge()&gt;o.getAge()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="arraylist结合collections方案排序但不去除重复">ArrayList结合Collections方案排序但不去除重复</span></h2>
<table>
<thead>
<tr>
<th>使用内部比较器</th>
<th>使用外部比较器</th>
</tr>
</thead>
<tbody>
<tr>
<td>实体类实现内部比较器</td>
<td>Comparator实现类实现外部比较器</td>
</tr>
<tr>
<td>将元素添加到ArrayList中</td>
<td>将元素添加到ArrayList中</td>
</tr>
<tr>
<td>Collections.sort(arrayList);</td>
<td>Collections.sort(arrayList,外部比较器)</td>
</tr>
</tbody>
</table>
<h2><span id="collections工具类">Collections工具类</span></h2>
<h3><span id="sort方法">sort()方法</span></h3>
<ul>
<li>用Arrays.sort()方法实现的</li>
<li>Collections.sort()</li>
<li>Collections.sort(stus,外部比较器)     可传入外部比较器</li>
</ul>
<h3><span id="arrayssort">Arrays.sort()</span></h3>
<ul>
<li>JDK8以前
<ul>
<li>判断待排序数组的长度，如果小于7则直接插入排序，否则使用归并排序。</li>
</ul>
</li>
<li>JDK8以后
<ul>
<li>java会使用TimSort进行排序。判断待排序数组的长度，如果长度小于32时会使用二分插入排序，否则会使用优化过的归并排序</li>
</ul>
</li>
</ul>
<h1><span id="map接口键key值value对">Map接口【键（key）值(value)对】</span></h1>
<h2><span id="map接口结构">Map接口结构</span></h2>
<p><img src="/post/%E9%9B%86%E5%90%88/D:%5C%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99%5Chzj%5Csz2212%5C004-%E9%9B%86%E5%90%88%5C%E9%9B%86%E5%90%88.assets%5Cimage-20230110111753024.png" alt="image-20230110111753024"></p>
<h2><span id="键值对的结构">键值对的结构</span></h2>
<ul>
<li>键：唯一性（采用Set集合标准）</li>
<li>值：非唯一性（采用List集合标准）</li>
</ul>
<h2><span id="hashset和treeset实现方案">HashSet和TreeSet实现方案</span></h2>
<ul>
<li>HashMap的实现其实就是HashSet的实现（哈希表）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TreeMap的实现其实就是TreeSet的实现（红黑树）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="hashmap">HashMap</span></h1>
<h2><span id="初始化">初始化</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;K,V&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2><span id="方法">方法</span></h2>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>方法</th>
<th>返回类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接添加元素</td>
<td>put(K k,V v)</td>
<td>boolean</td>
<td>添加成功返回true，失败返回false</td>
</tr>
<tr>
<td>根据键删除元素</td>
<td>remove(K k)</td>
<td>V</td>
<td>返回被删除的对象</td>
</tr>
<tr>
<td>根据键和值删除元素</td>
<td>remove(K k,V v)</td>
<td>boolean</td>
<td>键与值不匹配删除失败，返回false，反之true</td>
</tr>
<tr>
<td>根据键修改元素</td>
<td>replace(K k,V v)</td>
<td>V</td>
<td>返回被修改的对象</td>
</tr>
<tr>
<td>根据键获取对象</td>
<td>get(K k)</td>
<td>V</td>
<td>返回查找的对象</td>
</tr>
<tr>
<td>获取所有键</td>
<td>keySet()</td>
<td>Set&lt;K&gt;</td>
<td>返回包含所有键的Set集合</td>
</tr>
<tr>
<td>获取所有值</td>
<td>values()</td>
<td>Collection&lt;V&gt;</td>
<td>返回包含所有值的Collection集合</td>
</tr>
</tbody>
</table>
<h2><span id="遍历">遍历</span></h2>
<ul>
<li>遍历所有键</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; keys = stus.keySet();</span><br><span class="line"><span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">value</span> <span class="operator">=</span> stus.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历所有值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Stu&gt; values = stus.values();</span><br><span class="line"><span class="keyword">for</span> (Stu value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代器迭代所有键（只有删除的时候才会使用迭代器）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = stus.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(next &gt; <span class="number">1004</span>)&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="基本数据结构">基本数据结构</span></h2>
<ul>
<li>1.7 数组 + 链表</li>
<li>1.8 数组 + （链表 | 红黑树）</li>
</ul>
<h2><span id="key的设计">key的设计</span></h2>
<ol>
<li>
<p>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</p>
</li>
<li>
<p>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</p>
<blockquote>
<p>若修改了key，将无法通过修改后的key查找HashMap中的值</p>
</blockquote>
</li>
<li>
<p>key 的 hashCode 应该有良好的散列性</p>
</li>
</ol>
<h2><span id="执行原理">执行原理</span></h2>
<h3><span id="添加元素过程">添加元素过程</span></h3>
<ol>
<li>
<p>判断若是首次插入元素，未初始化结点数组</p>
<ol>
<li><a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F">调整数组大小</a></li>
</ol>
</li>
<li>
<p>已初始化过数组，<a href="#%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97">计算要插入结点数组的下标</a></p>
<ol>
<li>
<p>若该位置没有元素，则直接插入</p>
</li>
<li>
<p>若该位置有元素说明发生<a href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E">哈希碰撞</a>，可能出现下面几种情况</p>
<ol>
<li>
<p>两元素<a href="#%E5%88%A4%E9%87%8D">重复</a>，<a href="#%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%84%E7%90%86">处理重复元素</a></p>
</li>
<li>
<p>两元素不重复，原数组元素为树节点（已树化），插入或更新红黑树</p>
</li>
<li>
<p>两元素不重复，原数组元素为普通结点，则遍历该链表</p>
<ol>
<li>全链表没有重复元素，则插入该链表，若插入元素为该链表第九个，需处理链表过长（<a href="#%E6%A0%91%E5%8C%96">树化</a>或<a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F">扩容</a>）</li>
</ol>
</li>
</ol>
</li>
<li>
<p>遍历过程中发现链表有重复元素，<a href="#%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%84%E7%90%86">处理重复元素</a></p>
</li>
</ol>
</li>
<li>
<p>若添加新元素后的数组总个数超过threshold，还需<a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F">扩容</a></p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>jdk1.7</th>
<th>jdk1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>链表插入</td>
<td>头插法</td>
<td>尾插法</td>
</tr>
<tr>
<td>扩容</td>
<td>大于等于阈值且没有空位</td>
<td>大于阈值</td>
</tr>
</tbody>
</table>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认容量： 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;		<span class="comment">//最大容量 2^30^</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;		<span class="comment">//负载因子:数组增长率</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;				<span class="comment">//树化链长条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;			<span class="comment">//链化参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;			<span class="comment">//树化数组长度条件</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;						<span class="comment">//结点数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//当前结点数组为空，或长度为0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)		</span><br><span class="line">        n = (tab = resize()).length;		<span class="comment">//新建长度为默认容量16结点数组，，更新threshold为负载因子乘上默认容量</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)		<span class="comment">//要插入的数组位置为空</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);	<span class="comment">//插入该数组</span></span><br><span class="line">    <span class="keyword">else</span> &#123;								<span class="comment">//结点数组既不为空且插入位置发生冲突</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)		<span class="comment">//原数组元素为树节点</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">//TREEIFY_THRESHOLD=8	插入第九个树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// key有映射</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)	<span class="comment">//true丢弃重复元素，false替换</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);			<span class="comment">// LinkedHashMap</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;	<span class="comment">//返回被替换的真值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;		<span class="comment">//记录本次修改</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)		<span class="comment">//threshold比较标准是总数组元素个数，不是数组长度</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);	<span class="comment">// LinkedHashMap</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="调整数组大小">调整数组大小</span></h3>
<ol>
<li>首次添加元素，才创建数组（懒惰创建数组）
<ol>
<li>新建结点数组，长度为默认容量16，更新threshold为负载因子乘上默认容量</li>
</ol>
</li>
<li>首次添加元素，但<a href="#%E6%9E%84%E9%80%A0%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96threshold">构造集合时初始化了数组长度</a>
<ol>
<li>指定长度大于等于最大数组容量，更新threshold为int最大值</li>
<li>指定长度小于最大数组容量，更新threshold为指定长度乘上负载因子</li>
</ol>
</li>
<li>数组总元素个数超过threshold，需要扩容（数组中挂链长度大于8但数组长度小于64，为了分解链表也会扩容，扩容至64<a href="#%E6%A0%91%E5%8C%96">树化</a>）
<ol>
<li>数组长度已经大于等于最大容量，更新threshold为int最大值</li>
<li>数组已初始化（长度大于等于默认容量）且数组长度满足扩容条件（两倍仍小于最大容量），则扩容为原来的两倍，threshold也扩大两倍</li>
<li>由于数组中已有数据，扩容时还需遍历数组，将旧数组元素转移到新数组中
<ol>
<li>当前下标元素既没树化，也没链化，则直接运算其下标存入新数组中</li>
<li>当前元素为树节点（已树化），则拆分树或拆成链表</li>
<li>当前元素已链化，分解链表</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;	<span class="comment">//调整大小		数组初始化/数组长度插入新元素后大于threshold</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;					   <span class="comment">//结点数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;	<span class="comment">//大于等于最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;	<span class="comment">//threshold设为int最大值</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;				   <span class="comment">//返回旧结点数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新结点数组扩容后仍小于最大容量且旧结点数组长度大于等于16（意味着已经初始化）</span></span><br><span class="line">        <span class="comment">//新结点数组长度扩大两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;	</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)	<span class="comment">//扩容后不超过最大容量，且数组长度不小于默认长度</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// newThr为oldThr两倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 结点数组为空，但threshold已初始化，则按照以有的threshold初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 未初始化threshold和结点数组，表示使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;		<span class="comment">//新结点数组长度置为默认容量（16）</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);	<span class="comment">//newThr置为负载因子乘上默认容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;	<span class="comment">//按照以有的threshold初始化</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">//初始化数组长度大于等于最大容量时，新threshold设为int最大值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? </span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;	 		<span class="comment">//更新threshold</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];		<span class="comment">//新建结点数组，长度为newCap</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;			<span class="comment">//数组中尚且有元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;	<span class="comment">//当前下标有元素时</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;			<span class="comment">//清除旧数组元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)			<span class="comment">//当前元素没有挂链</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;		<span class="comment">//直接复制到新数组中</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)		<span class="comment">//树节点</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);<span class="comment">//拆分树或链化</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 当前元素有挂链</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//1.新数组长度为旧数组两倍</span></span><br><span class="line">                    <span class="comment">//2.当前下标位置有挂链</span></span><br><span class="line">                    <span class="comment">//3.按照旧数组长度，如2^i，即看第i位是否为1，将挂链分为两条链表</span></span><br><span class="line">                    <span class="comment">//4.第i位为0的存储在原位置，为1的存储在原数组长度加上原位置的位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;		<span class="comment">//next指向下个元素</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;	</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);	<span class="comment">//遍历原链表结点，并赋值到新链表上</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拆分树</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)	<span class="comment">//长度小于等于6</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);	<span class="comment">//链化</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="构造时初始化threshold">构造时初始化threshold</span></h3>
<p>构造HashMap或HashSet时带参将初始化threshold，参数即使大于最大容量也会自降为最大容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>参数大于1时，初始化的threshold值为大于等于参数且最接近参数的 2<sup>i</sup>数列	（i&gt;=4,i为正整数，最大为最大容量（2<sup>30</sup>））</p>
<blockquote>
<p>例如14、22、54的参数，则实际初始化threshold为16、32、64</p>
</blockquote>
</li>
<li>
<p>参数小于0时，抛出异常；</p>
</li>
<li>
<p>参数大于等于0小于等于1时，初始化threshold值为1</p>
</li>
<li>
<p>参数大于等于最大容量时，初始化threshold值理论上为设置的最大容量，但实际测试超过2<sup>29</sup>时， (OutOfMemoryError)异常</p>
</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;	</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;	</span><br><span class="line">    <span class="comment">//若n的二进制形式中至少有一个位为1 </span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;		<span class="comment">//n与自身右移1位进行或运算（有1则1），导致为1的位的右边1位必定为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;		<span class="comment">//再与自身右移2位进行或运算，则1位右边3位都为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;		<span class="comment">//再与自身右移4位进行或运算，则1位右边7位都为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;		<span class="comment">//再与自身右移8位进行或运算，则1位右边15位都为1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;		<span class="comment">//再与自身右移16位进行或运算，则1位右边31位都为1</span></span><br><span class="line">    <span class="comment">//运算后n的结果：为1的最高位其后至多31位都为1</span></span><br><span class="line">    <span class="comment">//n+1：为1最高位为第i-1位,即大于等于cap且最接近的2^i^数列</span></span><br><span class="line">    <span class="comment">//上述为cap大于1的情况</span></span><br><span class="line">    <span class="comment">//cap小于1时，n&lt;0，结果为1</span></span><br><span class="line">    <span class="comment">//cap等于1时，n=0，结果也为1</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="索引计算">索引计算</span></h3>
<p>计算元素插入数组的位置</p>
<p><strong>索引计算方法</strong></p>
<p><code>key.hash &amp; (capacity - 1)</code></p>
<ol>
<li>首先计算key的 hashCode()</li>
<li>再调用 HashMap 的 hash() 方法进行二次哈希：异或hashCode的高16位</li>
<li>最后和（数组容量-1）位与运算得到索引</li>
</ol>
<p><strong>为何要进行二次哈希</strong></p>
<ol>
<li>计算索引时，数组容量过小会忽略hashCode的高位数据，二次 hash() 可以综合高位数据，让哈希分布更为均匀</li>
<li>异或运算更好保留两组32位二进制数中各自的特征，且运算和或运算会导致结果偏向0或1</li>
</ol>
<p><strong>数组容量为何是 2 的 n 次幂</strong></p>
<ol>
<li>
<p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p>
<blockquote>
<p>和2<sup>n</sup>-1进行位与运算，相当于取二进制下的后n位</p>
</blockquote>
</li>
<li>
<p>扩容时重新计算索引效率更高：根据数组容量的最高位的0或1来决定元素的位置</p>
<blockquote>
<p>扩容时会拆分树、链表，需要计算拆分后链表的新位置</p>
<p>hash &amp; oldCap == 0 的元素留在原来位置 ，反之 hash &amp; oldCap == 1的</p>
<p>新位置 = 旧位置 + oldCap</p>
</blockquote>
</li>
</ol>
<ul>
<li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li>
</ul>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="哈希碰撞">哈希碰撞</span></h3>
<p>即两元素计算索引结果一致，将插入数组的同一下标</p>
<blockquote>
<p>不超过16位的值类型产生哈希碰撞，意味着它们与数组长度取模后的结果相等</p>
</blockquote>
<h3><span id="判重">判重</span></h3>
<p><code>p.hash == hash &amp;&amp;  (p.key == key || (key != null &amp;&amp; key.equals(p.key)))</code></p>
<ol>
<li>
<p>二次哈希的结果相等</p>
</li>
<li>
<p>且键的地址一致或键的equals相等，则说明两元素重复</p>
<blockquote>
<p>重复的元素一定会发生哈希碰撞</p>
</blockquote>
</li>
</ol>
<h3><span id="重复元素的处理">重复元素的处理</span></h3>
<ul>
<li>
<p>put()方法的参数onlyIfAbsent 为true时丢弃重复元素，false替换原数组元素</p>
</li>
<li>
<p>hashMap替换重复元素，hashSet丢弃重复元素</p>
</li>
</ul>
<h3><span id="树化">树化</span></h3>
<p><strong>树化意义</strong></p>
<ul>
<li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li>
<li>hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>
<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>
</ul>
<p><strong>树化规则</strong></p>
<ol>
<li>若结点数组中的链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;=64，才会进行树化</li>
<li>将链表上的元素转换成红黑树的形式插入结点数组中</li>
</ol>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<span class="comment">//64</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;<span class="comment">//链表上有元素</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">//遍历该链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);	<span class="comment">//将结点转换为树结点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)	<span class="comment">//树节点链表插入数组中</span></span><br><span class="line">            hd.treeify(tab);	<span class="comment">//将树节点链表构建成红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="链化">链化</span></h3>
<ul>
<li>情况1：在扩容时如果拆分树时，树元素个数 &lt;= 6 则会退化链表</li>
<li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除元素过程">删除元素过程</span></h3>
<ol>
<li>(tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null</li>
<li>根据hash查找要删除元素所在数组的下标位置
<ol>
<li>查找的结点与要删除结点一致（重复），则删除数组中的结点</li>
<li>查找的结点为树节点，则从树中查找是否有要删除的结点，并删除树中的结点</li>
<li>查找的结点有挂链，则遍历链表查找是否又要删除的结点，并删除链表中的结点</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true 只在value相等时删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false 删除时不移动其他结点</span></span><br><span class="line"><span class="comment"> * @返回结点，如果没有为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">//结点数组不为空且长度大于0，且要删除的数组位置不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;	</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))	<span class="comment">//两元素重复</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;	<span class="comment">//不重复，但next指向不为空</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)	<span class="comment">//树节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<span class="comment">//获取树中的结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//重复</span></span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||	 <span class="comment">//matchValue：true 只在value相等时删除</span></span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);	<span class="comment">//删除树节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;	<span class="comment">//删除数组元素</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;<span class="comment">//删除链表中结点</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="并发问题">并发问题</span></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;	<span class="comment">//遍历数组中的非空结点</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第二阶段</category>
      </categories>
  </entry>
</search>
