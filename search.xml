<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/post/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行运行</td>
<td>Shift + F10</td>
<td>万能解错/生成返回值</td>
<td>Alt + Enter</td>
</tr>
<tr>
<td>提示补全</td>
<td>Ctrl +空格(改成 Alt+/)</td>
<td>返回上次查看代码的位置</td>
<td>Ctrl + Alt + 左右箭头</td>
</tr>
<tr>
<td>单行注释</td>
<td>Ctrl + /</td>
<td>查看继承关系</td>
<td>Ctrl + H</td>
</tr>
<tr>
<td>多行注释</td>
<td>Ctrl + Shift + /</td>
<td>格式化代码</td>
<td><strong>Ctrl + Alt + L</strong></td>
</tr>
<tr>
<td>向下复制一行</td>
<td>Ctrl + D</td>
<td>提示方法参数类型</td>
<td>Ctrl + P</td>
</tr>
<tr>
<td>删除一行或多行</td>
<td>Ctrl + Y</td>
<td>复制</td>
<td>Ctrl + C</td>
</tr>
<tr>
<td>向上/下移动一行</td>
<td><strong>Alt+Shift+上或下箭头</strong></td>
<td>撤销</td>
<td>Ctrl + Z</td>
</tr>
<tr>
<td>向下开始新的一行</td>
<td>Shift + Enter</td>
<td>剪切</td>
<td>Ctrl + X</td>
</tr>
<tr>
<td>向上开始新的一行</td>
<td>Ctrl + Alt + Enter</td>
<td>粘贴</td>
<td>Ctrl + V</td>
</tr>
<tr>
<td>查看源码</td>
<td>Ctrl + 鼠标左键</td>
<td>保存</td>
<td>Ctrl + S</td>
</tr>
<tr>
<td>搜索类</td>
<td>Ctrl + N</td>
<td>全选</td>
<td>Ctrl + A</td>
</tr>
<tr>
<td>整体向后移动</td>
<td>Tab</td>
<td>全局查找</td>
<td>Ctrl + Shift+R</td>
</tr>
<tr>
<td>整体向前移动</td>
<td>Shift + Tab</td>
<td>查找任何东西</td>
<td>Shift+Shift</td>
</tr>
<tr>
<td>查看类的结构</td>
<td>Ctrl + F12</td>
<td>查看类的继承结构图</td>
<td>Ctrl + Alt + U</td>
</tr>
<tr>
<td>重构方法变量名</td>
<td>Shift + F6</td>
<td>抽取方法</td>
<td>Ctrl + Alt + M</td>
</tr>
<tr>
<td>大小写转换</td>
<td>Ctrl +Shift + U</td>
<td>最近修改的文件</td>
<td>Ctrl + E</td>
</tr>
<tr>
<td>生成get/set/toString</td>
<td>Alt + Insert</td>
<td>选择粘贴内容</td>
<td>Ctrl + Shift + V</td>
</tr>
<tr>
<td>查看文档说明</td>
<td>Ctrl + Q</td>
<td>优化导入的类</td>
<td>Ctrl + Alt + O</td>
</tr>
<tr>
<td>收起/展开所有方法</td>
<td>Ctrl + Shift + “+/-”</td>
<td>寻找方法被调用的地方</td>
<td>Alt + Alt + F7</td>
</tr>
<tr>
<td>生成surround with</td>
<td>Ctrl + Alt+T</td>
<td>跳到文件尾部</td>
<td>Ctrl + End</td>
</tr>
<tr>
<td>查找</td>
<td>Ctrl + F</td>
<td>跳到文件头部</td>
<td>Ctrl + Home</td>
</tr>
<tr>
<td>查找替换</td>
<td>Ctrl + R</td>
<td>实现/重写方法</td>
<td>Ctrl + O/</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>DOS常用命令</title>
    <url>/post/DOS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="DOS命令的基础使用：">DOS命令的基础使用：</h2>
<h3 id="dir"><code>dir</code></h3>
<ul>
<li>查看当前目录，其中dir指directory</li>
</ul>
<h3 id="mkdir-md"><code>mkdir</code>(md)</h3>
<ul>
<li>创建文件夹</li>
</ul>
<span id="more"></span>
<h3 id="rmdir-rd"><code>rmdir</code>(rd)</h3>
<ul>
<li>删除文件夹，若要删除非空的文件夹，需要<code>-s</code>来强行删除该文件夹下的所有子文件夹与文件，再加上<code>-q</code>则无需确认（安静模式）</li>
</ul>
<h3 id="cd"><code>cd</code></h3>
<ul>
<li>
<p>可以跳转至当前目录的所有子孙目录，但无法进行跨盘符跳转；若要进行跨盘符跳转，则使用“盘符”+“:”，例如<code>c:</code>,<code>d:</code>,<code>e:</code></p>
</li>
<li>
<p>特别地，<code>cd .\</code>表示当前目录<code>cd ..</code> 表示返回上一级目录,<code>cd \</code> 表示返回根目录</p>
</li>
</ul>
<h3 id="echo-回声"><code>echo</code>(回声)</h3>
<ul>
<li><code>echo 123</code>只使用echo + 字符串，则表示打印该字符串</li>
<li><code>echo 123 &gt; d:\hello.txt </code>加上大于号，表示将打印的字符串重定向到指定位置，此时对同一个文件多次echo将会覆盖上次写的内容</li>
<li><code>echo 123 &gt;&gt; d:\hello.txt</code> 两个大于号可对上次写下的内容进行叠加</li>
</ul>
<h3 id="del"><code>del</code></h3>
<ul>
<li>删除文件</li>
<li><code>del *.txt</code> 通配符删除，意为将当前目录下所有后缀为txt的文·件删除</li>
</ul>
<h3 id="type"><code>type</code></h3>
<ul>
<li>仅能查看文本文件内容</li>
</ul>
<h3 id="cls"><code>cls</code></h3>
<ul>
<li>clean sreen 清空屏幕</li>
</ul>
<h3 id="tree"><code>tree</code></h3>
<ul>
<li>以树形显示该目录下的所有文件夹</li>
<li>加上<code>-f</code> 可同时显示该目录下的所有文件</li>
</ul>
<h2 id="绝对路径与相对路径：">绝对路径与相对路径：</h2>
<ul>
<li>
<p>绝对路径：从盘符开始的路径</p>
</li>
<li>
<p>相对路径：从当前目录开始的路径</p>
</li>
</ul>
<h2 id="网络命令">网络命令</h2>
<ul>
<li>
<p><code>ping</code> 检查是否可以和其他主机通信</p>
<p><code>-t</code> 不间断发送数据包</p>
</li>
<li>
<p><code>ipconfig</code> 查看网卡信息</p>
<p><code>/all</code> 查看详细的网卡信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
      <tags>
        <tag>Dos</tag>
      </tags>
  </entry>
  <entry>
    <title>常用模板</title>
    <url>/post/IDEA%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>模板</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>psvm</strong></td>
<td>可生成 main 方法</td>
</tr>
<tr>
<td><strong>sout</strong></td>
<td>System.out.println() 快捷输出</td>
</tr>
<tr>
<td><strong>soutp</strong></td>
<td>System.out.println(&quot;方法形参名 = &quot; +  形参名);</td>
</tr>
<tr>
<td><strong>soutv</strong></td>
<td>System.out.println(&quot;变量名 = &quot; + 变 量);</td>
</tr>
<tr>
<td><strong>soutm</strong></td>
<td>System.out.println(“当前类名.当前方 法”);</td>
</tr>
<tr>
<td><strong>“abc”.sout</strong></td>
<td>System.out.println(“abc”);</td>
</tr>
<tr>
<td><strong>fori</strong></td>
<td>可生成 for 循环</td>
</tr>
<tr>
<td>iter</td>
<td>可生成增强 for 循环</td>
</tr>
<tr>
<td>itar</td>
<td>可生成普通 for 循环</td>
</tr>
<tr>
<td>list.for</td>
<td>可生成集合 list 的 for 循环 ,for(String s:list){}</td>
</tr>
<tr>
<td><strong>ifn</strong></td>
<td>可生成 if(xxx = null)</td>
</tr>
<tr>
<td><strong>inn</strong></td>
<td>可生成 if(xxx != null)或xxx.nn或 xxx.null</td>
</tr>
<tr>
<td>prsf</td>
<td>可生成 private static final</td>
</tr>
<tr>
<td>psf</td>
<td>可生成 public static final</td>
</tr>
<tr>
<td>psfi</td>
<td>可生成 public static final int</td>
</tr>
<tr>
<td>psfs</td>
<td>可生成 public static final String</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>JDK的安装及环境变量的配置</title>
    <url>/post/JDK%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1>引言</h1>
<p>JDK是Java开发的重要工具，安装JDK是学好Java的第一步</p>
<span id="more"></span>
<h1>JDK 的安装</h1>
<h2 id="下载">下载</h2>
<p>首先通过甲骨文官方下载JDK所需的安装包</p>
<p><a href="https://www.oracle.com/java/technologies/downloads/archive/">Java Archive | Oracle</a></p>
<p>选择需要的JDK版本，通常使用的是JDK8</p>
<img src="https://pic.imgdb.cn/item/6391d5c8b1fccdcd362211e2.png" style="zoom:50%;">
<p>往下找到适配自己系统的JDK，这里演示的是windows64字节</p>
<img src="https://pic.imgdb.cn/item/6391d6b8b1fccdcd362376b7.png" style="zoom: 33%;">
<p>点击下载链接，勾选接受协议，将会跳转至Oracle登录界面，没有Oracle账号还需注册，登录成功即可开始下载</p>
<h2 id="安装">安装</h2>
<ul>
<li>
<p>作为开发人员安装JDK，<strong>设置公共JRE公共功能不可用</strong>，因JDK本身即包含了JRE，无需再次安装，关于JDK： <a href="../Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0">Java语言概述</a></p>
</li>
<li>
<p>其次，安装的路径下<strong>不得存在中文</strong>，</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391d82cb1fccdcd3625d862.png" style="zoom: 80%;">
<h1>环境变量的配置</h1>
<h2 id="查看环境变量">查看环境变量</h2>
<p>鼠标右击此电脑点击属性，对于win11的系统，点击设备规格下的高级系统设置，点击环境变量</p>
<img src="https://pic.imgdb.cn/item/6391de65b1fccdcd362eea05.png" style="zoom: 80%;">
<h2 id="JAVA-HOME">JAVA_HOME</h2>
<p>点击系统变量中的新建，添加一个名为JAVA_HOME的变量，变量值为JDK的安装路径</p>
<img src="https://pic.imgdb.cn/item/6391de3db1fccdcd362eb8e5.png" style="zoom: 80%;">
<h2 id="Path">Path</h2>
<p>点击系统变量中的编辑，点击新建，输入<code>%JAVA_HOME%\bin</code></p>
<img src="https://pic.imgdb.cn/item/6392fd2db1fccdcd36c029a3.png" style="zoom:80%;">
<h2 id="CLASSPATH">CLASSPATH</h2>
<p>同理添加一个名为CLASSPATH的变量，变量值为</p>
<p><code> .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></p>
<p>这里需注意：</p>
<ul>
<li>CLASSPATH变量中的字符必须是英文字符</li>
<li>此处的%JAVA_HOME%意为对上一个JAVA_HOME的引用，即JDK的安装路径</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391e15eb1fccdcd3633b5d5.png" style="zoom: 80%;">
<p>随后一路确定，即配置完成</p>
<h1>测试</h1>
<p>win+r查看cmd，输入<code>java -version</code>查看JDK版本信息</p>
<img src="https://pic.imgdb.cn/item/6391e1f1b1fccdcd36358bae.png" style="zoom: 80%;">
<h1>总结</h1>
<h2 id="为什么要配置环境变量">为什么要配置环境变量?</h2>
<h3 id="path">path</h3>
<p>首次安装JDK后，当我们想去编译某个.java源代码，需要执行JDK的bin目录下的某个可执行文件(.exe)；在执行DOS命令行中，windows首先在当前目录下查找是否存在所指的可执行文件，若没有找到，将到path环境变量指定的目录中查找，若扔未找到，则报错。</p>
<p>对此，我们只能在DOS命令行中写下要执行文件的绝对路径，这使操作变得复杂。</p>
<p>根据windows系统查找可执行文件的原理，我们可以将常执行的文件的目录配置到环境变量中，如此，我们便可以不写文件的绝对路径仍能执行文件。</p>
<h3 id="JAVA-HOME-2">JAVA_HOME</h3>
<p>在配置了path的基础上，可能会出现多个环境变量需要配置JDK路径的情况，如果想更改使用JDK的版本号，需要找到每个JDK路径并修改他们，这将是个麻烦的过程。</p>
<p>因此，将JDK路径配置到JAVA_HOME下将方便我们对JDK版本的切换。</p>
<p>部分第三方软件约定使用JAVA_HOME来指定JDK路径（Tomcat）。</p>
<h3 id="CLASSPATH（一般不需配置）">CLASSPATH（一般不需配置）</h3>
<p>编译源代码生成的字节码文件，交给JVM运行处理，在没有配置classpath的情况下，在DOS命令行中输入运行指令，首先，JVM中的类加载器从当前目录下查找是否存在字节码文件，若找不到字节码文件则报错。因此，配置ClassPath环境变量是为了使类加载器从配置的路径中找到字节码文件。<a href="../Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">Java加载及执行原理</a></p>
<p>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</p>
<p>变量中包含了多条路径，它们分别由<code>;</code>隔开，其中 <code>.</code>指的是当前路径；其余两条路径分别为<code> %JAVA_HOME%\lib\dt.jar</code>、<code>%JAVA_HOME%\lib\tools.jar</code>。</p>
<p>一般情况下要想运行.class文件会切换至.class文件所在的目录，也就是当前路径，因此，CLASSPATH一般不需要配置</p>
<ul>
<li>问题：当两个类被分别放在不同目录下，但两个类之间存在调用另一个类的方法，如何使两个类正常运行？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test1</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args&#123;</span></span><br><span class="line"><span class="params">		System.out.println(<span class="string">&quot;222222222&quot;</span>)</span>;</span><br><span class="line">     	test1.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test2类调用了test1类的方法，经过测试我们无法直接编译test2.Java源文件</p>
<p><img src="https://pic.imgdb.cn/item/639318d0b1fccdcd36f02e1e.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -classpath &quot;另一个类所处目录路径&quot; test2.java</span><br></pre></td></tr></table></figure>
<p>通过Java命令-classpath修改CLASSPATH路径，实现对test2的编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -classpath .;&quot;另一个类所处目录路径&quot; test2</span><br></pre></td></tr></table></figure>
<p>执行.class文件时，仅配置了另一个类所处目录的路径会找不到当前要执行的test2.class，因此加上当前目录，即可运行</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java加载及执行原理</title>
    <url>/post/Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1>Java程序执行原理</h1>
<p>编程人员编写.Java源文件，经过编译器编译(javac)成.class字节码文件，字节码文件通过JVM的类加载器加载至执行引擎，执行引擎执行(java)字节码文件并与操作系统交互。</p>
<span id="more"></span>
<p><img src="https://pic.imgdb.cn/item/6393113db1fccdcd36e17411.png" alt="执行过程"></p>
<h1>源文件、类、字节码文件</h1>
<ul>
<li>源文件中可包含一个或多个类</li>
<li>源文件中至多有一个类被public修饰，当源文件中有public修饰类，原文件名必须与public修饰类名一致，当源文件中没有public修饰类，则源文件名与类名没有关系</li>
<li>在编译的过程中，对应每个类会生成相应的.class字节码文件，也就是说，当源文件中存在多个类时，编译完成后，会生成多个与类名一致的.class字节码文件</li>
<li>执行过程中，只需要指定字节码文件运行</li>
</ul>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java文档注释</title>
    <url>/post/Java%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h1>引言</h1>
<ul>
<li>
<p>注释可以提高代码的可读性，清晰完整的注释便于程序调试的过程</p>
</li>
<li>
<p>于编程者而言，书写注释是编程路上必须具有的良好习惯</p>
</li>
<li>
<p>对代码的解释说明,就像产品的说明书一样,良好的注释会减少团队的沟通成本</p>
</li>
</ul>
<span id="more"></span>
<ul>
<li>单行注释	/注释文字/</li>
<li>多行注释    /<em>注释文字</em>/     多行注释中不能有多行注释嵌套</li>
</ul>
<h1>文档注释</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span>	指定java程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment"><span class="doctag">@since</span> 自从哪个版本号开始就存在了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的程序的说明文档。</p>
<p>操作方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc –d mydoc –author –version FileName.java</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Java语言概述</title>
    <url>/post/Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1>介绍</h1>
<p>Java 是一种<strong>高级的、面向对象的、健壮的、多线程的、可跨平台的</strong>程序设计语言</p>
<span id="more"></span>
<h1>Java语言的特点</h1>
<h2 id="简单">简单</h2>
<p>Java相较于C语言<strong>少了复杂的指针，仅支持单继承</strong></p>
<h2 id="面向对象（封装、继承、多态）">面向对象（封装、继承、多态）</h2>
<h2 id="健壮">健壮</h2>
<p>Java相较于C语言，<strong>无需开发人员对内存进行管理</strong>，Java本身预留一条线程监测内存并自动申请或释放（GC机制）</p>
<h2 id="多线程">多线程</h2>
<p>Java支持<strong>多条线程并发进行</strong></p>
<h2 id="跨平台">跨平台</h2>
<p>通过Java语言编写的应用程序可以在<strong>不同系统环境下运行</strong>（JVM）</p>
<h1>Java技术体系平台</h1>
<h2 id="JavaSE">JavaSE</h2>
<p>Java标准版，主要面向<strong>桌面级应用程序</strong>的开发，为JavaEE、JavaME提供基础</p>
<h2 id="JavaEE">JavaEE</h2>
<p>Java企业版，主要用于<strong>企业应用的、部署在服务器端的Java应用程序</strong>的开发</p>
<h2 id="JavaME">JavaME</h2>
<p>Java微型版，支持Java在<strong>嵌入式等移动终端</strong>上运行</p>
<h2 id="三者之间的关系">三者之间的关系</h2>
<p>JavaEE和JavaME都包含了JavaSE，因此学习JavaSE是学习JavaEE、JavaME的基础</p>
<img src="https://pic.imgdb.cn/item/6391cce1b1fccdcd36138138.png" alt="三者之间关系" style="zoom: 50%;">
<h1>JVM、JRE、JDK三者关系</h1>
<h2 id="JVM（Java-Virtual-Machine）">JVM（Java Virtual Machine）</h2>
<p>Java虚拟机，Java源代码经过编译后生成的字节码需要通过Java虚拟机才能在不同的操作系统环境下运行。Java虚拟机是Java实现跨平台运行的关键。</p>
<p>JVM如何实现Java跨平台运行？</p>
<ul>
<li>对于不同的系统环境，提供了相对应的Java虚拟机</li>
<li>JVM接收源代码变异后的字节码，屏蔽了操作系统下的底层运行原理</li>
</ul>
<img src="https://pic.imgdb.cn/item/6391d2a8b1fccdcd361c1520.png" alt="JVM实现原理" style="zoom: 50%;">
<h2 id="JRE（Java-Runtime-Environment）">JRE（Java Runtime Environment）</h2>
<p>Java运行环境，JRE包括JVM以及一些Java基本类库，JRE可满足运行Java应用程序的需求。</p>
<h2 id="JDK（Java-Development-Kit）">JDK（Java Development Kit）</h2>
<p>Java开发工具包，JDK包括JRE以及Java开发工具，提供给开发人员使用</p>
<img src="https://pic.imgdb.cn/item/6391e28cb1fccdcd363743c4.png" style="zoom:50%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown 入门使用</title>
    <url>/post/Markdown%20%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。</p>
<span id="more"></span>
<h2 id="标题">标题</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h1>标题1</h1>
<h2 id="标题2">标题2</h2>
<h3 id="标题3">标题3</h3>
<h4 id="标题4">标题4</h4>
<h5 id="标题5">标题5</h5>
<h6 id="标题6">标题6</h6>
</blockquote>
<h2 id="列表">列表</h2>
<h3 id="有序列表">有序列表</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">把大象放进冰箱：</span><br><span class="line"><span class="bullet">1.</span> 打开冰箱</span><br><span class="line"><span class="bullet">2.</span> 把大象放进冰箱</span><br><span class="line"><span class="bullet">3.</span> 关上冰箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把大象放进冰箱:</p>
<ol>
<li>打开冰箱</li>
<li>把大象放进冰箱</li>
<li>关上冰箱</li>
</ol>
</blockquote>
<h3 id="无序列表">无序列表</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">无序列表：</span><br><span class="line"><span class="bullet">-</span> 所爱扥就</span><br><span class="line"><span class="bullet">-</span> 撒欧丹发腮</span><br><span class="line"><span class="bullet">-</span> 哦啊赛季反扒</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无序列表：</p>
<ul>
<li>所爱扥就</li>
<li>撒欧丹发腮</li>
<li>哦啊赛季反扒</li>
</ul>
</blockquote>
<h2 id="任务列表">任务列表</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">明天要做的事：	</span><br><span class="line"><span class="bullet">-</span> [ ] 吃饭	//每个字符之间由空格隔开	</span><br><span class="line"><span class="bullet">-</span> [ ] 睡觉</span><br><span class="line"><span class="bullet">-</span> [ ] 打豆豆</span><br></pre></td></tr></table></figure>
<blockquote>
<p>明天要做的事：</p>
<ul>
<li>[ ] 吃饭</li>
<li>[ ] 睡觉</li>
<li>[ ] 打豆豆</li>
</ul>
</blockquote>
<h2 id="代码块">代码块</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">``` c      //选择语言</span></span><br><span class="line"><span class="code">int main()&#123;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="数学公式：">数学公式：</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;\partial f&#125;&#123;\partial x&#125; = 2\sqrt&#123;a&#125;x</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$$<br>
\frac{\partial f}{\partial x} = 2\sqrt{a}x<br>
$$</p>
</blockquote>
<h2 id="表格">表格</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|姓名|年龄|成绩|</span><br><span class="line">|:--|--:|:-----:| </span><br><span class="line"><span class="code">			//冒号靠左为左对齐，靠右为右对齐，两边都有冒号为居中对齐</span></span><br><span class="line"><span class="code">|张三|18|90|</span></span><br><span class="line"><span class="code">|李四|20|89|</span></span><br></pre></td></tr></table></figure>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:right">年龄</th>
<th style="text-align:center">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">张三</td>
<td style="text-align:right">18</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:left">李四</td>
<td style="text-align:right">20</td>
<td style="text-align:center">89</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="脚注">脚注</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一条注释[^注释]</span><br><span class="line">[<span class="symbol">^注释</span>]:<span class="link">这是注释的注释。</span></span><br><span class="line"> ---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一条注释<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<hr>
</blockquote>
<h2 id="超链接">超链接</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span>)</span><br><span class="line">[<span class="string">百度</span>][<span class="symbol">id</span>]</span><br><span class="line">[<span class="symbol">id</span>]:<span class="link">http://www.baidu.com &quot;一个搜索引擎&quot;</span></span><br><span class="line"></span><br><span class="line">请参考[<span class="string">标题1</span>](<span class="link">#标题</span>)</span><br><span class="line"></span><br><span class="line">URL：</span><br><span class="line">http://www.baidu.com</span><br><span class="line"></span><br><span class="line">![<span class="string">百度</span>](<span class="link">https://imgse.com/i/z2p2JH&quot;百度搜索&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.baidu.com" title="一个搜索引擎">百度</a><br>
<a href="http://www.baidu.com" title="一个搜索引擎">百度</a></p>
<p>请参考<a href="#%E6%A0%87%E9%A2%98">标题1</a></p>
<p>URL：<br>
<a href="http://www.baidu.com">http://www.baidu.com</a></p>
<p><img src="https://pic.imgdb.cn/item/63914551b1fccdcd36559921.png%22%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%22" alt="百度"></p>
</blockquote>
<h2 id="字体变化">字体变化</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="code">`行内代码printf()`</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">:smile:</span><br><span class="line">$\theta=x^2$</span><br><span class="line">H~2~O,x^2^</span><br><span class="line">==这是一段高亮文字==</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>斜体</em><br>
<strong>加粗</strong><br>
<code>行内代码printf()</code><br>
<u>下划线</u><br>
😄<br>
$\theta=x^2$<br>
H<sub>2</sub>O,x<sup>2</sup><br>
==这是一段高亮文字==</p>
</blockquote>
<h2 id="参考视频">参考视频</h2>
<iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这是注释的注释。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Object类</title>
    <url>/post/Object%E7%B1%BB/</url>
    <content><![CDATA[<p>Object类是所有类的根类,如果一个类没有显示的继承其他类,默认继承Object</p>
<p>Object的类型变量可以指向任意类型的子类对象</p>
<span id="more"></span>
<h2 id="int-hashCode">int hashCode()</h2>
<p>返回该对象的哈希码值 可以类似的看做虚拟内存地址</p>
<h2 id="Class-getClass">Class&lt;?&gt; getClass()</h2>
<p>返回此对象的运行时类。看创建对象是哪个类</p>
<table>
<thead>
<tr>
<th>getClass()</th>
<th>getClass().getName()</th>
<th>getClass().getSimpleName()</th>
</tr>
</thead>
<tbody>
<tr>
<td>class  包名.类名</td>
<td>包名.类名</td>
<td>类名</td>
</tr>
</tbody>
</table>
<h2 id="String-toString">String toString()</h2>
<p>返回该对象的字符串表示。</p>
<ul>
<li>
<p>默认实现 类的全限定名@hashcode的十六进制</p>
</li>
<li>
<p>自定义类如果不想按照上面的格式输出 需要重写toString()</p>
</li>
</ul>
<h2 id="protected-void-finalize">protected void finalize()</h2>
<p>当对象不再被程序使用时，垃圾回收器将会将其回收</p>
<p>垃圾回收是在后台运行的，我们无法命令垃圾回收器马上回收资源，但是我们可 以告诉他，尽快回收资源（<strong>System.gc</strong> 和 Runtime.getRuntime().gc()）</p>
<p>垃圾回收器在回收某个对象的时候，首先会调用该对象的 finalize 方法</p>
<p>GC 主要针对堆内存 当垃圾收集器将要收集某个垃圾对象时将会调用 finalize，建议不要使用此方法，因为此方法的运行时间不确定，如果执行此方法出现错误，程序不会报告，仍然继续运行</p>
<h2 id="boolean-equals-Object-obj">boolean equals(Object obj)</h2>
<p>指示其他某个对象是否与此对象“相等”。</p>
<h2 id="和-equals-区别">== 和 equals 区别?</h2>
<table>
<thead>
<tr>
<th>== 比较运算符</th>
<th>equals是object中的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>既可以比较基本数据类型 也可以比较引用数据类型</td>
<td>只能比较引用数据类型</td>
</tr>
<tr>
<td>对于引用数据类型，比较的是地址</td>
<td>默认情况下equals方法底层使用==实现, 和 equals比较结果是一样</td>
</tr>
<tr>
<td></td>
<td>可重写成比较属性是否相等</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//存储在方法区同一地址下</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3.equals(str4));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>比较引用数据类型，使用equals更好</p>
<p>对于File、String、Date及包装类来说，是比较类型及内容而不考虑引用的是否是同一个对象；</p>
<p>原因：在这些类中重写了Object类的 equals()方法</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>static、final关键字</title>
    <url>/post/static%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1>static</h1>
<h2 id="修饰属性">修饰属性</h2>
<p>static修饰的属性称为：静态变量、全局变量、静态属性、全局属性、类变量、类属性，非static修饰的属性可称为实例变量</p>
<span id="more"></span>
<ul>
<li>静态属性随类的加载而加载，先于对象存在</li>
<li>静态属性仅存放JVM方法区的静态域中，所有对象共享</li>
</ul>
<p>静态属性常用于所有对象属性值唯一的属性，即属性值与对象无关</p>
<p><img src="https://pic.imgdb.cn/item/63a97c1608b6830163f144a1.png" alt></p>
<h2 id="修饰方法">修饰方法</h2>
<p>static修饰的方法称为：静态方法，非static修饰的方法可称为实例方法</p>
<ul>
<li>静态方法随着类的加载而加载，先于对象存在</li>
<li>静态方法常通过 类名.方法名 调用</li>
<li>静态方法无法访问非静态属性、非静态方法，他们需要实例才可以访问</li>
<li>实例方法既可以访问静态属性、静态方法，也可以访问非静态属性、非静态方法</li>
</ul>
<p>静态方法常用于</p>
<p>1.工具类（直接使用  类名.方法名 调用，Math.random() ）</p>
<p>2.处理静态属性的方法</p>
<p><strong>main()方法</strong>也是静态方法，在main()方法中不能直接访问该类中的非静态成员，需要创建实例对象，通过实例对象访问该类中的非静态成员</p>
<p>main()方法中的关键字</p>
<ul>
<li>Java虚拟机需要访问main()方法，访问权限使用public</li>
<li>main()方法无需创建实例对象，使用static</li>
<li>接收个String类型的数组参数，可通过java指令传参   <strong>java 类名  “XXX” “XXX” “XXX”</strong></li>
</ul>
<h2 id="修饰代码块">修饰代码块</h2>
<p>static修饰的代码块常用于初始化静态属性</p>
<h2 id="修饰内部类">修饰内部类</h2>
<h1>代码块</h1>
<p>代码块只能有static关键字来修饰，其中static修饰的称为静态代码块，否则称为实例代码块，代码块是为了对Java类或对象进行初始化</p>
<table>
<thead>
<tr>
<th>静态代码块</th>
<th>非静态代码块</th>
</tr>
</thead>
<tbody>
<tr>
<td>随着类的加载而加载，仅执行一次</td>
<td>每次创建对象都执行一次，先于构造器执行</td>
</tr>
<tr>
<td>静态代码块先于非静态代码块执行</td>
<td></td>
</tr>
<tr>
<td>静态代码块间顺序执行</td>
<td>非静态代码块间顺序执行</td>
</tr>
<tr>
<td>不可以调用非静态的属性和方法。</td>
<td>既能调用非静态成员，还能调用静态成员</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Order&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    	orderId = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    	orderId = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;<span class="comment">//同级别顺序执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; </span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">        System.out.print(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();      <span class="comment">//BCEF</span></span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();      <span class="comment">//BCEF</span></span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Father</span>();   <span class="comment">//BC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ADG************************</span><br><span class="line">BCEF************************</span><br><span class="line">BCEF************************</span><br><span class="line">BC</span><br></pre></td></tr></table></figure>
<h1>final</h1>
<ol>
<li>使用final修饰的类不能被继承</li>
<li>使用final修饰的方法不能被重写</li>
<li>使用final标记的变量称为常量。名称大写，且只能被赋值一次。</li>
</ol>
<p>final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</p>
<ul>
<li>final修饰基本数据类型的变量，值不能改变</li>
<li>修饰引用型数据类型的变量时，地址不能改变</li>
</ul>
<p>final、static同时修饰的属性为：全局唯一常量</p>
<h1>单例模式</h1>
<p>保证整个系统中一个类只有一个对象的实例，实现这种功能的方式就叫单例模式</p>
<ol>
<li>构造私有: 如果要保证一个类不能多次被实例化，那么我肯定要阻止对象被new 出来，所以需要把 类的所有构造方法私有化。</li>
<li>以静态方法返回实例。 因为外界就不能通过new来获得对象，所以我们要通过提供类的方法来让外界获取对象实例。</li>
<li>确保对象实例只有一个。 只对类进行一次实例化，以后都直接获取第一次实例化的对象。</li>
</ol>
<h2 id="懒汉模式">懒汉模式</h2>
<p>先不创建类的对象实例，等你需要的时候我再创建，线程不安全 节省资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstence</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="饿汉模式">饿汉模式</h2>
<p>我先把对象（面包）创建好，等我要用（吃）的直接直接来拿就行了，浪费资源  线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>super</title>
    <url>/post/super/</url>
    <content><![CDATA[<h1>super	超类的</h1>
<h2 id="子类对象实例化过程">子类对象实例化过程</h2>
<ul>
<li>
<p>不断向上查找直至到达顶层父类Object，然后不断向下依次调用父类的构造器进行父特征的初始化</p>
</li>
<li>
<p>整个过程只产生了一个对象</p>
</li>
</ul>
<p>super代表的就是父特征</p>
<h2 id="使用">使用</h2>
<blockquote>
<p>super()</p>
</blockquote>
<p>继承体系中,一定会调用<strong>父类的构造器</strong>初始化父特征，super()是子类构造器默认的第一行</p>
<blockquote>
<p>super.成员</p>
</blockquote>
<p>调用<strong>父类的属性和方法</strong></p>
<h3 id="调用父类的构造器">调用父类的构造器</h3>
<ol>
<li>子类中所有的构造器默认都会访问父类中无参数的构造器（默认有super()）</li>
<li>若父类中没有无参数的构造器，子类构造器必须调用本类或者父类中相应的构造器。即通过this(参数列表)或者super(参数列表)语句，且必须放在构造器的首行</li>
<li>若父类中没有无参数的构造器，且子类构造器中既未显式调用父类或本类的构造器，则编译出错</li>
</ol>
<h3 id="super（大多情况可省略）">super（大多情况可省略）</h3>
<ul>
<li>当<strong>父类和子类的属性名称相同</strong>，必须使用super.属性指定父类的属性</li>
<li>当<strong>方法重写需要调用父类的同名属性或者方法</strong>的时候,super不能省略</li>
</ul>
<h3 id="this和super">this和super</h3>
<table>
<thead>
<tr>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>变量</title>
    <url>/post/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1>引言</h1>
<p>由于变量能够把程序中准备使用的每一段数据都赋给一个简短、易于记忆的名字，因此它们十分有用。变量可以保存程序运行时用户输入的数据、特定运算的结果以及要在窗体上显示的一段数据等。简而言之，变量是用于跟踪几乎所有类型信息的简单工具。</p>
<span id="more"></span>
<h1>数据</h1>
<p>字面量即数据</p>
<h2 id="数据类型">数据类型</h2>
<h1>变量</h1>
<h2 id="变量使用">变量使用</h2>
<h3 id="声明变量">声明变量</h3>
<p>int var;</p>
<h3 id="变量的赋值">变量的赋值</h3>
<p>var = 10;</p>
<h3 id="声明和赋值变量">声明和赋值变量</h3>
<p>int var = 10; （数据类型，存储范围）</p>
<ul>
<li>Java可以在一行声明多个变量,例如: int a,b,c; long a,b,c=100</li>
<li>局部变量声明后必须赋值才能使用</li>
</ul>
<h3 id="变量的作用域（局部变量）">变量的作用域（局部变量）</h3>
<p>变量的作用域在前后花括号{}之间，作用域外相当于没有声明过该变量</p>
<p>作用域内只能有一个同名变量</p>
<h2 id="变量分类">变量分类</h2>
<p>变量可按照声明位置、数据类型分类</p>
<h3 id="按声明位置">按声明位置</h3>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量。</li>
<li>二者都有生命周期，但局部变量除形参外，需初始化。</li>
</ul>
<h3 id="按数据类型">按数据类型</h3>
<p>变量的类型必须与数据的类型一致</p>
<img src="https://pic.imgdb.cn/item/639332ffb1fccdcd36247b54.png" alt="数据类型" style="zoom: 67%;">
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>包装类的使用</title>
    <url>/post/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>针对八种基本数据类型定义相应的引用类型—包装类</p>
<p>首先,Java语言是一个面向对象的语言,但是Java中的基本数据类型却是不面向对象的，为了实现一 切皆对象,将每个基本数据类型设计一个对应的类进行代表，这种方式增强了Java面向对象的性质。</p>
<p>其次，如果仅仅有基本数据类型，那么在实际使用时将存在很多的不便，很多地方都需要使用对象。比如，在集合类中，我们是无法将int 、double等类型放进去的，因为集合的容器要求元素是Object类型。而包装类型的存在使得向集合中传入数值成为可能，包装类的存在弥补了基本数据类型的不足。</p>
<p>此外，包装类还为基本类型添加了属性和方法，丰富了基本类型的操作。如当我们想知道int取值 范围的最小值，我们需要通过运算，如下面所示，但是有了包装类，我们可以直接使Integer.MAX_VALUE即可。</p>
<p>注意:为什么要保留基本数据类型？Java种创建的对象都是存储在堆里的，使用的时候需要通过栈中的引用， 所以常用的基本数据类型，不需要使用new在堆上创建，而是直接在栈内存中存储不创建对象，就会比较高效。</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<h2 id="装箱和拆箱">装箱和拆箱</h2>
<h3 id="基本数据类型转换为包装类-装箱">基本数据类型转换为包装类(装箱)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Byte</span>(<span class="number">123</span>); 	<span class="comment">//通过构造器 </span></span><br><span class="line"><span class="type">Short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Short</span>(<span class="string">&quot;123&quot;</span>);<span class="comment">//NumberFormatException </span></span><br><span class="line"></span><br><span class="line"><span class="type">Interger</span> <span class="variable">t</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>); <span class="comment">//通过包装类的valueOf()方法 </span></span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> Long.valueOf(<span class="string">&quot;123&quot;</span>) <span class="comment">//NumberFormatException </span></span><br></pre></td></tr></table></figure>
<h3 id="包装类转换为基本数据类型-拆箱">包装类转换为基本数据类型(拆箱)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> obj.booleanValue(); <span class="comment">//调用包装类的.xxxValue()方法</span></span><br></pre></td></tr></table></figure>
<h3 id="自动拆装箱">自动拆装箱</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; </span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> i; </span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t<span class="comment">// jdk5之后出现自动拆装箱 </span></span><br></pre></td></tr></table></figure>
<h2 id="基本类型和字符串">基本类型和字符串</h2>
<h3 id="字符串转换成基本数据类型">字符串转换成基本数据类型</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;12&quot;</span>);<span class="comment">//通过包装类的构造器实现：</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.valueOf(<span class="string">&quot;123&quot;</span>);<span class="comment">//通过包装类的valueOf()实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(<span class="string">&quot;12.1&quot;</span>);<span class="comment">//通过包装类的parseXxx(String s)静态方法：</span></span><br></pre></td></tr></table></figure>
<h3 id="基本数据类型转换成字符串">基本数据类型转换成字符串</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= String.valueOf(<span class="number">2.34f</span>);<span class="comment">//调用字符串重载的valueOf()方法：</span></span><br><span class="line"></span><br><span class="line">String str= <span class="number">5</span> + “”<span class="comment">//使用+做字符串连接</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类</th>
<th>字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本数据类型转换成</td>
<td>\</td>
<td>包装类构造器、包装类.valueOf(X)、自动</td>
<td>包装类.valueOf(X)、字符串拼接</td>
</tr>
<tr>
<td>包装类转换成</td>
<td>包装类实例对象.XXXValue()、自动</td>
<td>\</td>
<td>包装类.toString()</td>
</tr>
<tr>
<td>字符串转换成</td>
<td>包装类构造器、包装类.valueOf(X)、包装类.parseXxx(X)</td>
<td>包装类构造器、包装类.valueOf(X)</td>
<td>\</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63aaec6708b6830163fb2d26.png" alt></p>
<h2 id="包装类中的缓存机制">包装类中的缓存机制</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//Integer num1 = 10;</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println((num1 == num2) +<span class="string">&quot;\t&quot;</span>+ num1.equals(num2));<span class="comment">//true	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line">System.out.println((num3 == num4) +<span class="string">&quot;\t&quot;</span>+ num3.equals(num4));<span class="comment">//false	true</span></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println((num5 == num6) +<span class="string">&quot;\t&quot;</span>+ num5.equals(num6));<span class="comment">//false	true</span></span><br></pre></td></tr></table></figure>
<p>Integer类第一次被使用时，Integer的静态内部类就被加载，加载的时候会创建-128到127的 Integer对象，同时创建一个数组cache来缓存这些对象。</p>
<ul>
<li>当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，不会再新建对象；</li>
<li>当使用new关键字或者使用valueOf()方法创建小于-128大于 127的值对象时，就会创建新对象。</li>
</ul>
<table>
<thead>
<tr>
<th>Character、Byte、Short、Integer、Long</th>
<th>Boolean</th>
<th>Float、Double</th>
</tr>
</thead>
<tbody>
<tr>
<td>有缓存区，且实现方式基本一样，都是-128到127的缓存范围。</td>
<td>没有缓存区，但在成员变量中就创建了两个相应的对象true、false</td>
<td>没有缓存区，即使在0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</td>
</tr>
</tbody>
</table>
<p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p>
<h2 id="基本数据类型与包装类区别">基本数据类型与包装类区别</h2>
<table>
<thead>
<tr>
<th></th>
<th>基本数据类型</th>
<th>包装类（引用数据类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员</td>
<td>\</td>
<td>可调用各种属性及方法</td>
</tr>
<tr>
<td>实例化</td>
<td>不需要实例化</td>
<td>必须实例化后才能使用</td>
</tr>
<tr>
<td>存储方式</td>
<td>直接存储数据值</td>
<td>实际是对象的引用</td>
</tr>
<tr>
<td>默认值</td>
<td>有默认值</td>
<td>默认值是null</td>
</tr>
<tr>
<td>空指针异常</td>
<td>不会发生空指针异常</td>
<td>可能发生空指针异常</td>
</tr>
<tr>
<td>强制转换</td>
<td>可以强制转换为其他类型</td>
<td>不能强制转换为其他类型</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/post/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>当我们使用代码描述主人喂养宠物的场景，首先在这个场景当中应该有“宠物对象” ，宠物对象应该有吃的行为，另外还需要一个“主人对象” ，主人对象应该有一个喂的行为。然而对于不同的宠物，吃的行为也不相同，或许是吃的东西不同，也或许是吃的方式不同，此时每当出现新的宠物时，我们就需要修改对于宠物吃行为的描述，这不符合OCP原则。对于需要更改的“宠物对象”，应当将其“封装”起来，在新的模块中对宠物不同的吃行为进行描述，而无需修改原本“宠物对象”的描述。</p>
<span id="more"></span>
<h1>多态(polymorphism)</h1>
<p>编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)多态情况</p>
<h2 id="前提">前提</h2>
<p>继承或实现</p>
<p>重写</p>
<h2 id="现象">现象</h2>
<ol>
<li>父类引用类型变量指向多种子类对象(父父new子)</li>
<li>该变量不能再访问子类中新添加的属性和方法（局限）</li>
<li>属性没有多态，即使子类有同名属性，编译期和运行期也访问的是父类的属性，但可以通过子类重写的方法调用子类的属性</li>
<li>子类重写父类的方法，编译期看到的是父类中的方法,运行期执行的是子类重写后的方法(编译期看左边 运行期看右边)</li>
</ol>
<h2 id="原理">原理</h2>
<h3 id="虚拟方法调用-多态情况下">虚拟方法调用(多态情况下)</h3>
<p>子类中定义了与父类同名同参数的方法,此时父类的方法称为<strong>虚拟方法</strong>(Virtual Method Invocation)</p>
<ul>
<li>
<p>在编译期，对象还没有创建出出来，只能看到父类的虚拟方法</p>
</li>
<li>
<p>直到运行期,真正的子类对象被创建出来,父类引用变量得到具体的子类对象地址，并动态调用子类重写的该方法。（动态绑定）</p>
</li>
</ul>
<h3 id="静态绑定与动态绑定">静态绑定与动态绑定</h3>
<p>重载，允许存在多个同名不同参数方法。编译器根据方法不同的参数列表，对同名方法的名称做修饰。同名方法就成了不同的方法。 它们的调用地址在编译期就绑定了。因此，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定” ；</p>
<p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或 “动态绑定 ” 。</p>
<h2 id="作用">作用</h2>
<p>提高了代码的通用性、提高软件的扩展性、实现软件设计的解耦</p>
<h2 id="应用">应用</h2>
<p>当方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</p>
<h2 id="类型转换-Casting">类型转换(Casting)</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<ul>
<li>
<p>自动类型转换：小的数据类型可以自动转换成大的数据类型</p>
</li>
<li>
<p>强制类型转换：可以把大的数据类型强制转换成小的数据类型</p>
</li>
</ul>
<h3 id="引用数据类型">引用数据类型</h3>
<p>对Java对象的强制类型转换称为<strong>造型</strong></p>
<ul>
<li>
<p>向上转型：从子类到父类的类型转换可以自动进行(多态)</p>
</li>
<li>
<p>向下转型：从父类到子类的类型转换必须通过造型(强制类型转换)实现</p>
</li>
<li>
<p>无继承关系的引用类型间的转换是非法的</p>
</li>
</ul>
<p>多态情况下，当我们需要访问子类中新添加的属性和方法时，需要向下转型（强转）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);		<span class="comment">//调用的是子类重写父类的方法	sub_1</span></span><br><span class="line">    <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> (Sub)base;		<span class="comment">//造型</span></span><br><span class="line">    s.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);			<span class="comment">//调用的是子类独有的方法	sub_2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof-操作符">instanceof 操作符</h3>
<p>在造型前可以使用instanceof操作符测试一个对象的类型</p>
<p>x instanceof A：</p>
<ul>
<li>
<p>检验x是否为类A的对象，返回值为boolean型。 x是A类对象返回true，反之返回false</p>
</li>
<li>
<p>如果x属于类A的子类B，返回值也为true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;…&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graduate</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;…&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(Person e)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Person) <span class="comment">// 处理Person类及其子类对象 </span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) <span class="comment">//处理Student类及其子类对象 </span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Graduate) <span class="comment">//处理Graduate类及其子类对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x所属的类与A类对象没有继承关系，则编译错误。</p>
<h2 id="验证：多态是运行时行为">验证：多态是运行时行为</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            animal = <span class="keyword">new</span> <span class="title class_">Cat</span> ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            animal = <span class="keyword">new</span> <span class="title class_">Dog</span> ();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    animal.eat();<span class="comment">//运行时才能确定animal引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; animal eat food&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; cat eat fish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog eat bone &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>常用文本编辑快捷键</title>
    <url>/post/%E5%B8%B8%E7%94%A8%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1>引言</h1>
<p>掌握一些最基本的快捷方式，对快速编辑有很好的效果。下面列举一些常用的快捷方式，如下所示：</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ctrl+c</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">ctrl+v</td>
<td style="text-align:center">粘贴</td>
</tr>
<tr>
<td style="text-align:center">ctrl+x</td>
<td style="text-align:center">剪切</td>
</tr>
<tr>
<td style="text-align:center">ctrl+s</td>
<td style="text-align:center">保存</td>
</tr>
<tr>
<td style="text-align:center">ctrl+z</td>
<td style="text-align:center">撤销</td>
</tr>
<tr>
<td style="text-align:center">ctrl+y</td>
<td style="text-align:center">重做</td>
</tr>
<tr>
<td style="text-align:center">ctrl+a</td>
<td style="text-align:center">全选</td>
</tr>
<tr>
<td style="text-align:center">ctrl + f</td>
<td style="text-align:center">查找</td>
</tr>
<tr>
<td style="text-align:center">home 键</td>
<td style="text-align:center">光标回到行首</td>
</tr>
<tr>
<td style="text-align:center">end 键</td>
<td style="text-align:center">光标回到行尾</td>
</tr>
<tr>
<td style="text-align:center">ctrl + home 键</td>
<td style="text-align:center">光标回到文章开始</td>
</tr>
<tr>
<td style="text-align:center">ctrl + end 键</td>
<td style="text-align:center">光标回到文章末尾</td>
</tr>
<tr>
<td style="text-align:center">shift + home 或 end 键</td>
<td style="text-align:center">选中一行</td>
</tr>
<tr>
<td style="text-align:center">ctrl + shift +右箭头或左箭头</td>
<td style="text-align:center">选中一个单词</td>
</tr>
<tr>
<td style="text-align:center">鼠标双击</td>
<td style="text-align:center">选中一个单词</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>标识符</title>
    <url>/post/%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h1>引言</h1>
<p>标识符是指用来标识某个实体的一个符号，在不同的应用环境下有不同的含义。.在计算机 编程语言 中，标识符是用户编程时使用的名字，用于给变量、 常量 、 函数 、语句块等命名，以建立起名称与使用之间的关系。标识符通常由字母和数字以及其它字符构成。</p>
<span id="more"></span>
<p>Java源程序中，凡是程序员能够自己命名的都是标识符</p>
<h1>标识符规则</h1>
<ol>
<li>标识符由26个英文字母、0-9数字、_$字符组成；不能出现#@！￥%&amp;等其它字符</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字、保留字，但可以包含它们，不能是if，可以是wifi</li>
<li>标识符中不能包含空格，不能是HelloWord</li>
</ol>
<p>区分源文件命名：<a href="../Java%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">源文件名与类名</a></p>
<h1>标识符命名规范</h1>
<table>
<thead>
<tr>
<th style="text-align:center">标识符</th>
<th style="text-align:center">命名规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">包名</td>
<td style="text-align:center">全部英文字母小写</td>
</tr>
<tr>
<td style="text-align:center">类名、接口名</td>
<td style="text-align:center">每个英文单词首字母大写</td>
</tr>
<tr>
<td style="text-align:center">变量名、方法名</td>
<td style="text-align:center">首个英文单词首字母小写，之后每个单词首字母大写</td>
</tr>
<tr>
<td style="text-align:center">常量名</td>
<td style="text-align:center">全部英文字母大写，单词之间由分隔符隔开</td>
</tr>
</tbody>
</table>
<h1>关键字</h1>
<table>
<thead>
<tr>
<th style="text-align:left">作用</th>
<th style="text-align:left">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">用于定义数据类型的关键字</td>
<td style="text-align:left">class interface enum byte short int long float double char boolean void</td>
</tr>
<tr>
<td style="text-align:left">用于定义流程控制的关键字</td>
<td style="text-align:left">if else switch case default while do for break continue return</td>
</tr>
<tr>
<td style="text-align:left">用于定义访问权限修饰符的关键字</td>
<td style="text-align:left">private protected public</td>
</tr>
<tr>
<td style="text-align:left">用于定义类，函数，变量修饰符的关键字</td>
<td style="text-align:left">abstract final static synchronized</td>
</tr>
<tr>
<td style="text-align:left">用于定义类与类之间关系的关键字</td>
<td style="text-align:left">extends implements</td>
</tr>
<tr>
<td style="text-align:left">用于定义建立实例及引用实例，判断实例的关键字</td>
<td style="text-align:left">new this super instanceof</td>
</tr>
<tr>
<td style="text-align:left">用于异常处理的关键字</td>
<td style="text-align:left">try catch finally throw throws</td>
</tr>
<tr>
<td style="text-align:left">用于包的关键字</td>
<td style="text-align:left">package import</td>
</tr>
<tr>
<td style="text-align:left">其他修饰符关键字</td>
<td style="text-align:left">native strictfp transient volatile assert</td>
</tr>
<tr>
<td style="text-align:left">用于定义数据类型值的字面值</td>
<td style="text-align:left">true false null</td>
</tr>
</tbody>
</table>
<h1>保留字</h1>
<p>现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字</p>
<p>goto，const</p>
<h1>总结</h1>
<h2 id="一个java源文件可以有名称相同，大小写不同的两个类吗">一个java源文件可以有名称相同，大小写不同的两个类吗?</h2>
<p>Java源文件可以有名称相同，大小写不同的两个类；</p>
<p>因为Java标识符严格区分大小写</p>
<p>不过在编译过程中，由于window系统不区分大小写，windows将前后编译生成的字节码文件视为同一个（即使这两个文件的命名一个是大写，一个是小写），后编译的类产生的字节码文件将替换掉先编译的类产生的字节码文件。</p>
<h2 id="java可不可以使用中文命名">java可不可以使用中文命名?</h2>
<p>可以 因为jdk使用的是unicode编码(全球统一编码),能够识别中文</p>
<h2 id="java源文件可以不可以数字开头">java源文件可以不可以数字开头?</h2>
<p>可以 java源文件不用遵循命名规则（public的类不行）</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/post/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1>引言</h1>
<p>赋值变量的过程中，不仅需要注意变量类型与数据类型是否一致，还需观察数据大小是否在数据类型的范围中。所以灵活使用数据类型能使我们更好的运用数据，根据数值大小将变量分配在合理的类型范围中，能有效减少存储空间。</p>
<span id="more"></span>
<h1>基本数据类型</h1>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">占用字节</th>
<th style="text-align:center">表数范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127(-2<sup>7</sup> ~2<sup>7</sup> -1 )</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-32768~32767(-2<sup>15</sup> ~ 2<sup>15</sup>-1 )</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">约21亿(-2<sup>31</sup> ~ 2<sup>31</sup> -1)</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2<sup>63</sup> ~ 2<sup>63</sup> -1</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">范围大于long(-3.403E38 ~ 3.403E38)</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1.798E308 ~ 1.798E308</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">1</td>
<td style="text-align:center">true,false</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0~65535</td>
</tr>
</tbody>
</table>
<ul>
<li>byte类型占用1个字节（B）即8位（bit），一共可以表示2的八次方个数即256个，其中首位为符号位，因此可以表示最大最小的数分别为：0111 1111(127)、1111 1111(-127)，从-127到127只有255个数，其中还有1000 0000（-0）表示成-128</li>
<li>int类型占用4个字节</li>
<li>浮点类型不能精确表示数据</li>
<li>浮点类型表数范围大于long类型，3.404*10<sup>38</sup>&gt;8<sup>38</sup>&gt;2<sup>114</sup>&gt;2<sup>63</sup>-1</li>
<li>boolean类型数据不能参与运算，不过Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都 使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。</li>
</ul>
<h1>字符型</h1>
<p>字符型数据通常有三种表示：</p>
<ul>
<li>单引号括起的单个字符 ‘a’</li>
<li>转义字符： \</li>
<li>直接使用Unicode编码’\u000a’</li>
</ul>
<p>Java中存在一些无法直接表示的特殊字符，如：换行(\n),	Unicode编码(\u4e2d)</p>
<p>使用转义字符来表示这些特殊的字符,那么如何输出“\”本身呢？</p>
<p>“\”本身由“\\”表示,同理“\\”由“\\\\”表示，“\u”由“\\u”表示，将“\\”看作一个整体</p>
<p>如果出现“\\\”多出一个转义字符无法形成新的整体，则会报错</p>
<h1>数据类型的转换</h1>
<ul>
<li>自动转换：表数范围小的数据类型变量转换成表述范围大的数据类型变量（小水杯的水倒入大水桶，水不会溢出）</li>
<li>强制转换：表数范围大的数据类型变量转换成表述范围小的数据类型变量（小水杯中的水可能无法装下大水桶中的水，即发生数据溢出）</li>
</ul>
<h2 id="字面量的类型">字面量的类型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span>; <span class="comment">//int类型</span></span><br><span class="line"><span class="number">3300L</span>; <span class="comment">//long类型</span></span><br><span class="line"><span class="number">123.56f</span>;<span class="comment">//float类型</span></span><br><span class="line"><span class="number">3.14</span>;<span class="comment">//double类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>整数
<ol>
<li>默认为int类型</li>
<li>L结尾为long类型，建议大写，小写不好区分</li>
</ol>
</li>
<li>小数
<ol>
<li>默认为double类型</li>
<li>F或f结尾为float类型</li>
</ol>
</li>
</ul>
<h2 id="常数赋值">常数赋值</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1.0</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1L</span>;	<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不难看出，当表数范围大的类型赋值给表数范围小的类型，将会产生错误</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">2147483648</span>;	<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> Long.MAX_VALUE;<span class="comment">//9223372036854775807</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ll</span> <span class="operator">=</span> <span class="number">9223372036854775808L</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字面量的值超过了字面量数据类型的表数范围也会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>; 	</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">56</span>;</span><br></pre></td></tr></table></figure>
<p>byte、short、char有特殊之处，此时虽然是范围大的类型赋值给范围小的类型，但</p>
<ul>
<li>当字面量类型为常数且整数类型时，若字面量大小在byte、short、char的表数范围内，则可以直接赋值</li>
</ul>
<p>换种方式，将整数类型的变量赋值给byte、short、char，即使在它们的表数范围内，也会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> i;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>这是因为在编译过程中，如果赋值的是常数，系统能直接判断是否在表数范围内，而变量在程序执行过程中可能发生变化，无法直接判断变量中的值是否在表数范围内，从而报错</p>
<h2 id="多种类型变量混合运算">多种类型变量混合运算</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">x4</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">x5</span> <span class="operator">=</span> <span class="number">1.0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">x6</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x3 + x4 + x5 + x6;</span><br></pre></td></tr></table></figure>
<p>将x1、x2、x3、x4、x5、x6相加，系统会将所有数据类型转换成表数范围最大的类型，因此需要用double类型的sum接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x3 + x4 + x5;</span><br></pre></td></tr></table></figure>
<p>同理上述相加可用<strong>double以及float</strong>类型的sum接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">x7</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + x7;</span><br></pre></td></tr></table></figure>
<p>byte、short、charr之间不会相互转换，他们三者在计算时首先转换为int类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1.0</span>*x3;</span><br></pre></td></tr></table></figure>
<p>乘除法同样符合</p>
<h3 id="难点">难点</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    s = s + <span class="number">1</span>;			<span class="comment">//报错</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    byte b = 3;</span></span><br><span class="line"><span class="comment">    b = b + 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    short s = 3;</span></span><br><span class="line"><span class="comment">    s = s + 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    char c = 3;</span></span><br><span class="line"><span class="comment">    c = c + 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>s = s + 1 ，不能将右侧的s直接代换成1，因为变量s可能在程序执行过程中发生变化，可以拆解成两步：</p>
<ol>
<li><code>short result = s + 1;</code></li>
<li><code>short s = result;</code></li>
</ol>
<p>第一步中，系统会将所有数据类型转换成表数范围最大的类型即int，int型变量无法直接赋值给short类型，因此报错</p>
<h1>总结</h1>
<h2 id="常数赋值（等号右边没有变量）">常数赋值（等号右边没有变量）</h2>
<ol>
<li>先观察字面量类型，观察是否超过字面量类型表数范围</li>
<li>字面量为常数且int类型时，被赋值变量类型为byte、short、char，字面量大小在byte、short、char的表数范围内，则可以直接赋值</li>
<li>表数范围小的类型可以赋值给表数范围大的类型，反之报错</li>
</ol>
<h2 id="多种类型变量混合运算-2">多种类型变量混合运算</h2>
<ol>
<li>byte、short、char三者在计算时首先转换为int类型</li>
<li>观察等号右边的最大表数范围的数据类型是否小于左边变量类型的表数范围</li>
<li>乘除法同样符合上述规则</li>
</ol>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>抽象类和接口</title>
    <url>/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象时，这样的类往往被称为抽象类。</p>
<p>抽象类是为了把<strong>相同的但不确定</strong>的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象方法。</p>
<p>当然，随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。父类足够抽象时，以至于它没有具体的实例。</p>
<p>然而，有时必须从几个类中抽象出共同的行为特征，继承它们所有的属性和方法。但是，Java不支持多重继承。这时，使用接口可以达到多重继承的效果。 例如：鼠标、键盘、打印机、扫描 仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须 能…”的思想。继承是一个&quot;是不是&quot;的关系，而接口实现则是 &quot;能不能&quot;的关系。</p>
<span id="more"></span>
<h1>abstract</h1>
<h2 id="抽象类">抽象类</h2>
<p>abstract修饰的类称为抽象类，命名规范:xxxxAbstract  Abstractxxxx  xxxxBase</p>
<ul>
<li>抽象类不能被实例化，抽象类就是用来继承并实现的，但是有构造器</li>
<li>抽象类中可以有抽象方法，供继承类重写，若继承类还是抽象类，可以不重写抽象方法</li>
<li>最多只能继承一个抽象类（单继承）</li>
</ul>
<h2 id="抽象方法">抽象方法</h2>
<p>abstract修饰的方法称为抽象方法</p>
<ul>
<li>抽象方法没有方法体，抽象方法就是供子类重写的（抽象子类不需要重写）</li>
<li>含有抽象方法的类一定是抽象类或接口</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>类</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>不能被继承</td>
<td>不能被重写</td>
</tr>
<tr>
<td>abstract</td>
<td>供子类继承实现</td>
<td>供继承类重写</td>
</tr>
<tr>
<td>static</td>
<td></td>
<td>需要方法体随类加载而加载</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td>对子类不可见</td>
</tr>
</tbody>
</table>
<p>因此，final不能修饰抽象类和抽象方法</p>
<p>static、private不能修饰抽象方法</p>
<h2 id="匿名抽象类">匿名抽象类</h2>
<p>如果抽象类没有实现类，仍然要获取抽象类的实例对象时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>;</span><br><span class="line">    abstrect <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;think&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接构造抽象类对象，需要在<strong>构造函数后面的花括号实现抽象方法</strong>。</p>
<h2 id="模板方法设计模式-TemplateMethod">模板方法设计模式(TemplateMethod)</h2>
<p>当功能内部一部分实现步骤是固定、通用的，一部分实现是不确定的。这时可以把不确定的、易变部分暴露出去， 让子类去实现。 由此定义出功能算法的骨架，子类不改变算法的结构，且无需重复固定的代码，只需要重定义算法的某些特定步骤。</p>
<p>银行的营业厅办理业务需要 以下步骤：</p>
<ol>
<li>取号 2.办业务 3.评价。</li>
</ol>
<p>三个步骤中取号和评价都是 <strong>固定的流程</strong>，每个人要做的 事儿都是一样的。但是办业 务这个步骤根据每个人要办 的事情不同所以需要有<strong>不同的实现</strong>。我们可以将整个办业务这件事儿封装成一个抽象类：取号和评价为模板方法，而办业务为供子类重写的抽象方法。</p>
<h1>接口</h1>
<p>interface，特殊的、轻量级的抽象类，接口名称和类名一样 符合标识符的规则和规范(首字母大写)</p>
<h2 id="接口实现">接口实现</h2>
<p>接口不能被实例化，供实现类使用，没有构造器</p>
<p>如果一个类实现了接口，则需要实现接口中所有方法，抽象类则不用</p>
<h3 id="JDK8前">JDK8前</h3>
<p>接口中包含	公共的静态常量、公共的抽象方法</p>
<h3 id="JDK8后">JDK8后</h3>
<h2 id="接口和类">接口和类</h2>
<p>一个类可以实现多个接口</p>
<p>一个接口可以继承多个接口</p>
<table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象级别</td>
<td>抽象类不能被实例化，供继承并实现</td>
<td>接口不能被实例化，供实现类使用，接口抽象级别高于抽象类</td>
</tr>
<tr>
<td>构造器</td>
<td>有构造器</td>
<td>没有构造器</td>
</tr>
<tr>
<td>继承</td>
<td>实现类最多继承一个抽象类</td>
<td>类可实现多个接口，接口可继承多个接口</td>
</tr>
<tr>
<td>成员</td>
<td>除了含有抽象方法，其余和普通类相差不大</td>
<td>只能是公共的静态常量、公共的抽象方法、（静态方法、默认方法为JDK8后）</td>
</tr>
<tr>
<td></td>
<td>继承类必须实现抽象方法，或本身为抽象类</td>
<td>实现类必须实现抽象方法，或本身为抽象类</td>
</tr>
<tr>
<td>没有实现类时</td>
<td>匿名抽象类</td>
<td>匿名实现类对象</td>
</tr>
<tr>
<td>设计模式</td>
<td>模板方法</td>
<td>简单工厂、工厂方法、代理模式</td>
</tr>
<tr>
<td></td>
<td>作为模板</td>
<td>作为标准或某种特性</td>
</tr>
</tbody>
</table>
<p>抽象类、接口都通过对象的多态性产生实例化对象，但由于抽象类单继承的局限，接口使用更为广泛</p>
<h2 id="匿名实现类对象">匿名实现类对象</h2>
<p>如果接口没有实现类，仍要得到接口的实现时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">think</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;think&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>流程控制</title>
    <url>/post/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(b = <span class="literal">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        从键盘分别输入年、月、日，判断这一天是当年的第几天</span></span><br><span class="line"><span class="comment">        注：判断一年是否是闰年的标准：</span></span><br><span class="line"><span class="comment">        1）可以被4整除，但不可被100整除、或</span></span><br><span class="line"><span class="comment">        2）可以被400整除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入月份：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入几号：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">month2</span> <span class="operator">=</span> <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year %<span class="number">100</span> != <span class="number">0</span> ||year % <span class="number">400</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    month2 = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        day += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        day += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        day += month2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        day += date;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的月份不合法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(day);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>继承</title>
    <url>/post/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>is a”代表的是类之间的继承关系，比如PC机是计算机，工作站也是计算机。PC机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java语言实现时，应该将PC机和工作站定义成两种类，均继承计算机类。</p>
<p>“has a”代表的是对象和它的成员的从属关系。同一种类的对象，通过它们的属性的不同值来区别。比如一台PC机的操作系统是Windows，另一台PC机的操作系统是Linux。操作系统是PC机的一个成员变量，根据这一成员变量的不同值，可以区分不同的PC机对象。<br>
再比如张三和李四都是人，但他们的名字不一样，可以以此区分这两个具体的人。名字应该作为人的成员变量。如果将名字叫“张三”的人和名字叫“李四”的人分别定义成两个类，均继承“人”这个类，显然是不合理的。</p>
<p>is a 的意识是如果A是B，那么B就是A的基类。比如：等边三角形是使是三角形，那么，三角形就是等边三角形的基类。<br>
has a 是如果A中有B，那么，B就是A的组成部分</p>
<p>如果你确定两件对象之间是is-a的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承而不是聚合。<br>
如果你确定两件对象之间是has-a的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类，而不是从电脑类继承。</p>
<span id="more"></span>
<p>如果多个类有着共同的属性,并且类之间符合is a 的关系，可以将共性的抽取到一个类中,作为父类,</p>
<p>别的类通过使用extends继承它,进而获取它的所有的成员(处理构造器)</p>
<h2 id="意义">意义</h2>
<p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个 类无需再定义这些属性和行为，只要继承那个类即可。</p>
<h2 id="使用">使用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类:继承其他类的类,又叫派生类</li>
<li>父类:被继承的类,又叫基类或者超类</li>
</ul>
<ol>
<li>Java只支持单继承,不能多继承,支持多级继承</li>
<li>如果继承了一个类,那么就拥有了除了构造方法之外的父类的所有的成员(属性和方法)</li>
<li>私有成员(private)不能被继承的,引用了私有成员的方法可以被子类继承的</li>
</ol>
<p>静态成员也是被继承的(没有意义)</p>
]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
  <entry>
    <title>编码与数制</title>
    <url>/post/%E7%BC%96%E7%A0%81%E4%B8%8E%E6%95%B0%E5%88%B6/</url>
    <content><![CDATA[<h1>引言</h1>
<p>1、2、3、4……，我们从小便学习这么计数，并使用到现在。但是这样的计数方式从何而来呢？又如何发展成如今计算机的计数方式？</p>
<span id="more"></span>
<p>罗马人从使用手指计数到在羊皮上画出Ⅰ、Ⅱ、Ⅲ来代替手指的字符，他们定义出了能够表示不同个数的符号，并随后引出了X(十)、C(百)、(M)千等等符号。随着要表示的数量越来越多，他们不得不引出更多的符号。</p>
<p>印度人发明了如今成为国际通用的阿拉伯数字，与罗马人的计数方式相比，阿拉伯数字不需要不断引出新的符号，而是用数字的位置来表示，高位在左，低位在右，传入欧洲后，加上逢十进一，演变成如今人们使用的数字计数，即十进制计数法（D)。</p>
<h1>进位计数法</h1>
<h2 id="r进制计数法">r进制计数法</h2>
<p>r进制计数法是从十进制计数法中抽象出来的概念，r可以表示任何整数，逢r进一</p>
<p>相比于传统计数方法，r进制计数法</p>
<ul>
<li>
<p>利用了数字位置的信息</p>
<p>每个数位表示不同的常数，第0位表示r<sup>0</sup>,第1位表示r<sup>1</sup>……</p>
<p>（从0开始）第i位表示r<sup>i</sup>，r<sup>i</sup>就是第i位的<strong>位权</strong></p>
</li>
<li>
<p>每个数位使用r种不同数码</p>
<p>r就是<strong>基数</strong></p>
<p>真实的数字 = 累加 （每个数位的数字	乘以	该位的位权）</p>
<blockquote>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
</li>
</ul>
<h2 id="二进制计数法">二进制计数法</h2>
<p>在计算机中使用高电平和低电平两种稳定状态的电子器件，因而使用二进制来表示计算机中的数据</p>
<p>二进制中的1、0对应了逻辑中的真、假，为逻辑运算提供便利条件</p>
<p>常用的还有<strong>八进制计数法（O）、十六进制计数法（H）</strong></p>
<h1>不同进制间的转换</h1>
<p>为了深入了解不同进制表示的数据，还需分析不同进制间的转换</p>
<h2 id="任意进制-十进制">任意进制 -&gt; 十进制</h2>
<h3 id="按权展开相加法">按权展开相加法</h3>
<p>累加 （每个数位的数字	乘以	该位的位权）</p>
<h2 id="二进制-八进制-、十六进制">二进制 -&gt; 八进制 、十六进制</h2>
<ul>
<li>二进制的3个数位最多能表示8个数字</li>
<li>二进制的4个数位最多能表示16个数字</li>
</ul>
<p>二进制 -&gt; 八进制 ：</p>
<ol>
<li>小数点左边：3位1组-&gt;最左边补0凑3位</li>
<li>小数点右边：3位1组-&gt;最右边补0凑3位</li>
<li>每组转化成八进制数</li>
</ol>
<p>二进制 -&gt; 十六进制：</p>
<ol>
<li>小数点左边：4位1组-&gt;最左边补0凑4位</li>
<li>小数点右边：4位1组-&gt;最右边补0凑4位</li>
<li>每组转化成十六进制数</li>
</ol>
<h2 id="八进制-、十六进制-二进制">八进制 、十六进制 -&gt; 二进制</h2>
<p>八进制 -&gt; 二进制 ：1位 -&gt; 3位二进制数</p>
<p>十六进制 -&gt; 二进制：1位 -&gt; 4位二进制数</p>
<p>最后去掉最高位最小位的0</p>
<h2 id="八进制-十六进制">八进制 -&gt; 十六进制</h2>
<p>以二进制为桥梁  八进制-&gt;二进制-&gt;十六进制</p>
<h2 id="十进制-二进制">十进制 -&gt; 二进制</h2>
<h3 id="基数乘除法">基数乘除法</h3>
<p>进位计数法有效利用了数码的位置信息，如何借助数字位置信息实现进制转换呢？</p>
<blockquote>
<p>对于一个r进制数：K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
<p>= K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup></p>
</blockquote>
<p>乘以基数r</p>
<blockquote>
<p>r*(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)</p>
<p>=r*(K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)</p>
<p>=K<sub>n</sub>*r<sup>n+1</sup>+K<sub>n-1</sub>*r<sup>n</sup>+…+K<sub>2</sub>*r<sup>3</sup>+K<sub>1</sub>*r<sup>2</sup>+K<sub>0</sub>*r<sup>1</sup>+K<sub>-1</sub>*r<sup>0</sup>+K<sub>-2</sub>*r<sup>-1</sup>+…+K<sub>-m</sub>*r<sup>-m+1</sup>+0*r<sup>m</sup></p>
<p>=K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>0</p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生左移，并在最右边一位补0</p>
<p>除以基数r</p>
<blockquote>
<p>(K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)\r</p>
<p>= (K<sub>n</sub>*r<sup>n</sup>+K<sub>n-1</sub>*r<sup>n-1</sup>+…+K<sub>2</sub>*r<sup>2</sup>+K<sub>1</sub>*r<sup>1</sup>+K<sub>0</sub>*r<sup>0</sup>+K<sub>-1</sub>*r<sup>-1</sup>+K<sub>-2</sub>*r<sup>-2</sup>+…+K<sub>-m</sub>*r<sup>-m</sup>)\r</p>
<p>=0*r<sup>n</sup>+K<sub>n</sub>*r<sup>n-1</sup>+K<sub>n-1</sub>*r<sup>n</sup>-2+…+K<sub>2</sub>*r<sup>1</sup>+K<sub>1</sub>*r<sup>0</sup>+K<sub>0</sub>*r<sup>-1</sup>+K<sub>-1</sub>*r<sup>-2</sup>+K<sub>-2</sub>*r<sup>-3</sup>+…+K<sub>-m</sub>*r<sup>-m-1</sup></p>
<p>=0K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub></p>
</blockquote>
<p>相比于K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>，各个数位的数码同时发生右移，并在最左边一位补0</p>
<table>
<thead>
<tr>
<th></th>
<th>第n+1位</th>
<th>第n位</th>
<th>第n-1位</th>
<th>…</th>
<th>第2位</th>
<th>第1位</th>
<th>第0位</th>
<th>第-1位</th>
<th>…</th>
<th>第-(m-1)</th>
<th>第-m位</th>
<th>第-(m+1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>原数</td>
<td></td>
<td>Kn</td>
<td>Kn-1</td>
<td>…</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>…</td>
<td>K-(m-1)</td>
<td>K-m</td>
<td></td>
</tr>
<tr>
<td>乘以基数r</td>
<td>Kn</td>
<td>Kn-1</td>
<td>Kn-2</td>
<td>…</td>
<td>K1</td>
<td>K0</td>
<td>K-1</td>
<td>K-2</td>
<td>…</td>
<td>K-m</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>除以基数r</td>
<td></td>
<td>0</td>
<td>Kn</td>
<td>…</td>
<td>K3</td>
<td>K2</td>
<td>K1</td>
<td>K0</td>
<td>…</td>
<td>K-(m-2)</td>
<td>K-(m-1)</td>
<td>K-m</td>
</tr>
</tbody>
</table>
<h4 id="对于整数：除基取余法">对于整数：除基取余法</h4>
<p>将数字除以基数，相当于右移了数字，小数点右边的为余数，先除得的余数为低位，即二进制的最低位</p>
<p>继续将商除以基数，继续右移，直到商为0，后除得的余数为高位</p>
<p><strong>除基取余，先余为低，后余为高，商0结束</strong></p>
<h4 id="对于小数：乘基取整法">对于小数：乘基取整法</h4>
<p>将数字乘以基数，相当于左移了数字，小数点左边的为高位</p>
<p>此时乘积的结构为： 高位数码（整数部分） + 剩余数  (**.**K<sub>-1</sub>K<sub>-2</sub>…K<sub>-m</sub>)*r =  K<sub>-1</sub> <strong>.</strong> K<sub>-2</sub>…K<sub>-m</sub></p>
<p>乘积减去高位数码得到剩余数，再将剩余数继续乘基数，重复以上步骤，直到高位数码为0</p>
<p><strong>乘基取整，先整为高，后整为低，整0结束</strong></p>
<p>注意：不是每个小数都能用二进制表示</p>
<h3 id="拼凑法">拼凑法</h3>
<p>在十进制转换为二进制中，大小适中的数字，可以通过位权凑出数字</p>
<table>
<thead>
<tr>
<th style="text-align:left">2<sup>-4</sup></th>
<th style="text-align:left">2<sup>-3</sup></th>
<th style="text-align:left">2<sup>-2</sup></th>
<th style="text-align:left">2<sup>-1</sup></th>
<th style="text-align:left">2<sup>0</sup></th>
<th style="text-align:left">2<sup>1</sup></th>
<th style="text-align:left">2<sup>2</sup></th>
<th style="text-align:left">2<sup>3</sup></th>
<th style="text-align:left">2<sup>4</sup></th>
<th style="text-align:left">2<sup>5</sup></th>
<th style="text-align:left">2<sup>6</sup></th>
<th style="text-align:left">2<sup>7</sup></th>
<th style="text-align:left">2<sup>8</sup></th>
<th style="text-align:left">2<sup>9</sup></th>
<th style="text-align:left">2<sup>10</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0.0625</td>
<td style="text-align:left">0.125</td>
<td style="text-align:left">0.25</td>
<td style="text-align:left">0.5</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">4</td>
<td style="text-align:left">8</td>
<td style="text-align:left">16</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64</td>
<td style="text-align:left">128</td>
<td style="text-align:left">256</td>
<td style="text-align:left">512</td>
<td style="text-align:left">1024</td>
</tr>
</tbody>
</table>
<p>75.325D = 64 + 8 + 2 + 1 + 0.25 + 0.125 = 2<sup>6</sup> + 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> + 2<sup>-2</sup> + 2<sup>-3</sup> = 1001011.011B</p>
<p>在了解了计算机的进位计数法及不同进制的转换后，便可以学习如何将生活中的数存入计算机</p>
<h1>整数的表示</h1>
<p>在日常生活中带正负号的数，我们通常称为 <strong>真值</strong></p>
<p>将数据<strong>符号数字化</strong>后并能够存储到计算机中的数称为 <strong>机器数</strong>。</p>
<p>先看简化的无符号整数（以下都是二进制计数）</p>
<h2 id="无符号整数">无符号整数</h2>
<p>K<sub>n</sub>K<sub>n-1</sub>…K<sub>2</sub>K<sub>1</sub>K<sub>0</sub></p>
<ul>
<li>没有符号位，默认为正号</li>
<li>最大值为：2<sup>n+1</sup>-1，最小值为0</li>
</ul>
<h3 id="加法运算">加法运算</h3>
<blockquote>
<p>1+1 = 0001 + 0001 = 0010B = 2D</p>
</blockquote>
<h3 id="减法运算">减法运算</h3>
<p>减法只考虑正数减正数：</p>
<ol>
<li>正数减负数、负数减正数本质上是加法，</li>
<li>负数减负数其实也就是正数减正数</li>
</ol>
<blockquote>
<p>2-1 = 0010 - 0001 = 0001 =1D</p>
</blockquote>
<p>实际上，早期的计算机中设有关于减法的相关电路，复杂的电路伴随着高昂的成本，因此如今的计算机逻辑运算单元中，只有加法器进行加法的运算，减法的运算也是通过加法器实现。那么如何通过加法运算实现减法呢？</p>
<h3 id="钟表时针">钟表时针</h3>
<p>类似于钟表的时针：如果说现在时针现在停在10点钟，那么什么时候时针会停在8点钟呢？</p>
<p>时针倒拨2小时，或是正拨10小时，超过12小时后，时针将走第二圈，并最终停在8点钟</p>
<blockquote>
<p>10 - 2 = 8，10 + 10 = 20 = 12 + 8</p>
<p>即 (10 - 2) mod 12 = 8</p>
<p>​	(10 + 10) mod 12 = 8</p>
</blockquote>
<ul>
<li>
<p>mod就是<strong>取模运算</strong>，它们除以整数12，并计算最后的余数</p>
</li>
<li>
<p>8和20对于模12<strong>同余</strong>(有着相同的余数)，它们将共同停在余数8点钟</p>
</li>
</ul>
<h3 id="取模运算">取模运算</h3>
<p>对整数a、b，取模运算就是a除以b，并计算余数（模余），记作</p>
<blockquote>
<p>a Mod b = a - [a/b]*b，[a/b]为向下取整</p>
</blockquote>
<p>如：20 Mod 12 = 20 - [20/12]*12 = 20 - 1*12 = 8</p>
<h3 id="同余">同余</h3>
<p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余,记作</p>
<blockquote>
<p>a Mod r =  b Mod r =&gt; a ≡ b (mod m)</p>
<p>性质：<strong>a、b满足a-b为r的整数倍</strong></p>
</blockquote>
<h3 id="思考">思考</h3>
<p>与钟表时针相比，计算机计数也有相似的地方：</p>
<table>
<thead>
<tr>
<th style="text-align:left">钟表时针</th>
<th style="text-align:left">计算机计数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">钟表时针取值只有[0-11]，超过12后会从0重新开始</td>
<td style="text-align:left">计算机作二进制表示的数位有限，超过一定数值也会重新开始计数</td>
</tr>
<tr>
<td style="text-align:left">将时针倒拨可以通过正拨等价实现</td>
<td style="text-align:left">计算机减法也可以使用加法等价实现</td>
</tr>
<tr>
<td style="text-align:left">(10-2) mod 12 = (10+10) mod 12</td>
<td style="text-align:left">(x - a) Mod r = (x + b) Mod r</td>
</tr>
<tr>
<td style="text-align:left">(10-2) ≡ (10+10) (mod 12)</td>
<td style="text-align:left">(x-a) ≡ (x+ b) (mod r)</td>
</tr>
</tbody>
</table>
<ul>
<li>x - a与x + b同余</li>
<li>根据<a href="#%E5%90%8C%E4%BD%99">同余的性质</a>，(x+ b) - (x-a) = r*Z，化简得 b = r*Z - a	（Z为整数、r为模）</li>
</ul>
<p>为了方便计算，可以只找离模最近的数，取Z = 1，即 b = r - a</p>
<p>也就是说，减法中减去a与加上 <strong>r - a</strong>等价，但r - a中仍存在减法，</p>
<p>这时需要利用计算机中的取反操作：</p>
<blockquote>
<p><strong>r  = a + ~a +1</strong>	（~为取反符号）</p>
</blockquote>
<p>二进制中任何一个数与它取反后的数相加，都会得到每个位为1的数，此时加上1就能得到该位下的模</p>
<blockquote>
<p>b = r - a = ~a +1</p>
</blockquote>
<p>x减去a 可以等价成 x 加上取反后的a加1，即</p>
<blockquote>
<p><strong>x - a = x + b =  x + ~a + 1</strong></p>
</blockquote>
<p>至此，减法运算可以仅通过加法、取反来实现</p>
<h2 id="带符号整数">带符号整数</h2>
<h3 id="原码">原码</h3>
<p>接着引入符号位的概念，最高位为符号位，正数为0，负数为1</p>
<p>符号位与真值的绝对值构成了原码</p>
<blockquote>
<p>[1]<sub>原</sub> = 0001	[-1]<sub>原</sub> = 1001</p>
</blockquote>
<p>8位的原码表示范围为：</p>
<blockquote>
<p>​	1111 1111 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4 id="原码的运算">原码的运算</h4>
<ul>
<li>原码中的符号位仅用来表示数的正、负，不参加运算，只有数值部分参与运算</li>
<li>原码运算时，先比较两个数的符号，若两个数的符号相同，则将两个数的相加，最后加上符号</li>
<li>若两数的符号不同，则需比较两数的数值大小，然后将数值较大的数减去数值较小的数，并将数值较大的数的符号作为最后结果的符号。</li>
</ul>
<h3 id="补码">补码</h3>
<p>回顾<a href="#%E6%80%9D%E8%80%83">无符号整数的减法运算</a>，x减去a 可以等价成 x 加上取反后的a加1</p>
<h4 id="补码引言">补码引言</h4>
<p>无符号4位2进制的模为2<sup>4</sup></p>
<blockquote>
<ol>
<li>被减数-减数 = 0：1 - 1 = 0001 + 1111 = 1)0000B = 0D</li>
<li>被减数-减数 &gt; 0：2 - 1 = 0010 + 1111 = 1)0001B = 1D</li>
<li>被减数-减数 &lt; 0：1 - 2 = 0001 + 1110 = 1111B = 15D(16 - 1)</li>
</ol>
</blockquote>
<p>结果都比原来多了2<sup>4</sup>,都多加了一个模</p>
<ol>
<li>对于被减数 - 减数 &gt;= 0，忽视溢出位，数值位等于实际值</li>
<li>对于被减数 - 减数 &lt; 0，还需减去一个模，a - r = a - (a + ~a + 1) = -(~a + 1)，数值位才等于实际值</li>
</ol>
<p>我们继续整合符号位，当符号位中0表示负号，1表示正号时，符号位参与运算后为1</p>
<ul>
<li>对于被减数 - 减数 &gt;= 0，溢出位参与符号位的运算恰好使得结果的符号为正</li>
<li>对于被减数 - 减数&lt; 0，符号位不变表示结果小于0，恰好表示了 -(~a + 1)中的负号</li>
<li>对于减数，将x - a = x+ b 看作 x -a = x + [-a]<sub>新的形式</sub>，- a = [-a]<sub>新的形式</sub></li>
</ul>
<h4 id="小结">小结</h4>
<p>加上符号位的减法运算，我们可以总结出：</p>
<ol>
<li>减法变加法，减数看成负数，数值位为按位取反后加1，符号位为1</li>
<li>符号位应为数值位高一位，参与加法运算</li>
<li>结果如果符号位为0则不变，如果符号为1，符号位不变，作 取反加1 的变换</li>
</ol>
<p>至此，补码的定义逐渐清晰起来</p>
<h4 id="定义">定义</h4>
<ul>
<li>补码的符号位为数值位高一位，0表示负，1表示正</li>
<li>正数的补码与原码一致，负数的补码符号位不变，数值位作 取反加1</li>
</ul>
<p>8位的补码表示范围为：</p>
<p>​	1111 1111 ~ 0111 1111，补码没有-0的结果，补码中的1000 0000表示-128</p>
<p>(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub> + [1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub> = -128D</p>
<p>表示范围：-128 ~ 127</p>
<h4 id="补码的加法">补码的加法</h4>
<p>最低位开始，按位相加，并往高位进位（符号位参与运算）</p>
<h4 id="补码的减法">补码的减法</h4>
<p>减法变加法，减数看成负数，被减数的补码加上减数的负数的补码，，减数符号位为1不变，数值位为按位取反后加1</p>
<p>有符号5位2进制的模为2<sup>5</sup>，第5位为符号位</p>
<blockquote>
<p><strong>[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></strong></p>
</blockquote>
<ol>
<li>被减数-减数 = 0	[1]<sub>补</sub> - [1]<sub>补</sub> = [1]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0000]<sub>补</sub> = 0D</li>
<li>被减数-减数 &gt; 0	[2]<sub>补</sub> - [1]<sub>补</sub> = [2]<sub>补</sub> + [-1]<sub>补</sub> = [<u>0</u>0010 + <u>1</u>1111]<sub>补</sub> = [<u>0</u>0001]<sub>补</sub> = 1D</li>
<li>被减数-减数 &lt; 0	[1]<sub>补</sub> - [2]<sub>补</sub> = [1]<sub>补</sub> + [-2]<sub>补</sub> = [<u>0</u>0001 + <u>1</u>1110]<sub>补</sub> = [<u>1</u>1111]<sub>补</sub>= -1D</li>
</ol>
<p>结果还是补码，计算机内，所有带符号整数的加减法都先转换为补码</p>
<h4 id="补码-原码">补码&lt;-&gt;原码</h4>
<ol>
<li>
<p>在补码减法运算中，[a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub>；根据原码、补码定义，[b]<sub>补</sub> = [b]<sub>原</sub>，-[b]<sub>原</sub> = [-b]<sub>原</sub>，</p>
<blockquote>
<p>[a]<sub>原</sub> + [-b]<sub>原</sub> = [a]<sub>原</sub> - [b]<sub>原</sub> =  [a]<sub>补</sub> - [b]<sub>补</sub> = [a]<sub>补</sub> + [-b]<sub>补</sub></p>
</blockquote>
</li>
</ol>
<p>也就是 [-b]<sub>原</sub>到 [-b]<sub>补</sub>的转换，[-b]<sub>原</sub>的符号位为1不变，数值位按位取反后加1</p>
<ol start="2">
<li>而被减数-减数 &lt; 0，结果为补码，要转换成原码，符号位为1不变，还需将数值位按位取反后加1</li>
</ol>
<p>总结：补码与原码之间的转换相同，正数不变，负数符号位为1不变，数值位按位取反后加1</p>
<h3 id="反码">反码</h3>
<p>在使用补码作减法运算中，对于正数用不到按位取反的操作，而多次将负数的数值位按位取反再加一，将数值位按位取反也定义成新的形式，这个新的形式就是反码</p>
<h4 id="定义-2">定义</h4>
<ul>
<li>反码的最高位为符号位，符号位为1为负数，符号位为0则为负数</li>
<li>正数的反码与原码相同，负数的反码符号位为1不变，数值位按位取反</li>
</ul>
<p>8位的反码表示范围为：</p>
<blockquote>
<p>​	1000 0000 ~ 0111 1111</p>
<p>= -127 ~ 127</p>
</blockquote>
<h4 id="反码-补码">反码 -&gt; 补码</h4>
<p>[X]<sub>补</sub> = [X]<sub>反</sub> + 1</p>
<h3 id="移码">移码</h3>
<p>移码的符号位用“1”表示正数，用“0”表示负数，数值部分与补码相同。</p>
<p>常用于表示浮点数的阶码</p>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr>
<th>n + 1 bit</th>
<th>无符号整数</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
<th>移码</th>
</tr>
</thead>
<tbody>
<tr>
<td>表示范围</td>
<td>0 ~ 2<sup>n+1</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>-1) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
<td>-(2<sup>n</sup>) ~ 2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最大值</td>
<td>11…11=2<sup>n+1</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11 = 2<sup>n</sup>-1</td>
<td>0,11…11=2<sup>n</sup>-1</td>
<td>1,11…11=2<sup>n</sup>-1</td>
</tr>
<tr>
<td>最小值</td>
<td>00…00 = 0</td>
<td>1,11…11 = -(2<sup>n</sup>-1)</td>
<td>1,00…00 = -(2<sup>n</sup>-1)</td>
<td>1,00…00=-(2<sup>n</sup>)</td>
<td>0,00…00=-(2<sup>n</sup>)</td>
</tr>
<tr>
<td>0的表示</td>
<td>00…00</td>
<td>[+0]<sub>原</sub>=0,00…00,[-0]<sub>原</sub>=1,00…00</td>
<td>[+0]<sub>反</sub>=0,00…00[-0]<sub>反</sub>=1,11…11</td>
<td>[0]<sub>补</sub>=0,00…00</td>
<td>[0]<sub>移</sub>=1,00…00</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.imgdb.cn/item/63993b6ab1fccdcd36b1b146.png" alt="相互转换"></p>
<h1>定点数的表示</h1>
<p>定点数约定小数点的位置不变，定点纯整数约定了小数点在数值位的最后。定点纯小数约定了数值位的最高位在小数点后面。</p>
<h2 id="定点小数的原码、反码表示">定点小数的原码、反码表示</h2>
<p>​	整数符号位后接，号，小数符号位接.号</p>
<h2 id="定点小数的补码">定点小数的补码</h2>
<p>​	定点小数的补码加减法运算同带符号整数的补码加减法运算</p>
<h2 id="位数扩展">位数扩展</h2>
<p>定点小数与定点整数做时，扩展位置不同</p>
<ul>
<li>定点小数右边扩展</li>
<li>定点整数在符号位后一位扩展</li>
</ul>
<h1>浮点数的表示</h1>
<p>浮点数是与定点数相对的概念，定点数约定小数点的位置不变。</p>
<p>使用定点数表示时，当定点数占用的字长多而有效数字少时，就会造成存储空间的浪费；使用浮点数表示，合理改变小数点的位置，仅存储有效数字和2次幂信息，在位数有限的情况下，既扩大了数的表示范围，又保留了数的有效精度</p>
<h2 id="浮点数的形式">浮点数的形式</h2>
<p>浮点数由尾数M和阶码E构成。基数为2的数F的浮点数表示为：</p>
<blockquote>
<p>F = M*2<sup>E</sup></p>
</blockquote>
<ul>
<li>尾数M存储有效数字，尾数反映数字的精度</li>
<li>阶码E存储2次幂信息，阶码反映表示范围，以及小数点的位置</li>
</ul>
<h3 id="浮点数编码规则">浮点数编码规则</h3>
<table>
<thead>
<tr>
<th>阶符</th>
<th>阶码</th>
<th>数符</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>k位</td>
<td>1位</td>
<td>n位</td>
</tr>
<tr>
<td>阶码的正负</td>
<td>数值大小</td>
<td>浮点数的正负</td>
<td>数值精度</td>
</tr>
</tbody>
</table>
<ul>
<li>尾数M必须为<strong>小数</strong>，用n+1位有符号定点小数表示，可采用的原码，补码。</li>
<li>阶码E必须为<strong>整数</strong>，用k+1位有符号定点整数表示，可采用原码，补码，移码。</li>
<li>浮点数编码的位数m=(n+1)+(k+1)</li>
</ul>
<h2 id="非规格化浮点数">非规格化浮点数</h2>
<p>当对尾数M只要求是小数而无其他限制时，此时的浮点数被称为非规格化浮点数。</p>
<p>假设阶码和尾数都用原码表示，则非规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th>阶码和尾数</th>
<th>数值</th>
<th>阶码和尾数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶码最小值</td>
<td>- (2<sup>k</sup>-1)</td>
<td>阶码最大值</td>
<td>2<sup>k</sup>-1</td>
</tr>
<tr>
<td>尾数最小负值</td>
<td>-(1- 2<sup>-n</sup>)</td>
<td>尾数最大负值</td>
<td>-2<sup>-n</sup></td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>2<sup>-n</sup></td>
<td>尾数最大正值</td>
<td>1-2<sup>-n</sup></td>
</tr>
</tbody>
</table>
<p>以8位数值位，一位符号位的阶码为例子： 由于用原码表示，</p>
<p>阶码的最小值：1 11111111 即 -(2^8 - 1) = -255</p>
<p>阶码的最大值：0 0000000 即   2^8 - 1  =  255</p>
<p>尾数也是8位数值位，1为符号位原码的形式：</p>
<p>由于我们限定了浮点数的尾数只能是小数，所以我们当成定点纯小数的形式进行分析：</p>
<p>尾数的最小负值：1.11111111	即-(1- 2<sup>-8</sup>)</p>
<p>尾数的最大负值：1.0000001	即-2<sup>8</sup></p>
<p>尾数的最大正值：0.11111111	即1- 2<sup>-8</sup></p>
<p>尾数的最小正值	0.0000001	即2<sup>8</sup></p>
<h2 id="规格化浮点数">规格化浮点数</h2>
<p>假如一个尾数M用原码表示为0.00000001，那么这8位尾数的前7位都是0，这7个0实际上是无效数值位，我们完全可以改写成：</p>
<blockquote>
<p>0.1XXXXXXX×2<sup>-7</sup></p>
</blockquote>
<p>当1左移到最高位时，尾数后面多出来了7位可以多表示7个有效位来提高精度</p>
<p>规格化浮点数，就是调整一个非规格化浮点数的位数和阶码的大小，使非零的浮点数在尾数的最高位上保证是一个有效值</p>
<p>规格化浮点数使尾数存储空间能表示更多的有效数位</p>
<h3 id="规范">规范</h3>
<p>若尾数M用原码表示，</p>
<ul>
<li>
<p>当M ≥0时，[M]<sub>原</sub> = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M]<sub>原</sub> = 1.1XXXXXXX</p>
<p>若尾数M用补码表示，</p>
</li>
<li>
<p>当M ≥0时，[M] 补 = 0.1XXXXXXX</p>
</li>
<li>
<p>当M&lt; 0时，[M] 补 = 1.0XXXXXXX</p>
</li>
</ul>
<h3 id="表示范围">表示范围</h3>
<p>尾数用原码表示，则规格化浮点数可表示的范围如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>数值</th>
<th></th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>尾数最小负值</td>
<td>-(1-2<sup>n</sup>)</td>
<td>尾数最大负值</td>
<td>-1/2</td>
</tr>
<tr>
<td>尾数最小正值</td>
<td>1/2</td>
<td>尾数最大正值</td>
<td>1-2<sup>n</sup></td>
</tr>
</tbody>
</table>
<p>因此规格化浮点数将尾数M的绝对值限定在规定的数值范围之内，即</p>
<blockquote>
<p>1/2 ≤ ∣ M ∣ &lt; 1 （原码）</p>
</blockquote>
<p>要使尾数的绝对值在此范围内，通过改变小数点的位置（相应地改变阶码）就可以做到。</p>
<h3 id="操作">操作</h3>
<table>
<thead>
<tr>
<th>非规格化浮点数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>当运算结果最高位不是有效位时</td>
<td>尾数每左移一位，阶码减一</td>
</tr>
<tr>
<td>当运算结果的尾数的有效位进到小数点前面时</td>
<td>尾数每右移一位，阶码加一</td>
</tr>
</tbody>
</table>
<ul>
<li>判断浮点数是否规格化：尾数最高位是否是有效位</li>
<li>正数补码（原码）而言，有效位都为1；而对于负数补码而言，有效位为0，对于负数原码，有效位为1</li>
<li>特别地，补码表示中，-1/2（1.100000000）不是规格化形式，-1（1.00000000）是规格化形式；，注意不要与原码规格化判定的绝对值范围混淆</li>
</ul>
<h2 id="IEEE-754标准浮点数">IEEE 754标准浮点数</h2>
<h3 id="单精度浮点数">单精度浮点数</h3>
<p>IEEE 754规定单精度浮点数的真值N一般表示为：</p>
<blockquote>
<p>N = (-1)<sup>S</sup> * 2<sup>e-127</sup> * 1.f</p>
</blockquote>
<table>
<thead>
<tr>
<th>数符S</th>
<th>阶码e</th>
<th>尾数f</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>8位</td>
<td>23位</td>
</tr>
<tr>
<td>浮点数的正负</td>
<td>含1位阶符，采用移码表示，偏移量127</td>
<td>浮点数的精度，采用原码表示</td>
</tr>
</tbody>
</table>
<ul>
<li>IEEE 754中的阶码采用移码来表示，但对于单精度浮点数来说，移码的偏移量不是2<sup>7</sup>而是2<sup>7</sup> − 1 = 127 ,这是因为IEEE 754将移码编码的全0和全1作为了特殊标识。</li>
<li>IEEE 754浮点数是规格化浮点数，为了能够更多地表示尾数的有效数位，规定尾数真值的整数部分必须为1，尾数编码时整数1隐去，小数部分f用原码表示。</li>
</ul>
<table>
<thead>
<tr>
<th>真值D</th>
<th>补码</th>
<th>移码</th>
<th>阶码真值</th>
</tr>
</thead>
<tbody>
<tr>
<td>-128</td>
<td>1000 0000</td>
<td>0000 0000</td>
<td>/</td>
</tr>
<tr>
<td>-127</td>
<td>1000 0001</td>
<td>0000 0001</td>
<td>1111 1110</td>
</tr>
<tr>
<td>-126</td>
<td>1000 0010</td>
<td>0000 0010</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>-1</td>
<td>1111 1111</td>
<td>0111 1111</td>
<td>0000 0000</td>
</tr>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>1000 0000</td>
<td>0000 0001</td>
</tr>
<tr>
<td>1</td>
<td>0000 0001</td>
<td>1000 0001</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>125</td>
<td>0111 1101</td>
<td>1111 1101</td>
<td></td>
</tr>
<tr>
<td>126</td>
<td>0111 1110</td>
<td>1111 1110</td>
<td></td>
</tr>
<tr>
<td>127</td>
<td>0111 1111</td>
<td>1111 1111</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="阶码e全0和全1时的特殊含义">阶码e全0和全1时的特殊含义</h4>
<ol>
<li>当阶码全0，且尾数f不全0时，表示该浮点数不是规格化浮点数，尾数实际为：0.XXXXXXXX 次正规数,而不是规定形式的：1.XXXXXXXX</li>
<li>当阶码e全1，且尾数f全为0时，则该浮点数表示正无穷大或负无穷大，当数符s为1时，表示负无穷大，当数符s为0时，表示正无穷大。</li>
<li>当阶码e全1，且尾数f不全为0时，则该浮点数表示非数值数据（NaN）。</li>
</ol>
<h4 id="为什么IEEE-754使用移码表示阶码e">为什么IEEE 754使用移码表示阶码e</h4>
<h5 id="保证浮点数的机器零的阶码为全0">保证浮点数的机器零的阶码为全0</h5>
<p>机器零：机器数表示0的形式</p>
<p>​	IEEE 754标准下，浮点数尾数真值的整数部分隐藏了真值1，因此无法通过尾数全0来表示机器0；使用阶符表示机器0时，当阶码的真值趋向负无穷时，即指数趋于负无穷，此时浮点真值也趋于0，因此规定使用阶码中真值为负数且最小的数来表示机器0；假设使用8位补码来表示阶码，此时机器0表示为1000 0000B（-127D)，若使用8位移码，则使用 0000 0000 ；使用移码更直观，因此规定<strong>尾数、阶码同时全为0来表示机器0</strong>。（阶码全0，尾数不全0时，表示浮点数非规格化）</p>
<h5 id="移码全部位于正轴上，随真值增大而增大">移码全部位于正轴上，随真值增大而增大</h5>
<p>​	移码是对于某一个系列或集合的数使它们都映射到正数轴上去，即在数轴上把数都统一往右移动n位，使得所有的数都不为负数。IEEE 754标准下，移码E=e+偏移量，因此对于所有的E都有E大于等于0。由于移码都是从0开始的正数，所以即使是二进制的表示形式，也能直接<strong>比较阶码对应数值的大小</strong>(而补码之间的比较要观察符号位，同时转换成原码对数值位进行比较)。</p>
<h5 id="移码也能减法变加法">移码也能减法变加法</h5>
<p>移码相对于补码仅符号位取反，进行减法运算时，也能加法变减法，只是符号位代表的含义不同，0表示负数，1表示正数，使用移码减法运算和补码减法运算得到的结果真值相同。</p>
<h5 id="总结-2">总结</h5>
<p>对于单精度浮点数：<br>
(1)阶码的真值E=e-127，并且0&lt;e&lt;255，-126&lt;E&lt;127。</p>
<p>(2)当e=0或255时，在IEEE 754中表示特殊的数。</p>
<p>(3)所能表示的范围为：</p>
<ul>
<li>正数为：+2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到+2 <sup>−126</sup> ×(1+0)</li>
<li>负数为：−2 <sup>+127</sup> ×(1+1−2 <sup>−23</sup> )到−2 <sup>−126</sup> ×(1+0)</li>
</ul>
<h3 id="双精度浮点数">双精度浮点数</h3>
<p>简要说明双精度浮点数（与单精度浮点数相类似）：</p>
<p>（1)阶码的真值E的取值范围为：-1022 ~ +1023,偏移量为+1023,阶码移码编码e为：<br>
+1 ~ + 2046</p>
<p>（2）双精度浮点数的规格化数表示为：N=(−1) s ×2 e−1023 ×1.f</p>
<p>（3）所能表示的规格化数范围：<br>
正数为：+2 +1023 ×(1+1−2 −52 )到+2 −1022 ×(1+0)</p>
<p>负数为：−2 +1023 ×(1+1−2 −52 )到−2 −1022 ×(1+0)</p>
<p>（4）当e=0或e=2047时，在IEEE 754标准中表示特殊的数</p>
<h3 id="舍入模式">舍入模式</h3>
<p>我们在进行对阶或者右规格化的时候，阶数较小的操作数在进行右移的时候，会造成尾数部分的低位丢失，从而会造成误差。因此我们才需要根据需求，采取四种舍入模式中的一种对尾数进行舍入操作以减少误差。</p>
<p>二、IEEE754标准中的4种舍入模式<br>
1、就近舍入：</p>
<p>即十进制下的四舍五入。但是也会出现以下几种情况：</p>
<p>多余数字是1001，它大于0.5，故最低位进1。<br>
多余数字是0111，它小于0.5，则直接舍掉多余数字。<br>
多余数字是1000，正好是等于0.5的特殊情况；那么此时最低位为0则舍掉多余位，最低位为1则进位1。<br>
注意这里说明的数位都是指二进制数。因为这是尾数，所以在计算这些二进制和0.5的关系的时候，也即转为10进制的时候，我们用每一位的权重乘以2^(-i)然后求和即可。</p>
<p>2、朝0舍入：即朝数轴零点方向舍入，所以我们直接截尾即可。</p>
<p>3、朝正无穷舍入：对正数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；负数的话不管多余位是多少直接截尾即可。</p>
<p>4、朝负无穷舍入：对负数而言，多余位全为0则直接截尾，不全为0则向最低有效位进1；正数的话不管多余位是多少直接截尾即可。</p>
]]></content>
      <categories>
        <category>计算机组成与原理</category>
      </categories>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/post/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1>引言</h1>
<span id="more"></span>
<h1>算数运算符</h1>
<h2 id="加法-、取正">+:	 加法 、取正</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>，b = <span class="number">2</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(a + b + str);<span class="comment">//3hello</span></span><br><span class="line">System.out.println(str + a + b);<span class="comment">//hello12</span></span><br><span class="line">System.out.println(str + (a + b));<span class="comment">//hello3</span></span><br><span class="line">System.out.println(a + str + b);<span class="comment">//1hello2</span></span><br></pre></td></tr></table></figure>
<p>从左向右执行：</p>
<ul>
<li>符号两边有任意一边是字符串 做的是字符串拼接</li>
<li>符号两边都是数字 做的是加法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;<span class="comment">//48</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">System.out.println(x + y + c);<span class="comment">//52</span></span><br><span class="line">System.out.println(s + y + c);<span class="comment">//030</span></span><br><span class="line">System.out.println(y + c + s);<span class="comment">//510</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;*	*&quot;</span>);<span class="comment">//*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//数字</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//数字*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));<span class="comment">//*	*</span></span><br></pre></td></tr></table></figure>
<h2 id="减法-、-取负">-  :	减法 、 取负</h2>
<h2 id="乘法">* :	乘法</h2>
<h2 id="除法">\ :	除法</h2>
<p>​		<code>System.out.println(10/3*3);//9</code></p>
<h2 id="：取余">%：取余</h2>
<ul>
<li>
<p>任意数字和n取余结果是[0，n-1]</p>
</li>
<li>
<p>取余结果符号和被除数符号一致</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(a  + <span class="string">&quot; % &quot;</span> + b  + <span class="string">&quot; = &quot;</span> + (a % b));</span><br><span class="line">System.out.println(-a + <span class="string">&quot; % &quot;</span> + b  + <span class="string">&quot; = &quot;</span> + (-a % b));</span><br><span class="line">System.out.println(a  + <span class="string">&quot; % &quot;</span> + -b + <span class="string">&quot; = &quot;</span> + (a % -b));</span><br><span class="line">System.out.println(-a + <span class="string">&quot; % &quot;</span> + -b + <span class="string">&quot; = &quot;</span> + (-a % -b));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	随意给出一个整数，打印显示它的个位数，十位数，百</span></span><br><span class="line"><span class="comment">	位数的值，例如:数字345的情况如下：</span></span><br><span class="line"><span class="comment">	个位数：5 十位数：4 百位数：3</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">345</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;个位数:&quot;</span> + number%<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;十位数:&quot;</span> + number/<span class="number">10</span>%<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;百位数:&quot;</span> + number/<span class="number">100</span>);<span class="comment">//number/10/10</span></span><br></pre></td></tr></table></figure>
<h2 id="前-、-后-、前–、后–">前++ 、 后++、前–、后–</h2>
<h3 id>++</h3>
<ul>
<li>同:运算结果相同 都是减1</li>
<li>异:前++：先加1 再赋值     后++：先赋值 再加1</li>
</ul>
<h2 id="–">–</h2>
<ul>
<li>同:运算结果相同 都是减1</li>
<li>异:前–：先减1 再赋值     后–：先赋值 再减</li>
<li>++ – 不改变自身数据类型 所以 byte b = 3 ;b++;不报错，区别于<a href="../%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型中的常数赋值</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//b = b + 1;//报错</span></span><br><span class="line">b++;<span class="comment">//++b  === (byte)(b + 1)</span></span><br></pre></td></tr></table></figure>
<h1>赋值运算符</h1>
<h2 id="基本运算符：">基本运算符： =</h2>
<h2 id="扩展运算符：">扩展运算符： += -= *= /= %=</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给一个数加1 有几种方式</span></span><br><span class="line">i = i + <span class="number">1</span>;<span class="comment">//方式1</span></span><br><span class="line">i++;<span class="comment">//++i; 方式2</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">//方式3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不改变自身数据类型 byte b = 5; b += 1; 不报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//b = b + 1; //报错</span></span><br><span class="line">b += <span class="number">1</span>;	<span class="comment">//不报错 b = (byte)(b + 1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">ii *= <span class="number">0.1</span>;<span class="comment">//不报错 ii = (int)(ii * 0.1) </span></span><br></pre></td></tr></table></figure>
<h1>关系运算符</h1>
<h1>逻辑运算符</h1>
<p>操作数是boolean 运算结果也是boolean类型</p>
<h2 id="逻辑与、短路与">逻辑与、短路与</h2>
<ul>
<li>有一假结果是假</li>
<li>同:运算结果相同</li>
<li>当运算符左侧是false,&amp;右侧继续运算 &amp;&amp; 发生短路 右侧不运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp; 和 &amp;&amp;短路与的区别</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">//boolean result = sex == &#x27;女&#x27; &amp; age++ == 10;	//age = 11</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> sex == <span class="string">&#x27;女&#x27;</span> &amp;&amp; age++ == <span class="number">10</span>;		<span class="comment">//age = 10</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑或、短路或">逻辑或、短路或</h2>
<ul>
<li>有一真结果为真</li>
<li>运算结果相同</li>
<li>当运算符左侧是true,|右侧继续运算 || 发生短路 右侧不运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//| 和 || 的区别</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">//boolean result = sex == &#x27;男&#x27; | age++ == 10;	//age = 11</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> sex == <span class="string">&#x27;男&#x27;</span> || age++ == <span class="number">10</span>;		<span class="comment">//age = 10</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑非">逻辑非</h2>
<ul>
<li>！取反</li>
</ul>
<h2 id="逻辑异或">逻辑异或</h2>
<ul>
<li>^ :相同为假 不同为真</li>
</ul>
<h1>位运算符</h1>
<p>操作的是数值,得到数值的补码然后进行位运算</p>
<h2 id="移位运算-一元运算符">移位运算(一元运算符)</h2>
<h3 id="左移">左移 &lt;&lt;</h3>
<p>每移动一位相当于* 2 空位补0</p>
<h3 id="右移">右移 &gt;&gt;</h3>
<p>每移动一位相当于/ 2 最高位是0就补0 是1就补1</p>
<h3 id="无符号右移">无符号右移 &gt;&gt;&gt;</h3>
<p>每移动一位相当于/ 2 最高位补0</p>
<h2 id="逻辑运算-二元运算符">逻辑运算(二元运算符)</h2>
<p>每一位上如果是1 看做true 如果是0 看做false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑与">逻辑与 &amp;</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x &amp; y;<span class="comment">//4</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000100 4</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑或">逻辑或 |</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = x | y;<span class="comment">//13</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001101 13</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑非-2">逻辑非 ~</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = ~x;<span class="comment">//-13</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11110011 补码</span></span><br><span class="line"><span class="comment">//11111111 11111111 11111111 11110010 反码	补码减去1得到反码</span></span><br><span class="line"><span class="comment">//10000000 00000000 00000000 00001101 源码 	符号位不变其他位取反得到源码	- 13</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑异或-2">逻辑异或 ^</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = x ^ y;<span class="comment">//9</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001100 12</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00000101 5</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//00000000 00000000 00000000 00001001 9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>m = (m^^<sup>n)</sup>^^n</li>
</ul>
<h3 id="3种变量交换">3种变量交换</h3>
<h4 id="临时变量">临时变量</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br></pre></td></tr></table></figure>
<h4 id="累加消除">累加消除</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = a + b;</span><br><span class="line">a = b - a;</span><br><span class="line">b = b - a;</span><br></pre></td></tr></table></figure>
<ol>
<li>少定义一个变量</li>
<li>有局限，可能超过int类型</li>
</ol>
<h4 id="异或消除">异或消除</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br></pre></td></tr></table></figure>
<ol>
<li>少定义一个变量</li>
<li>没有局限</li>
<li>m = (m^^<sup>n)</sup>^^n</li>
</ol>
<h1>三元运算符</h1>
<ul>
<li>
<p>boolean表达式 ? 表达式1 : 表达式2</p>
</li>
<li>
<p>boolean表达式返回true  表达式1的结果作为整个表达式的结果</p>
</li>
<li>
<p>boolean表达式返回false 表达式2的结果作为整个表达式的结果</p>
</li>
</ul>
<p>注意:</p>
<ol>
<li>表达式1 和 表达式2 结果类型必须保持一致</li>
<li>表达式结果会发生自动类型转换，转换成范围大的数据类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span> ? <span class="string">&quot;已成年&quot;</span> : <span class="number">1.0</span>;<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="number">1</span> : <span class="number">1.0</span>;	<span class="comment">//不报错 发生自动类型转换 1.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);<span class="comment">//发生自动类型转换</span></span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第一阶段</category>
      </categories>
  </entry>
</search>
