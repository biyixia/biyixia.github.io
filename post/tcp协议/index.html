<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> biyixia</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="biyixia" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-tcp协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/post/tcp%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2024-07-13T15:19:42.263Z" itemprop="datePublished">2024-07-13</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">14k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">49 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2><span id="osi模型">OSI模型</span></h2>
<p>国际标准化组织ISO为了使网络应用更为普及，推出了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B&amp;spm=1001.2101.3001.7020">OSI参考模型</a>，即开放式系统互联（Open System Interconnect）模型，一般都叫OSI参考模型。OSI参考模型是ISO组织在1985年发布的网络互连模型，其含义就是为所有公司使用一个统一的规范来控制网络，这样所有公司遵循相同的通信规范，网络就能互联互通了</p>
<p>定义了网络互连的七层框架，每一层实现各自的功能和协议，并完成与相邻层的接口通信</p>
<table>
<thead>
<tr>
<th>OSI模型框架</th>
<th>主要通信协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</td>
</tr>
<tr>
<td>表示层</td>
<td>XDR、ASN.1、SMB、AFP、NCP</td>
</tr>
<tr>
<td>会话层</td>
<td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL</td>
</tr>
<tr>
<td>网络层</td>
<td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</td>
</tr>
<tr>
<td>数据链路层</td>
<td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td>
</tr>
<tr>
<td>物理层</td>
<td>铜缆、网线、光缆、无线电</td>
</tr>
</tbody>
</table>
<h2><span id="tcpip协议">TCP/IP协议</span></h2>
<ul>
<li>是Internet互联网最基本的协议</li>
<li>包含了一系列的协议，也叫TCP/IP协议族（TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP协议</li>
<li>提供了点对点的连结机制，并且将传输数据帧的封装、寻址、传输、路由以及接收方式，都予以标准化</li>
</ul>
<h2><span id="tcpip协议的分层模型">TCP/IP协议的分层模型</span></h2>
<p>其在一定程度上参考了七层ISO模型。七层被简化为了四个层次。TCP/IP模型中的各种协议，依其功能不同，被分别归属到这四层之中，常被视为是简化过后的七层OSI模型，TCP/IP协议与七层ISO模型的对应关系，大致如下图所示：</p>
<table>
<thead>
<tr>
<th>TCP/IP协议模型框架</th>
<th>对应OSI模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>应用层、表示层、会话层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>链路层（或数据链路层或网络接口层）</td>
<td>数据链路层、物理层</td>
</tr>
</tbody>
</table>
<h3><span id="应用层">应用层</span></h3>
<ul>
<li>读取来自传输层的数据或者将数据传输写入传输层</li>
<li>包括所有和应用程序协同工作，并利用基础网络交换应用程序的业务数据的协议</li>
<li>一些特定的程序被认为运行在这个层上，该层协议所提供的服务能直接支持用户应用</li>
<li>包括HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登陆）、DNS（域名解析）、Telnet以及许多其他协议</li>
</ul>
<h3><span id="传输层">传输层</span></h3>
<ul>
<li>实现端对端的数据传输</li>
<li>这种传输服务分为可靠和不可靠的，其中TCP是典型的可靠传输，而UDP则是不可靠传输</li>
<li>为端到端连接提供流量控制、差错控制、QoS(Quality of Service)服务质量等管理服务</li>
<li>传输层的协议解决了诸如端到端可靠性问题，能确保数据可靠的到达目的地，甚至能保证数据按照正确的顺序到达目的地</li>
<li>主要有两个性质不同的协议：TCP传输控制协议和UDP用户数据报协议
<ul>
<li>TCP协议是一个面向连接的、可靠的传输协议，它提供一种可靠的字节流，能保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送（传输效率低，但可靠性强）</li>
<li>UDP协议是一个无连接的数据报协议，是一个“尽力传递”和“不可靠”协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按顺序到达（传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（比如QQ聊天数据））</li>
</ul>
</li>
</ul>
<h3><span id="网络层">网络层</span></h3>
<ul>
<li>在复杂的网络环境中为要发送的数据报找到一个合适的路径进行传输</li>
<li>简单来说，网络层负责将数据传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一个地址</li>
<li>另外，网络层负责寻找合适的路径到达对方计算机，并把数据帧传送给对方，网络层还可以实现拥塞控制、网际互连等功能</li>
<li>主要负责网络中数据包的传送等</li>
<li>协议的代表包括：ICMP、IP、IGMP等</li>
</ul>
<h3><span id="链路层">链路层</span></h3>
<ul>
<li>也称作数据链路层或网络接口层</li>
<li>用来处理连接网络的硬件部分。该层既包括操作系统硬件的设备驱动、NIC（网卡）、光纤等物理可见部分，还包括连接器等一切传输媒介。在这一层，数据的传输单位为比特</li>
<li>通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡，它们一起处理与传输媒介（如电缆或其他物理设备）的物理接口细节</li>
<li>其主要协议有ARP、RARP等</li>
</ul>
<h2><span id="图解-物理层使用mac解决设备的身份证问题">图解 物理层：使用MAC解决设备的身份证问题</span></h2>
<h4><span id="通信的原始时代">通信的原始时代</span></h4>
<p>很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c116974d56c675f7538797a22e91c0a5.png" alt="img"></p>
<p>直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根<strong>网线</strong>连接了起来。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a836e2da1f508613647ca30447a76720.png" alt="image"></p>
<p>用一根网线连接起来怎么就能&quot;通信&quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。</p>
<p>如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在<strong>开枪</strong>吧~</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1072881fab34b4a2e55f26b28b80df88.gif" alt="image.gif"></p>
<p>反正，你们就是连起来了，并且可以通信。</p>
<p>有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开<strong>两个网口</strong>，用一共<strong>三根网线</strong>，彼此相连。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3ed1eec2d396a3e47d5ef4c54f6cabed.png" alt="image"></p>
<p>随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/00ab6bac211258aedd99d2633d105664.png" alt="image"></p>
<p><strong>集线器的诞生</strong></p>
<p>于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c33959d3b2df76cd5beb599561e098e9.png" alt="image"></p>
<p>你给它取名叫<strong>集线器</strong>，它仅仅是无脑将电信号<strong>转发到所有出口（广播）</strong>，不做任何处理，你觉得它是没有智商的，因此把人家定性在了<strong>物理层</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/00f213db8eb3a7d6735c026de3833ca1.gif" alt="image.gif"></p>
<p>由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？</p>
<p>首先，你要给所有的连接到交换机的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，全局唯一的名字作为标识，你把这个更高端的名字称为 MAC 地址。</p>
<p>你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。</p>
<p>这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6b1e9c8e0c27da30b41d0115d3dd1194.png" alt="image"></p>
<p>B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便<strong>收下</strong>。</p>
<p>其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便<strong>丢弃</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e44f6748c5c296f8e37a7eb18d764cb5.gif" alt="image"></p>
<p>虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。</p>
<h3><span id="图解-数据链路使用交换机解决mac-地址映射问题">图解 数据链路：使用交换机解决MAC 地址映射问题</span></h3>
<h4><span id="集线器的问题">集线器的问题</span></h4>
<p>如果把这个集线器弄得更智能一些，<strong>只发给目标 MAC 地址指向的那台电脑</strong>，就好了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b6ad2350fab1e911a2c8531cba5693d.gif" alt="image"></p>
<h4><span id="交换机的诞生">交换机的诞生</span></h4>
<p>虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做<strong>交换机</strong>。也正因为这一点点智能，你把它放在了另一个层级，<strong>数据链路层</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d13e6e7fb9838fe0acd6370692d57f92.png" alt="image"></p>
<p>如上图所示，你是这样设计的。</p>
<p>交换机内部维护一张 <strong>MAC 地址表</strong>，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。</p>
<p><img src="https://img-blog.csdnimg.cn/69857c6f4e994760b205ed62a591d1eb.png" alt="img"></p>
<p>假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/913f402efac18571df11fb219e09f11e.png" alt="image"></p>
<p>到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上，于是把数据从 1 号端口发给了 B，完事~</p>
<p>你给这个通过这样传输方式而组成的小范围的网络，叫做以太网。</p>
<p>当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？</p>
<p>假如在 MAC 地址表为空是，你给 B 发送了如下数据</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/913f402efac18571df11fb219e09f11e.png" alt="image"></p>
<p>由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：</p>
<p><strong>MAC：aa-aa-aa-aa-aa-aa-aa<br>
端口：4</strong></p>
<p>交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。</p>
<p>之后，只有机器 B 收到了确实是发给自己的包，于是做出了响应，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：</p>
<p><strong>MAC：bb-bb-bb-bb-bb-bb<br>
端口：1</strong></p>
<p>过程如下</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ae47c4fd0533b29cfce00a78e784e362.gif" alt="image"></p>
<p>经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~</p>
<p>随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/96c4da16c077389b994e7526f2ba73f0.png" alt="image"></p>
<p>你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。</p>
<p>但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。</p>
<h4><span id="mac-地址和端口的映射记录">MAC 地址和端口的映射记录</span></h4>
<p>最终，<strong>两个交换机将分别记录 A ~ H 所有机器的映射记录</strong>。</p>
<p><strong>左边的交换机</strong></p>
<p><img src="https://img-blog.csdnimg.cn/7de11b8018b0497a942b922b55046aa1.png" alt="img"></p>
<p><strong>右边的交换机</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c625bdc4fd23458a8a43bfb28a1b3bc6.png" alt="img"></p>
<p>这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。</p>
<p>但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。</p>
<h3><span id="图解-传输层ip地址和路由器">图解 传输层：IP地址和路由器</span></h3>
<h4><span id="二层交换机的问题">二层交换机的问题</span></h4>
<p>交换机已经无法记录如此庞大的映射关系了。</p>
<p>此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。</p>
<p>那我可不可以让那根红色的网线，接入一个新的设备，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次转发呢？</p>
<p>这个设备就是路由器，它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发，你把它定在了网络层。<br>
<img src="https://img-blog.csdnimg.cn/img_convert/635d579c31b4ab410cd05715bc764741.png" alt="image"></p>
<p>注意，路由器的每一个端口，都有独立的 MAC 地址</p>
<p>好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。</p>
<p>那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH… 的数据包，统统先发送给路由器呢？</p>
<p>不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是</p>
<p><strong>C 的 MAC 地址：FFFF-FFFF-CCCC</strong> <strong>D 的 MAC 地址：FFFF-FFFF-DDDD</strong></p>
<p>那我们就可以说，将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统统先发送给路由器。</p>
<p>这样是否可行呢？答案是否定的。</p>
<h4><span id="ip地址的诞生">IP地址的诞生</span></h4>
<p>我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示</p>
<p><strong>00-16-EA-AE-3C-40</strong></p>
<p>它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。</p>
<p>其中前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。</p>
<p>只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。</p>
<p>那如果你希望向上面那样表示将目标 MAC 地址为 FFFF-FFFF-？开头的，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。</p>
<p>这显然是不现实的。</p>
<p>于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：</p>
<p>11000000101010000000000000000001</p>
<p>你觉得有些不清晰，于是把它分成四个部分，中间用点相连。</p>
<p>11000000.10101000.00000000.00000001</p>
<p>你还觉得不清晰，于是把它转换成 10 进制。</p>
<p>192.168.0.1</p>
<p>最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。</p>
<p>这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bbcfa3e647d0bdb78a9b69cf6157c68d.png" alt="image"></p>
<p>如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，“将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！”，巧妙吧。</p>
<p>路由器的诞生<br>
路由器诞生了，专门负责IP地址的寻找。那报文交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？</p>
<p>别急我们慢慢来。</p>
<p>我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3e0e17cfa7a0fed1b604890ef4e1cca5.png" alt="image"></p>
<p>现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。</p>
<p>假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ec10004d89fc45b41721099b7408b5f0.png" alt="image"></p>
<p>但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。</p>
<p>A ~ 路由器这段的包如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/36f94ba80eb664a50698787f4ba34a85.png" alt="image"></p>
<p>路由器到 C 这段的包如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/adc2e43a9763d4cadae0b5abc55d636e.png" alt="image"></p>
<p>好了，上面说的两种情况（A-&gt;B，A-&gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。</p>
<h4><span id="子网的由来">子网的由来</span></h4>
<p><strong>A 给 C 发数据包，怎么知道是否要通过路由器转发呢？</strong></p>
<p><strong>答案：子网</strong></p>
<p>如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。</p>
<p>如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。</p>
<p>好，那现在只需要解决，什么叫处于一个子网就好了。</p>
<ul>
<li>192.168.0.1 和 192.168.0.2 处于同一个子网</li>
<li>192.168.0.1 和 192.168.1.1 处于不同子网</li>
</ul>
<p>这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：</p>
<p><strong><a target="_blank" rel="noopener" href="http://192.168.0.xxx">192.168.0.xxx</a> 开头的，就算是在一个子网，否则就是在不同的子网。</strong></p>
<p>那对于计算机来说，怎么表达这个意思呢？于是人们发明了<strong>子网掩码</strong>的概念</p>
<p>假如某台机器的子网掩码定为 255.255.255.0</p>
<p>这表示，将源 IP 与目的 IP 分别同这个子网掩码进行<strong>与运算*<em>*</em>，相等则是在一个子网，不相等就是在不同子网</strong>，就这么简单。</p>
<p>比如</p>
<p>A电脑：192.168.0.1 &amp; 255.255.255.0 = 192.168.0.0</p>
<p>B电脑：192.168.0.2 &amp; 255.255.255.0 = 192.168.0.0</p>
<p>C电脑：192.168.1.1 &amp; 255.255.255.0 = 192.168.1.0</p>
<p>D电脑：192.168.1.2 &amp; 255.255.255.0 = 192.168.1.0</p>
<p>那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。<br>
<img src="https://img-blog.csdnimg.cn/img_convert/7e6a21dbdc49b7a772f1348e542cdfef.png" alt="image"></p>
<p>所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 &amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，之后怎么转发，A 不关心。</p>
<p>A 如何知道，哪个设备是路由器？</p>
<p>答案：在 A 上要设置默认网关</p>
<p>上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？</p>
<p>其实说发给路由器不准确，应该说 A 会把包发给默认网关。</p>
<p>对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。</p>
<p>所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c30114bad824d8d262469cea973210a.png" alt="image"></p>
<p>仅此而已！</p>
<h4><span id="路由表的由来和mac表的由来好像都是逼出来的">路由表的由来（和Mac表的由来好像，都是逼出来的）</span></h4>
<p><strong>路由器如何知道C在哪里？</strong></p>
<p><strong>答案：路由表</strong></p>
<p>现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，<strong>路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去</strong>，才能直接（或间接）地最终到达目的地 C 呢。</p>
<p>路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。</p>
<p>这个表就叫路由表。</p>
<p>至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~</p>
<p>不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。<br>
<img src="https://img-blog.csdnimg.cn/dc1ece919966403ba41f5654f7c68596.png" alt="img"></p>
<p>我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24</p>
<p><img src="https://img-blog.csdnimg.cn/d0ad11bb4215484fb3364d7d2d7ab2db.png" alt="img"></p>
<p>这就很好理解了，路由表就表示，<strong><a target="_blank" rel="noopener" href="http://192.168.0.xxx">192.168.0.xxx</a> 这个子网下的，都转发到 0 号端口，<a target="_blank" rel="noopener" href="http://192.168.1.xxx">192.168.1.xxx</a> 这个子网下的，都转发到 1 号端口</strong>。下一跳列还没有值，我们先不管</p>
<p>配合着结构图来看（这里把子网掩码和默认网关都补齐了）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e48fef70877bae108f18a636b6e2d64f.gif" alt="image"></p>
<p><strong>刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？</strong></p>
<p><strong>答案：arp</strong></p>
<p>假如你（A）此时不知道你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？</p>
<p>答案很简单，在网络层，我需要把 IP 地址对应的 MAC 地址找到，也就是通过某种方式，找到 192.168.0.2 对应的 MAC 地址 BBBB。</p>
<p>这种方式就是 arp 协议，同时电脑 A 和 B 里面也会有一张 arp 缓存表，表中记录着 IP 与 MAC 地址的对应关系。<br>
<img src="https://img-blog.csdnimg.cn/eb5ac8ee07c84815a7d0bcd23fe91608.png" alt="img"></p>
<p>一开始的时候这个表是空的，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会广播一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个响应。此时 A 便更新了自己的 arp 表。</p>
<p>这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整。</p>
<h3><span id="图解整个传输过程">图解：整个传输过程</span></h3>
<p><strong>从各个节点的视角来看</strong></p>
<h4><span id="电脑视角"><strong>电脑视角</strong>：</span></h4>
<ul>
<li>首先我要知道我的 IP 以及对方的 IP</li>
<li>通过子网掩码判断我们是否在同一个子网</li>
<li>在同一个子网就通过 arp 获取对方 mac 地址直接扔出去</li>
<li>不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去</li>
</ul>
<h4><span id="交换机视角"><strong>交换机视角：</strong></span></h4>
<ul>
<li>我收到的数据包必须有目标 MAC 地址</li>
<li>通过 MAC 地址表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去</li>
<li>查不到就所有端口都发出去</li>
</ul>
<p><strong>路由器视角：</strong></p>
<ul>
<li>我收到的数据包必须有目标 IP 地址</li>
<li>通过路由表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）</li>
<li>查不到则返回一个路由不可达的数据包</li>
</ul>
<p>如果你嗅觉足够敏锐，你应该可以感受到下面这句话：</p>
<p>网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。</p>
<p><strong>涉及到的三张表分别是</strong></p>
<ul>
<li>交换机中有 <strong>MAC 地址</strong>表用于映射 MAC 地址和它的端口</li>
<li>路由器中有<strong>路由表</strong>用于映射 IP 地址(段)和它的端口</li>
<li>电脑和路由器中都有** arp 缓存表**用于缓存 IP 和 MAC 地址的映射关系</li>
</ul>
<p><strong>这三张表是怎么来的</strong></p>
<ul>
<li>MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。</li>
<li>路由表是各种路由算法 + 人工配置逐步完善起来的。</li>
<li>arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。</li>
</ul>
<p>知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！</p>
<h4><span id="参考的网络拓扑图">参考的网络拓扑图</span></h4>
<p>那接下来我们就放上参考的 <strong>最后一个</strong>网络拓扑图吧，请做好 <strong>战斗</strong> 准备！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a889e11a36f66f1645d918e754a0a173.png" alt="image"></p>
<p>这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。</p>
<p>也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。</p>
<p><img src="https://img-blog.csdnimg.cn/6dac658cc72049b2b29261894451a79a.png" alt="img"></p>
<p><strong>这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/da2d65dda084a873779b01f59ff606aa.png" alt="image"></p>
<p>思考一分钟…</p>
<p><strong>详细过程动画描述：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6740f3b2596d7bf32d214a40f58603ec.gif" alt="image"></p>
<p><strong>详细过程文字描述：</strong></p>
<p>\1. 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）</p>
<p>\2. A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。</p>
<p>\3. A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包<br>
<img src="https://img-blog.csdnimg.cn/img_convert/7bb8957a74eef0cdc7f36df7a05702dd.png" alt="image"></p>
<p>\4. 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器1</p>
<p>\5. 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5*</p>
<p>\6. 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。</p>
<p>\7. 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。</p>
<p>\8. 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。</p>
<p>\9. 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其 6 号端口出去，于是从 6 号端口把数据包发出去。</p>
<p>**10.**F 最终收到了数据包！**并且发现目的 MAC 地址就是自己，于是收下了这个包</p>
<h3><span id="http报文传输原理">HTTP报文传输原理</span></h3>
<p>利用TCP/IP进行网络通信时，数据包会按照分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。从客户端到服务器的数据，每一帧数据的传输的顺序都为：应用层-&gt;运输层-&gt;网络层-&gt;链路层-&gt;链路层-&gt;网络层-&gt;运输层-&gt;应用层。</p>
<h4><span id="http报文传输过程">HTTP报文传输过程</span></h4>
<p>以一个HTTP请求的传输为例，请求从HTTP客户端（如浏览器）和HTTP服务端应用的传输过程，大致如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210308122800578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图：HTTP请求报文的分层传输过程</p>
<h4><span id="数据封装和分用">数据封装和分用</span></h4>
<p>接下来，为大家介绍一下数据封装和分用。</p>
<p>数据通过互联网传输的时候不可能是光秃秃的不加标识，如果这样数据就会乱。所以数据在发送的时候，需要加上特定标识，加上特定标识的过程叫做数据的封装，在数据使用的时候再去掉特定标识，去掉特定标识的过程就叫做分用。TCP/IP协议的数据封装和分用过程，大致如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210308122819964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>图：TCP/IP协议的数据封装和分用过程</p>
<p>在数据封装时，数据经过每个层都会打上该层特定标识，添加上头部。</p>
<p>在传输层封装时，添加的报文首部时要存入一个应用程序的标识符，无论TCP和UDP都用一个16位的端口号来表示不同的应用程序，并且都会将源端口和目的端口存入报文首部中。</p>
<p>在网络层封装时，IP首部会标识处理数据的协议类型，或者说标识出网络层数据帧所携带的上层数据类型，如TCP、UDP、ICMP、IP、IGMP等等。<br>
具体来说，会在IP首部中存入一个长度为8位的数值，称作协议域：<br>
1表示为ICMP协议、2表示为IGMP协议、6表示为TCP协议、17表示为UDP协议、等等。IP首部还会标识发送方地址（源IP）和接收方地址（目标IP）。</p>
<p>在链路层封装时，网络接口分别要发送和接收IP、ARP和RARP等多种不同协议的报文，因此也必须在以太网的帧首部中加入某种形式的标识，以指明所处理的协议类型，为此，以太网的报文帧的首部也有一个16位的类型域，标识出以太网数据帧所携带的上层数据类型，如IPv4、ARP、IPV6、PPPoE等等。</p>
<p>数据封装和分用的过程大致为：发送端每通过一层会增加该层的首部，接收端每通过一层则删除该层的首部。</p>
<p>总体来说，TCP/IP分层管理、数据封装和分用的好处：分层之后若需改变相关设计，只需替换变动的层。各层之间的接口部分规划好之后，每个层次内部的设计就可以自由改动。层次化之后，设计也变得相对简单：各个层只需考虑分派给自己的传输任务。</p>
<p>TCP/IP与OSI的区别主要有哪些呢？除了TCP/IP与OSI在分层模块上稍有区别，更重要的区别为：OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开发哪种程序”。</p>
<p>实际上，在传输过程中，数据报文会在不同的物理网络之间传递，还是以一个HTTP请求的传输为例，请求在不同物理网络之间的传输过程，大致如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210308122843370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图：HTTP请求在不同物理网络之间的传输过程</p>
<p>数据包在不同物理网络之间的传输过程中，网络层会通过路由器去对不同的网络之间的数据包进行存储、分组转发处理。构造互连网最简单的方法是把两个或多个网络通过路由器进行连接。路由器可以简单理解为一种特殊的用于网络互连的硬件盒，其作用是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和FDDI（光纤分布式数据接口）等等。</p>
<p>物理网络之间通过路由器进行互连，随着增加不同类型的物理网络，可能会有很多个路由器，但是对于应用层来说仍然是一样的，TCP协议栈为大家屏蔽了物理层的复杂性。总之，物理细节和差异性的隐藏，使得互联网TCP/IP传输的功能变得非常强大。</p>
<p>接下来，开始为大家介绍与传输性能有密切关系的内容：TCP传输层的三次握手建立连接，四次挥手释放连接。不过在此之前，还得先介绍一下TCP报文协议。</p>
<p>TCP协议的报文格式<br>
在TCP/IP协议栈中，IP协议层只关心如何使数据能够跨越本地网络边界的问题，而不关心数据如何传输。整体TCP/IP协议栈，共同配合一起解决数据如何通过许许多多个点对点通路，顺利传输到达目的地。一个点对点通路被称为一“跳”（hop），通过TCP/IP协议栈，网络成员能够在许多“跳”的基础上建立相互的数据通路。</p>
<p>传输层TCP协议提供了一种面向连接的、可靠的字节流服务，其数据帧格式，大致如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210308122904344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图：传输层TCP协议的数据帧格式</p>
<p>一个传输层TCP协议的数据帧，大致包含以下字段：</p>
<h4><span id="一源端口号">（一）源端口号</span></h4>
<p>源端口号表示报文的发送端口，占16位。源端口和源IP地址组合起来，可以标识报文的发送地址。</p>
<h4><span id="二目的端口号">（二）目的端口号</span></h4>
<p>目的端口号表示报文的接收端口，占16位。目的端口和目的IP地址相结合，可以标识报文的接收地址。</p>
<p>TCP协议是基于IP协议的基础上传输的，TCP报文中的源端口号+源IP，与TCP报文中的目的端口号+目的IP一起，组合起来唯一性的确定一条TCP连接。</p>
<h4><span id="三序号sequence-number">（三）序号（Sequence Number）</span></h4>
<p>TCP传输过程中，在发送端出的字节流中，传输报文中的数据部分的每一个字节都有它的编号。序号（Sequence<br>
Number）占32位，发起方发送数据时，都需要标记序号。</p>
<p>序号（Sequence Number）的语义与SYN控制标志（Control<br>
Bits）的值有关。根据控制标志（Control Bits）中的SYN是否为1，序号（Sequence<br>
Number）表达不同的含义：</p>
<p>（1）当SYN = 1时，当前为连接建立阶段，此时的序号为初始序号ISN((Initial Sequence<br>
Number)，通过算法来随机生成序号；</p>
<p>（2）当SYN = 0时在数据传输正式开始时，第一个报文的序号为 ISN +<br>
1，后面的报文的序号，为前一个报文的SN值+TCP报文的净荷字节数(不包含TCP头)。比如，如果发送端发送的一个TCP帧的净荷为12byte，序号为5，则发送端接着发送的下一个数据包的时候，序号的值应该设置为5+12=17。</p>
<p>在数据传输过程中，TCP协议通过序号（Sequence<br>
Number）对上层提供有序的数据流。发送端可以用序号来跟踪发送的数据量；接收端可以用序号识别出重复接收到的TCP包，从而丢弃重复包；对于乱序的数据包，接收端也可以依靠序号对其进行排序。</p>
<h4><span id="四确认序号acknowledgment-number">（四）确认序号（Acknowledgment Number）</span></h4>
<p>确认序号（Acknowledgment<br>
Number）标识了报文接收端期望接收的字节序列。如果设置了ACK控制位，确认序号的值表示一个准备接收的包的序列码，注意，它所指向的是准备接收的包，也就是下一个期望接收的包的序列码。</p>
<p>举个例子，假设发送端（如Client）发送3个净荷为1000byte、起始SN序号为1的数据包给Server服务端，Server每收到一个包之后，需要回复一个ACK响应确认数据包给Client。ACK响应数据包的ACK<br>
Number值，为每个Client包的为SN+包净荷，既表示Server已经确认收到的字节数，还表示期望接收到的下一个Client发送包的SN序号，具体的ACK值如下图左边的正常传输部分所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210308123045409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图：传输过程的确认序号（Acknowledgment Number）值示例图</p>
<p>在上图的左边部分，Server第1个ACK包的ACK<br>
Number值为1001，是通过Client第1个包的SN+包净荷=1+1000计算得到，表示期望第2个Client包的SN序号为1001；Server第2个ACK包的ACK<br>
Number值为2001，为Client第2个包的SN+包净荷=2001，表示期望第3个Server包的SN为2001，以此类推。</p>
<p>如果发生错误，假设Server在处理Client的第二个发送包异常，Server仍然回复一个ACK<br>
Number值为1001的确认包，则Client的第二个数据包需要重复发送，具体的ACK值如上图右边的正常传输部分所示。</p>
<p>只有控制标志的ACK标志为1时，数据帧中的确认序号ACK<br>
Number才有效。TCP协议规定，连接建立后，所有发送的报文的ACK必须为1，也就是建立连接后，所有报文的确认序号有效。如果是SYN类型的报文，其ACK标志为0，故没有确认序号。</p>
<h4><span id="五头部长度">（五）头部长度</span></h4>
<p>该字段占用4位，用来表示TCP报文首部的长度，单位是4bit位。其值所表示的并不是字节数，而是头部的所含有的32bit的数目（或者倍数），或者4个字节的倍数，所以TCP头部最多可以有60字节（4*15=60）。没有任何选项字段的TCP头部长度为20字节，所以其头部长度为5，可以通过20/4=5计算得到。</p>
<h4><span id="六预留6位">（六）预留6位</span></h4>
<p>头部长度后面预留的字段长度为6位，作为保留字段，暂时没有什么用处。</p>
<h4><span id="七控制标志">（七）控制标志</span></h4>
<p>控制标志（Control<br>
Bits）共6个bit位，具体的标志位为：URG、ACK、PSH、RST、SYN、FIN。6个标志位的说明，如下表所示。</p>
<p>表：TCP报文控制标志（Control Bits）说明</p>
<p><img src="https://img-blog.csdnimg.cn/b156b8b97d084a01b76bd656699da71a.png" alt="img"></p>
<p>在连接建立的三次握手过程中，若只是单个SYN置位，表示的只是建立连接请求。如果SYN和ACK同时置位为1，表示的建立连接之后的响应。</p>
<h4><span id="八窗口大小">（八）窗口大小：</span></h4>
<p>长度为16位，共2个字节。此字段用来进行流量控制。流量控制的单位为字节数，这个值是本端期望一次接收的字节数。</p>
<h4><span id="九校验和">（九）校验和：</span></h4>
<p>长度为16位，共2个字节。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，接收端用于对收到的数据包进行验证。</p>
<h4><span id="十紧急指针">（十）紧急指针：</span></h4>
<p>长度为16位，2个字节。它是一个偏移量，和SN序号值相加表示紧急数据最后一个字节的序号。</p>
<p>以上十项内容是TCP报文首部必须的字段，也称固有字段，长度为20个字节。接下来是TCP报文的可选项和填充部分。</p>
<h4><span id="十一可选项和填充部分">（十一）可选项和填充部分</span></h4>
<p>可选项和填充部分的长度为4n字节（n是整数），该部分是根据需要而增加的选项。如果不足4n字节，要加填充位，使得选项长度为32位（4字节）的整数倍，具体的做法是在这个字段中加入额外的零，以确保TCP头是32位（4字节）的整数倍。</p>
<p>最常见的选项字段是MSS（Maximum Segment<br>
Size最长报文大小），每个连接方通常都在通信的第一个报文段（SYN标志为1的那个段）中指明这个选项字段，表示当前连接方所能接受的最大报文段的长度。</p>
<p>由于可选项和填充部分不是必须的，所以TCP报文首部最小长度为20个字节。</p>
<p>至此，TCP报文首部的字段，就全部介绍完了。TCP报文首部的后面，接着的是数据部分，不过数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据，比如在处理超时的过程中，也会发送不带任何数据的报文段。</p>
<p>总体来说，TCP协议的可靠性，主要通过以下几点来保障：</p>
<p>（1）应用数据分割成TCP认为最适合发送的数据块。这部分是通过MSS（最大数据包长度）选项来控制的，通常这种机制也被称为一种协商机制，MSS规定了TCP传往另一端的最大数据块的长度。值得注意的是，MSS只能出现在SYN报文段中，若一方不接收来自另一方的MSS值，则MSS就定为536字节。一般来讲，MSS值还是越大越好，这样可以提高网络的利用率。</p>
<p>（2）重传机制。设置定时器，等待确认包，如果定时器超时还没有收到确认包，则报文重传。</p>
<p>（3）对首部和数据进行校验。</p>
<p>（4）接收端对收到的数据进行排序，然后交给应用层。</p>
<p>（5）接收端丢弃重复的数据。</p>
<p>（6）TCP还提供流量控制，主要是通过滑动窗口来实现流量控制。</p>
<p>至此TCP协议的数据帧格式介绍完了。接下来开始为大家重点介绍：TCP传输层的三次握手建立连接，四次挥手释放连接。</p>
<h3><span id="tcp的三次握手">TCP的三次握手</span></h3>
<p>TCP连接的建立时，双方需要经过三次握手，而断开连接时，双方需要经过四次分手，那么，其三次握手和四次分手分别做了什么呢？又是如何进行的呢？</p>
<p>通常情况下，建立连接的双方，由一端打开一个监听套接字（ServerSocket）来监听来自请求方的TCP（Socket）连接，当服务器端监听开始时，必须做好准备接受外来的连接，在Java中该操作通过创建一个ServerSocket服务监听套接字实例来完成，此操作会调用底层操作系统（如Linux）的C代码中三个函数socket()、bind()、listen()<br>
来完成。开始监听之后，服务器端就做好接受外来连接的准备，如果监听到建立新连接的请求，会开启一个传输套接字，称之为被动打开（Passive<br>
Open）。</p>
<p>一段简单的服务端监听新连接请求，并且被动打开（Passive<br>
Open）传输套接字的Java示例代码，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务端socket</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环监听等待客户端的连接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//监听到客户端连接，传输套接字被动开启</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启线程进行连接的IO处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ServerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerThread</span>(socket);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端在发起连接建立时，Java代码通过创建Socket实例，调用底层的connect(…)方法，主动打开(Active<br>
Open)Socket连接。套接字监听方在收到请求之后，监听方和发起方（客户端）之间就会建立一条的连接通道，该通道由双方IP和双方端口所唯一确定。</p>
<p>一段简单的客户端连接主动打开(Active Open)的Java示例代码，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和服务器创建连接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入给监听方的输出流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">…..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取监听方的输入流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">…..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="三次握手过程">三次握手过程</span></h4>
<p>TCP连接的建立时，双方需要经过三次握手，具体过程如下：</p>
<p>（1）第一次握手：Client进入SYN_SENT状态，发送一个SYN帧来主动打开传输通道，该帧的SYN标志位被设置为1，同时会带上Client分配好的SN序列号，该SN是根据时间产生的一个随机值，通常情况下每间隔4ms会加1。除此之外，SYN帧还会带一个MSS（最大报文段长度）可选项的值，表示客户端发送出去的最大数据块的长度。</p>
<p>（2）第二次握手：Server端在收到SYN帧之后，会进入SYN_RCVD状态，同时返回SYN+ACK帧给Client，主要目的在于通知Client，Server端已经收到SYN消息，现在需要进行确认。Server端发出的SYN+ACK帧的ACK标志位被设置为1，其确认序号AN（Acknowledgment<br>
Number）值被设置为Client的SN+1；SYN+ACK帧的SYN标志位被设置为1，SN值为Server端生成的SN序号；SYN+ACK帧的MSS（最大报文段长度）表示的是Server端的最大数据块长度。</p>
<p>（3）第三次握手：Client在收到Server的第二次握手SYN+ACK确认帧之后，首先将自己的状态会从SYN_SENT变成ESTABLISHED，表示自己方向的连接通道已经建立成功，Client可以发送数据给Server端了。然后，Client发ACK帧给Server端，该ACK帧的ACK标志位被设置为1，其确认序号AN（Acknowledgment<br>
Number）值被设置为Server端的SN序列号+1。还有一种情况，Client可能会将ACK帧和第一帧要发送的数据，合并到一起发送给Server端。</p>
<p>（4）Server端在收到Client的ACK帧之后，会从SYN_RCVD状态会进入ESTABLISHED状态，至此，Server方向的通道连接建立成功，Server可以发送数据给Client，TCP的全双工连接建立完成。</p>
<h4><span id="三次握手的图解">三次握手的图解</span></h4>
<p>三次握手的交互过程，具体如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210308122934847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图：TCP建立的连接时三次握手示意图</p>
<p>Client和Server完成了三次握手后，双方就进入了数据传输的阶段。数据传输完成后，连接将断开，连接断开的过程需要经历四次挥手。</p>
<h3><span id="tcp的四次挥手">TCP的四次挥手</span></h3>
<p>业务数据通信完成之后，TCP连接开始断开（或者拆接）的过程，在这个过程中连接的每个端的都能独立地、主动的发起，断开的过程TCP协议使用了四路挥手操作。</p>
<h4><span id="四次挥手具体过程">四次挥手具体过程</span></h4>
<p>四次挥手具体过程，具体如下：</p>
<p>（1）第一次挥手：主动断开方（可以是客户端，也可以是服务器端），向对方发送一个FIN结束请求报文，此报文的FIN位被设置为1，并且正确设置Sequence<br>
Number（序列号）和Acknowledgment<br>
Number（确认号）。发送完成后，主动断开方进入FIN_WAIT_1状态，这表示主动断开方没有业务数据要发送给对方，准备关闭SOCKET连接了。</p>
<p>（2）第二次挥手：正常情况下，在收到了主动断开方发送的FIN断开请求报文后，被动断开方会发送一个ACK响应报文，报文的Acknowledgment<br>
Number（确认号）值为断开请求报文的Sequence Number<br>
（序列号）加1，该ACK确认报文的含义是：“我同意你的连接断开请求”。之后，被动断开方就进入了CLOSE-WAIT（关闭等待）状态，TCP协议服务会通知高层的应用进程，对方向本地方向的连接已经关闭，对方已经没有数据要发送了，若本地还要发送数据给对方，对方依然会接受。被动断开方的CLOSE-WAIT（关闭等待）还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>主动断开方在收到了ACK报文后，由FIN_WAIT_1转换成FIN_WAIT_2状态。</p>
<p>（3）第三次挥手：在发送完成ACK报文后，被动断开方还可以继续完成业务数据的发送，待剩余数据发送完成后，或者CLOSE-WAIT（关闭等待）截止后，被动断开方会向主动断开方发送一个FIN+ACK结束响应报文，表示被动断开方的数据都发送完了，然后，被动断开方进入LAST_ACK状态。</p>
<p>（4）第四次挥手：主动断开方收在到FIN+ACK断开响应报文后，还需要进行最后的确认，向被动断开方发送一个ACK确认报文，然后，自己就进入TIME_WAIT状态，等待超时后最终关闭连接。处于TIME_WAIT状态的主动断开方，在等待完成2MSL的时间后，如果期间没有收到其他报文，则证明对方已正常关闭，主动断开方的连接最终关闭。</p>
<p>被动断开方在收到主动断开方的最后的ACK报文以后，最终关闭了连接，自己啥也不管了。</p>
<h4><span id="四次挥手图解">四次挥手图解</span></h4>
<p>四次挥手的全部交互过程，具体如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210308122951816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图：TCP建立的连接时四次挥手的示意图</p>
<p>处于TIME_WAIT状态的主动断开方，在等待完成2MSL的时间后，才真正关闭连接通道，其等待的时间为什么是2MSL呢？</p>
<p>2MSL翻译过来就是两倍的MSL。MSL全称为Maximum Segment<br>
Lifetime，指的是一个TCP报文片段在网络中最大的存活时间，具体来说，2MSL对应于一次消息的来回（一个发送和一个回复）所需的最大时间。如果直到2MSL，主动断开方都没有再一次收到对方的报文（如FIN报文），则可以推断ACK已经被对方成功接收，此时，主动断开方将最终结束自己的TCP连接。所以，TCP的TIME_WAIT状态也称为2MSL等待状态。</p>
<p>有关MSL的具体的时间长度，在RFC1122协议中推荐为2分钟。在SICS（瑞典计算机科学院）开发的一个小型开源的TCP/IP协议栈——LwIP开源协议栈中MSL默认为1分钟。在源自Berkeley的TCP协议栈实现中MSL默认长度为30秒。总体来说，TIME_WAIT（2MSL）等待状态的时间长度，一般维持在1-4分钟之间。</p>
<p>通过三次握手建立连接和四次挥手拆除连接，一次TCP的连接建立及拆除，至少进行7次通信，可见其成本是很高的。</p>
<h3><span id="三次握手-四次挥手的常见面试题">三次握手、四次挥手的常见面试题</span></h3>
<p>有关TCP的连接建立的三次握手及拆除过程的四次挥手的面试问题，是技术面试过程中的出现频率很高的重点和难点问题，常见问题大致如下：</p>
<h4><span id="问题1为什么关闭连接的需要四次挥手而建立连接却只要三次握手呢">问题（1）：为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</span></h4>
<p>关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p>
<p>而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>
<h4><span id="问题2为什么连接建立的时候是三次握手可以改成两次握手吗">问题（2）：为什么连接建立的时候是三次握手，可以改成两次握手吗？</span></h4>
<p>三次握手完成两个重要的功能：一是双方都做好发送数据的准备工作，而且双方都知道对方已准备好；二是双方完成初始SN序列号的协商，双方的SN序列号在握手过程中被发送和确认。</p>
<p>如果把三次握手改成两次握手，可能发生死锁。两次握手的话，缺失了Client的二次确认ACK帧，假想的TCP建立的连接时二次挥手，可以如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210308123012842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图：假想的TCP建立的连接时二次握手的示意图</p>
<p>在假想的TCP建立的连接时二次握手过程中，Client发送Server发送一个SYN请求帧，Server收到后发送了确认应答SYN+ACK帧。按照两次握手的协定，Server认为连接已经成功地建立了，可以开始发送数据帧。这个过程中，如果确认应答SYN+ACK帧在传输中被丢失，Client没有收到，Client将不知道Server是否已准备好，也不知道Server的SN序列号，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，会一直等待Server的SYN+ACK确认应答帧。而Server在发出的数据帧后，一直没有收到对应的ACK确认后就会产生超时，重复发送同样的数据帧。这样就形成了死锁。</p>
<h4><span id="问题3为什么主动断开方在time-wait状态必须等待2msl的时间">问题（3）：为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</span></h4>
<p>原因之一：主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p>
<p>原因之二：防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>
<h4><span id="问题4如果已经建立了连接但是client端突然出现故障了怎么办">问题（4）：如果已经建立了连接，但是Client端突然出现故障了怎么办？</span></h4>
<p>TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/post/tcp%E5%8D%8F%E8%AE%AE/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">集合源码</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '3cdc50fed141dacb5545',
    clientSecret: 'efa362468591880b87d44cbe3e1c41428af53b94',
    repo: 'gitalk',
    owner: 'biyixia',
    admin: ['biyixia'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> biyixia
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="biyixia"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>



    
    

  </div>
</body>

</html>