<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Servlet |  biyixia</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="biyixia" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-servlet"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Servlet
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/post/servlet/" class="article-date">
  <time datetime="2023-07-10T02:51:46.743Z" itemprop="datePublished">2023-07-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/">第二阶段</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">7.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">29 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2><span id="web应用目录结构">web应用目录结构</span></h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">project(Web应用程序根目录)</span><br><span class="line">src</span><br><span class="line">----- main</span><br><span class="line">--------- java</span><br><span class="line">--------- resources</span><br><span class="line">--------- webapp(视图相关文件)</span><br><span class="line">------------- WEB-INF(源代码)</span><br><span class="line">----------------- classes(编译后的Servlet类)</span><br><span class="line">--------------------- XXX.class</span><br><span class="line">--------------------- XXX.class</span><br><span class="line">----------------- lib(web应用程序需要的外部jar包)</span><br><span class="line">--------------------- XXX.jar</span><br><span class="line">--------------------- XXX.jar</span><br><span class="line">----------------- web.xml (Web应用程序配置文件)</span><br><span class="line">------------- JSP，HTML，图片等资源(放在WEB-INF外,用户只要输入资源URL就可以直接访问到)</span><br></pre></td></tr></table></figure>
<p>下图中，Servlet/JSP容器对应于如Tomcat这类程序，里面的三个框框对应于各种Servlet类的实例</p>
<p>当容器收到请求时，则会根据请求的url去调用相应的servlet类的实例的方法去处理响应该请求</p>
<p>注：在一个应用程序中，容器会为每个Servlet类生成一个实例<br>
<img src="https://pic.imgdb.cn/item/64ad17391ddac507ccbbcf38.jpg" style="zoom:67%;"></p>
<h2><span id="servlet结构">Servlet结构</span></h2>
<img src="https://pic.imgdb.cn/item/64acba0c1ddac507cc27c59d.jpg" style="zoom:67%;">
<h3><span id="servlet接口">Servlet接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void init(ServletConfig var1)</td>
<td>初始化在实例化后自动执行，默认首次请求该Servlet时实例化，可配置为服务器启动时实例化（避免首次请求耗时过长），且Servlet使用单例模式，只执行一次实例化、初始化</td>
</tr>
<tr>
<td>void service(ServletRequest v1,ServletResponse v2)</td>
<td>当客户端发送请求访问该Servlet时，服务器就会自动调用该方法处理请求</td>
</tr>
<tr>
<td>void destroy()</td>
<td>服务器关闭或重启时需要清空内存，将会调用该方法销毁Servlet</td>
</tr>
<tr>
<td>ServletConfig getServletConfig()</td>
<td>返回当前Servlet的ServletConfig对象</td>
</tr>
<tr>
<td>String getServletInfo()</td>
<td>返回对当前Servlet的描述</td>
</tr>
</tbody>
</table>
<p>其中init、Service和destroy是生命周期方法</p>
<h3><span id="genericservlet">GenericServlet</span></h3>
<ol>
<li>提供了Servlet接口的默认实现（除了service）</li>
<li>当我们要创建自己的Servlet时只需要继承GenericServlet类，覆盖需要改写的方法即可</li>
</ol>
<h3><span id="httpservlet">HttpServlet</span></h3>
<p><strong>继承并重写了父类GenericServlet中的service方法</strong></p>
<ol>
<li>参数(ServletRequest req, ServletResponse resp) 强制转换为 (HttpServletRequest, HttpServletResponse)</li>
<li>并调用重载的方法：service(HttpServletRequest req, HttpServletResponse  )</li>
</ol>
<p><strong>重载的Service方法</strong></p>
<ol>
<li>获取请求方式，并根据请求方式的不同执行对应的doXXX方法（doGet、doPost、doHead、doPut、doTrace、doOptions、doDelete）</li>
<li>对应的doXXX方法在自定义Servlet中继承重写，用于实际处理请求</li>
</ol>
<h2><span id="request和response结构">Request和Response结构</span></h2>
<img src="https://pic.imgdb.cn/item/64acbbc41ddac507cc2eb6e5.jpg" style="zoom:67%;">
<h3><span id="servletrequest接口">ServletRequest接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getParameter(String var1)</td>
<td>获得客户端传来的参数的，即Parameter是用于客户端和服务端之间的信息传递</td>
</tr>
<tr>
<td>String[] getParameterValues(java.lang.String name)</td>
<td>返回一个包含所有的给定请求参数的值的字符串对象的向量。若该参数不存在，则返回一个空值</td>
</tr>
<tr>
<td>Object getAttribute(String var1)</td>
<td>在服务端获得另一个服务端通过setAttribute传进去的参数</td>
</tr>
<tr>
<td>void setAttribute(String var1, Object var2)</td>
<td>用于服务端之间的信息传递</td>
</tr>
<tr>
<td>void removeAttribute(String var1)</td>
<td>删除服务端中存储的数据</td>
</tr>
<tr>
<td>getRemoteAddr</td>
<td>浏览器的IP地址</td>
</tr>
<tr>
<td>getRemotePort</td>
<td>浏览器端端口号</td>
</tr>
<tr>
<td>getServerName</td>
<td>服务器名称</td>
</tr>
<tr>
<td>getServerPort</td>
<td>服务器端口号</td>
</tr>
<tr>
<td>getScheme</td>
<td>协议名称</td>
</tr>
<tr>
<td>setCharacterEncoding(String var1)</td>
<td>设置字符集编码</td>
</tr>
</tbody>
</table>
<h3><span id="servletresponse接口">ServletResponse接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PrintWriter getWriter()</td>
<td>获取writer（打印流），通过调用writer的print方法向response中写入内容（可识别前端代码html,css,javascript）</td>
</tr>
<tr>
<td>void setContentType(String var1)</td>
<td>设置response的内容类型，一般用于处理响应中的中文乱码现象</td>
</tr>
</tbody>
</table>
<h3><span id="httpservletrequst">HttpServletRequst</span></h3>
<p>实现ServletRequest接口，封装了http请求报文，使得我们可以不用自己去解析http报文</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getMethod()</td>
<td>请求方式</td>
</tr>
<tr>
<td>getRequestURL</td>
<td>请求的完整路径URL</td>
</tr>
<tr>
<td>getRequestURI</td>
<td>请求的相对路径URI</td>
</tr>
</tbody>
</table>
<h3><span id="httpservletresponse">HttpServletResponse</span></h3>
<p>实现ServletResponse接口，封装了响应报文，使得我们不用自己管http协议中的许多细节</p>
<p><strong>响应状态码</strong></p>
<p>表示程序的运行状态</p>
<table>
<thead>
<tr>
<th>响应状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>404</td>
<td>无法通过路径找到资源文件</td>
</tr>
<tr>
<td>500</td>
<td>服务端运行发生了异常</td>
</tr>
<tr>
<td>200</td>
<td>程序运行一切正常</td>
</tr>
</tbody>
</table>
<p><strong>手动发送状态码</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void sendError(int sc)</td>
<td>向客户端发送【sc】状态码响应错误</td>
</tr>
<tr>
<td>void sendError(<em>int</em> var1, String var2)</td>
<td>向客户端发送【var1】状态码、【var2】描述信息响应错误</td>
</tr>
</tbody>
</table>
<h2><span id="cookie和httpsession">Cookie和HttpSession</span></h2>
<h3><span id="cookie">cookie</span></h3>
<p>通过浏览器将键值对数据保存在客户端硬盘上（如商城的购物车、登录的记住密码或免登录）</p>
<p><strong>保存键值对</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.需要实例化cookie对象，需要键值对参数</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(id,name);</span><br><span class="line"><span class="comment">//2.设置cookie数据的有效时间，单位是秒</span></span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>);</span><br><span class="line"><span class="comment">//3.利用响应对象将cookie数据保存在浏览器硬盘中</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p><strong>查看键值对</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过请求对象获取cookie对象数组</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//遍历cookies数组查看每个cookie的键值数据</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookies != <span class="literal">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        System.out.println(cookie.getName());</span><br><span class="line">        System.out.println(cookie.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="httpsession">HttpSession</span></h3>
<p>可存储键值对数据（setAttribute），一般应用于登录功能</p>
<p><img src="https://pic.imgdb.cn/item/64113030ebf10e5d5374df8a.jpg" alt></p>
<ol>
<li>HttpSession对象存储在服务器中（tomcat）</li>
<li>相同客户端、相同浏览器对应一个HttpSession对象</li>
<li>一个HttpSession对象可以存储多个键值对，且在该对象中共享（即同一客户端、同一浏览器范围内共享数据）</li>
</ol>
<p><strong>生命周期</strong></p>
<ul>
<li>HttpSession对象生命周期为整个浏览器运行期间，浏览器运行结束，即浏览器关闭（所有页面关闭），HttpSession对象的生命周期结束</li>
<li>不同品牌的浏览器HttpSession对象生命周期不一样</li>
</ul>
<p><strong>实例化</strong></p>
<p>当浏览器首次使用httpSession的任意方法，服务器会自动的创建一个session对象（先创建该客户端的该浏览器的JSESSIONID并存储到浏览器的Cookies中，浏览器可以通过Cookies携带的SessionID从服务器的HttpSession对象获取键值对数据）</p>
<p>当浏览器中存储SessionID的Cookies丢失（手动删除），此时使用HttpSession任意方法，则服务器自动重新生成Session对象（重新存储JSESSIONID到新的Cookies）</p>
<p>当浏览器禁用Cookies，由于浏览器无法通过Cookies访问服务器中的HttpSession对象，则每次使用HttpSession任意方法，服务器都会重新生成Session对象（此时可通过url找到之前的HttpSession）</p>
<p><strong>客户端浏览器访问HttpSession的方式</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过Cookies携带SessionID</td>
<td>默认使用Cookies</td>
</tr>
<tr>
<td>通过url携带SessionID（<code>url + &quot;;jsessionid=【sessionID】&quot;</code>）</td>
<td>与Cookies同时使用时Cookies传递优先级更高</td>
</tr>
</tbody>
</table>
<p><strong>销毁</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>HttpSession</th>
</tr>
</thead>
<tbody>
<tr>
<td>浏览器关闭或手动删除Cookies</td>
<td>仅cookies销毁，浏览器无法通过之前的SessionID找到HttpSession</td>
<td>存在</td>
</tr>
<tr>
<td><code>httpSession.removeAttribute(K);</code></td>
<td>仅HttpSession中的key删除</td>
<td>存在</td>
</tr>
<tr>
<td><code>httpSession.setMaxInactiveInterval</code></td>
<td>设置过期时间(单位是秒)，HttpSession对象将被GC清除</td>
<td>销毁</td>
</tr>
<tr>
<td>服务器重启或关闭</td>
<td>tomcat重启或关闭</td>
<td>销毁</td>
</tr>
</tbody>
</table>
<p><strong>请求对象request获取HttpSession对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回关于该请求的当前会话。或者若该请求没有会话则就创建一个</span></span><br><span class="line">getSession();</span><br><span class="line"><span class="comment">//返回有关本请求的当前HttpSession，或者若该请求没有会话，且“创建”属性为真，则就创建一个</span></span><br><span class="line">getSession(<span class="type">boolean</span> create);</span><br></pre></td></tr></table></figure>
<h2><span id="其他接口">其他接口</span></h2>
<h3><span id="servletconfig接口">ServletConfig接口</span></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getInitParameter(String var1)</td>
<td>获取该servlet的初始参数。初始参数以键值对的形式在注解中或者在部署描述符web.xml中设置</td>
</tr>
<tr>
<td><em>ServletContext</em> getServletContext();</td>
<td>获得该Servlet的上下文信息，返回一个ServletContext对象</td>
</tr>
<tr>
<td>void setContentType(String type)</td>
<td>处理响应中的中文乱码（代码开始处添加）</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.write(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;title&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;hello!!!!!!!!!!&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/title&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:50px&#x27;&gt;helloWorld!!!!!!!&lt;/div&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<h3><span id="servletcontext接口">ServletContext接口</span></h3>
<p>整个当前的web应用程序的上下文</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getInitParameter(String var1)</td>
<td>相较于ServletConfig是全局范围，所有Servlet都能访问</td>
</tr>
<tr>
<td>Object getAttribute(String var1)</td>
<td>相较于ServletConfig是全局范围，所有Servlet都能访问</td>
</tr>
<tr>
<td>void setAttribute(String var1, Object var2)</td>
<td>相较于ServletConfig是全局范围，所有Servlet都能访问</td>
</tr>
</tbody>
</table>
<h2><span id="servlet配置">Servlet配置</span></h2>
<h3><span id="webxml">web.xml</span></h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>【servlet_name】<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>【servlet_class】<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--修改类实例化时间为服务器启动时,多个类在服务器启动时共同实例化时，数字越小越先实例化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>【servlet_name】<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>【servlet_path】<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3><span id="注解">注解</span></h3>
<p><strong>@WebServlet</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>servlet类的名称，如果没有定义默认使用的是类名，servlet-name标签一致(一般不写)</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>servlet类的请求名称，以/开始，不能重复，可以有多个(必须存在)</td>
</tr>
<tr>
<td>loadOnStartup</td>
<td>服务器启动时实例化该类对象(有选择使用)</td>
</tr>
</tbody>
</table>
<p>当@WebServlet只配置一个请求名称可简化属性名称，@WebServlet(urlPatterns =“/anno”)    ==&gt;     @WebServlet(“/anno”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;【servlet_name】&quot;,urlPatterns =&#123;&quot;/【servlet_path】&quot;,&quot;/【servlet_path】&quot;&#125;,loadOnStartup =1)</span></span><br><span class="line"><span class="keyword">public</span> class 【servlet_class】 <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="欢迎页面">欢迎页面</span></h2>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置欢迎首页，省略第一个页面的路径编写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/a.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/b.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/hello.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2><span id="会话跟踪">会话跟踪</span></h2>
<p>保存键值对参数</p>
<table>
<thead>
<tr>
<th>保存键值对方式</th>
<th>客户端请求</th>
<th>服务端接收</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL重写</td>
<td>加在url地址后面，如<code>url?key1=value1&amp;key2=value2...</code></td>
<td>request.getParameter(key)</td>
</tr>
<tr>
<td>隐藏域</td>
<td>表单中的隐藏域中<code>&lt;input type='hidden' name='id' value='1'/&gt;</code></td>
<td>request.getParameter(“id”)</td>
</tr>
<tr>
<td>Cookie</td>
<td><code>Cookie cookie = new Cookie(String key, String value);</code><br><code>httpServletResponse.addCookie(cookie);</code></td>
<td><code>request.getCookies();</code><br><code>cookie.getValue;</code><br><code>cookie.getName;</code></td>
</tr>
<tr>
<td>Session</td>
<td><code>HttpSession session = request.getSession;</code><br><code>session.setAttribute(name,value);</code></td>
<td><code>HttpSession session = request.getSession;</code><br><code>session.getAttribute(name);</code></td>
</tr>
</tbody>
</table>
<p>s服务端会为每一个客户端在服务端的内存中保存一个HttpSession对象，该对象可以通过HttpServletRequest对象的getSession方法获得（若该客户端在服务端中没有对应的HttpSession对象，则调用该方法会为其创建一个；若该客户端的HttpSession对象已经存在于服务端中了，则该方法会直接返回该对象）。当服务端为该客户端在服务端内存中创建HttpSession对象时，会为该客户端生成给一个独一无二的id，并通过cookie的方式回复给该客户端（该过程无需我们管），则在之后该客户端对服务端的访问中，都会带上这个写有id的cookie，从而使得服务端可以通过该id在服务端的内存中找到与该客户端对应的session对象</p>
<table>
<thead>
<tr>
<th>不同</th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody>
<tr>
<td>键值对存储</td>
<td>客户端，服务端将键值对参数写进cookie后相应给客户端，让客户端保存存有键值对参数的cookie</td>
<td>服务端，服务端将键值对参数写进HttpSession对象中存在自己的内存里</td>
</tr>
<tr>
<td>说明</td>
<td>当服务端需要获取键值对参数时，需要从客户端发来的cookie中获取</td>
<td>当服务端需要获取键值对参数时，只需要从客户端获取其id，就可以从自己的内存中获取到对应的键值对参数</td>
</tr>
</tbody>
</table>
<p>对于在多个页面中跳转并保存键值对参数的情况，前两种方式存取较为复杂，而后两种方法由于将键值对保存在客户端或服务端，可直接通过客户端或服务端获取，且能较持久的保存</p>
<p><strong>当使用Post请求方式且请求参数为中文时会出现乱码现象</strong></p>
<p>请求：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code> 设置字符编码，避免中文乱码现象</p>
<p><strong>响应参数为中文时，响应到客户端页面会出现乱码现象</strong></p>
<p>响应：<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code> 处理响应的中文乱码</p>
<h2><span id="servlet跳转">Servlet跳转</span></h2>
<h3><span id="请求转发">请求转发</span></h3>
<img src="https://pic.imgdb.cn/item/64abcf1d1ddac507cce9ef9e.jpg" style="zoom: 50%;">
<p>服务端在执行servlet执行到这个动作时发生的跳转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取转发器对象,参数：目标的请求名称</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;【参数】&quot;</span>);</span><br><span class="line">requestDispatcher.forward(request,response);</span><br></pre></td></tr></table></figure>
<h3><span id="响应重定向">响应重定向</span></h3>
<img src="https://pic.imgdb.cn/item/64abcf331ddac507ccea4c66.jpg" style="zoom:50%;">
<p>服务端通过HttpServletResponse去回复给客户端一个url，让客户端再去发请求给这个新的url</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数：目标的请求名称</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;【参数】&quot;</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>请求转发</th>
<th>响应重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用方法的对象</td>
<td>HttpServletRequest</td>
<td>HttpServletResponse</td>
</tr>
<tr>
<td>URL</td>
<td>转发前的路径</td>
<td>转发后的路径</td>
</tr>
<tr>
<td>客户端请求参数</td>
<td>转发与被转发的Servlet都能获取，转发前后共用一个Request</td>
<td>仅被转发的Servlet能获取</td>
</tr>
<tr>
<td>转发前存储在request作用域的键值对数据</td>
<td>只有一次请求，转发后的Servlet能获取</td>
<td>多次请求、响应，转发后的Servlet不能获取</td>
</tr>
<tr>
<td>执行顺序</td>
<td>类似方法调用，转发后仍继续执行原Servlet下行代码</td>
<td>执行完当前Servlet再重定向，即访问第二个请求</td>
</tr>
<tr>
<td>转发后的请求方式</td>
<td>转发后执行doPost</td>
<td>转发后执行doGet</td>
</tr>
<tr>
<td>执行效率</td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td>访问范围</td>
<td>服务器内部资源</td>
<td>任意资源路径</td>
</tr>
</tbody>
</table>
<p><strong>当执行对数据增删改操作时，应使用response.sendRedirect()</strong></p>
<p>若使用request.getRequestDispatcher().forward(request,response)，转发前后的URL不发生改变，因此对页面刷新则再次发送转发前的请求，即刷新一次页面后就修改了一条数据的原因</p>
<h2><span id="jsp">JSP</span></h2>
<p>JSP本质上时另一种形式的Servlet类，当jsp页面首次被访问时会被服务器翻译为一个Servlet实现类</p>
<p>当jsp后续被访问时，服务器会检查jsp是否改动，若改动则重新编译，否则按原来的Servlet生命周期执行</p>
<p>jsp本身包含html，也能写java</p>
<p>JSP中的内容由语法元素和模板数据两部分构成。语法元素由如&lt;% %&gt;这种类型的符号包裹。其余的内容都为模板数据。模板数据在转换成servlet时，会全部原封不动的被writer.print到response中，而语法元素部分则会被转为相应的Java代码。</p>
<h3><span id="jsp隐式对象">JSP隐式对象</span></h3>
<p>以下对象可在jsp中直接使用</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>所属类</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>javax.servlet.http.HttpServletRequest</td>
</tr>
<tr>
<td>response</td>
<td>javax.servlet.http.HttpServletResponse</td>
</tr>
<tr>
<td>out</td>
<td>javax.servlet.jsp.JspWriter</td>
</tr>
<tr>
<td>session</td>
<td>javax.servlet.http.HttpSession</td>
</tr>
<tr>
<td>application</td>
<td>javax.servlet.ServletContext</td>
</tr>
<tr>
<td>config</td>
<td>javax.servlet.ServletConfig</td>
</tr>
<tr>
<td>pageContext</td>
<td>javax.servlet.jsp.PageContext</td>
</tr>
</tbody>
</table>
<ol>
<li>out 相当于从HttpServletResponse中获得的PrintWriter对象</li>
<li>pageContext的 getAttribute(String name, int scope)和setAttribute(String name, Object value, int scope)方法可以指定Attribute的作用范围</li>
</ol>
<table>
<thead>
<tr>
<th>scope参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUEST_ SCOPE</td>
<td>HttpServletRequest中的get/setAttribute方法</td>
</tr>
<tr>
<td>SESSION_SCOPE</td>
<td>HttpSession中的get/setAttribute方法</td>
</tr>
<tr>
<td>APPLICATION_SCOPE</td>
<td>ServletContext中的get/setAttribute方法</td>
</tr>
<tr>
<td>PAGE_SCOPE</td>
<td>只是在当前页面有效</td>
</tr>
</tbody>
</table>
<h3><span id="语法元素">语法元素</span></h3>
<hr>
<h4><span id="指令">指令</span></h4>
<p><strong>page</strong></p>
<p>语法格式：<code>&lt;%@ page attr1=&quot;value1&quot; attr2=&quot;value2&quot;...%&gt;</code></p>
<p>示例：</p>
<ol>
<li><code>&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot; language=&quot;java&quot; %&gt;</code> 指定响应字符集编码以及编码语言</li>
<li><code>&lt;%@ page import=&quot;java.util.ArrayList, java.util.Date&quot; errorPage=&quot;errorHandler.jsp&quot;%&gt;</code> 引入了ArrayList和Date包；指定了当前页面的errorPage（当前页面发生异常后会跳转到errorPage且那个跳转重点jsp也要用page指令声明属性isErrorPage=“True”）</li>
</ol>
<hr>
<p><strong>include</strong></p>
<p>语法格式：<code>&lt;%@ include file=&quot;【路径】&quot;%&gt;</code></p>
<p>在jsp被服务器翻译前，该指令会被【路径】所指向文件内容所替换；然后被翻译为一个Servlet实现类（url所指向的文件不会被翻译成Servlet）</p>
<hr>
<h4><span id="脚本">脚本</span></h4>
<table>
<thead>
<tr>
<th>脚本元素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;% ... %&gt;</code></td>
<td>Java代码（局部变量、循环、选择、方法体），被服务器拼接到Servlet的service方法中</td>
</tr>
<tr>
<td><code>&lt;%! ... %&gt;</code></td>
<td>声明方法、成员变量、代码块、内部类，被服务器翻译成Servlet的成员方法、成员变量</td>
</tr>
<tr>
<td><code>&lt;%= ... %&gt;</code></td>
<td>打印流输出到浏览器显示</td>
</tr>
<tr>
<td><code>&lt;%-- ... --%&gt;</code></td>
<td>jsp注释（推荐）</td>
</tr>
<tr>
<td><code>&lt;!-- --&gt;</code></td>
<td>html注释</td>
</tr>
</tbody>
</table>
<h4><span id="动作">动作</span></h4>
<p><strong>include</strong></p>
<p>语法格式：&lt;jsp:include page=“XXX.jsp”/&gt;</p>
<p>在jsp被服务器翻译时，将不同页面分别翻译为对应的Servlet实现类，然后依次运行输出（多个Servlet实现类）</p>
<hr>
<p><strong>forward</strong></p>
<p>语法格式：&lt;jsp:forward page=“XXX.jsp”/&gt;</p>
<p>在jsp被服务器翻译时，该动作会被翻译成一个forward方法，类似于方法调用，当前jsp余下部分在XXX.jsp执行完成后执行</p>
<hr>
<p>目前推荐 在jsp页面中使用 <strong>EL</strong> 、<strong>JSTL</strong> ，替代脚本元素的使用（&lt;% … %&gt;），使得JSP中不包含Java后端代码，使得前后端能更好的解耦</p>
<h2><span id="el表达式">EL表达式</span></h2>
<p>语法：<code>$&#123;表达式&#125;</code></p>
<p>从内存中  <strong>从作用域范围最小开始</strong>  <strong>根据键检索数据</strong> 作为jsp数据（找不到则进入作用域范围更大范围检索)</p>
<p>语法： <code>$&#123;a[b]&#125;</code> 或 <code>$&#123;a.b&#125;</code></p>
<table>
<thead>
<tr>
<th>a的数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>List或者数组</td>
<td>b的数据类型为int，b作为索引取值，本质上调用 <code>$&#123;a.get(b)&#125;</code></td>
</tr>
<tr>
<td>Map</td>
<td>b作为键，返回值，本质上调用 <code>$&#123;a.get(&quot;b&quot;)&#125;</code></td>
</tr>
<tr>
<td>对象</td>
<td>b为对象a的属性，本质上调用 <code>$&#123;a.getB()&#125;</code></td>
</tr>
</tbody>
</table>
<p><strong>EL隐式对象</strong></p>
<p>和JSP隐式对象类似，表达式语言也有隐式对象用于访问request，response这类的对象</p>
<table>
<thead>
<tr>
<th>EL隐式对象</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>applicationScope<br>sessionScope<br>requestScope<br>pageScope</td>
<td>可以获取不同范围的Attribute</td>
<td>${applicationScope.myVar}相当于&lt;%application.getAttribute(“myVar”)%&gt;</td>
</tr>
<tr>
<td>cookie</td>
<td>可以获取当前请求中的所有cookie（用key唯一识别）</td>
<td></td>
</tr>
<tr>
<td>pageContext</td>
<td>可以获取所有JSP隐式对象</td>
<td>${pageContext.request.method}相当于&lt;%request.getMethod()%&gt;</td>
</tr>
<tr>
<td>initParam</td>
<td>可以获取当前ServletContext的初始参数</td>
<td>${initParam.key}相当于&lt;%application.getInitParameter(“key”)%&gt;</td>
</tr>
<tr>
<td>param</td>
<td>可以获取当前请求的参数</td>
<td>${param.key}相当于&lt;%request.getParameter(“key”)%&gt;</td>
</tr>
<tr>
<td>paramValues</td>
<td>与param类似，只不过value都是数组，用于获取值是数组的参数</td>
<td>${paramValues.selectedOptions[0]}表示取出selectedOptions参数的第一个值</td>
</tr>
<tr>
<td>header</td>
<td>Map，可以获取请求的头</td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="jstl">JSTL</span></h2>
<p>JSP标准标签库，JSP Standard Tag Library</p>
<ol>
<li>使用前导入jstl依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在jsp中声明</li>
</ol>
<p><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;	</code></p>
<hr>
<p><strong>set标签</strong></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--在当前request中set一个名字为job的attribute，并将value赋给这个attribute--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;job&quot;</span> scope=<span class="string">&quot;request&quot;</span> value=<span class="string">&quot;$&#123;...&#125;&quot;</span>/&gt;</span><br><span class="line">&lt;%--相当于&lt;%request.setAttribute(<span class="string">&quot;job&quot;</span>, value)%&gt;--%&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--调用address对象的setCity方法将value的值set进去--%&gt;</span><br><span class="line">&lt;c:set target=<span class="string">&quot;$&#123;address&#125;&quot;</span> property=<span class="string">&quot;city&quot;</span> value=<span class="string">&quot;$&#123;...&#125;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>remove标签</strong></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--删除request中job这个attribute--%&gt;</span><br><span class="line">&lt;c:remove <span class="keyword">var</span>=<span class="string">&quot;job&quot;</span> scope=<span class="string">&quot;request&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>if标签</strong></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--如果请求参数中的user为<span class="string">&#x27;usr&#x27;</span>，password为<span class="string">&#x27;psw&#x27;</span>，则中间的JSP片段会被执行，反之被忽略--%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;param.user==&#x27;usr&#x27; &amp;&amp; param.password==&#x27;psw&#x27;&#125;&quot;</span>&gt; </span><br><span class="line">    JSP segment</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--遵循的是ifelse的规则,只执行其中一条语句--%&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 90 &amp;&amp; requestScope.score &lt;= 100&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为优秀!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 80 &amp;&amp; requestScope.score &lt; 90&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为良好!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 70 &amp;&amp; requestScope.score &lt; 80&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为中等!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 60 &amp;&amp; requestScope.score &lt; 70&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为及格!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.score &gt;= 0 &amp;&amp; requestScope.score &lt; 60&#125;&quot;</span>&gt;&lt;%--表示一个条件--%&gt;</span><br><span class="line">        &lt;h2&gt;成绩等级为不及格!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt; &lt;%--上面所有的都不成立，执行此代码--%&gt;</span><br><span class="line">        &lt;h2&gt;分数有误!!!!!&lt;/h2&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>forEach标签</strong></p>
<table>
<thead>
<tr>
<th>标签属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>items</td>
<td>数据源，也就是要遍历的集合容器(EL表达式结合)</td>
</tr>
<tr>
<td>var</td>
<td>自定义一个变量，这个变量自动接收每次循环从集合中获取的一个元素</td>
</tr>
<tr>
<td>varStatus</td>
<td>自定义一个变量，变量用来记录循环的运行</td>
</tr>
<tr>
<td>begin</td>
<td>varStatus属性定义变量初始值</td>
</tr>
<tr>
<td>end</td>
<td>varStatus属性定义变量结束值</td>
</tr>
<tr>
<td>step</td>
<td>varStatus属性定义变量在每次循环后的变化</td>
</tr>
</tbody>
</table>
<p>后四个属性用于自定义控制循环，map集合没有索引值，因此遍历时无法使用后四个属性</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--遍历address.phones。其中varStatus是一个LoopTagStatus类型的对象，它有一个index属性可以获得当前遍历到的索引--%&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;requestScope.userList&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;user&quot;</span>&gt; </span><br><span class="line">    $&#123;user&#125;--------------------</span><br><span class="line">    $&#123;user.uid&#125;===&gt;</span><br><span class="line">    $&#123;user.username&#125;===&gt;</span><br><span class="line">    $&#123;user.password&#125;&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;requestScope.userList&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;user&quot;</span> varStatus=<span class="string">&quot;i&quot;</span> begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;30000&quot;</span> step=<span class="string">&quot;2&quot;</span>&gt;</span><br><span class="line">    $&#123;user&#125;--------------------</span><br><span class="line">    $&#123;user.uid&#125;===&gt;</span><br><span class="line">    $&#123;user.username&#125;===&gt;</span><br><span class="line">    $&#123;user.password&#125;&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>综上，EL更倾向用于访问或者获取某些东西和对它们进行一些算术或逻辑运算，而JSTL则用于完成其余部分。两者共同配合使用来完成对scriplet的替代</p>
<h2><span id="监听器listener">监听器Listener</span></h2>
<p>对监听器接口进行实现并注册，便可以对当前web应用程序的某些行为进行监听</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 实现监听器接口ListenerInterface</span></span><br><span class="line"><span class="comment">//2. 通过注解WebListener进行注册（也可通过web.xml注册）</span></span><br><span class="line"><span class="meta">@WebListener</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerClass</span> <span class="keyword">implements</span> <span class="title class_">ListenerInterface</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> xxx <span class="title function_">methodA</span><span class="params">(...)</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> xxx <span class="title function_">methodB</span><span class="params">(...)</span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>监听器接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServletContextListener</td>
<td>当ServletContext被创建和销毁时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>ServletContextAttributeListener</td>
<td>当ServletContext中的Attributes被添加、删除、修改时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>HttpSessionListener</td>
<td>当HttpSession被创建和销毁时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>HttpSessionAttributeListener</td>
<td>当HttpSession中的Attributes被添加、删除、修改时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>ServletRequestListener</td>
<td>当ServletRequest被创建和销毁时，接口中对应的那个方法会被调用</td>
</tr>
<tr>
<td>ServletRequestAttributeListener</td>
<td>当ServletRequest中的Attributes被添加、删除、修改时，接口中对应的那个方法会被调用</td>
</tr>
</tbody>
</table>
<p>这些接口中的方法都会接收一个xxxEvent类型的对象，通过该对象可以拿到触发当前方法的对象</p>
<p>如ServletContextListener中的方法都会接收一个ServletContextEvent对象，通过该对象的getServletContext方法可以拿到触发该方法的ServletContext</p>
<p>ServletRequestListener中的方法都会接收一个ServletRequestEvent对象，通过该对象的getServletRequest方法可以拿到触发该方法的ServletRequest</p>
<h2><span id="过滤器filter">过滤器Filter</span></h2>
<p>过滤器可以对客户端的请求、响应进行拦截，在其对应Servlet执行serivce方法前做处理</p>
<p><strong>多个过滤器可以形成一个链条，不同配置方式下的过滤器链执行顺序不同</strong></p>
<table>
<thead>
<tr>
<th>web.xml</th>
<th>注解</th>
<th>两种配置都存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>由filter-mapping顺序决定</td>
<td>由类名的字典顺序由小到大决定</td>
<td>先执行所有xml配置，再执行所有注解配置</td>
</tr>
</tbody>
</table>
<p>注意：过滤器链在请求过程 与 响应过程 中的处理顺序相反</p>
<p><img src="https://pic.imgdb.cn/item/64acfdf21ddac507cc4cc398.jpg" alt></p>
<h3><span id="过滤器配置">过滤器配置</span></h3>
<p><strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>XXX.XXX.XXX<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--拦截指定路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--拦截HTTP类型请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>dispatcher</th>
<th>拦截请求类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUEST</td>
<td>拦截HTTP请求</td>
</tr>
<tr>
<td>FORWORD</td>
<td>拦截请求转发方式的请求</td>
</tr>
<tr>
<td>INCLUDE</td>
<td>拦截通过<code>request.getRequestDispatcher(&quot;&quot;).indeclude()</code>以及通过<code>&lt;jsp:include page=&quot;…&quot;&gt;</code>发出的请求</td>
</tr>
<tr>
<td>ERROR</td>
<td>拦截&lt;error - page&gt;发出的请求</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter.destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拦截并处理请求，注意参数为ServletRequest、ServletResponse，而非Servlet的HttpServletRequest、HttpServletResponse</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//1. 执行chain对象中的doFilter方法则继续运行下一个过滤器或目标程序，否则终止运行</span></span><br><span class="line">        <span class="comment">//2. chain对象的doFilter方法将过滤器分为上下两部分，方法之上的代码请求时运行，方法之下的代码响应时运行   </span></span><br><span class="line">        chain.doFilter(request,response);  <span class="comment">//放行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter.init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解配置拦截指定路径</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/testServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain Chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>init(FilterConfig filterConfig)</td>
<td>过滤器初始化，服务器启动时直接实例化过滤器对象，自动调用该方法</td>
</tr>
<tr>
<td>doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)</td>
<td>方法最后必须要调用FilterChain接口的doFilter(request, response)方法，用于将request继续向后传递给链条中的下一个（可能是Filter或者Servlet）进行处理</td>
</tr>
<tr>
<td>destroy()</td>
<td>过滤器销毁的方法,服务器关闭时自动销毁对象，自动调用该方法</td>
</tr>
</tbody>
</table>
<h3><span id="过滤器应用">过滤器应用</span></h3>
<ol>
<li>过滤乱码</li>
<li>限制资源访问</li>
</ol>
<h2><span id="同步与异步">同步与异步</span></h2>
<table>
<thead>
<tr>
<th></th>
<th>同步</th>
<th>异步</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用某方法时</td>
<td>必须得到方法执行结果后才继续执行后续指令，否则一致等待方法执行完成（阻塞）</td>
<td>即使没有得到方法执行结果也能继续执行后续指令（调用完成后一般通过状态、通知和回调来通知调用者）</td>
</tr>
</tbody>
</table>
<h2><span id="异步处理">异步处理</span></h2>
<p>每次有请求进来时，容器会从线程池中为该请求分配一个线程来处理该请求。然而，容器中的线程池能分配的线程数是有上限的。当处理请求的程序（如service或doFilter方法）较耗时时，会导致线程无法短时间内完成并归还池中，线程池将很快耗尽，便无法接受新进来的请求</p>
<p>为了解决这个问题，可以使用异步的Servlet或Filter，使得处理请求的过程不在当前的方法（如service或doFilter方法）中进行，而是只在当前方法中新建一个线程去处理该请求，然后就结束当前方法，使得该条从容器线程池中取出的线程能很快被还回</p>
<p>可以认为只是换了个线程（不使用容器的线程池中的线程）去处理这个请求，其它完全没有区别。当新建的线程结束后，便会发回response给客户端（同非异步的过程）</p>
<p><strong>使用方法</strong></p>
<ol>
<li>
<p>在Servlet或Filter上注解为异步的（也可以通过web.xml部署）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(asyncSupported=true)</span></span><br><span class="line"><span class="meta">@WebFilter(asyncSupported=true)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在如service、doFilter、doGet、doPost这类处理请求的方法中新建线程去处理该请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">asyncContext.start(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(asyncContext));</span><br></pre></td></tr></table></figure>
<ol>
<li>调用ServletRequest的startAsync方法获得一个AsyncContext 的实例。该实例包含了当前的ServletRequest和ServletResponse，可通过getter方法取出</li>
<li>调用AsyncContext实例的start方法并传一个Runnable实例来开启一个新线程去执行Runnable中的run方法</li>
<li>如果run方法中需要用到request，则可以把AsyncContext实例传递过去（也可以使用匿名内部类，就可以直接访问AsyncContext实例了）</li>
<li>在run方法的最后需要调用AsyncContext实例的complete()方法（用以结束当前线程）或者dispatch(String url)方法（用以将请求转发给url指定的servlet并结束当前线程）</li>
</ol>
</li>
</ol>
<h2><span id="异步监听器">异步监听器</span></h2>
<p>AsyncListener接口：当异步操作启动完毕、执行完成、执行出错、执行超时时，接口中对应的那个方法会被调用。接口中的每个方法都会接收一个AsyncEvent对象，可以从中获取到AsyncContex和当执行出错时抛出的异常</p>
<p>异步监听器的注册：在调用AsyncContext对象的start方法前，通过调用AsyncContext对象的addListener(a AsyncListener instance)方法进行注册</p>
<h2><span id="文件上传">文件上传</span></h2>
<h3><span id="前端代码">前端代码</span></h3>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;upload&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;!--显示为一个选择要上传的文件的按钮,multiple属性可选择多个文件上传--&gt;</span><br><span class="line">    Select a file &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;fieldName&quot;</span> multiple=<span class="string">&quot;multiple&quot;</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Upload&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="后端代码">后端代码</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="comment">//为Servlet增加MultipartConfig注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取表单中文件的部分</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">part</span> <span class="operator">=</span> request.getPart(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line">        <span class="comment">//写入硬盘</span></span><br><span class="line">        part.write(<span class="string">&quot;D:\\temp\\1.jpg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="文件下载">文件下载</span></h2>
<ol>
<li>客户端直接访问要下载的文件的url（文件位于web应用程序目录下）</li>
<li>在servlet中将文件放进response中响应到客户端</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//若设置file-type为octet-stream，则浏览器会提示用户进行下载；若设置file-type为pdf或者图片之类的，则浏览器会直接解析显示出来</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;application/pdf&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Temp\\1.pdf&quot;</span>);</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line">    <span class="comment">//将文件通过输入流读取成二进制放进byte数组中</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferedInputStream.available()];</span><br><span class="line">    bufferedInputStream.read(bytes);</span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">    <span class="comment">//将byte数组中的内容通过输出流写进response中</span></span><br><span class="line">    outputStream.write(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/post/servlet/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/post/Linux/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            linux
          
        </div>
      </a>
    
    
      <a href="/post/Spring%20Boot/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Spring Boot</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '3cdc50fed141dacb5545',
    clientSecret: 'efa362468591880b87d44cbe3e1c41428af53b94',
    repo: 'gitalk',
    owner: 'biyixia',
    admin: ['biyixia'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> biyixia
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="biyixia"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>



    
    
<script>
  const password = "momo";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "Please enter password",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "Ok",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "Incorrect password, please try again",
            confirmButtonText: "Ok",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>