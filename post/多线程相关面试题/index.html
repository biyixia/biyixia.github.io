<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>多线程相关面试题 |  biyixia</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="biyixia" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-多线程相关面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  多线程相关面试题
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2024-07-05T15:27:55.676Z" itemprop="datePublished">2024-07-05</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">37.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">139 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1><span id="java多线程相关面试题">Java多线程相关面试题</span></h1>
<h2><span id="1线程的基础知识">1.线程的基础知识</span></h2>
<h3><span id="11-线程和进程的区别">1.1 线程和进程的区别？</span></h3>
<blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p><strong>什么是程序？</strong></p>
<p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</p>
<p><strong>什么是进程？</strong></p>
<p>引入进程是为了有效管理和调度进入计算机系统主存储器运行的程序</p>
<p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p>
<p>一个进程之内可以分为一到多个线程。</p>
<blockquote>
<p>进程特征：</p>
<ul>
<li>动态性：相比于静态的程序，进程是一段程序的执行过程，包括了进程从创建、运行到消亡的过程（生命周期）</li>
<li>独立性：进程是操作系统调度和资源分配的最小单位（系统运行的基本单位），系统在运行时为每个进程分配不同的内存（进程间的内存不共享导致相互数据交换和通信的成本高）</li>
<li>并发性：任何进程都可以同其他进程一起并发执行，现代操作系统大多都支持多进程</li>
<li>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果； 但是执行过程中，程序不能发生改变</li>
</ul>
</blockquote>
<p><strong>什么是线程？</strong></p>
<p>一个线程就是程序内部的一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p>
<p>进程进一步细化为线程，一个进程中至少有一个线程</p>
<p>Java 中，线程是CPU调度和执行的最小单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器</p>
<p><img src="https://pic.imgdb.cn/item/66880a94d9c307b7e9793bae.png" alt></p>
<p>线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源（程序计数器(PC)、虚拟机栈和本地方法栈），但它可与同属一个进程的其它线程共享进程所拥有的全部资源（内存单元）</p>
<p><img src="https://pic.imgdb.cn/item/665193bbd9c307b7e9992370.png" alt></p>
<p><strong>二者对比</strong></p>
<ul>
<li>
<p>进程可能是整个程序或部分程序的动态执行；线程则是程序内部的指令流</p>
<blockquote>
<p>一个程序至少有一个进程，一个进程至少有一个线程；线程依赖于进程而存在</p>
<p>进程中包含了线程，每个线程执行不同的任务</p>
</blockquote>
</li>
<li>
<p>不同的进程使用不同的内存空间；同属于一个进程下的所有线程可以共享内存空间</p>
<blockquote>
<p>进程是系统进行资源调度和分配的的基本单位；线程是任务调度和执行的基本单位</p>
</blockquote>
</li>
<li>
<p>进程在创建或撤销的过程中系统都要为之分配、回收资源；而线程的上下文切换（从一个线程切换到另一个线程）的成本更低</p>
</li>
</ul>
<h3><span id="12-并行和并发有什么区别">1.2 并行和并发有什么区别？</span></h3>
<blockquote>
<p>难易程度：☆</p>
<p>出现频率：☆</p>
</blockquote>
<p>单核CPU</p>
<ul>
<li>
<p>单核CPU下线程实际还是串行执行的</p>
</li>
<li>
<p>操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。</p>
</li>
<li>
<p>总结为一句话就是： 微观串行，宏观并行</p>
</li>
</ul>
<p>一般会将这种线程轮流使用CPU的做法称为并发（concurrent）</p>
<p>两个或以上的事件在同一时间段内发生（在一段时间内有多条CPU指令在一个CPU上快速轮换、交替），宏观上具有多个进程同时执行的效果</p>
<p><img src="https://pic.imgdb.cn/item/66519ca5d9c307b7e9a432d3.png" alt></p>
<p>多核CPU</p>
<p>每个核（core）都可以调度运行线程，这时候线程可以是并行的。</p>
<p>两个或以上的事件在同一时刻发生（在同一时刻有多条CPU指令在多个CPU上同时执行）</p>
<p><img src="https://pic.imgdb.cn/item/66519c89d9c307b7e9a40d34.png" alt></p>
<p><strong>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</strong></p>
<p><strong>并行（parallel）是同一时间动手做（doing）多件事情的能力</strong></p>
<h3><span id="13-创建线程的四种方式">1.3 创建线程的四种方式</span></h3>
<blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程</p>
<p>详细创建方式参考下面代码：</p>
<p>① <strong>继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="comment">//重写Thread类的run()---&gt;将此线程要执行的操作声明在run()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的子类对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② <strong>实现runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个类去实现Runnable接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="comment">//实现类去重写run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建实现类的对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将此对象作为参数传递到Thread类中的构造器中,创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ <strong>实现Callable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创接一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">	<span class="comment">// 2.实现call方法,将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyCallable...call...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将此对象作为传递到FutureTask构造器中,创建FutureTask的对象</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(mc) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.将FutureTask的对象传递到Thread的构造器中,创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用futureTask的get方法获取执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④ <strong>线程池创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个类实现Runable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnalbe</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现类中重写run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个类实现Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现类中重写call()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//3.提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.<span class="keyword">new</span> <span class="title class_">FixedThreadPool</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//设置线程的属性</span></span><br><span class="line">        service.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line">        <span class="comment">//4.创建实现类的对象</span></span><br><span class="line">        <span class="type">NumberThread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberThread1</span>();</span><br><span class="line">        <span class="comment">//5.执行指定的线程操作</span></span><br><span class="line">        service.execute(thread1);<span class="comment">//适合用与Runnalbe</span></span><br><span class="line">        <span class="comment">//6.关闭线程</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());<span class="comment">//适合用于Callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="14-runnable-和-callable-有什么区别">1.4 runnable 和 callable 有什么区别</span></h3>
<blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<ol>
<li>Runnable 接口run方法没有返回值；Callable接口call方法有返回值且能通过泛型指定，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li>
<li>Callable接口的call()方法允许抛出异常（checked Exception）；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
<li>Callable适用于对某个任务的计算结果进行处理，或者需要进行网络或IO操作等。常常使用Callable来实现异步任务的处理，以提高系统的吞吐量和响应速度； Runnable适用于简单的打印输出或者修改一些共享的变量</li>
</ol>
<h3><span id="15-线程的-run和-start有什么区别">1.5 线程的 run()和 start()有什么区别？</span></h3>
<blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<ul>
<li>start()方法用于启动响应的线程，通过该线程调用run方法执行run方法中所定义的逻辑代码；而run()方法封装了要被线程执行的代码</li>
<li>start()方法启动后无法重复调用，否则会报IllegalStateException异常；而run()方法可以重复调用</li>
</ul>
<h3><span id="16-线程包括哪些状态状态之间是如何变化的">1.6 线程包括哪些状态，状态之间是如何变化的</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程的状态可以参考JDK中的Thread类中的枚举State</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尚未启动的线程的线程状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自		 * 操作系统的其他资源，例如处理器。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法或在调          * 用Object.wait后重新进入同步块/方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：</span></span><br><span class="line"><span class="comment">		* Object.wait没有超时</span></span><br><span class="line"><span class="comment">         * 没有超时的Thread.join</span></span><br><span class="line"><span class="comment">         * LockSupport.park</span></span><br><span class="line"><span class="comment">         * 处于等待状态的线程正在等待另一个线程执行特定操作。</span></span><br><span class="line"><span class="comment">         * 例如，一个对对象调用Object.wait()的线程正在等待另一个线程对该对象调用Object.notify()			* 或Object.notifyAll() 。已调用Thread.join()的线程正在等待指定线程终止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定          * 时等待状态：</span></span><br><span class="line"><span class="comment">		* Thread.sleep</span></span><br><span class="line"><span class="comment">		* Object.wait超时</span></span><br><span class="line"><span class="comment">		* Thread.join超时</span></span><br><span class="line"><span class="comment">		* LockSupport.parkNanos</span></span><br><span class="line"><span class="comment">		* LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 已终止线程的线程状态。线程已完成执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>状态之间是如何变化的</p>
<p><img src="https://pic.imgdb.cn/item/66880b50d9c307b7e97ae109.png" alt></p>
<p>分别是</p>
<ul>
<li>新建
<ul>
<li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li>
<li>此时未与操作系统底层线程关联</li>
</ul>
</li>
<li>可运行
<ul>
<li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li>
<li>此时与底层线程关联，由操作系统调度执行</li>
</ul>
</li>
<li>终结
<ul>
<li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li>
<li>此时会取消与底层线程关联</li>
</ul>
</li>
<li>阻塞
<ul>
<li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li>
<li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li>
</ul>
</li>
<li>等待
<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
<li>有时限等待
<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li>
<li>执行join()方法，或者发出了I/O请求；join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态</li>
</ul>
</li>
</ul>
<h3><span id="17-新建-t1-t2-t3-三个线程如何保证它们按顺序执行">1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</span></h3>
<blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>代码举例：</p>
<p>为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();                          <span class="comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();                              <span class="comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="18-notify和-notifyall有什么区别">1.8 notify()和 notifyAll()有什么区别？</span></h3>
<blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>notifyAll：唤醒所有wait的线程</p>
<p>notify：只随机唤醒一个 wait 线程（随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hold lock&quot;</span>);</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="19-在-java-中-wait-和-sleep-方法的不同">1.9 在 java 中 wait 和 sleep 方法的不同？</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>共同点</p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
<li>都可以响应<strong>interrupt</strong>中断，也就是说在线程调用方法进入休眠状态后，如果收到中断信号，都可以进行响应并中断，且都可以抛出InterruptException 异常</li>
</ul>
<p>不同点</p>
<ul>
<li>
<p>方法归属不同</p>
<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li>
<p>醒来时机不同</p>
<ul>
<li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li>
<p>锁特性不同（重点）</p>
<ul>
<li>
<p>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</p>
<blockquote>
<p>为什么 wait() 要放在同步代码块中？</p>
<p>同步方法就是在方法前加关键字 synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待；防止在 cpu 切换线程的时候，其它线程先执行了notify() ，后执行 wait() ，线程永远无法被唤醒， 所以要将wait() 放在同步代码块。</p>
</blockquote>
</li>
<li>
<p>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</p>
</li>
<li>
<p>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</p>
</li>
</ul>
<blockquote>
<p>wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行</p>
</blockquote>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitSleepCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sleeping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">illegalWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        LOCK.wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">waiting</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">                    LOCK.wait(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;sleeping...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="110-如何停止一个正在运行的线程">1.10 如何停止一个正在运行的线程？</span></h3>
<blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止（不推荐，方法已作废）</li>
<li>使用interrupt方法中断线程</li>
</ul>
<p>代码参考如下：</p>
<p>① <strong>使用退出标志，使线程正常退出</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt1</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠6秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改标记为true</span></span><br><span class="line">        t1.flag = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② <strong>使用stop方法强行终止</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt2</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠2秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用stop方法</span></span><br><span class="line">        t1.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ <strong>使用interrupt方法中断线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.打断阻塞的线程</span></span><br><span class="line">        <span class="comment">/*Thread t1 = new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;t1 正在运行...&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t1&quot;);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        Thread.sleep(500);</span></span><br><span class="line"><span class="comment">        t1.interrupt();</span></span><br><span class="line"><span class="comment">        System.out.println(t1.isInterrupted());*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打断正常的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">                <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打断状态：&quot;</span>+interrupted);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//        t2.interrupt();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2线程中并发锁">2.线程中并发锁</span></h2>
<h3><span id="21-讲一下synchronized关键字的底层原理">2.1 讲一下synchronized关键字的底层原理？</span></h3>
<blockquote>
<p>难易程度：☆☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4><span id="211-基本使用">2.1.1 基本使用</span></h4>
<p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p>
<p>如下抢票的代码，如果不加锁，就会出现超卖或者一张票卖给多个人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到一张票,剩余:&quot;</span> + ticketNum);</span><br><span class="line">            <span class="comment">// 非原子性操作</span></span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketDemo</span> <span class="variable">ticketDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                ticketDemo.getTicket();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="212-monitor">2.1.2 Monitor</span></h4>
<p>Monitor 被翻译为监视器，是由jvm提供，c++语言实现</p>
<p>在代码中想要体现monitor需要借助javap命令查看clsss的字节码，比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到这个类的class文件，在class文件目录下执行<code>javap -v SyncTest.class</code>，反编译效果如下：</p>
<img src="https://pic.imgdb.cn/item/66880b87d9c307b7e97b5e12.png" style="zoom:50%;">
<blockquote>
<ul>
<li>monitorenter    上锁开始的地方</li>
<li>monitorexit        解锁的地方</li>
<li>其中被monitorenter和monitorexit包围住的指令就是上锁的代码</li>
<li>有两个monitorexit的原因，第二个monitorexit是为了防止锁住的代码抛异常后不能及时释放锁</li>
</ul>
</blockquote>
<p>在使用了synchornized代码块时需要指定一个对象，所以synchornized也被称为对象锁</p>
<p>monitor主要就是跟这个对象产生关联，如下图</p>
<p><img src="https://pic.imgdb.cn/item/66880bb1d9c307b7e97bb412.png" alt></p>
<p>Monitor内部具体的存储结构：</p>
<ul>
<li>
<p>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</p>
</li>
<li>
<p>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</p>
</li>
<li>
<p>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</p>
</li>
</ul>
<p>具体的流程：</p>
<ul>
<li>代码进入synchorized代码块，先让lock（对象锁）关联的monitor，然后判断Owner是否有线程持有</li>
<li>如果没有线程持有，则让当前线程持有，表示该线程获取锁成功</li>
<li>如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去竞争锁的持有权（非公平）</li>
<li>如果代码块中调用了wait()方法，则会进去WaitSet中进行等待</li>
</ul>
<p>参考回答：</p>
<ul>
<li>
<p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</p>
</li>
<li>
<p>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</p>
</li>
<li>
<p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p>
</li>
<li>
<p>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</p>
</li>
</ul>
<h3><span id="22-synchronized关键字的底层原理-进阶">2.2 synchronized关键字的底层原理-进阶</span></h3>
<p>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</p>
<ul>
<li>
<p>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
</li>
<li>
<p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p>
</li>
</ul>
<h4><span id="221-对象的内存结构">2.2.1 对象的内存结构</span></h4>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充</p>
<p><img src="https://pic.imgdb.cn/item/66880bced9c307b7e97bf61b.png" alt></p>
<p>我们需要重点分析MarkWord对象头</p>
<h4><span id="222-markword">2.2.2 MarkWord</span></h4>
<p><img src="https://pic.imgdb.cn/item/66880bf2d9c307b7e97c40e7.png" alt></p>
<blockquote>
<ul>
<li>
<p>hashcode：25位的对象标识Hash码</p>
</li>
<li>
<p>age：对象分代年龄占4位</p>
</li>
<li>
<p>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</p>
</li>
<li>
<p>thread：持有偏向锁的线程ID，占23位</p>
</li>
<li>
<p>epoch：偏向时间戳，占2位</p>
</li>
<li>
<p>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</p>
</li>
<li>
<p>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</p>
</li>
</ul>
</blockquote>
<p>我们可以通过lock的标识，来判断是哪一种锁的等级</p>
<ul>
<li>后三位是001表示无锁</li>
<li>后三位是101表示偏向锁</li>
<li>后两位是00表示轻量级锁</li>
<li>后两位是10表示重量级锁</li>
</ul>
<h4><span id="223-再说monitor重量级锁">2.2.3 再说Monitor重量级锁</span></h4>
<p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，<strong>该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</strong></p>
<p><img src="https://pic.imgdb.cn/item/66880c19d9c307b7e97c93a9.png" alt></p>
<p>简单说就是：每个对象的对象头都可以设置monoitor的指针，让对象与monitor产生关联</p>
<h4><span id="224-轻量级锁">2.2.4 轻量级锁</span></h4>
<p>在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>加锁的流程</strong></p>
<p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p>
<p><img src="https://pic.imgdb.cn/item/66880c34d9c307b7e97cc8f7.png" alt></p>
<p>2.通过CAS指令将Lock Record的地址存储在对象头的mark word中（数据进行交换），如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p>
<p><img src="https://pic.imgdb.cn/item/66880c4ad9c307b7e97cf908.png" alt></p>
<p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。</p>
<p><img src="https://pic.imgdb.cn/item/66880c66d9c307b7e97d34f9.png" alt></p>
<p>4.如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p>
<p><strong>解锁过程</strong></p>
<p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p>
<p>2.如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p>
<p><img src="https://pic.imgdb.cn/item/66880c7fd9c307b7e97d67cb.png" alt></p>
<p>3.如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</p>
<p><img src="https://pic.imgdb.cn/item/66880c96d9c307b7e97d9975.png" alt></p>
<h4><span id="225-偏向锁">2.2.5 偏向锁</span></h4>
<p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现</p>
<p>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>加锁的流程</strong></p>
<p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p>
<p><img src="https://pic.imgdb.cn/item/66880cb3d9c307b7e97dd587.png" alt></p>
<p>2.通过CAS指令将Lock Record的<strong>线程id</strong>存储在对象头的mark word中，同时也设置偏向锁的标识为101，如果对象处于无锁状态则修改成功，代表该线程获得了偏向锁。</p>
<p><img src="https://pic.imgdb.cn/item/66880cd0d9c307b7e97e0ebb.png" alt></p>
<p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。与轻量级锁不同的时，这里不会再次进行cas操作，只是判断对象头中的线程id是否是自己，因为缺少了cas操作，性能相对轻量级锁更好一些</p>
<p><img src="https://pic.imgdb.cn/item/66880ce9d9c307b7e97e4398.png" alt></p>
<p>解锁流程参考轻量级锁</p>
<h4><span id="226-参考回答">2.2.6 参考回答</span></h4>
<p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody>
</table>
<p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p>
<h3><span id="23你谈谈-jmmjava-内存模型">2.3你谈谈 JMM（Java 内存模型）</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。</p>
<p>Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p>
<p><img src="https://pic.imgdb.cn/item/66880cfbd9c307b7e97e6a5f.png" alt></p>
<p>特点：</p>
<ol>
<li>
<p>所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
</li>
<li>
<p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>
</li>
<li>
<p>线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。</p>
</li>
</ol>
<h3><span id="24-cas-你知道吗">2.4 CAS 你知道吗？</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<h4><span id="241-概述及基本工作流程">2.4.1 概述及基本工作流程</span></h4>
<p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</p>
<p>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p>
<ul>
<li>
<p>AbstractQueuedSynchronizer（AQS框架）</p>
</li>
<li>
<p>AtomicXXX类</p>
</li>
</ul>
<p>例子：</p>
<p>我们还是基于刚才学习过的JMM内存模型进行说明</p>
<ul>
<li>线程1与线程2都从主内存中获取变量int a = 100,同时放到各个线程的工作内存中</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66880d1dd9c307b7e97eaef3.png" alt></p>
<blockquote>
<p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</p>
</blockquote>
<ul>
<li>线程1操作：V：int a = 100，A：int a = 100，B：修改后的值：int a = 101 (a++)
<ul>
<li>线程1拿A的值与主内存V的值进行比较，判断是否相等</li>
<li>如果相等，则把B的值101更新到主内存中</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66880d31d9c307b7e97eda8e.png" alt></p>
<ul>
<li>线程2操作：V：int a = 100，A：int a = 100，B：修改后的值：int a = 99(a–)
<ul>
<li>线程2拿A的值与主内存V的值进行比较，判断是否相等(目前不相等，因为线程1已更新V的值99)</li>
<li>不相等，则线程2更新失败</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66880d4ad9c307b7e97f13ba.png" alt></p>
<ul>
<li>
<p>自旋锁操作</p>
<ul>
<li>
<p>因为没有加锁，所以线程不会陷入阻塞，效率较高</p>
</li>
<li>
<p>如果竞争激烈，重试频繁发生，效率会受影响</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66880d5bd9c307b7e97f370c.png" alt></p>
<p>需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功</p>
<h4><span id="242-cas-底层实现">2.4.2 CAS 底层实现</span></h4>
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p>
<p><img src="https://pic.imgdb.cn/item/66880db7d9c307b7e97ff066.png" alt></p>
<p>都是native修饰的方法，由系统提供的接口执行，并非java代码实现，一般的思路也都是自旋锁实现</p>
<img src="https://pic.imgdb.cn/item/66880d71d9c307b7e97f60ad.png" style="zoom:50%;">
<p>在java中比较常见使用有很多，比如ReentrantLock和Atomic开头的线程安全类，都调用了Unsafe中的方法</p>
<ul>
<li>ReentrantLock中的一段CAS代码</li>
</ul>
<img src="https://pic.imgdb.cn/item/66880d85d9c307b7e97f87d7.png" style="zoom:50%;">
<h4><span id="243-乐观锁和悲观锁">2.4.3 乐观锁和悲观锁</span></h4>
<ul>
<li>
<p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p>
</li>
<li>
<p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
</li>
</ul>
<h3><span id="25-请谈谈你对-volatile-的理解">2.5 请谈谈你对 volatile 的理解</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<h4><span id="251-保证线程间的可见性">2.5.1 保证线程间的可见性</span></h4>
<p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
<p>一个典型的例子：永不停止的循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可见性例子</span></span><br><span class="line"><span class="comment">// -Xint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeverLoop</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;modify stop to true...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;stopped... c:&quot;</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行上述代码的时候，发现foo()方法中的循环是结束不了的，也就说读取不到共享变量的值结束循环。</p>
<p>主要是因为在JVM虚拟机中有一个JIT（即时编辑器）给代码做了优化。</p>
<blockquote>
<p>上述代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>在很短的时间内，这个代码执行的次数太多了，当达到了一个阈值，JIT就会优化此代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>当把代码优化成这样子以后，及时<code>stop</code>变量改变为了<code>false</code>也依然停止不了循环</p>
</blockquote>
<p>解决方案：</p>
<p>第一：</p>
<p>在程序运行的时候加入vm参数<code>-Xint</code>表示禁用即时编辑器，不推荐，得不偿失（其他程序还要使用）</p>
<p>第二：</p>
<p>在修饰<code>stop</code>变量的时候加上<code>volatile</code>,表示当前代码禁用了即时编辑器，问题就可以解决，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h4><span id="252-禁止进行指令重排序">2.5.2 禁止进行指令重排序</span></h4>
<p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
<img src="https://pic.imgdb.cn/item/66880d9ad9c307b7e97fb4d6.png" style="zoom:50%;">
<p>在去获取上面的结果的时候，有可能会出现4种情况</p>
<p>情况一：先执行actor2获取结果—&gt;0,0(正常)</p>
<p>情况二：先执行actor1中的第一行代码，然后执行actor2获取结果—&gt;0,1(正常)</p>
<p>情况三：先执行actor1中所有代码，然后执行actor2获取结果—&gt;1,1(正常)</p>
<p>情况四：先执行actor1中第二行代码，然后执行actor2获取结果—&gt;1,0(发生了指令重排序，影响结果)</p>
<p><strong>解决方案</strong></p>
<p>在变量上添加volatile，禁止指令重排序，则可以解决问题</p>
<img src="https://pic.imgdb.cn/item/66880dd1d9c307b7e9802c0f.png" style="zoom:50%;">
<p>屏障添加的示意图</p>
<img src="https://pic.imgdb.cn/item/66880df0d9c307b7e98068a9.png" style="zoom:50%;">
<ul>
<li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li>
<li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li>
</ul>
<p><strong>其他补充</strong></p>
<p>我们上面的解决方案是把volatile加在了int y这个变量上，我们能不能把它加在int x这个变量上呢？</p>
<p>下面代码使用volatile修饰了x变量</p>
<img src="https://pic.imgdb.cn/item/66880e02d9c307b7e9808c0c.png" style="zoom:50%;">
<p>屏障添加的示意图</p>
<img src="https://pic.imgdb.cn/item/66880e1ad9c307b7e980c28c.png" style="zoom:50%;">
<p>这样显然是不行的，主要是因为下面两个原则：</p>
<ul>
<li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li>
<li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li>
</ul>
<p>所以，现在我们就可以总结一个volatile使用的小妙招：</p>
<ul>
<li>写变量让volatile修饰的变量的在代码最后位置</li>
<li>读变量让volatile修饰的变量的在代码最开始位置</li>
</ul>
<h3><span id="26-什么是aqs">2.6 什么是AQS？</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4><span id="261-概述">2.6.1 概述</span></h4>
<p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p>
<p>AQS与Synchronized的区别</p>
<table>
<thead>
<tr>
<th><strong>synchronized</strong></th>
<th><strong>AQS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>关键字，c++ 语言实现</td>
<td>java  语言实现</td>
</tr>
<tr>
<td>悲观锁，自动释放锁</td>
<td>悲观锁，手动开启和关闭</td>
</tr>
<tr>
<td>锁竞争激烈都是重量级锁，性能差</td>
<td>锁竞争激烈的情况下，提供了多种解决方案</td>
</tr>
</tbody>
</table>
<p>AQS常见的实现类</p>
<ul>
<li>
<p>ReentrantLock      阻塞式锁</p>
</li>
<li>
<p>Semaphore        信号量</p>
</li>
<li>
<p>CountDownLatch   倒计时锁</p>
</li>
</ul>
<h4><span id="262-工作机制">2.6.2 工作机制</span></h4>
<ul>
<li>在AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66880e2fd9c307b7e980f352.png" alt></p>
<blockquote>
<ul>
<li>线程0来了以后，去尝试修改state属性，如果发现state属性是0，就修改state状态为1，表示线程0抢锁成功</li>
<li>线程1和线程2也会先尝试修改state属性，发现state的值已经是1了，有其他线程持有锁，它们都会到FIFO队列中进行等待，</li>
<li>FIFO是一个双向队列，head属性表示头结点，tail表示尾结点</li>
</ul>
</blockquote>
<p><strong>如果多个线程共同去抢这个资源是如何保证原子性的呢？</strong></p>
<p><img src="https://pic.imgdb.cn/item/66880e3fd9c307b7e9811639.png" alt></p>
<p>在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待</p>
<p><strong>AQS是公平锁吗，还是非公平锁？</strong></p>
<ul>
<li>
<p>新的线程与队列中的线程共同来抢资源，是非公平锁</p>
</li>
<li>
<p>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</p>
</li>
</ul>
<blockquote>
<p>比较典型的AQS实现类ReentrantLock，它默认就是非公平锁，新的线程与队列中的线程共同来抢资源</p>
</blockquote>
<h3><span id="25-reentrantlock的实现原理">2.5 ReentrantLock的实现原理</span></h3>
<blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4><span id="251-概述">2.5.1 概述</span></h4>
<p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li>
<p>可中断</p>
</li>
<li>
<p>可以设置超时时间</p>
</li>
<li>
<p>可以设置公平锁</p>
</li>
<li>
<p>支持多个条件变量</p>
</li>
<li>
<p>与synchronized一样，都支持重入</p>
</li>
</ul>
<p>1</p>
<h4><span id="252-实现原理">2.5.2 实现原理</span></h4>
<p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p>
<p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
<p>查看ReentrantLock源码中的构造方法：</p>
<img src="https://pic.imgdb.cn/item/66880e5cd9c307b7e9815a3c.png" style="zoom:50%;">
<p>提供了两个构造方法，不带参数的默认为非公平</p>
<p>如果使用带参数的构造函数，并且传的值为true，则是公平锁</p>
<p>其中NonfairSync和FairSync这两个类父类都是Sync</p>
<p><img src="https://pic.imgdb.cn/item/66880e6ed9c307b7e98181db.png" alt></p>
<p>而Sync的父类是AQS，所以可以得出ReentrantLock底层主要实现就是基于AQS来实现的</p>
<img src="https://pic.imgdb.cn/item/66880e78d9c307b7e9819b09.png" style="zoom:50%;">
<p><strong>工作流程</strong></p>
<p><img src="https://pic.imgdb.cn/item/66880e88d9c307b7e981c21c.png" alt></p>
<ul>
<li>
<p>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</p>
</li>
<li>
<p>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</p>
</li>
<li>
<p>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</p>
</li>
<li>
<p>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</p>
</li>
</ul>
<h3><span id="26-synchronized和lock有什么区别">2.6 synchronized和Lock有什么区别 ?</span></h3>
<blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>参考回答</p>
<ul>
<li>语法层面
<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li>
<li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li>
</ul>
</li>
<li>功能层面
<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
</li>
<li>性能层面
<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<h3><span id="27-死锁产生的条件是什么">2.7 死锁产生的条件是什么？</span></h3>
<blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<blockquote>
<p>例如：</p>
<p>t1 线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2 线程获得B对象锁，接下来想获取A对象的锁</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deadlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果</p>
<img src="https://pic.imgdb.cn/item/66880ea3d9c307b7e9820450.png" style="zoom:50%;">
<p>此时程序并没有结束，这种现象就是死锁现象…线程t1持有A的锁等待获取B锁，线程t2持有B的锁等待获取A的锁。</p>
<h3><span id="28-如何进行死锁诊断">2.8 如何进行死锁诊断？</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p>
<p>步骤如下：</p>
<p>第一：查看运行的线程</p>
<img src="https://pic.imgdb.cn/item/66880eb2d9c307b7e9821e88.png" style="zoom:50%;">
<p>第二：使用jstack查看线程运行的情况，下图是截图的关键信息</p>
<p>运行命令：<code>jstack -l 46032</code></p>
<p><img src="https://pic.imgdb.cn/item/66880ec3d9c307b7e98240d6.png" alt></p>
<p><strong>其他解决工具，可视化工具</strong></p>
<ul>
<li>jconsole</li>
</ul>
<p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p>
<ul>
<li>VisualVM：故障处理工具</li>
</ul>
<p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>
<h3><span id="210-concurrenthashmap">2.10  ConcurrentHashMap</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>ConcurrentHashMap 是一种线程安全的高效Map集合</p>
<p>底层数据结构：</p>
<ul>
<li>
<p>JDK1.7底层采用分段的数组+链表实现</p>
</li>
<li>
<p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</p>
</li>
</ul>
<h4><span id="1-jdk17中concurrenthashmap">（1） JDK1.7中concurrentHashMap</span></h4>
<p>数据结构</p>
<p><img src="https://pic.imgdb.cn/item/66880edbd9c307b7e9827579.png" alt></p>
<blockquote>
<ul>
<li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是16，一旦初始化之后中间不可扩容</li>
<li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li>
<li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li>
</ul>
</blockquote>
<p>存储流程</p>
<p><img src="https://pic.imgdb.cn/item/66880eecd9c307b7e98296d0.png" alt></p>
<ul>
<li>先去计算key的hash值，然后确定segment数组下标</li>
<li>再通过hash值确定hashEntry数组中的下标存储数据</li>
<li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li>
</ul>
<h4><span id="2-jdk18中concurrenthashmap">（2） JDK1.8中concurrentHashMap</span></h4>
<p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表</p>
<p>采用 CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li>
<p>CAS控制数组节点的添加</p>
</li>
<li>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66880efcd9c307b7e982b936.png" alt></p>
<h3><span id="211-导致并发程序出现问题的根本原因是什么">2.11 导致并发程序出现问题的根本原因是什么</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>Java并发编程三大特性</p>
<ul>
<li>
<p>原子性</p>
</li>
<li>
<p>可见性</p>
</li>
<li>
<p>有序性</p>
</li>
</ul>
<h4><span id="1原子性">（1）原子性</span></h4>
<p>线程中的一个或多个操作在执行过程中不被其他线程干扰，要么全部执行成功，要么全部执行失败（其中不可暂停，也不可中断）</p>
<blockquote>
<p>比如，如下代码能保证原子性吗？</p>
<img src="https://pic.imgdb.cn/item/66880f0bd9c307b7e982d830.png" style="zoom:50%;">
<p>以上代码会出现超卖或者是一张票卖给同一个人，执行并不是原子性的</p>
<p>解决方案：</p>
<p>1.synchronized：同步加锁</p>
<p>2.JUC里面的lock：加锁</p>
<img src="https://pic.imgdb.cn/item/66880f57d9c307b7e9837028.png" style="zoom:50%;">
</blockquote>
<h4><span id="2内存可见性">（2）内存可见性</span></h4>
<p>让一个线程对共享变量的修改对另一个线程可见</p>
<blockquote>
<p>比如，以下代码不能保证内存可见性</p>
<img src="https://pic.imgdb.cn/item/66880f69d9c307b7e983906c.png" style="zoom:50%;">
<p>解决方案：</p>
<ul>
<li>
<p>synchronized</p>
</li>
<li>
<p>volatile（推荐）</p>
</li>
<li>
<p>LOCK</p>
</li>
</ul>
</blockquote>
<h4><span id="3有序性">（3）有序性</span></h4>
<p>指令重排：处理器为了提高程序运行效率（编译器优化、处理器乱序执行、缓存等因素），可能导致代码的实际执行顺序与编写顺序不同</p>
<p>在单线程程序中不会改变程序最终执行结果；但在多线程环境中可能会导致最终执行结果不理想</p>
<blockquote>
<img src="https://pic.imgdb.cn/item/66880f7dd9c307b7e983ba6b.png" style="zoom:50%;">
<p>解决方案：</p>
<ul>
<li>volatile</li>
</ul>
</blockquote>
<h2><span id="3线程池">3.线程池</span></h2>
<h3><span id="31-说一下线程池的核心参数线程池的执行原理知道嘛">3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数</p>
<img src="https://pic.imgdb.cn/item/66880f8cd9c307b7e983d9bb.png" style="zoom:50%;">
<ul>
<li>
<p>corePoolSize 核心线程数目</p>
</li>
<li>
<p>maximumPoolSize 最大线程数目 = (核心线程+救急线程的最大数目)</p>
</li>
<li>
<p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p>
</li>
<li>
<p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p>
</li>
<li>
<p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
</li>
<li>
<p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p>
</li>
<li>
<p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p>
</li>
</ul>
<p><strong>工作流程</strong></p>
<img src="https://pic.imgdb.cn/item/66880f9ed9c307b7e9840173.png" style="zoom:50%;">
<blockquote>
<p>1，任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行</p>
<p>2，如果核心线程数满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列</p>
<p>3，如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务</p>
<p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p>
<p>4，如果所有线程都在忙着（核心线程+临时线程），则走拒绝策略</p>
</blockquote>
<p>拒绝策略：</p>
<p>1.AbortPolicy：直接抛出异常，默认策略；</p>
<p>2.CallerRunsPolicy：用调用者所在的线程来执行任务；</p>
<p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p>
<p>4.DiscardPolicy：直接丢弃任务；</p>
<p>参考代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> duration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>(name, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name, <span class="type">long</span> duration)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.duration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;myThread&quot;</span>).debug(<span class="string">&quot;running...&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MyTask(&quot;</span> + name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                queue,</span><br><span class="line">                r -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;myThread&quot;</span> + c.getAndIncrement()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;1&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;2&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;4&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;5&quot;</span>,<span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;6&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showState</span><span class="params">(ArrayBlockingQueue&lt;Runnable&gt; queue, ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Object&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Runnable runnable : queue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">callable</span> <span class="operator">=</span> FutureTask.class.getDeclaredField(<span class="string">&quot;callable&quot;</span>);</span><br><span class="line">                callable.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">adapter</span> <span class="operator">=</span> callable.get(runnable);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.util.concurrent.Executors$RunnableAdapter&quot;</span>);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">task</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">                task.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> task.get(adapter);</span><br><span class="line">                tasks.add(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LoggerUtils.main.debug(<span class="string">&quot;pool size: &#123;&#125;, queue: &#123;&#125;&quot;</span>, threadPool.getPoolSize(), tasks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="32-线程池中有哪些常见的阻塞队列">3.2 线程池中有哪些常见的阻塞队列</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p>
<p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p>
<p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p>
<p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p>
<p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p>
<p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p>
<table>
<thead>
<tr>
<th><strong>LinkedBlockingQueue</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>默认无界，支持有界</td>
<td>强制有界</td>
</tr>
<tr>
<td>底层是链表</td>
<td>底层是数组</td>
</tr>
<tr>
<td>是懒惰的，创建节点的时候添加数据</td>
<td>提前初始化 Node  数组</td>
</tr>
<tr>
<td>入队会生成新 Node</td>
<td>Node需要是提前创建好的</td>
</tr>
<tr>
<td>两把锁（头尾）</td>
<td>一把锁</td>
</tr>
</tbody>
</table>
<p>左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方式</p>
<ul>
<li>LinkedBlockingQueue读和写各有一把锁，性能相对较好</li>
<li>ArrayBlockingQueue只有一把锁，读和写公用，性能相对于LinkedBlockingQueue差一些</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66880fbad9c307b7e9843c2d.png" alt></p>
<h3><span id="33-如何确定核心线程数">3.3 如何确定核心线程数</span></h3>
<blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p>
<ul>
<li>IO密集型任务</li>
</ul>
<p>一般来说：文件读写、DB读写、网络请求等</p>
<p>推荐：核心线程数大小设置为2N+1    （N为计算机的CPU核数）</p>
<ul>
<li>CPU密集型任务</li>
</ul>
<p>一般来说：计算型代码、Bitmap转换、Gson转换等</p>
<p>推荐：核心线程数大小设置为N+1    （N为计算机的CPU核数）</p>
<p>java代码查看CPU核数</p>
<img src="https://pic.imgdb.cn/item/66880fc7d9c307b7e98454f6.png" style="zoom:50%;">
<p><strong>参考回答：</strong></p>
<p>① 高并发、任务执行时间短 --&gt;（ CPU核数+1 ），减少线程上下文的切换</p>
<p>② 并发不高、任务执行时间长</p>
<ul>
<li>
<p>IO密集型的任务 --&gt; (CPU核数 * 2 + 1)</p>
</li>
<li>
<p>计算密集型任务 --&gt; （ CPU核数+1 ）</p>
</li>
</ul>
<p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）</p>
<h3><span id="34-线程池的种类有哪些">3.4 线程池的种类有哪些</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p>
<ol>
<li>
<p>创建使用固定线程数的线程池</p>
<img src="https://pic.imgdb.cn/item/66880fd4d9c307b7e9846fbf.png" style="zoom:50%;">
<ul>
<li>
<p>核心线程数与最大线程数一样，没有救急线程</p>
</li>
<li>
<p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p>
</li>
<li>
<p>适用场景：适用于任务量已知，相对耗时的任务</p>
</li>
<li>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FixedThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个固定大小的线程池，核心线程数和最大线程数都是3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">FixedThreadDemo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p>
<img src="https://pic.imgdb.cn/item/66880fe2d9c307b7e984890a.png" style="zoom:50%;">
<ul>
<li>
<p>核心线程数和最大线程数都是1</p>
</li>
<li>
<p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p>
</li>
<li>
<p>适用场景：适用于按照顺序执行的任务</p>
</li>
<li>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSingleThreadCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//单个线程池，核心线程数和最大线程数都是1</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>可缓存线程池</p>
<img src="https://pic.imgdb.cn/item/66880ff1d9c307b7e984a64a.png" style="zoom:50%;">
<ul>
<li>
<p>核心线程数为0</p>
</li>
<li>
<p>最大线程数是Integer.MAX_VALUE</p>
</li>
<li>
<p>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p>
</li>
<li>
<p>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
<li>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//修改睡眠时间，模拟线程执行需要花费的时间</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;执行完了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个缓存的线程，没有核心线程数，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p>
<p><img src="https://pic.imgdb.cn/item/66881002d9c307b7e984c99b.png" alt></p>
<ul>
<li>
<p>适用场景：有定时和延迟执行的任务</p>
</li>
<li>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 结束：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//按照周期执行的线程池，核心线程数为2，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * schedule 提交任务到线程池中</span></span><br><span class="line"><span class="comment">         * 第一个参数：提交的任务</span></span><br><span class="line"><span class="comment">         * 第二个参数：任务执行的延迟时间</span></span><br><span class="line"><span class="comment">         * 第三个参数：时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3><span id="35-为什么不建议用executors创建线程池">3.5 为什么不建议用Executors创建线程池</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考阿里开发手册《Java开发手册-嵩山版》</p>
<img src="https://pic.imgdb.cn/item/6688100fd9c307b7e984e407.png" style="zoom:50%;">
<h2><span id="4线程使用场景问题">4.线程使用场景问题</span></h2>
<h3><span id="41-线程池使用场景countdownlatch-future你们项目哪里用到了多线程">4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4><span id="411-countdownlatch">4.1.1 CountDownLatch</span></h4>
<p>CountDownLatch（闭锁/倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p>
<ul>
<li>
<p>其中构造参数用来初始化等待计数值</p>
</li>
<li>
<p>await() 用来等待计数归零</p>
</li>
<li>
<p>countDown() 用来让计数减一</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6688101dd9c307b7e984ffe4.png" style="zoom:50%;">
<p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//初始化了一个倒计时锁 参数为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-waiting...&quot;</span>);</span><br><span class="line">        <span class="comment">//等待其他线程完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-wait end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="412-案例一es数据批量导入">4.1.2 案例一（es数据批量导入）</span></h4>
<p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p>
<p>整体流程就是通过CountDownLatch+线程池配合去执行</p>
<p><img src="https://pic.imgdb.cn/item/6688102cd9c307b7e9851f48.png" alt></p>
<p>详细实现流程：</p>
<p><img src="https://pic.imgdb.cn/item/66881039d9c307b7e985382e.png" alt></p>
<blockquote>
<p>详细实现代码，请查看当天代码</p>
</blockquote>
<h4><span id="413-案例二数据汇总">4.1.3 案例二（数据汇总）</span></h4>
<p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p>
<p><img src="https://pic.imgdb.cn/item/66881047d9c307b7e9855268.png" alt></p>
<blockquote>
<p>详细实现代码，请查看当天代码</p>
</blockquote>
<ul>
<li>
<p>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</p>
</li>
<li>
<p>报表汇总</p>
<img src="https://pic.imgdb.cn/item/66881053d9c307b7e9856b97.png" style="zoom:50%;">
</li>
</ul>
<h4><span id="414-案例二异步调用">4.1.4 案例二（异步调用）</span></h4>
<p><img src="https://pic.imgdb.cn/item/66881064d9c307b7e9858951.png" alt></p>
<p>在进行搜索的时候，需要保存用户的搜索记录，而搜索记录不能影响用户的正常搜索，我们通常会开启一个线程去执行历史记录的保存，在新开启的线程在执行的过程中，可以利用线程提交任务</p>
<h3><span id="41-如何控制某个方法允许并发访问线程的数量">4.1 如何控制某个方法允许并发访问线程的数量？</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，我们可以通过其限制执行的线程数量，达到限流的效果</p>
<p>当一个线程执行时先通过其方法进行获取许可操作，获取到许可的线程继续执行业务逻辑，当线程执行完成后进行释放许可操作，未获取达到许可的线程进行等待或者直接结束。</p>
<p>Semaphore两个重要的方法</p>
<p>lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p>
<p>lsemaphore.release()：释放一个信号量，此时信号量个数+1</p>
<p>线程任务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5其他">5.其他</span></h2>
<h3><span id="51-谈谈你对threadlocal的理解">5.1 谈谈你对ThreadLocal的理解</span></h3>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4><span id="511-概述">5.1.1 概述</span></h4>
<p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p>
<img src="https://pic.imgdb.cn/item/66881071d9c307b7e985a961.png" style="zoom:50%;">
<h4><span id="512-threadlocal基本使用">5.1.2 ThreadLocal基本使用</span></h4>
<p>三个主要方法：</p>
<ul>
<li>
<p>set(value) 设置值</p>
</li>
<li>
<p>get() 获取值</p>
</li>
<li>
<p>remove() 清除值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + threadLocal.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="513-threadlocal的实现原理amp源码解析">5.1.3 ThreadLocal的实现原理&amp;源码解析</span></h4>
<p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</p>
<p><img src="https://pic.imgdb.cn/item/6688107ed9c307b7e985c456.png" alt></p>
<p>在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap</p>
<p>ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置</p>
<p><strong>set方法</strong></p>
<img src="https://pic.imgdb.cn/item/6688108cd9c307b7e985e028.png" style="zoom:50%;">
<p><strong>get方法/remove方法</strong></p>
<img src="https://pic.imgdb.cn/item/6688109bd9c307b7e985fdc9.png" style="zoom:50%;">
<h4><span id="514-threadlocal-内存泄露问题">5.1.4 ThreadLocal-内存泄露问题</span></h4>
<p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p>
<ul>
<li>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</li>
</ul>
<img src="https://pic.imgdb.cn/item/668810a8d9c307b7e9861950.png" style="zoom:50%;">
<ul>
<li>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</li>
</ul>
<img src="https://pic.imgdb.cn/item/668810b6d9c307b7e98637cf.png" style="zoom:50%;">
<p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p>
<p><img src="/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240705232702659.png" alt="image-20240705232702659"></p>
<p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p>
<h2><span id="6-真实面试还原">6 真实面试还原</span></h2>
<h3><span id="61-线程的基础知识">6.1 线程的基础知识</span></h3>
<blockquote>
<p><strong>面试官</strong>：聊一下并行和并发有什么区别？</p>
<p><strong>候选人：</strong></p>
<p>是这样的~~</p>
<p>现在都是多核CPU，在多核CPU下</p>
<p>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</p>
<p>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</p>
<hr>
<p><strong>面试官</strong>：说一下线程和进程的区别？</p>
<p><strong>候选人：</strong></p>
<p>嗯，好~</p>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
<hr>
<p><strong>面试官</strong>：如果在java中创建线程有哪些方式？</p>
<p><strong>候选人：</strong></p>
<p>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。</p>
<p><strong>面试官</strong>：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</p>
<p><strong>候选人：</strong></p>
<p>是这样的~</p>
<p>最主要的两个线程一个是有返回值，一个是没有返回值的。</p>
<p>Runnable 接口run方法无返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>
<p>还有一个就是，他们异常处理也不一样。Runnable接口run方法只能抛出运行时异常，也无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息</p>
<p>在实际开发中，如果需要拿到执行的结果，需要使用Callalbe接口创建线程，调用FutureTask.get()得到可以得到返回值，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>
<hr>
<p><strong>面试官</strong>：线程包括哪些状态，状态之间是如何变化的？</p>
<p><strong>候选人：</strong></p>
<p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p>
<p>关于线程的状态切换情况比较多。我分别介绍一下</p>
<p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p>
<p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p>
<p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p>
<p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p>
<p><strong>面试官</strong>：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？</p>
<p><strong>候选人：</strong></p>
<p>它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</p>
<p>不同点主要有三个方面：</p>
<p>第一：方法归属不同</p>
<p>sleep(long) 是 Thread 的静态方法。而 wait()，是 Object 的成员方法，每个对象都有</p>
<p>第二：线程醒来时机不同</p>
<p>线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去</p>
<p>第三：锁特性不同</p>
<p>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</p>
<p>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（相当于我放弃 cpu，但你们还可以用）</p>
<p>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（相当于我放弃 cpu，你们也用不了）</p>
<p><strong>面试官</strong>：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</p>
<p><strong>候选人：</strong></p>
<p>嗯~~，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）</p>
<p>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>比如说：</p>
<p>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成</p>
<p><strong>面试官</strong>：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</p>
<p><strong>候选人：</strong></p>
<p>start方法用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。run方法封装了要被线程执行的代码，可以被调用多次。</p>
<p><strong>面试官</strong>：那如何停止一个正在运行的线程呢？</p>
<p><strong>候选人</strong>：</p>
<p>有三种方式可以停止线程</p>
<p>第一：可以使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记</p>
<p>第二：可以使用线程的stop方法强行终止，不过一般不推荐，这个方法已作废</p>
<p>第三：可以使用线程的interrupt方法中断线程，内部其实也是使用中断标志来中断线程</p>
<p>我们项目中使用的话，建议使用第一种或第三种方式中断线程</p>
</blockquote>
<h3><span id="62-线程中并发锁">6.2 线程中并发锁</span></h3>
<blockquote>
<p><strong>面试官</strong>：讲一下synchronized关键字的底层原理？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~好的，</p>
<p>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。</p>
<p>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。</p>
<p><strong>面试官</strong>：好的，你能具体说下Monitor 吗？</p>
<p><strong>候选人</strong>：</p>
<p>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因</p>
<p>monitor内部维护了三个变量</p>
<ul>
<li>
<p>WaitSet：保存处于Waiting状态的线程</p>
</li>
<li>
<p>EntryList：保存处于Blocked状态的线程</p>
</li>
<li>
<p>Owner：持有锁的线程</p>
</li>
</ul>
<p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner</p>
<p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p>
<p><strong>面试官</strong>：好的，那关于synchronized 的锁升级的情况了解吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道一些（要谦虚）</p>
<p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<p>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
<p>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</p>
<p>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</p>
<p>一旦锁发生了竞争，都会升级为重量级锁</p>
<p><strong>面试官</strong>：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，其实，在高并发下，我们可以采用ReentrantLock来加锁。</p>
<p><strong>面试官</strong>：嗯，那你说下ReentrantLock的使用方式和底层原理？</p>
<p><strong>候选人</strong>：</p>
<p>好的，</p>
<p>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p>
<p>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p>
<p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</p>
<p>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</p>
<p><strong>面试官</strong>：好的，刚才你说了CAS和AQS，你能介绍一下吗？</p>
<p><strong>候选人</strong>：</p>
<p>好的。</p>
<p>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p>
<ul>
<li>
<p>CAS使用到的地方很多：AQS框架、AtomicXXX类</p>
</li>
<li>
<p>在操作共享变量的时候使用的自旋锁，效率上更高一些</p>
</li>
<li>
<p>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</p>
</li>
</ul>
<p>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p>
<p>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态</p>
<p>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中</p>
<ul>
<li>
<p>tail 指向队列最后一个元素</p>
</li>
<li>
<p>head  指向队列中最久的一个元素</p>
</li>
</ul>
<p>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。</p>
<p><strong>面试官</strong>：synchronized和Lock有什么区别 ?</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，好的，主要有三个方面不太一样</p>
<p>第一，语法层面</p>
<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li>
</ul>
<p>第二，功能层面</p>
<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
<p>第三，性能层面</p>
<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
<p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p>
<hr>
<p><strong>面试官</strong>：死锁产生的条件是什么？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：</p>
<p>t1 线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2 线程获得B对象锁，接下来想获取A对象的锁</p>
<p>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁</p>
<p><strong>面试官</strong>：那如果产出了这样的，如何进行死锁诊断？</p>
<p><strong>候选人</strong>：</p>
<p>这个也很容易，我们只需要通过jdk自动的工具就能搞定</p>
<p>我们可以先通过jps来查看当前java程序运行的进程id</p>
<p>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p>
<hr>
<p><strong>面试官</strong>：请谈谈你对 volatile 的理解</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~</p>
<p>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能</p>
<p>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
<p>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化</p>
<hr>
<p><strong>本文作者</strong>：接《集合相关面试题》</p>
<p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯好的，</p>
<p>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p>
<ul>
<li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li>
<li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li>
</ul>
<p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。</p>
<p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p>
<p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升</p>
</blockquote>
<h3><span id="63-线程池">6.3 线程池</span></h3>
<blockquote>
<p><strong>面试官</strong>：线程池的种类有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>嗯！是这样</p>
<p>在jdk中默认提供了4中方式创建线程池</p>
<p>第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。</p>
<p>第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。</p>
<p>第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><strong>面试官</strong>：线程池的核心参数有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>在线程池中一共有7个核心参数：</p>
<ol>
<li>
<p>corePoolSize 核心线程数目 - 池中会保留的最多线程数</p>
</li>
<li>
<p>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</p>
</li>
<li>
<p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p>
</li>
<li>
<p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p>
</li>
<li>
<p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
</li>
<li>
<p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p>
</li>
<li>
<p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p>
</li>
</ol>
<p>在拒绝策略中又有4中拒绝策略</p>
<p>当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。</p>
<p><strong>面试官</strong>：如何确定核心线程池呢？</p>
<p><strong>候选人</strong>：</p>
<p>是这样的，我们公司当时有一些规范，为了减少线程上下文的切换，要根据当时部署的服务器的CPU核数来决定，我们规则是：CPU核数+1就是最终的核心线程数。</p>
<p><strong>面试官</strong>：线程池的执行原理知道吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~，它是这样的</p>
<p>首先判断线程池里的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队 列里。如果工作队列满了，则判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任 务。如果已经满了，则交给拒绝策略来处理这个任务。</p>
<p><strong>面试官</strong>：为什么不建议使用Executors创建线程池呢？</p>
<p><strong>候选人</strong>：</p>
<p>好的，其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p>
<p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p>
<p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p>
</blockquote>
<h3><span id="64-线程使用场景问题">6.4 线程使用场景问题</span></h3>
<blockquote>
<p><strong>面试官</strong>：如果控制某一个方法允许并发访问线程的数量？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，我想一下</p>
<p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p>
<p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p>
<p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p>
<p><strong>面试官</strong>：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，刚才讲过了导致线程安全的原因，如果解决的话，jdk中也提供了很多的类帮助我们解决多线程安全的问题，比如：</p>
<ul>
<li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li>
<li>synchronized、volatile、LOCK，可以解决可见性问题</li>
<li>Happens-Before 规则可以解决有序性问题</li>
</ul>
<hr>
<p><strong>面试官</strong>：你在项目中哪里用了多线程？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，我想一下当时的场景[根据自己简历上的模块设计多线程场景]</p>
<p>参考场景一：</p>
<p>es数据批量导入</p>
<p>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。</p>
<p>参考场景二：</p>
<p>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行</p>
<p>参考场景三：</p>
<p>《黑马头条》项目中使用的</p>
<p>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用</p>
</blockquote>
<h3><span id="65-其他">6.5 其他</span></h3>
<blockquote>
<p><strong>面试官</strong>：谈谈你对ThreadLocal的理解</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的~~</p>
<p>ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享</p>
<p><strong>面试官</strong>：好的，那你知道ThreadLocal的底层原理实现吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道一些~</p>
<p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p>
<p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p>
<p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p>
<p><strong>面试官</strong>：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，我之前看过源码，我想一下~~</p>
<p>是应为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。</p>
<p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。</p>
</blockquote>
<p>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行</p>
<h2><span id="什么是多进程-多线程">什么是多进程、多线程？</span></h2>
<ul>
<li>多进程是指操作系统能同时运行多个任务（程序）</li>
<li>多线程是指在同一程序中有多个顺序流在执行（一个进程同一时间并行执行多个线程）</li>
</ul>
<p>所谓串行，其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子：当我们下载多个文件时，在串行中它是按照一定的顺序去进行下载的，也就是说，必须等下载完A之后才能开始下载B，它们在时间上是不可能发生重叠的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/df594ffe5bcceb97c4f7796f50baa006.png" alt="640"></p>
<p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的，在同一时刻发生的，并行在时间上是重叠的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/23c3fbc0f394789e150fdf8781cafadd.png" alt="640"></p>
<p>举个例子，我们打开腾讯管家，腾讯管家本身就是一个程序，也就是说它就是一个进程，它里面有很多的功能，能查杀病毒、清理垃圾、电脑加速等众多功能。</p>
<p>按照单线程来说，无论你想要清理垃圾、还是要病毒查杀，那么你必须先做完其中的一件事，才能做下一件事，这里面是有一个执行顺序的。</p>
<p>如果是多线程的话，我们其实在清理垃圾的时候，还可以进行查杀病毒、电脑加速等等其他的操作，这个是严格意义上的同一时刻发生的，没有执行上的先后顺序</p>
<h2><span id="什么是线程安全">什么是线程安全？</span></h2>
<p>当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的</p>
<p>确保在多条线程访问同一个方法时，程序是否还能按照预期的行为执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    count ++;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启3条线程，每个线程循环10次执行以上方法，得到以下结果：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ceb145de48e6c58699c65b55c909804b.png" alt="640"></p>
<p>我们可以看到，这里出现了两个26，出现这种问题的原因有很多。</p>
<p>最常见的一种，就是我们A线程在进入方法后，拿到了count的值，刚把这个值读取出来，还没有改变count的值的时候，结果线程B也进来的，那么导致线程A和线程B拿到的count值是一样的。</p>
<p>Java中确保线程安全最常用的两种方式。先来看段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">    j = j + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家觉得这段代码是线程安全的吗？</p>
<p>毫无疑问，它绝对是线程安全的，我们来分析一下，为什么它是线程安全的？</p>
<p>我们可以看到这段代码是没有任何状态的，就是说我们这段代码，不包含任何的作用域，也没有去引用其他类中的域进行引用，它所执行的作用范围与执行结果只存在它这条线程的局部变量中，并且只能由正在执行的线程进行访问。当前线程的访问，不会对另一个访问同一个方法的线程造成任何的影响。</p>
<p>两个线程同时访问这个方法，因为没有共享的数据，所以他们之间的行为，并不会影响其他线程的操作和结果，所以说无状态的对象，也是线程安全的。</p>
<p><strong>添加一个状态呢？</strong></p>
<p>如果我们给这段代码添加一个状态，添加一个count，来记录这个方法并命中的次数，每请求一次count+1，那么这个时候这个线程还是安全的吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;   </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 记录方法的命中次数   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;  </span><br><span class="line">        count++ ;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;      </span><br><span class="line">        j = j + i;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显已经不是了，单线程运行起来确实是没有任何问题的，但是当出现多条线程并发访问这个方法的时候，问题就出现了，我们先来分析下count+1这个操作。</p>
<p>进入这个方法之后首先要读取count的值，然后修改count的值，最后才把这把值赋值给count，总共包含了三步过程：“读取”一&gt;“修改”一&gt;“赋值”，既然这个过程是分步的，那么我们先来看下面这张图，看看你能不能看出问题：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b32fdb479959903bf9dd76408b2867c1.png" alt="640?"></p>
<p>可以发现，count的值并不是正确的结果，当线程A读取到count的值，但是还没有进行修改的时候，线程B已经进来了，然后线程B读取到的还是count为1的值，正因为如此所以我们的count值已经出现了偏差，那么这样的程序放在我们的代码中，是存在很多的隐患的。</p>
<h2><span id="如何确保线程安全">如何确保线程安全？</span></h2>
<p>synchronized关键字</p>
<ul>
<li>
<p>控制线程同步的，保证我们的线程在多线程环境下，不被多个线程同时执行，确保我们数据的完整性</p>
</li>
<li>
<p>当synchronized锁住一个对象之后，别的线程如果想要获取锁对象，那么就必须等这个线程执行完释放锁对象之后才可以，否则一直处于等待状态</p>
</li>
<li>
<p>要注意缩小synchronized的使用范围，如果随意使用时很影响程序的性能，别的对象想拿到锁，结果你没用锁还一直把锁占用，这样就有点浪费资源</p>
</li>
<li>
<p>使用方法一般是加在方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 记录方法的命中次数  </span></span><br><span class="line">    <span class="comment">// 锁的是括号里的对象，而不是代码，其次，对于非静态的synchronized方法，锁的是对象本身也就是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;    </span><br><span class="line">        count++ ;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;    </span><br><span class="line">        j = j + i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Lock</p>
<ul>
<li>从Java1.6开始引入Lock，Lock的引入让锁有了可操作性，就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// ReentrantLock是Lock的子类   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span>&#123;    </span><br><span class="line">    lock.lock(); </span><br><span class="line">    <span class="comment">// 获取锁对象  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        <span class="comment">// Thread.sleep(2000);    </span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;       </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);     </span><br><span class="line">        lock.unlock(); <span class="comment">// 手动释放锁对象，无论如何都会执行    </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="type">LockTest</span> <span class="variable">lockTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockTest</span>();    </span><br><span class="line">    <span class="comment">// 线程1     </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;     </span><br><span class="line">        <span class="meta">@Override</span>         </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;      </span><br><span class="line">            <span class="comment">// Thread.currentThread()  返回当前线程的引用     </span></span><br><span class="line">            lockTest.method(Thread.currentThread());      </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);    </span><br><span class="line">    <span class="comment">// 线程2   </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;   </span><br><span class="line">        <span class="meta">@Override</span>   </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;      </span><br><span class="line">            lockTest.method(Thread.currentThread());   </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);   </span><br><span class="line">    t1.start();     </span><br><span class="line">    t2.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e508507c0b74d1503d6d1a75b5668cf7.png" alt="640?"></p>
<p>其实在Lock还有几种获取锁的方式，我们这里再说一种，就是tryLock()这个方法跟Lock()是有区别的，Lock在获取锁的时候，如果拿不到锁，就一直处于等待状态，直到拿到锁，但是tryLock()却不是这样的，tryLock是有一个Boolean的返回值的，如果没有拿到锁，直接返回false，停止等待，它不会像Lock()那样去一直等待获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span>&#123;     </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象   </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;    </span><br><span class="line">        <span class="keyword">try</span> &#123;          </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);    </span><br><span class="line">            <span class="comment">// Thread.sleep(2000);      </span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;     </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);      </span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 释放锁对象    </span></span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：我们继续使用刚才的两个线程进行测试可以发现，在线程t1获取到锁之后，线程t2立马进来，然后发现锁已经被占用，那么这个时候它也不在继续等待。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a2997ff879b806a31a0d8debcaae457b.png" alt="640?"></p>
<p>似乎这种方法，感觉不是很完美，如果我第一个线程，拿到锁的时间，比第二个线程进来的时间还要长，是不是也拿不到锁对象？</p>
<p>那我能不能，用一中方式来控制一下，让后面等待的线程，可以等待5秒，如果5秒之后，还获取不到锁，那么就停止等，其实tryLock()是可以进行设置等待的相应时间的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象      </span></span><br><span class="line">    <span class="comment">// 如果2秒内获取不到锁对象，那就不再等待       </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>,TimeUnit.SECONDS)) &#123;         </span><br><span class="line">        <span class="keyword">try</span> &#123;              </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);    </span><br><span class="line">            <span class="comment">// 这里睡眠3秒            </span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);         </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;             </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;             </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);    </span><br><span class="line">            lock.unlock(); </span><br><span class="line">            <span class="comment">// 释放锁对象  </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：看上面的代码，我们可以发现，虽然我们获取锁对象的时候，可以等待2秒，但是我们线程t1在获取锁对象之后，执行任务缺花费了3秒，那么这个时候线程t2是不在等待的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2034afb57a67bb10615cd4002d887abc.png" alt="640?"></p>
<p>我们再来改一下这个等待时间，改为5秒，再来看下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException &#123;   </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象     </span></span><br><span class="line">    <span class="comment">// 如果5秒内获取不到锁对象，那就不再等待     </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS)) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;             </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;         </span><br><span class="line">            e.printStackTrace();         </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;           </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);  </span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 释放锁对象    </span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：这个时候我们可以看到，线程t2等到5秒获取到了锁对象，执行了任务代码。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1df3ef93e83b5c5fd84c100c15a0b8ef.png" alt="640?"></p>
<p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p>
<p>在Java中，一个应用程序可以包含多个线程。每个线程执行特定的任务，并可与其他线程并发执行多线程使系统的空转时间最少，提高CPU利用率、多线程编程环境用方便的模型隐藏CPU在任务间切换的事实在Java程序启动时，一个线程立刻运行，该线程通常称为程序的主线程。</p>
<p>主线程的重要性体现在两个方面：</p>
<p>1、它是产生其他子线程的线程。</p>
<p>2、通常它必须最后完成执行，因为它执行各种关闭动作。</p>
<p>进程和线程的关系：</p>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源</li>
<li>处理机分给线程，即真正在处理机上运行的是线程</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体</li>
</ul>
<hr>
<h2><span id="为什么要使用多线程呢">为什么要使用多线程呢?</span></h2>
<p>我们现在所使用操作系统都是多任务操作系统(早期使用的DOS操作系统为单任务操作系统)，多任务操作指在同一时刻可以同时做多件事(可以同时执行多个程序)。<br>
多进程:每个程序都是一个进程，在操作系统中可以同时执行多个程序,多进程的目的是为了有效的使用CPU资源，每开一个进程系统要为该进程分配相关的系统资源(内存资源)；<br>
多线程:线程是进程内部比进程更小的执行单元(执行流|程序片段),每个线程完成一个任务,每个进程内部包含了多个线程每个线程做自己的事情，在进程中的所有线程共享该进程的资源；<br>
主线程:在进程中至少存在一个主线程，其他子线程都由主线程开启,主线程不一定在其他线程结束后结束，有可能在其他线程结束前结束。Java中的主线程是main线程,是Java的main函数;</p>
<hr>
<h2><span id="多线程应用场景">多线程应用场景?</span></h2>
<p>当应用场景为计算密集型时：为了将每个cpu充分利用起来，线程数量正常是cpu核数+1，还可以看jdk的使用版本，1.8版本中可以使用cpu核数*2。<br>
当应用场景为io密集型时：做web端开发的时候，涉及到大量的网络传输，不进入持，缓存和与数据库交互也会存在大量io，当发生io时候，线程就会停止，等待io结束，数据准备好，线程才会继续执行，所以当io密集时，可以多创建点线程，让线程等待时候，其他线程执行，更高效的利用cpu效率，他有一个计算公式，套用公式的话，双核cpu理想的线程数就是20。</p>
<hr>
<h2><span id="多线程的好处">多线程的好处?</span></h2>
<p>采用多线程技术的应用程序可以更好地利用系统资源。主要优势在于充分利用了CPU的空闲时间片，用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。</p>
<ul>
<li>易于调度</li>
<li>提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分</li>
<li>开销少。创建线程比创建进程要快，所需开销很少</li>
<li>利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行</li>
</ul>
<p>使用线程可以把占据时间长的程序中的任务放到后台去处理<br>
用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>
程序的运行速度可能加快<br>
在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。<br>
多线程技术在IOS软件开发中也有举足轻重的位置。<br>
多线程的缺点</p>
<ul>
<li>提高应用程序的响应。如图形化界面，可增强用户的体验</li>
<li>提高计算机CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程独立运行，利于理解和修改</li>
</ul>
<hr>
<h2><span id="使用多线程可能带来什么问题">使用多线程可能带来什么问题?</span></h2>
<p>如果有大量的线程可能会降低程序的运行速度，可能发生内存泄露、死锁、线程不安全等等问题</p>
<hr>
<h2><span id="多核cpu的效率会是单核cpu的倍数吗">多核CPU的效率会是单核CPU的倍数吗？</span></h2>
<ul>
<li>多个和核心有其他共享资源的限制：如cache、寄存器没有同步扩充</li>
<li>多核CPU之间的协调管理损耗</li>
</ul>
<h2><span id="创建线程用runnable还是thread">创建线程用Runnable还是Thread？</span></h2>
<p>共同点：</p>
<ul>
<li>启动线程使用的都是Thread类中定义的start()方法</li>
<li>创建线程的对象，都是Thread的子类或Thread的实现类</li>
</ul>
<p>不同点：</p>
<ul>
<li>一个是继承类，一个是实现接口</li>
<li>相比与Java只支持单继承，实现Runnable没有单继承的局限</li>
<li>实现Runnable更适合处理有共享数据的问题</li>
<li>实现Runnbale能够分离代码和数据</li>
</ul>
<p>联系：</p>
<ul>
<li>public class Thread implements Runnable  （代理模式）</li>
</ul>
<hr>
<h2><span id="什么是上下文切换">什么是上下文切换?</span></h2>
<p>上下文切换指的是内核操作系统的核心在CPU上对进程或者线程进行切换</p>
<p>在多线程编程中，一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式</p>
<p>当一个线程执行完 CPU 时间片时，就会退回就绪状态，并切换其他的线程，这个过程就是进行了一次上下文切换</p>
<hr>
<h2><span id="如何创建守护线程">如何创建守护线程？</span></h2>
<p>通过Thread类的setDaemon(true)方法将线程设置为守护线程，但是要在线程启动（start方法）前调用，否则抛出IllegalThreadStateException异常</p>
<hr>
<h2><span id="用户线程和守护线程有什么区别">用户线程和守护线程有什么区别？</span></h2>
<ul>
<li>用户线程是虚拟机启动的线程中的普通线程，当所有用户线程结束运行后，虚拟机才会停止运行（守护线程自动关闭）</li>
<li>守护线程是在程序中创建的线程，它的作用是为其他线程提供服务。当所有的用户线程结束运行后，守护线程也会随之结束，而不管它是否执行完毕。守护线程通常用于执行一些辅助性任务，如垃圾回收、缓存清理等，它们不需要等待所有的任务完成后再退出</li>
<li>一个守护线程创建的子线程依然是守护线程</li>
</ul>
<hr>
<h2><span id="为什么thread类的sleep和yield方法是静态的">为什么Thread类的sleep()和yield()方法是静态的？</span></h2>
<p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<p>首先明确一点，在一个线程拿到锁的时候，其他线程向拿到锁就必须要等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepYield</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">                thread1.<span class="keyword">yield</span>();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; have finished.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>假设yield()为非静态方法，若thread2拿到锁，调用了thread1的yield()方法，意为让thread1暂时放弃当前占有的CPU时间片，与大家一起再进行时间片竞争。关键是thread1现在处于阻塞状态！它在等待thread2释放锁，它根本没有占用CPU时间片。所以此时调用thread1的yield()方法是没有意义的！<br>
sleep()方法道理类似，本来就是阻塞状态，所以没必要再阻塞，即使“自然阻塞状态”比如是10ms，你设置了100ms，而“自然阻塞状态”持续时间是无法预测的，所以设定的休眠时间便失去了意义！<br>
而对于单线程而言，即使没有锁的争夺，在一个线程执行的时候另外一个线程也处于“不占有CPU时间片的状态”，什么时候再拿到时间片或者多长时间竞争一次CPU时间片都是无法预测的。所以在正在执行的线程里调用另外一个线程的yield()和sleep()方法依然是没有意义的。<br>
ps:有人可能会问怎么没有列举线程调用自己的实例方法来yield或者sleep的情况呢？<br>
答：调用自己的实例方法跟调用类方法效果是一样的，所以不用考虑这种情况。</p>
<hr>
<h2><span id="多线程的常用方法">多线程的常用方法？</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>start()</td>
<td>启动线程，并执行线程的 run() 方法</td>
</tr>
<tr>
<td>run()</td>
<td>线程在被调度时执行的方法，子线程执行的业务逻辑放在该方法体中</td>
</tr>
<tr>
<td>currentThread()</td>
<td>返回当前线程 。在Thread子类中就是this ，通常用于主线程和Runnable 实现类</td>
</tr>
<tr>
<td>setName(String)</td>
<td>设置线程的名称</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回线程的名称</td>
</tr>
<tr>
<td>sleep(long millis)</td>
<td>睡眠指定时间，程序暂停运行，睡眠期间会让出CPU的执行权，去执行其它线程，同时CPU也会监视睡眠的时间，一旦睡眠时间到就会立刻执行(因为睡眠过程中仍然保留着锁，有锁只要睡眠时间到就能立刻执行)（强迫一个线程睡眠N毫秒）</td>
</tr>
<tr>
<td>yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程（线程让步）</td>
</tr>
<tr>
<td>join(long millis)</td>
<td>等待该线程终止的时间最长为 millis 毫秒。join()方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行。注意该方法也需要捕捉异常（等待线程终止）</td>
</tr>
<tr>
<td>isAlive()</td>
<td>测试线程是否处于活动状态，线程调用start后，即处于活动状态</td>
</tr>
<tr>
<td>getPriority()</td>
<td>获取当前线程优先值（优先级取值范围[1,10]，默认为5）</td>
</tr>
<tr>
<td>setPriority (int newPriority)</td>
<td>设置当前线程优先级<br>线程优先级高，被CPU调度的概率大，但不代表一定会运行，还有小概率运行优先级低的线程。</td>
</tr>
<tr>
<td>interrupt()</td>
<td>中断线程，由运行状态到死亡状态</td>
</tr>
<tr>
<td>wait()</td>
<td>一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。而当前线程排队等候其他线程调用notify() 或 notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行（强迫一个线程等待）</td>
</tr>
<tr>
<td>notify()</td>
<td>一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个（通知一个线程继续执行）</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>一旦执行此方法，就会唤醒所有被wait的线程（所有线程继续执行）</td>
</tr>
</tbody>
</table>
<p>过时的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop()</td>
<td>强制线程生命周期结束，已经废止</td>
</tr>
<tr>
<td>suspend()/resume()</td>
<td>可能死锁，已经废止</td>
</tr>
</tbody>
</table>
<p><strong>yield() 和 sleep() 的异同</strong></p>
<p>相同点：yield() 方法和 sleep() 方法类似，也不会释放“锁”。</p>
<p>不同点：yield() 方法只是使当前线程重新回到可执行状态，所以执行 yield()的线程有可能在进入到可执行状态后马上又被执行。 yield() 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep()方法不同。</p>
<p><strong>join() 和 sleep() 的异同</strong></p>
<p>相同点：都可以实现等待<br>
不同点：由于join的内部实现是wait()，所以使用join()方法时会释放锁，那么其他线程就可以调用此线程的同步方法了。<br>
sleep() 方法不释放锁，因此线程会一直等待下去，直到任务完成，才会释放锁。</p>
<p><strong>sleep() 与 wait() 的异同</strong></p>
<p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>
不同点：<br>
（1） 两个方法声明的位置不同：Thread类中声明sleep() ,<br>
Object类中声明wait()<br>
（2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中<br>
（3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。<br>
（4）当调用某一对象的 wait() 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify() 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll() 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</p>
<hr>
<h2><span id="如何在-windows-和-linux-上查找哪个线程cpu利用率最高">如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</span></h2>
<p>Windows系统下执行java  -jar  arthas-boot.jar<br>
Linux系统下解压arthas，执行ps  -ef  |  grep  java找出java进程pid数字</p>
<hr>
<h2><span id="为什么我们调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></h2>
<ul>
<li>创建线程，即线程进入新建状态</li>
<li>调用线程的start()方法，将启动线程并使线程进入就绪状态</li>
<li>当分配到时间片后就开始运行run()方法，线程进入运行状态，从而实现多线程</li>
</ul>
<p>而直接调用run()方法只是将run()方法作为主线程下的普通方法执行，并不会在其他线程中执行</p>
<hr>
<h2><span id="什么是-callable-和-future">什么是 Callable 和 Future?</span></h2>
<p>Callable和Future是Java并发包中用于支持并发编程的两个接口。它们通常与ExecutorService（线程池）一起使用，用于执行具有返回值的任务，并在任务执行完成后获取结果或取消任务。</p>
<p>Callable 接口<br>
Callable是一个接口，类似于Runnable接口，但是它有返回值，并且可以抛出异常。Callable定义了一个带有泛型的call方法，该方法返回一个结果并可能抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 执行一些耗时的任务，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future 接口</p>
<p>Future接口用于表示异步计算的结果，它提供了一些方法来检查计算是否完成、等待计算完成并获取结果，以及取消计算等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(callable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取结果</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Future通过get方法等待任务执行完成，并获取返回结果。如果任务还未完成，get方法会阻塞当前线程，直到任务完成为止。</p>
<p>组合使用：<br>
Callable和Future通常一起使用，通过submit方法提交Callable任务给ExecutorService，然后通过返回的Future对象来管理任务的执行和获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(callable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 阻塞等待任务执行完成，并获取结果</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<p>​        总的来说，Callable和Future提供了一种更灵活的方式来处理并发任务的执行和获取结果，尤其适用于需要在任务执行完成后获取结果的情况。</p>
<ul>
<li>Callable接口类似于Runnable</li>
<li>Runnable不会返回结果，并且无法抛出返回结果的异常；而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到</li>
<li>Future可以拿到异步执行任务的返回值。可以认为是带有返回值的Runnable.Future接口表示异步任务，是还没有完成的任务给出的未来结果</li>
<li>所以说Callable用于产生结果，Future用于获取结果</li>
</ul>
<hr>
<h2><span id="线程调度策略有哪些">线程调度策略有哪些？</span></h2>
<p><strong>抢占式调度(Preemptive Scheduling)</strong></p>
<ul>
<li>Java运行时系统采用抢占式调度策略</li>
<li>Java运行时系统让优先级高的线程以较大的概率使用CPU，如果线程优先级相同则随机选择（简单的、非抢占式的轮转的调度顺序）</li>
</ul>
<p>操作系统根据线程的优先级和时间片来决定当前运行的线程。当时间片用完或更高优先级的线程就绪时，当前线程会被抢占并让出CPU资源</p>
<p><strong>时间片轮转调度(Round-Robin Scheduling)</strong></p>
<ul>
<li>所有线程轮流使用CPU，并且平均分配每个线程占用CPU的时间</li>
<li>从所有处于就绪状态的线程中选择优先级最高的线程分配一定的CPU时间运行。该时间过后再选择其他线程运行</li>
<li>只有当线程运行结束、放弃(yield)CPU或由于某种原因进入阻塞状态，低优先级的线程才有机会执行</li>
<li>如果有两个优先级相同的线程都在等待CPU，则调度程序以轮转的方式选择运行的线程</li>
</ul>
<p>每个线程被分配一个固定的时间片(通常是几毫秒)，线程在该时间片内运行。当时间片用完后，操作系统会将当前线程放到就绪队列的尾部，并选择下一个就绪线程执行</p>
<p><strong>优先级调度(Priority Scheduling)</strong></p>
<ul>
<li>根据线程的优先级来决定线程的调度顺序</li>
<li>较高优先级的线程会优先执行，而较低优先级的线程会等待</li>
<li>优先级可以由开发人员手动设置，操作系统也可以根据一些策略自动调整线程的优先级</li>
</ul>
<p><strong>公平调度(Fair Scheduling)</strong></p>
<ul>
<li>试图确保每个线程都能公平地分享CPU资源</li>
<li>所有线程按照其就绪的顺序获得CPU时间。这意味着较长等待的线程会更早地获得执行机会</li>
</ul>
<hr>
<h2><span id="java中用到的线程调度算法是什么">Java中用到的线程调度算法是什么？</span></h2>
<p>在Java中，线程调度的算法是由操作系统负责的，Java虚拟机(JVM)只是利用操作系统提供的调度机制来实现线程调度。因此，Java中使用的线程调度算法由底层操作系统决定，Java虚拟机无法直接控制或修改这些算法。Java中的线程调度方法(如Thread.yield()、Thread.sleep()和Object.wait()等)主要用于协调线程之间的交互和同步，而不是直接控制线程的调度</p>
<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<hr>
<h2><span id="什么是线程调度器和时间分片">什么是线程调度器和时间分片？</span></h2>
<p><strong>线程调度器(Thread Scheduler)</strong></p>
<ul>
<li>是操作系统内核中的一个组件，负责为就绪状态的线程分配并管理CPU时间，控制多线程程序的执行顺序</li>
<li>当有多个线程同时运行时，线程调度器会在这些线程之间进行切换，使得每个线程都有机会使用 CPU 资源，并实现任务的并发执行</li>
<li>线程调度并不受到 Java 虚拟机控制，因此需减少程序对线程优先级的依赖</li>
</ul>
<p><strong>时间分片（Time Slicing）</strong></p>
<ul>
<li>指将可用的 CPU 时间分配给可用的 Runnable 线程的过程</li>
<li>分配 CPU 时间可以基于线程优先级或者线程等待的时间，确保每个线程都能获得一定的运行时间，从而实现多任务并发执行</li>
</ul>
<hr>
<hr>
<h2><span id="为什么-wait-定义在-object-里而不是-thread类里">为什么 wait() 定义在 object 里，而不是 Thread类里？</span></h2>
<p>Java 的锁是对象级别的锁，而不是线程级别，所以 wait()是 Object 的方法。 sleep() 是线程级别的，所以存在于Thread 类中</p>
<hr>
<h2><span id="为什么线程通信的方法-wait-notify和-notifyall被定义在-object-类里">为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</span></h2>
<p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法</p>
<p>因为这些方法的调用是依赖锁对象，而同步代码块的锁对象是任意。锁而Object代表任意的对象，所以定义在这里面。</p>
<hr>
<h2><span id="thread-类中的-yield-方法有什么作用">Thread 类中的 yield 方法有什么作用？</span></h2>
<ul>
<li>用于暂停当前线程（运行状态转为就绪状态），使得其他线程可以获得执行机会</li>
<li>在高并发场景下，为了平衡线程的负载和提高系统的整体性能（当前线程没有被调度器选择执行，而其他线程又没有占用 CPU 时）</li>
<li>但是也可能导致资源的浪费和系统的混乱。因为它可能让当前闲置的线程让出 CPU 资源给其他线程，但这些其他线程可能很快又变得不活跃，这可能导致 CPU 在不同线程之间频繁切换，反而降低了系统的整体性能。在使用时需要考虑到系统的整体负载和资源利用率</li>
</ul>
<hr>
<h2><span id="为什么-thread-类的-sleep和-yield-方法是静态的">为什么 Thread 类的 sleep()和 yield ()方法是静态的？</span></h2>
<p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行</p>
<p>所以在其他处于等待状态的线程上调用这些方法是没有意义的</p>
<p>这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法</p>
<hr>
<h2><span id="线程的-sleep方法和-yield方法有什么区别">线程的 sleep()方法和 yield()方法有什么区别？</span></h2>
<ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；而yield()方法只会给相同优先级或更高优先级的线程以运行的机会</li>
<li>线程执行sleep()方法后会转入阻塞状态，所以，执行sleep()方法后的线程在指定的时间内肯定不会呗执行，而yield（）方法只是使当前线程重新回到可执行状态，所以执行yield（）方法的线程可能在在进入到可执行状态后马上又被执行</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常</li>
<li>sleep()方法比yield()方法具有更好的可移植性</li>
</ul>
<hr>
<h2><span id="多线程的中断是什么">多线程的中断是什么？</span></h2>
<p>线程在运行过程中，有些时候可能需要中断一些阻塞的线程</p>
<p>类Thread中提供了几种中断线程的方法，其中Thread.suspend()和Thread.stop()方法已经过时了，因为这两个方法是不安全的</p>
<p>Thread.stop()，会直接终止该线程，并且会立即释放这个线程持有的所有锁，而这些锁恰恰是用来维持数据的一致性的</p>
<p>如果此时。写线程写入数据时写到一半，并强行终止，由于此时对象锁已经被释放，另一个等待该锁的读线程就会读到这个不一致的对象</p>
<p>hread.suspend()会导致死锁，Thread.resume()也不能使用。</p>
<hr>
<h2><span id="java-中-interrupted-和-isinterrupted-方法的区别">Java 中 interrupted 和 isInterrupted 方法的区别？</span></h2>
<ul>
<li>interrupted：查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了</li>
<li>isInterrupted仅仅是查询当前线程的中断状态</li>
</ul>
<hr>
<h2><span id="你对线程优先级的理解是什么">你对线程优先级的理解是什么？</span></h2>
<ul>
<li>每一个线程都是有优先级的.</li>
<li>一般来说，高优先级的线程在运行时会具有优先权. 但这依赖于线程调度的实现.这个实现是和操作系统相关的</li>
<li>线程优先级是一个int 变量(从 1-10).1 代表最低优先级.10 代表最高优先级。</li>
</ul>
<hr>
<h2><span id="线程类的构造方法-静态块是被哪个线程调用的">线程类的构造方法、静态块是被哪个线程调用的</span></h2>
<ul>
<li>被new这个线程类所在的线程所调用的</li>
<li>而run方法里面的代码才是被线程自身所调用的</li>
<li>举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：<br>
(1)Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的；<br>
(2)Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的；</li>
</ul>
<hr>
<h2><span id="一个线程运行时发生异常会怎样">一个线程运行时发生异常会怎样？</span></h2>
<ul>
<li>如果异常没有被捕获该线程将会停止执行</li>
<li>Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM 会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler 并将线程和异常作为参数传递给handler 的uncaughtException()方法进行处理</li>
</ul>
<h2><span id="java-线程数过多会造成什么异常">Java 线程数过多会造成什么异常？</span></h2>
<ul>
<li>线程的生命周期开销非常高</li>
<li>消耗过多的CPU 资源<br>
如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU 资源时还将产生其他性能的开销。</li>
<li>降低稳定性<br>
JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</li>
</ul>
<hr>
<h2><span id="什么是-futuretask">什么是 FutureTask？</span></h2>
<p>FutureTask 表示一个异步运算的任务</p>
<p>FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作</p>
<p>由于 FutureTask<br>
也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中</p>
<hr>
<h2><span id="线程之间如何进行通讯的">线程之间如何进行通讯的？</span></h2>
<p>通常多个线程的运行是互不干扰的，但是CPU对线程的切换是随机的，若想让多个线程之间有规律的运行，就需要线程通讯</p>
<p>从而让多个线程按照我们预期的运行过程去执行</p>
<ul>
<li>wait()：当前线程释放锁并且进入就绪状态<br>
notify()：唤醒当前线程，唤醒调用wait()方法进入就绪状态后的线程<br>
notifyAll()：唤醒所有进入就绪状态的线程</li>
<li>join()方法：使A线程加入B线程中执行，B线程进入阻塞状态，只有当A线程运行结束后B线程才会继续执行</li>
<li>volatile关键字：实现线程变量之间真正共享，多个线程同时监控着共享变量，当变量发生变化时其它线程立即改变，具体实现与JMM内存模型有关</li>
</ul>
<hr>
<h2><span id="线程安全的概念">线程安全的概念？</span></h2>
<p>多个线程可以共享进程的堆和方法区资源，既多个线程共享类变量</p>
<p>多个线程共享一个进程的变量时，如果线程对这个变量只有读操作，没有更新操作则这个线程没有线程安全问题</p>
<p>如果线程需要对这个变量进行修改操作，则可能会因为数据更新不及时导致变量信息不准确而引发线程不安全</p>
<hr>
<h2><span id="线程安全如何保证">线程安全如何保证？</span></h2>
<p>当多个线程对同一个资源进行操作的时候就会有线程安全</p>
<p>解决线程安全的核心思想就是加锁</p>
<ul>
<li>JVM提供的锁，就是synchronized锁，即同步代码和同步代码块</li>
<li>jdk提供的各种锁，如lock</li>
</ul>
<hr>
<h2><span id="java中哪些集合是线程安全的">Java中哪些集合是线程安全的？</span></h2>
<ul>
<li>在JDK1.1版本中，所有的集合都是线程安全的</li>
<li>但是在1.2及以后的版本中就出现了一些线程不安全的集合</li>
<li>因为线程不安全的集合普遍比线程安全的集合效率高的多。在JDK源码中相同效果的集合线程安全的比线程不安全的仅仅多了一个同步机制，但是效率上却低了不少，而且对线程不安全的集合加锁以后也能达到安全的效果（但是效率会低，因为会有锁的获取以及等待）</li>
</ul>
<p>下面列举一些常用的线程安全的集合</p>
<ul>
<li>Vector：就比ArrayList多了个同步化机制</li>
<li>HashTable：就比HashMap多了个线程安全</li>
<li>ConcurrentHashMap：是一种高效但是线程安全的集合</li>
<li>Stack：栈，线程安全，继承与Vector</li>
</ul>
<hr>
<h2><span id="synchronized-关键字用法">synchronized 关键字用法？</span></h2>
<ul>
<li>
<p>修饰实例方法: 作用于当前<strong>对象实例</strong>加锁，进入同步代码前要获得当前对象实例的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰静态方法: 也就是给<strong>当前类</strong>加锁，会作用于类的所有对象实例</p>
<p>进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰代码块 ：指定加锁对象，对<strong>给定对象/类</strong>加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得当前 class 的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2><span id="构造方法可以使用-synchronized-关键字修饰么">构造方法可以使用 synchronized 关键字修饰么？</span></h2>
<ul>
<li>构造方法不能使用 synchronized 关键字修饰</li>
<li>构造方法本身就属于线程安全的，不存在同步的构造方法一说</li>
</ul>
<hr>
<h2><span id="synchronized使用双重校验锁实现对象单例线程安全">synchronized使用：双重校验锁实现对象单例(线程安全)。</span></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">	<span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 提供getInstance方法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="同步和异步的区别">同步和异步的区别？</span></h2>
<ul>
<li>同步：功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。这时程序是阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。因此，简单来说，同步就是必须一件一件做事，等前一件事做完了才能做完下一件事</li>
<li>异步：与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作，当这个调用完成后，一般通过状态或者回调来通知调用者</li>
</ul>
<hr>
<h2><span id="同步方法和同步块哪个是更好的选择">同步方法和同步块，哪个是更好的选择？</span></h2>
<ul>
<li>同步块，因为同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率（同步的范围越小越好）</li>
</ul>
<hr>
<h2><span id="为什么-wait-notify和-notifyall必须在同步方法或者同步块中被调用">为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</span></h2>
<p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁</p>
<p>接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法</p>
<p>当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁</p>
<p>由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用</p>
<hr>
<h2><span id="什么是线程同步和线程互斥">什么是线程同步和线程互斥？</span></h2>
<p><strong>线程同步</strong></p>
<ul>
<li>指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）</li>
<li>也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！</li>
</ul>
<p><strong>线程互斥</strong></p>
<ul>
<li>指对于共享的进程系统资源，在各单个线程访问时的排它性</li>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）</li>
</ul>
<hr>
<h2><span id="什么是线程池">什么是线程池？</span></h2>
<ul>
<li>提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务</li>
<li>由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能</li>
</ul>
<hr>
<h2><span id="为什么要用线程池">为什么要用线程池？</span></h2>
<ul>
<li>使用继承Thread或者实现Runnable接口的方式来创建及销毁线程会产生耗费资源、线程上下文切换问题</li>
<li>同时创建过多的线程也可能引发资源耗尽的风险</li>
<li>线程池方便线程任务的管理。java中涉及到线程池的相关类均在jdk1.5开始的java.util.concurrent包中，涉及到的几个核心类及接口包括：Executor、Executors、ExecutorService、ThreadPoolExecutor、FutureTask、Callable、Runnable等</li>
</ul>
<hr>
<h2><span id="线程池的优势">线程池的优势？</span></h2>
<ul>
<li>提供了一种限制和管理资源（包括执行一个任务）</li>
<li>每个线程池还维护一些基本统计信息，例如已完成任务的数量</li>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>
<hr>
<h2><span id="线程池的工作原理">线程池的工作原理？</span></h2>
<ul>
<li>线程提交到线程池</li>
<li>判断核心线程池是否已经达到设定的数量，如果没有达到，则直接创建线程执行任务</li>
<li>如果达到了，则放在队列中，等待执行</li>
<li>如果队列已经满了，则判断线程的数量是否已经达到设定的最大值，如果达到了，则直接执行拒绝策略</li>
<li>如果没有达到，则创建线程执行任务</li>
</ul>
<hr>
<h2><span id="线程池都有哪些状态">线程池都有哪些状态？</span></h2>
<ul>
<li>RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）</li>
<li>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态</li>
<li>TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态</li>
<li>TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做</li>
</ul>
<hr>
<h2><span id="什么是executors">什么是Executors？</span></h2>
<ul>
<li>Executor是一个线程池框架</li>
<li>Executor 位于java.util.concurrent.Executors，提供了用于创建工作线程的线程池的工厂方法。它包含一组用于有效管理工作线程的组件</li>
<li>Executor API 通过 Executors 将任务的执行与要执行的实际任务解耦</li>
</ul>
<hr>
<h2><span id="在-java-中-executor-和-executors-的区别">在 Java 中 Executor 和 Executors 的区别？</span></h2>
<p>Executor接口对象能执行我们的线程任务<br>
Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求<br>
ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法，我们能够获得任务执行的状态并且可以获取任务的返回值</p>
<hr>
<h2><span id="executors新建线程池类型">Executors新建线程池类型？</span></h2>
<ul>
<li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
<li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行</li>
</ul>
<hr>
<h2><span id="executors新建线程池的弊端">Executors新建线程池的弊端？</span></h2>
<ul>
<li>newFixedThreadPool和newSingleThreadExecutor：堆积的请求处理队列可能会耗费非常大的内存，甚至OOM</li>
<li>newCachedThreadPool和newScheduledThreadPool：线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM</li>
<li>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，规避资源耗尽的风险</li>
</ul>
<hr>
<h2><span id="什么是threadpoolexecutor">什么是ThreadPoolExecutor？</span></h2>
<p>ThreadPoolExecutor是线程池的核心实现类，在JDK1.5引入，位于java.util.concurrent包。</p>
<hr>
<h2><span id="通过threadpoolexecutor如何创建线程池">通过ThreadPoolExecutor如何创建线程池？</span></h2>
<p>通过下面的demo来了解ThreadPoolExecutor创建线程的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolSerialTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//超过 corePoolSize 线程数量的线程最大空闲时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//以秒为时间单位</span></span><br><span class="line">        <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">        <span class="comment">//创建工作队列，用于存放提交的等待执行任务</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建线程池</span></span><br><span class="line">            threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line">                    maximumPoolSize,</span><br><span class="line">                    keepAliveTime,</span><br><span class="line">                    unit,</span><br><span class="line">                    workQueue,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//循环提交任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//提交任务的索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (i + <span class="number">1</span>);</span><br><span class="line">                threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">//线程打印输出</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;大家好，我是线程：&quot;</span> + index);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//模拟线程执行时间，10s</span></span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//每个任务提交后休眠500ms再提交下一个任务，用于保证提交顺序</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个新任务被提交时：</p>
<ul>
<li>当前活跃线程数&lt;corePoolSize，则创建一个新线程执行新任务；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）未满时，则将新任务放入队列中；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）已满，且当前活跃线程数&lt;maximumPoolSize，则继续创建一个新线程执行新任务；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）已满，且当前活跃线程数=maximumPoolSize，则执行拒绝策略（handler）;</li>
</ul>
<p>当任务执行完成后：</p>
<ul>
<li>超出corePoolSize的空闲线程，在等待新任务时，如果超出了keepAliveTime，则线程会被销毁；</li>
<li>如果allowCoreThreadTimeOut被设置为true，那么corePoolSize以内的空闲线程，如果超出了keepAliveTime，则同样会被销毁。</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor线程池中的几种重要的参数">ThreadPoolExecutor线程池中的几种重要的参数？</span></h2>
<ul>
<li>corePoolSize：线程池中的核心线程数量，这几个核心线程在没有用的时候，也不会被回收</li>
<li>maximumPoolSize：线程池中可以容纳的最大线程的数量</li>
<li>keepAliveTime：除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清 除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间</li>
<li>util：计算这个时间的一个单位</li>
<li>workQueue：等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）</li>
<li>threadFactory：创建线程的线程工厂</li>
<li>handler：拒绝策略，我们可以在任务满了之后，拒绝执行某些任务</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor饱和拒绝策略是什么">ThreadPoolExecutor饱和(拒绝)策略是什么？</span></h2>
<ul>
<li>当线程充满了ThreadPool的有界队列时，饱和策略开始起作用</li>
<li>饱和策略可以理解为队列饱和后，处理后续无法入队的任务的策略</li>
<li>ThreadPoolExecutor可以通过调用setRejectedExecutionHandler来修改饱和策略</li>
</ul>
<hr>
<h2><span id="说说线程池的拒绝策略">说说线程池的拒绝策略？</span></h2>
<p>当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务</p>
<p>JDK默认提供的四种拒绝策略（在ThreadPoolExecutor中）</p>
<ul>
<li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li>
<li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</li>
<li>DiscardOleddestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理</li>
</ul>
<p>自定义拒绝策略</p>
<ul>
<li>RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor的execute方法和-submit方法的区别是什么呢">ThreadPoolExecutor的execute()方法和 submit()方法的区别是什么呢？</span></h2>
<ul>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</li>
<li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完</li>
</ul>
<hr>
<h2><span id="什么是线程组为什么在-java-中不推荐使用">什么是线程组，为什么在 Java 中不推荐使用？</span></h2>
<ul>
<li>线程组ThreadGroup对象中的stop，resume，suspend会导致安全问题，主要是死锁问题</li>
<li>线程组ThreadGroup不是线程安全的，在使用过程中不能及时获取安全的信息</li>
</ul>
<hr>
<h2><span id="线程池如何关闭">线程池如何关闭？</span></h2>
<ul>
<li>shutdownNow()：立即关闭线程池(暴力)，正在执行中的及队列中的任务会被中断，同时该方法会返回被中断的队列中的任务列表</li>
<li>shutdown()：平滑关闭线程池，正在执行中的及队列中的任务能执行完成，后续进来的任务会被执行拒绝策略</li>
<li>isTerminated()：当正在执行的任务及对列中的任务全部都执行（清空）完就会返回true</li>
</ul>
<hr>
<h2><span id="线程池的复用原理">线程池的复用原理？</span></h2>
<ul>
<li>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制</li>
<li>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来</li>
</ul>
<hr>
<h2><span id="线程池都有哪几种工作队列">线程池都有哪几种工作队列？</span></h2>
<ul>
<li>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序</li>
<li>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</li>
<li>SynchronousQueue 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool()使用了这个队列</li>
<li>PriorityBlockingQueue 一个具有优先级的无限阻塞队列</li>
</ul>
<hr>
<h2><span id="springboot如何整合线程池">SpringBoot如何整合线程池？</span></h2>
<p>首先是利用好SpringBoot的自动装配功能，配置好线程池的一些基本参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTaskConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 线程池名前缀</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">threadNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;Api-Async-&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean的名称， 默认为首字母小写的方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;taskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，</span></span><br><span class="line"><span class="comment">     * 当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</span></span><br><span class="line"><span class="comment">     * 当队列满了，就继续创建线程，当线程数量大于等于maxPoolSize后，开始使用拒绝策略拒绝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 核心线程数（默认线程数）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">//缓冲队列数</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">//允许线程空闲时间（单位是秒）</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveTime);</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        <span class="comment">//用来设置线程池关闭时候等待所有任务都完成再继续销毁其他的Bean</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//线程池对拒绝任务的处理策略，CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好线程池的基本参数时候，我们就可以使用线程池了， 只要在一个限定域为public的方法头部加上@Async注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行任务&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="线程池的优化">线程池的优化？</span></h2>
<ul>
<li>
<p>分析任务的特性</p>
<p>任务的性质：CPU 密集型任务、IO 密集型任务和混合型任务。<br>
任务的优先级：高、中、低。<br>
任务的执行时间：长、中、短。<br>
任务的依赖性：是否依赖其他系统资源，如数据库连接</p>
</li>
<li>
<p>具体策略</p>
<ul>
<li>CPU 密集型任务配置尽可能小的线程，如配置N（CPU核心数）+1个线程的线程池。</li>
<li>IO 密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*N（CPU核心数）。</li>
<li>混合型任务如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务。只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率；如果这两个任务执行时间相差太大，则没必要进行分解。</li>
<li>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理，它可以让优先级高的任务先得到执行。但是，如果一直有高优先级的任务加入到阻塞队列中，那么低优先级的任务可能永远不能执行。</li>
<li>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</li>
<li>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，线程数应该设置得较大，这样才能更好的利用 CPU。</li>
<li>建议使用有界队列，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。使用无界队列，线程池的队列就会越来越大，有可能会撑满内存，导致整个系统不可用。</li>
</ul>
</li>
</ul>
<hr>
<h2><span id="什么是threadlocal">什么是ThreadLocal？</span></h2>
<p>从字面上理解ThreadLocal就是“线程局部变量”的意思</p>
<p>简单的说就是，一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的（每个线程都只能看到自己线程的值）</p>
<ul>
<li>
<p>set()：赋值操作</p>
</li>
<li>
<p>get()：获取变量中的值</p>
</li>
<li>
<p>remove()：删除当前这个变量的值</p>
<p>需要注意的是initialValue方法会在第一次调用时被触发，用于初始化当前变量值，例如在下列代码中我们需要创建一个ThreadLocal，用于创建一个与线程绑定的Connection对象：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadLocal</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(…);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>每个ThreadLocal实例内部都可以保存一个值（基本数据类型值或者引用类型的引用值），这个值是可以修改的</li>
<li>每一个ThreadLocal实例就类似于一个变量名，不同的ThreadLocal实例就是不同的变量名，它们内部会存有一个值（暂时这么理解）在后面的描述中所说的“ThreadLocal变量或者是线程变量”代表的就是ThreadLocal类的实例</li>
<li>通过重写initialValue方法指定ThreadLocal变量的初始值，默认情况下initialValue返回的是null</li>
</ul>
<hr>
<h2><span id="threadlocal的具体实现">ThreadLocal的具体实现?</span></h2>
<p>一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的（每个线程都只能看到自己线程的值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; num = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 重写这个方法，可以修改“线程变量”的初始值，默认是null</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一号线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 在一号线程中将ThreadLocal变量设置为1</span></span><br><span class="line">                num.set(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;一号线程中ThreadLocal变量中保存的值为：&quot;</span> + num.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建二号线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                num.set(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;二号线程中ThreadLocal变量中保存的值为：&quot;</span> + num.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//为了让一二号线程执行完毕，让主线程睡500ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中ThreadLocal变量中保存的值：&quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码中在类中创建了一个静态的“ThreadLocal变量”，在主线程中创建两个线程，在这两个线程中分别设置ThreadLocal变量为1和2。然后等待一号和二号线程执行完毕后，在主线程中查看ThreadLocal变量的值</li>
<li>程序结果重点看的是主线程输出的是0，如果是一个普通变量，在一号线程和二号线程中将普通变量设置为1和2，那么在一二号线程执行完毕后在打印这个变量，输出的值肯定是1或者2（到底输出哪一个由操作系统的线程调度逻辑有关）</li>
<li>但使用ThreadLocal变量通过两个线程赋值后，在主线程程中输出的却是初始值0。在这也就是为什么“一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的”，每个线程都只能看到自己线程的值，这也就是ThreadLocal的核心作用：实现线程范围的局部变量</li>
</ul>
<hr>
<h2><span id="threadlocal的原理分析">ThreadLocal的原理分析?</span></h2>
<p>每个Thread对象都有一个ThreadLocalMap</p>
<p>当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中</p>
<p>其中键就是ThreadLocal，值可以是任意类型</p>
<p>想要存入的ThreadLocal中的数据实际上并没有存到ThreadLocal对象中去，而是以这个ThreadLocal实例作为key存到了当前线程中的一个Map中去了</p>
<p>获取ThreadLocal的值时同样也是这个道理。这也就是为什么ThreadLocal可以实现线程之间隔离的原因了</p>
<ul>
<li>ThreadLocal的作用：实现线程范围内的局部变量，即ThreadLocal在一个线程中是共享的，在不同线程之间是隔离的。</li>
<li>ThreadLocal的原理：ThreadLocal存入值时使用当前ThreadLocal实例作为key，存入当前线程对象中的Map中去。最开始在看源码之前，我以为是以当前线程对象作为key将对象存入到ThreadLocal中的Map中去</li>
</ul>
<hr>
<h2><span id="threadlocal和synchonized区别">ThreadLocal和Synchonized区别？</span></h2>
<ul>
<li>两者都用于解决多线程并发访问</li>
<li>但是Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离</li>
<li>Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享</li>
<li>而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享</li>
</ul>
<hr>
<h2><span id="threadlocal内存泄漏以及解决方案">ThreadLocal内存泄漏以及解决方案？</span></h2>
<ul>
<li>如果ThreadLocal没有外部强引用，那么在发生垃圾回收的时候，ThreadLocal就必定会被回收</li>
<li>而ThreadLocal又作为Map中的key，ThreadLocal被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li>
<li>解决方案：每次使用完ThreadLocal都调用它的remove()方法清除数据，或者按照JDK建议将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进</li>
</ul>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            集合源码
          
        </div>
      </a>
    
    
      <a href="/post/%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80api/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">常用类、基础API</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '3cdc50fed141dacb5545',
    clientSecret: 'efa362468591880b87d44cbe3e1c41428af53b94',
    repo: 'gitalk',
    owner: 'biyixia',
    admin: ['biyixia'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> biyixia
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="biyixia"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>



    
    

  </div>
</body>

</html>