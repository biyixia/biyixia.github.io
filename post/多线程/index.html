<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>多线程 |  biyixia</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="biyixia" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-多线程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  多线程
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2024-05-06T08:12:04.213Z" itemprop="datePublished">2024-05-06</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">19.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">71 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2><span id="为什么引入进程的概念">为什么引入进程的概念？</span></h2>
<p>- 从理论角度看，是对正在运行的程序过程的抽象<br>
 - 从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序</p>
<h2><span id="什么是程序">什么是程序？</span></h2>
<ul>
<li>程序是用于完成某个指定任务的指令集合</li>
<li>是一段静态的代码</li>
</ul>
<h2><span id="什么是进程">什么是进程？</span></h2>
<ul>
<li>进程就是一段程序的执行过程（内存中正在运行的应用程序）</li>
</ul>
<h2><span id="进程有怎么样的特征">进程有怎么样的特征？</span></h2>
<ul>
<li>动态性：相比于静态的程序，进程是一段程序的执行过程，包括了进程从创建、运行到消亡的过程（生命周期）</li>
<li>独立性：进程是操作系统调度和资源分配的最小单位（系统运行的基本单位），系统在运行时为每个进程分配不同的内存（进程间的内存不共享导致相互数据交换和通信的成本高）</li>
<li>并发性：任何进程都可以同其他进程一起并发执行，现代操作系统大多都支持多进程</li>
<li>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果； 但是执行过程中，程序不能发生改变</li>
</ul>
<h2><span id="什么是线程">什么是线程？</span></h2>
<p>进程进一步细化为线程，是程序内部的一条执行路径，一个进程中至少有一个线程</p>
<p>是CPU调度和执行的最小单位</p>
<p>线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源（程序计数器(PC)、虚拟机栈和本地方法栈），但它可与同属一个进程的其它线程共享进程所拥有的全部资源（内存单元）</p>
<p><img src="https://pic.imgdb.cn/item/665193bbd9c307b7e9992370.png" alt></p>
<p>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行</p>
<h2><span id="进程和线程的区别">进程和线程的区别？</span></h2>
<ul>
<li>进程是正在运行中的程序，是系统进行资源调度和分配的的基本单位；线程是进程的子任务，是任务调度和执行的基本单位</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在</li>
<li>进程在执行过程中拥有独立的内存单元，而线程不拥有系统资源，但可以与同属于一个进程的其他线程共享进程的全部资源</li>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>
<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li>
<li>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销</li>
<li>每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文</li>
</ul>
<hr>
<h2><span id="什么是并行-并发">什么是并行、并发？</span></h2>
<ul>
<li>
<p>并行：两个或以上的事件在同一时刻发生（在同一时刻有多条CPU指令在多个CPU上同时执行）</p>
<p><img src="https://pic.imgdb.cn/item/66519c89d9c307b7e9a40d34.png" alt></p>
</li>
<li>
<p>并发：两个或以上的事件在同一时间段内发生（在一段时间内有多条CPU指令在一个CPU上快速轮换、交替），宏观上具有多个进程同时执行的效果</p>
<p><img src="https://pic.imgdb.cn/item/66519ca5d9c307b7e9a432d3.png" alt></p>
</li>
</ul>
<hr>
<h2><span id="什么是多进程-多线程">什么是多进程、多线程？</span></h2>
<ul>
<li>多进程是指操作系统能同时运行多个任务（程序）</li>
<li>多线程是指在同一程序中有多个顺序流在执行（一个进程同一时间并行执行多个线程）</li>
</ul>
<p>那什么是多线程？提到多线程这里要说两个概念，就是串行和并行</p>
<p>所谓串行，其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子：当我们下载多个文件时，在串行中它是按照一定的顺序去进行下载的，也就是说，必须等下载完A之后才能开始下载B，它们在时间上是不可能发生重叠的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/df594ffe5bcceb97c4f7796f50baa006.png" alt="640"></p>
<p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的，在同一时刻发生的，并行在时间上是重叠的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/23c3fbc0f394789e150fdf8781cafadd.png" alt="640"></p>
<p>举个例子，我们打开腾讯管家，腾讯管家本身就是一个程序，也就是说它就是一个进程，它里面有很多的功能，能查杀病毒、清理垃圾、电脑加速等众多功能。</p>
<p>按照单线程来说，无论你想要清理垃圾、还是要病毒查杀，那么你必须先做完其中的一件事，才能做下一件事，这里面是有一个执行顺序的。</p>
<p>如果是多线程的话，我们其实在清理垃圾的时候，还可以进行查杀病毒、电脑加速等等其他的操作，这个是严格意义上的同一时刻发生的，没有执行上的先后顺序</p>
<h2><span id="什么是线程安全">什么是线程安全？</span></h2>
<p>当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的</p>
<p>确保在多条线程访问同一个方法时，程序是否还能按照预期的行为执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    count ++;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启3条线程，每个线程循环10次执行以上方法，得到以下结果：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ceb145de48e6c58699c65b55c909804b.png" alt="640"></p>
<p>我们可以看到，这里出现了两个26，出现这种问题的原因有很多。</p>
<p>最常见的一种，就是我们A线程在进入方法后，拿到了count的值，刚把这个值读取出来，还没有改变count的值的时候，结果线程B也进来的，那么导致线程A和线程B拿到的count值是一样的。</p>
<p>Java中确保线程安全最常用的两种方式。先来看段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">    j = j + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家觉得这段代码是线程安全的吗？</p>
<p>毫无疑问，它绝对是线程安全的，我们来分析一下，为什么它是线程安全的？</p>
<p>我们可以看到这段代码是没有任何状态的，就是说我们这段代码，不包含任何的作用域，也没有去引用其他类中的域进行引用，它所执行的作用范围与执行结果只存在它这条线程的局部变量中，并且只能由正在执行的线程进行访问。当前线程的访问，不会对另一个访问同一个方法的线程造成任何的影响。</p>
<p>两个线程同时访问这个方法，因为没有共享的数据，所以他们之间的行为，并不会影响其他线程的操作和结果，所以说无状态的对象，也是线程安全的。</p>
<p><strong>添加一个状态呢？</strong></p>
<p>如果我们给这段代码添加一个状态，添加一个count，来记录这个方法并命中的次数，每请求一次count+1，那么这个时候这个线程还是安全的吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;   </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 记录方法的命中次数   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;  </span><br><span class="line">        count++ ;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;      </span><br><span class="line">        j = j + i;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显已经不是了，单线程运行起来确实是没有任何问题的，但是当出现多条线程并发访问这个方法的时候，问题就出现了，我们先来分析下count+1这个操作。</p>
<p>进入这个方法之后首先要读取count的值，然后修改count的值，最后才把这把值赋值给count，总共包含了三步过程：“读取”一&gt;“修改”一&gt;“赋值”，既然这个过程是分步的，那么我们先来看下面这张图，看看你能不能看出问题：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b32fdb479959903bf9dd76408b2867c1.png" alt="640?"></p>
<p>可以发现，count的值并不是正确的结果，当线程A读取到count的值，但是还没有进行修改的时候，线程B已经进来了，然后线程B读取到的还是count为1的值，正因为如此所以我们的count值已经出现了偏差，那么这样的程序放在我们的代码中，是存在很多的隐患的。</p>
<h2><span id="如何确保线程安全">如何确保线程安全？</span></h2>
<p>synchronized关键字</p>
<ul>
<li>
<p>控制线程同步的，保证我们的线程在多线程环境下，不被多个线程同时执行，确保我们数据的完整性</p>
</li>
<li>
<p>当synchronized锁住一个对象之后，别的线程如果想要获取锁对象，那么就必须等这个线程执行完释放锁对象之后才可以，否则一直处于等待状态</p>
</li>
<li>
<p>要注意缩小synchronized的使用范围，如果随意使用时很影响程序的性能，别的对象想拿到锁，结果你没用锁还一直把锁占用，这样就有点浪费资源</p>
</li>
<li>
<p>使用方法一般是加在方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 记录方法的命中次数  </span></span><br><span class="line">    <span class="comment">// 锁的是括号里的对象，而不是代码，其次，对于非静态的synchronized方法，锁的是对象本身也就是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">threadMethod</span><span class="params">(<span class="type">int</span> j)</span> &#123;    </span><br><span class="line">        count++ ;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;    </span><br><span class="line">        j = j + i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Lock</p>
<ul>
<li>从Java1.6开始引入Lock，Lock的引入让锁有了可操作性，就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// ReentrantLock是Lock的子类   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span>&#123;    </span><br><span class="line">    lock.lock(); </span><br><span class="line">    <span class="comment">// 获取锁对象  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        <span class="comment">// Thread.sleep(2000);    </span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;       </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);     </span><br><span class="line">        lock.unlock(); <span class="comment">// 手动释放锁对象，无论如何都会执行    </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="type">LockTest</span> <span class="variable">lockTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockTest</span>();    </span><br><span class="line">    <span class="comment">// 线程1     </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;     </span><br><span class="line">        <span class="meta">@Override</span>         </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;      </span><br><span class="line">            <span class="comment">// Thread.currentThread()  返回当前线程的引用     </span></span><br><span class="line">            lockTest.method(Thread.currentThread());      </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);    </span><br><span class="line">    <span class="comment">// 线程2   </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;   </span><br><span class="line">        <span class="meta">@Override</span>   </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;      </span><br><span class="line">            lockTest.method(Thread.currentThread());   </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);   </span><br><span class="line">    t1.start();     </span><br><span class="line">    t2.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e508507c0b74d1503d6d1a75b5668cf7.png" alt="640?"></p>
<p>其实在Lock还有几种获取锁的方式，我们这里再说一种，就是tryLock()这个方法跟Lock()是有区别的，Lock在获取锁的时候，如果拿不到锁，就一直处于等待状态，直到拿到锁，但是tryLock()却不是这样的，tryLock是有一个Boolean的返回值的，如果没有拿到锁，直接返回false，停止等待，它不会像Lock()那样去一直等待获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span>&#123;     </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象   </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;    </span><br><span class="line">        <span class="keyword">try</span> &#123;          </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);    </span><br><span class="line">            <span class="comment">// Thread.sleep(2000);      </span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;     </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);      </span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 释放锁对象    </span></span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：我们继续使用刚才的两个线程进行测试可以发现，在线程t1获取到锁之后，线程t2立马进来，然后发现锁已经被占用，那么这个时候它也不在继续等待。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a2997ff879b806a31a0d8debcaae457b.png" alt="640?"></p>
<p>似乎这种方法，感觉不是很完美，如果我第一个线程，拿到锁的时间，比第二个线程进来的时间还要长，是不是也拿不到锁对象？</p>
<p>那我能不能，用一中方式来控制一下，让后面等待的线程，可以等待5秒，如果5秒之后，还获取不到锁，那么就停止等，其实tryLock()是可以进行设置等待的相应时间的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象      </span></span><br><span class="line">    <span class="comment">// 如果2秒内获取不到锁对象，那就不再等待       </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>,TimeUnit.SECONDS)) &#123;         </span><br><span class="line">        <span class="keyword">try</span> &#123;              </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);    </span><br><span class="line">            <span class="comment">// 这里睡眠3秒            </span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);         </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;             </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;             </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);    </span><br><span class="line">            lock.unlock(); </span><br><span class="line">            <span class="comment">// 释放锁对象  </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：看上面的代码，我们可以发现，虽然我们获取锁对象的时候，可以等待2秒，但是我们线程t1在获取锁对象之后，执行任务缺花费了3秒，那么这个时候线程t2是不在等待的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2034afb57a67bb10615cd4002d887abc.png" alt="640?"></p>
<p>我们再来改一下这个等待时间，改为5秒，再来看下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException &#123;   </span><br><span class="line">    <span class="comment">// lock.lock(); // 获取锁对象     </span></span><br><span class="line">    <span class="comment">// 如果5秒内获取不到锁对象，那就不再等待     </span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS)) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;             </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;         </span><br><span class="line">            e.printStackTrace();         </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;           </span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);  </span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 释放锁对象    </span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：这个时候我们可以看到，线程t2等到5秒获取到了锁对象，执行了任务代码。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1df3ef93e83b5c5fd84c100c15a0b8ef.png" alt="640?"></p>
<p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p>
<p>在Java中，一个应用程序可以包含多个线程。每个线程执行特定的任务，并可与其他线程并发执行多线程使系统的空转时间最少，提高CPU利用率、多线程编程环境用方便的模型隐藏CPU在任务间切换的事实在Java程序启动时，一个线程立刻运行，该线程通常称为程序的主线程。</p>
<p>主线程的重要性体现在两个方面：</p>
<p>1、它是产生其他子线程的线程。</p>
<p>2、通常它必须最后完成执行，因为它执行各种关闭动作。</p>
<p>进程和线程的关系：</p>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源</li>
<li>处理机分给线程，即真正在处理机上运行的是线程</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体</li>
</ul>
<hr>
<h2><span id="为什么要使用多线程呢">为什么要使用多线程呢?</span></h2>
<p>我们现在所使用操作系统都是多任务操作系统(早期使用的DOS操作系统为单任务操作系统)，多任务操作指在同一时刻可以同时做多件事(可以同时执行多个程序)。<br>
多进程:每个程序都是一个进程，在操作系统中可以同时执行多个程序,多进程的目的是为了有效的使用CPU资源，每开一个进程系统要为该进程分配相关的系统资源(内存资源)；<br>
多线程:线程是进程内部比进程更小的执行单元(执行流|程序片段),每个线程完成一个任务,每个进程内部包含了多个线程每个线程做自己的事情，在进程中的所有线程共享该进程的资源；<br>
主线程:在进程中至少存在一个主线程，其他子线程都由主线程开启,主线程不一定在其他线程结束后结束，有可能在其他线程结束前结束。Java中的主线程是main线程,是Java的main函数;</p>
<hr>
<h2><span id="多线程应用场景">多线程应用场景?</span></h2>
<p>当应用场景为计算密集型时：为了将每个cpu充分利用起来，线程数量正常是cpu核数+1，还可以看jdk的使用版本，1.8版本中可以使用cpu核数*2。<br>
当应用场景为io密集型时：做web端开发的时候，涉及到大量的网络传输，不进入持，缓存和与数据库交互也会存在大量io，当发生io时候，线程就会停止，等待io结束，数据准备好，线程才会继续执行，所以当io密集时，可以多创建点线程，让线程等待时候，其他线程执行，更高效的利用cpu效率，他有一个计算公式，套用公式的话，双核cpu理想的线程数就是20。</p>
<hr>
<h2><span id="多线程的好处">多线程的好处?</span></h2>
<p>采用多线程技术的应用程序可以更好地利用系统资源。主要优势在于充分利用了CPU的空闲时间片，用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。</p>
<ul>
<li>易于调度</li>
<li>提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分</li>
<li>开销少。创建线程比创建进程要快，所需开销很少</li>
<li>利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行</li>
</ul>
<p>使用线程可以把占据时间长的程序中的任务放到后台去处理<br>
用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>
程序的运行速度可能加快<br>
在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。<br>
多线程技术在IOS软件开发中也有举足轻重的位置。<br>
多线程的缺点</p>
<ul>
<li>提高应用程序的响应。如图形化界面，可增强用户的体验</li>
<li>提高计算机CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程独立运行，利于理解和修改</li>
</ul>
<hr>
<h2><span id="使用多线程可能带来什么问题">使用多线程可能带来什么问题?</span></h2>
<p>如果有大量的线程可能会降低程序的运行速度，可能发生内存泄露、死锁、线程不安全等等问题</p>
<hr>
<h2><span id="多核cpu的效率会是单核cpu的倍数吗">多核CPU的效率会是单核CPU的倍数吗？</span></h2>
<ul>
<li>多个和核心有其他共享资源的限制：如cache、寄存器没有同步扩充</li>
<li>多核CPU之间的协调管理损耗</li>
</ul>
<hr>
<h2><span id="创建线程的几种方式">创建线程的几种方式？</span></h2>
<ul>
<li>继承于Thread类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//重写Thread类的run()---&gt;将此线程要执行的操作声明在run()中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//业务逻辑:获取当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Thread类的子类对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//通过start方法调用当前线程的run方法</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现Runnable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个类去实现Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//实现类去重写run()</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//业务逻辑:获取当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建实现类的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//将此对象作为参数传递到Thread类中的构造器中,创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//通过start方法调用当前线程的run方法</span></span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现Callable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创接一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">// 2.实现call方法,将此线程需要执行的操作声明在call()中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//业务逻辑:获取当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">// 4.将此对象作为传递到FutureTask构造器中,创建FutureTask的对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">// 5.将FutureTask的对象传递到Thread的构造器中,创建Thread对象并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//get()得到的即为线程重写方法的返回值</span></span><br><span class="line">		   <span class="comment">// 6.如果对返回值感兴趣可以用该Object sum = FutureTask的对象.get();</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span>+sum);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个类实现Runable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnalbe</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现类中重写run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个类实现Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现类中重写call()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//3.提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.<span class="keyword">new</span> <span class="title class_">FixedThreadPool</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//设置线程的属性</span></span><br><span class="line">        service.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line">        <span class="comment">//4.创建实现类的对象</span></span><br><span class="line">        <span class="type">NumberThread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberThread1</span>();</span><br><span class="line">        <span class="comment">//5.执行指定的线程操作</span></span><br><span class="line">        service.execute(thread1);<span class="comment">//适合用与Runnalbe</span></span><br><span class="line">        <span class="comment">//6.关闭线程</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());<span class="comment">//适合用于Callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="创建线程用runnable还是thread">创建线程用Runnable还是Thread？</span></h2>
<p>共同点：</p>
<ul>
<li>启动线程使用的都是Thread类中定义的start()方法</li>
<li>创建线程的对象，都是Thread的子类或Thread的实现类</li>
</ul>
<p>不同点：</p>
<ul>
<li>一个是继承类，一个是实现接口</li>
<li>相比与Java只支持单继承，实现Runnable没有单继承的局限</li>
<li>实现Runnable更适合处理有共享数据的问题</li>
<li>实现Runnbale能够分离代码和数据</li>
</ul>
<p>联系：</p>
<ul>
<li>public class Thread implements Runnable  （代理模式）</li>
</ul>
<hr>
<h2><span id="实现runnable接口和callable接口的区别">实现Runnable接口和Callable接口的区别？</span></h2>
<table>
<thead>
<tr>
<th>区别</th>
<th>Runnalbe</th>
<th>Callable</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法</td>
<td>run()</td>
<td>call()</td>
</tr>
<tr>
<td>返回值</td>
<td>没有返回值，void类型</td>
<td>必须有一个返回值，且能通过泛型指定</td>
</tr>
<tr>
<td>异常处理</td>
<td>无法对run()方法抛出的异常进行任何处理</td>
<td>自定义的call()方法可以抛出一个checked Exception，并由其执行者Handler进行捕获并处理</td>
</tr>
<tr>
<td>使用场景</td>
<td>适用于不需要返回值，且不会抛出checked Exception的情况，比如简单的打印输出或者修改一些共享的变量</td>
<td>适用于那些需要返回值或者需要抛出checked Exception的情况，比如对某个任务的计算结果进行处理，或者需要进行网络或IO操作等。常常使用Callable来实现异步任务的处理，以提高系统的吞吐量和响应速度</td>
</tr>
</tbody>
</table>
<hr>
<h2><span id="线程的-run和-start有什么区别">线程的 run()和 start()有什么区别？</span></h2>
<table>
<thead>
<tr>
<th>调用该方法时的区别</th>
<th>run()</th>
<th>start()</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否创建新的线程</td>
<td>在当前线程中执行run()方法中的代码，不会创建新的线程，相当于普通方法</td>
<td>会创建一个新线程去执行run()方法中的代码，因此start方法用来启动相应的线程</td>
</tr>
<tr>
<td>是否能重复调用</td>
<td>可以重复调用</td>
<td>启动后无法重复调用，否则会报IllegalStateException异常</td>
</tr>
<tr>
<td>同步或异步</td>
<td>同步调用run()方法，因此不支持多线程</td>
<td>异步地调用run()方法，支持多线程</td>
</tr>
</tbody>
</table>
<p>使用时调用线程的 start() 方法后，线程处于可运行状态，此时它可以由 JVM 调度并执行，这并不意味着线程就会立即运行;<br>
run() 方法是线程运行时由 JVM 回调的方法，无需手动写代码调用</p>
<hr>
<h2><span id="说说线程的生命周期和状态">说说线程的生命周期和状态?</span></h2>
<p><img src="https://pic.imgdb.cn/item/66521814d9c307b7e93bce26.png" alt></p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20220830/1661828121@6f4fc75b826c73cf923e44f0f1abfd3d.jpg" alt="img"></p>
<p><img src="https://pic.imgdb.cn/item/6652183fd9c307b7e93bfa6a.png" alt></p>
<ul>
<li>
<p>创建状态（New）：新创建了一个线程对象</p>
</li>
<li>
<p>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权</p>
</li>
<li>
<p>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码</p>
</li>
<li>
<p>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态</p>
<p>阻塞的情况分三种：</p>
<ul>
<li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li>
</ul>
</li>
<li>
<p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期</p>
</li>
</ul>
<hr>
<h2><span id="什么是上下文切换">什么是上下文切换?</span></h2>
<p>上下文切换指的是内核操作系统的核心在CPU上对进程或者线程进行切换</p>
<p>在多线程编程中，一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式</p>
<p>当一个线程执行完 CPU 时间片时，就会退回就绪状态，并切换其他的线程，这个过程就是进行了一次上下文切换</p>
<hr>
<h2><span id="如何创建守护线程">如何创建守护线程？</span></h2>
<p>通过Thread类的setDaemon(true)方法将线程设置为守护线程，但是要在线程启动（start方法）前调用，否则抛出IllegalThreadStateException异常</p>
<hr>
<h2><span id="用户线程和守护线程有什么区别">用户线程和守护线程有什么区别？</span></h2>
<ul>
<li>用户线程是虚拟机启动的线程中的普通线程，当所有用户线程结束运行后，虚拟机才会停止运行（守护线程自动关闭）</li>
<li>守护线程是在程序中创建的线程，它的作用是为其他线程提供服务。当所有的用户线程结束运行后，守护线程也会随之结束，而不管它是否执行完毕。守护线程通常用于执行一些辅助性任务，如垃圾回收、缓存清理等，它们不需要等待所有的任务完成后再退出</li>
<li>一个守护线程创建的子线程依然是守护线程</li>
</ul>
<hr>
<h2><span id="为什么thread类的sleep和yield方法是静态的">为什么Thread类的sleep()和yield()方法是静态的？</span></h2>
<p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<p>首先明确一点，在一个线程拿到锁的时候，其他线程向拿到锁就必须要等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepYield</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">                thread1.<span class="keyword">yield</span>();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; have finished.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>假设yield()为非静态方法，若thread2拿到锁，调用了thread1的yield()方法，意为让thread1暂时放弃当前占有的CPU时间片，与大家一起再进行时间片竞争。关键是thread1现在处于阻塞状态！它在等待thread2释放锁，它根本没有占用CPU时间片。所以此时调用thread1的yield()方法是没有意义的！<br>
sleep()方法道理类似，本来就是阻塞状态，所以没必要再阻塞，即使“自然阻塞状态”比如是10ms，你设置了100ms，而“自然阻塞状态”持续时间是无法预测的，所以设定的休眠时间便失去了意义！<br>
而对于单线程而言，即使没有锁的争夺，在一个线程执行的时候另外一个线程也处于“不占有CPU时间片的状态”，什么时候再拿到时间片或者多长时间竞争一次CPU时间片都是无法预测的。所以在正在执行的线程里调用另外一个线程的yield()和sleep()方法依然是没有意义的。<br>
ps:有人可能会问怎么没有列举线程调用自己的实例方法来yield或者sleep的情况呢？<br>
答：调用自己的实例方法跟调用类方法效果是一样的，所以不用考虑这种情况。</p>
<hr>
<h2><span id="多线程的常用方法">多线程的常用方法？</span></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>start()</td>
<td>启动线程，并执行线程的 run() 方法</td>
</tr>
<tr>
<td>run()</td>
<td>线程在被调度时执行的方法，子线程执行的业务逻辑放在该方法体中</td>
</tr>
<tr>
<td>currentThread()</td>
<td>返回当前线程 。在Thread子类中就是this ，通常用于主线程和Runnable 实现类</td>
</tr>
<tr>
<td>setName(String)</td>
<td>设置线程的名称</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回线程的名称</td>
</tr>
<tr>
<td>sleep(long millis)</td>
<td>睡眠指定时间，程序暂停运行，睡眠期间会让出CPU的执行权，去执行其它线程，同时CPU也会监视睡眠的时间，一旦睡眠时间到就会立刻执行(因为睡眠过程中仍然保留着锁，有锁只要睡眠时间到就能立刻执行)（强迫一个线程睡眠N毫秒）</td>
</tr>
<tr>
<td>yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程（线程让步）</td>
</tr>
<tr>
<td>join(long millis)</td>
<td>等待该线程终止的时间最长为 millis 毫秒。join()方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行。注意该方法也需要捕捉异常（等待线程终止）</td>
</tr>
<tr>
<td>isAlive()</td>
<td>测试线程是否处于活动状态，线程调用start后，即处于活动状态</td>
</tr>
<tr>
<td>getPriority()</td>
<td>获取当前线程优先值（优先级取值范围[1,10]，默认为5）</td>
</tr>
<tr>
<td>setPriority (int newPriority)</td>
<td>设置当前线程优先级<br>线程优先级高，被CPU调度的概率大，但不代表一定会运行，还有小概率运行优先级低的线程。</td>
</tr>
<tr>
<td>interrupt()</td>
<td>中断线程，由运行状态到死亡状态</td>
</tr>
<tr>
<td>wait()</td>
<td>一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。而当前线程排队等候其他线程调用notify() 或 notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行（强迫一个线程等待）</td>
</tr>
<tr>
<td>notify()</td>
<td>一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个（通知一个线程继续执行）</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>一旦执行此方法，就会唤醒所有被wait的线程（所有线程继续执行）</td>
</tr>
</tbody>
</table>
<p>过时的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop()</td>
<td>强制线程生命周期结束，已经废止</td>
</tr>
<tr>
<td>suspend()/resume()</td>
<td>可能死锁，已经废止</td>
</tr>
</tbody>
</table>
<p><strong>yield() 和 sleep() 的异同</strong></p>
<p>相同点：yield() 方法和 sleep() 方法类似，也不会释放“锁”。</p>
<p>不同点：yield() 方法只是使当前线程重新回到可执行状态，所以执行 yield()的线程有可能在进入到可执行状态后马上又被执行。 yield() 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep()方法不同。</p>
<p><strong>join() 和 sleep() 的异同</strong></p>
<p>相同点：都可以实现等待<br>
不同点：由于join的内部实现是wait()，所以使用join()方法时会释放锁，那么其他线程就可以调用此线程的同步方法了。<br>
sleep() 方法不释放锁，因此线程会一直等待下去，直到任务完成，才会释放锁。</p>
<p><strong>sleep() 与 wait() 的异同</strong></p>
<p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>
不同点：<br>
（1） 两个方法声明的位置不同：Thread类中声明sleep() ,<br>
Object类中声明wait()<br>
（2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中<br>
（3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。<br>
（4）当调用某一对象的 wait() 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify() 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll() 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</p>
<hr>
<h2><span id="如何在-windows-和-linux-上查找哪个线程cpu利用率最高">如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</span></h2>
<p>Windows系统下执行java  -jar  arthas-boot.jar<br>
Linux系统下解压arthas，执行ps  -ef  |  grep  java找出java进程pid数字</p>
<hr>
<h2><span id="为什么我们调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></h2>
<ul>
<li>创建线程，即线程进入新建状态</li>
<li>调用线程的start()方法，将启动线程并使线程进入就绪状态</li>
<li>当分配到时间片后就开始运行run()方法，线程进入运行状态，从而实现多线程</li>
</ul>
<p>而直接调用run()方法只是将run()方法作为主线程下的普通方法执行，并不会在其他线程中执行</p>
<hr>
<h2><span id="什么是-callable-和-future">什么是 Callable 和 Future?</span></h2>
<p>Callable和Future是Java并发包中用于支持并发编程的两个接口。它们通常与ExecutorService（线程池）一起使用，用于执行具有返回值的任务，并在任务执行完成后获取结果或取消任务。</p>
<p>Callable 接口<br>
Callable是一个接口，类似于Runnable接口，但是它有返回值，并且可以抛出异常。Callable定义了一个带有泛型的call方法，该方法返回一个结果并可能抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 执行一些耗时的任务，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future 接口</p>
<p>Future接口用于表示异步计算的结果，它提供了一些方法来检查计算是否完成、等待计算完成并获取结果，以及取消计算等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(callable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待任务执行完成，并获取结果</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，Future通过get方法等待任务执行完成，并获取返回结果。如果任务还未完成，get方法会阻塞当前线程，直到任务完成为止。</p>
<p>组合使用：<br>
Callable和Future通常一起使用，通过submit方法提交Callable任务给ExecutorService，然后通过返回的Future对象来管理任务的执行和获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(callable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 阻塞等待任务执行完成，并获取结果</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<p>​        总的来说，Callable和Future提供了一种更灵活的方式来处理并发任务的执行和获取结果，尤其适用于需要在任务执行完成后获取结果的情况。</p>
<ul>
<li>Callable接口类似于Runnable</li>
<li>Runnable不会返回结果，并且无法抛出返回结果的异常；而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到</li>
<li>Future可以拿到异步执行任务的返回值。可以认为是带有返回值的Runnable.Future接口表示异步任务，是还没有完成的任务给出的未来结果</li>
<li>所以说Callable用于产生结果，Future用于获取结果</li>
</ul>
<hr>
<h2><span id="线程调度策略有哪些">线程调度策略有哪些？</span></h2>
<p><strong>抢占式调度(Preemptive Scheduling)</strong></p>
<ul>
<li>Java运行时系统采用抢占式调度策略</li>
<li>Java运行时系统让优先级高的线程以较大的概率使用CPU，如果线程优先级相同则随机选择（简单的、非抢占式的轮转的调度顺序）</li>
</ul>
<p>操作系统根据线程的优先级和时间片来决定当前运行的线程。当时间片用完或更高优先级的线程就绪时，当前线程会被抢占并让出CPU资源</p>
<p><strong>时间片轮转调度(Round-Robin Scheduling)</strong></p>
<ul>
<li>所有线程轮流使用CPU，并且平均分配每个线程占用CPU的时间</li>
<li>从所有处于就绪状态的线程中选择优先级最高的线程分配一定的CPU时间运行。该时间过后再选择其他线程运行</li>
<li>只有当线程运行结束、放弃(yield)CPU或由于某种原因进入阻塞状态，低优先级的线程才有机会执行</li>
<li>如果有两个优先级相同的线程都在等待CPU，则调度程序以轮转的方式选择运行的线程</li>
</ul>
<p>每个线程被分配一个固定的时间片(通常是几毫秒)，线程在该时间片内运行。当时间片用完后，操作系统会将当前线程放到就绪队列的尾部，并选择下一个就绪线程执行</p>
<p><strong>优先级调度(Priority Scheduling)</strong></p>
<ul>
<li>根据线程的优先级来决定线程的调度顺序</li>
<li>较高优先级的线程会优先执行，而较低优先级的线程会等待</li>
<li>优先级可以由开发人员手动设置，操作系统也可以根据一些策略自动调整线程的优先级</li>
</ul>
<p><strong>公平调度(Fair Scheduling)</strong></p>
<ul>
<li>试图确保每个线程都能公平地分享CPU资源</li>
<li>所有线程按照其就绪的顺序获得CPU时间。这意味着较长等待的线程会更早地获得执行机会</li>
</ul>
<hr>
<h2><span id="java中用到的线程调度算法是什么">Java中用到的线程调度算法是什么？</span></h2>
<p>在Java中，线程调度的算法是由操作系统负责的，Java虚拟机(JVM)只是利用操作系统提供的调度机制来实现线程调度。因此，Java中使用的线程调度算法由底层操作系统决定，Java虚拟机无法直接控制或修改这些算法。Java中的线程调度方法(如Thread.yield()、Thread.sleep()和Object.wait()等)主要用于协调线程之间的交互和同步，而不是直接控制线程的调度</p>
<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<hr>
<h2><span id="什么是线程调度器和时间分片">什么是线程调度器和时间分片？</span></h2>
<p><strong>线程调度器(Thread Scheduler)</strong></p>
<ul>
<li>是操作系统内核中的一个组件，负责为就绪状态的线程分配并管理CPU时间，控制多线程程序的执行顺序</li>
<li>当有多个线程同时运行时，线程调度器会在这些线程之间进行切换，使得每个线程都有机会使用 CPU 资源，并实现任务的并发执行</li>
<li>线程调度并不受到 Java 虚拟机控制，因此需减少程序对线程优先级的依赖</li>
</ul>
<p><strong>时间分片（Time Slicing）</strong></p>
<ul>
<li>指将可用的 CPU 时间分配给可用的 Runnable 线程的过程</li>
<li>分配 CPU 时间可以基于线程优先级或者线程等待的时间，确保每个线程都能获得一定的运行时间，从而实现多任务并发执行</li>
</ul>
<hr>
<h2><span id="为什么-wait-要放在同步代码块中">为什么 wait() 要放在同步代码块中？</span></h2>
<p>同步方法就是在方法前加关键字 synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待；防止在 cpu 切换线程的时候，其它线程先执行了notify() ，后执行 wait() ，线程永远无法被唤醒， 所以要将wait() 放在同步代码块。</p>
<hr>
<h2><span id="说说-sleep-方法和-wait-方法区别和共同点">说说 sleep() 方法和 wait() 方法区别和共同点?</span></h2>
<p><strong>共同点</strong></p>
<ul>
<li>都是使当前线程进入休眠状态，即暂停线程的执行</li>
<li>都可以响应<strong>interrupt</strong>中断，也就是说在线程调用方法进入休眠状态后，如果收到中断信号，都可以进行响应并中断，且都可以抛出InterruptException 异常</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>所属类不同：sleep() 方法属于 Thread 类的静态方法，而 wait() 方法属于Object类。</li>
<li>唤醒方式不同：sleep() 方法必须传递一个超时时间的参数，过了这个时间后线程就会自动唤醒，进入就绪状态； 而 wait() 方法可以不传递参数，此时线程会进入永久休眠，直到另一个线程调用notify() 方法或者 notifyAll() 方法之后，休眠的线程才会被唤醒。也就是说sleep() 方法可以 主动唤醒，而不传参的wait() 方法只能被动唤醒</li>
<li>语法使用不同：</li>
<li>释放锁资源不同：在线程调用 wait() 方法时，线程会主动释放锁并进入等待状态； 而线程在调用sleep() 方法时，线程不会释放锁</li>
<li>线程进入状态不同：<br>
线程调用sleep() 方法会进入 TIMED_WAITING 有时限等待状态；而调用无参数的wait() 方法，线程会进入 WAITING 无时<br>
限等待状态</li>
<li>wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行</li>
</ul>
<hr>
<h2><span id="为什么-wait-定义在-object-里而不是-thread类里">为什么 wait() 定义在 object 里，而不是 Thread类里？</span></h2>
<p>Java 的锁是对象级别的锁，而不是线程级别，所以 wait()是 Object 的方法。 sleep() 是线程级别的，所以存在于Thread 类中</p>
<hr>
<h2><span id="为什么线程通信的方法-wait-notify和-notifyall被定义在-object-类里">为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</span></h2>
<p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法</p>
<p>因为这些方法的调用是依赖锁对象，而同步代码块的锁对象是任意。锁而Object代表任意的对象，所以定义在这里面。</p>
<hr>
<h2><span id="thread-类中的-yield-方法有什么作用">Thread 类中的 yield 方法有什么作用？</span></h2>
<ul>
<li>用于暂停当前线程（运行状态转为就绪状态），使得其他线程可以获得执行机会</li>
<li>在高并发场景下，为了平衡线程的负载和提高系统的整体性能（当前线程没有被调度器选择执行，而其他线程又没有占用 CPU 时）</li>
<li>但是也可能导致资源的浪费和系统的混乱。因为它可能让当前闲置的线程让出 CPU 资源给其他线程，但这些其他线程可能很快又变得不活跃，这可能导致 CPU 在不同线程之间频繁切换，反而降低了系统的整体性能。在使用时需要考虑到系统的整体负载和资源利用率</li>
</ul>
<hr>
<h2><span id="为什么-thread-类的-sleep和-yield-方法是静态的">为什么 Thread 类的 sleep()和 yield ()方法是静态的？</span></h2>
<p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行</p>
<p>所以在其他处于等待状态的线程上调用这些方法是没有意义的</p>
<p>这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法</p>
<hr>
<h2><span id="线程的-sleep方法和-yield方法有什么区别">线程的 sleep()方法和 yield()方法有什么区别？</span></h2>
<ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；而yield()方法只会给相同优先级或更高优先级的线程以运行的机会</li>
<li>线程执行sleep()方法后会转入阻塞状态，所以，执行sleep()方法后的线程在指定的时间内肯定不会呗执行，而yield（）方法只是使当前线程重新回到可执行状态，所以执行yield（）方法的线程可能在在进入到可执行状态后马上又被执行</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常</li>
<li>sleep()方法比yield()方法具有更好的可移植性</li>
</ul>
<hr>
<h2><span id="多线程的中断是什么">多线程的中断是什么？</span></h2>
<p>线程在运行过程中，有些时候可能需要中断一些阻塞的线程</p>
<p>类Thread中提供了几种中断线程的方法，其中Thread.suspend()和Thread.stop()方法已经过时了，因为这两个方法是不安全的</p>
<p>Thread.stop()，会直接终止该线程，并且会立即释放这个线程持有的所有锁，而这些锁恰恰是用来维持数据的一致性的</p>
<p>如果此时。写线程写入数据时写到一半，并强行终止，由于此时对象锁已经被释放，另一个等待该锁的读线程就会读到这个不一致的对象</p>
<p>hread.suspend()会导致死锁，Thread.resume()也不能使用。</p>
<hr>
<h2><span id="如何停止一个正在运行的线程">如何停止一个正在运行的线程？</span></h2>
<p>Java没有为停止线程提供 API</p>
<p>JDK 1.0 本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK 版本中他们被弃用了.</p>
<p>之后Java API 的设计者就没有提供一个兼容且线程安全的方法来停止一个线程</p>
<p>当run() 或者 call() 方法执行完的时候线程会自动结束, 如果要手动结束一个线程.你可以用volatile布尔变量来退出 run()方法的循环或者是取消任务来中断线程。</p>
<hr>
<h2><span id="java-中-interrupted-和-isinterrupted-方法的区别">Java 中 interrupted 和 isInterrupted 方法的区别？</span></h2>
<ul>
<li>interrupted：查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了</li>
<li>isInterrupted仅仅是查询当前线程的中断状态</li>
</ul>
<hr>
<h2><span id="notify-和-notifyall-有什么区别">notify() 和 notifyAll() 有什么区别？</span></h2>
<ul>
<li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li>
<li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；</li>
</ul>
<hr>
<h2><span id="你对线程优先级的理解是什么">你对线程优先级的理解是什么？</span></h2>
<ul>
<li>每一个线程都是有优先级的.</li>
<li>一般来说，高优先级的线程在运行时会具有优先权. 但这依赖于线程调度的实现.这个实现是和操作系统相关的</li>
<li>线程优先级是一个int 变量(从 1-10).1 代表最低优先级.10 代表最高优先级。</li>
</ul>
<hr>
<h2><span id="线程类的构造方法-静态块是被哪个线程调用的">线程类的构造方法、静态块是被哪个线程调用的</span></h2>
<ul>
<li>被new这个线程类所在的线程所调用的</li>
<li>而run方法里面的代码才是被线程自身所调用的</li>
<li>举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：<br>
(1)Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的；<br>
(2)Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的；</li>
</ul>
<hr>
<h2><span id="一个线程运行时发生异常会怎样">一个线程运行时发生异常会怎样？</span></h2>
<ul>
<li>如果异常没有被捕获该线程将会停止执行</li>
<li>Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM 会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler 并将线程和异常作为参数传递给handler 的uncaughtException()方法进行处理</li>
</ul>
<h2><span id="java-线程数过多会造成什么异常">Java 线程数过多会造成什么异常？</span></h2>
<ul>
<li>线程的生命周期开销非常高</li>
<li>消耗过多的CPU 资源<br>
如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU 资源时还将产生其他性能的开销。</li>
<li>降低稳定性<br>
JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</li>
</ul>
<hr>
<h2><span id="什么是-futuretask">什么是 FutureTask？</span></h2>
<p>FutureTask 表示一个异步运算的任务</p>
<p>FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作</p>
<p>由于 FutureTask<br>
也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中</p>
<hr>
<h2><span id="线程之间如何进行通讯的">线程之间如何进行通讯的？</span></h2>
<p>通常多个线程的运行是互不干扰的，但是CPU对线程的切换是随机的，若想让多个线程之间有规律的运行，就需要线程通讯</p>
<p>从而让多个线程按照我们预期的运行过程去执行</p>
<ul>
<li>wait()：当前线程释放锁并且进入就绪状态<br>
notify()：唤醒当前线程，唤醒调用wait()方法进入就绪状态后的线程<br>
notifyAll()：唤醒所有进入就绪状态的线程</li>
<li>join()方法：使A线程加入B线程中执行，B线程进入阻塞状态，只有当A线程运行结束后B线程才会继续执行</li>
<li>volatile关键字：实现线程变量之间真正共享，多个线程同时监控着共享变量，当变量发生变化时其它线程立即改变，具体实现与JMM内存模型有关</li>
</ul>
<hr>
<h2><span id="线程安全的概念">线程安全的概念？</span></h2>
<p>多个线程可以共享进程的堆和方法区资源，既多个线程共享类变量</p>
<p>多个线程共享一个进程的变量时，如果线程对这个变量只有读操作，没有更新操作则这个线程没有线程安全问题</p>
<p>如果线程需要对这个变量进行修改操作，则可能会因为数据更新不及时导致变量信息不准确而引发线程不安全</p>
<hr>
<h2><span id="线程安全如何保证">线程安全如何保证？</span></h2>
<p>当多个线程对同一个资源进行操作的时候就会有线程安全</p>
<p>解决线程安全的核心思想就是加锁</p>
<ul>
<li>JVM提供的锁，就是synchronized锁，即同步代码和同步代码块</li>
<li>jdk提供的各种锁，如lock</li>
</ul>
<hr>
<h2><span id="java中哪些集合是线程安全的">Java中哪些集合是线程安全的？</span></h2>
<ul>
<li>在JDK1.1版本中，所有的集合都是线程安全的</li>
<li>但是在1.2及以后的版本中就出现了一些线程不安全的集合</li>
<li>因为线程不安全的集合普遍比线程安全的集合效率高的多。在JDK源码中相同效果的集合线程安全的比线程不安全的仅仅多了一个同步机制，但是效率上却低了不少，而且对线程不安全的集合加锁以后也能达到安全的效果（但是效率会低，因为会有锁的获取以及等待）</li>
</ul>
<p>下面列举一些常用的线程安全的集合</p>
<ul>
<li>Vector：就比ArrayList多了个同步化机制</li>
<li>HashTable：就比HashMap多了个线程安全</li>
<li>ConcurrentHashMap：是一种高效但是线程安全的集合</li>
<li>Stack：栈，线程安全，继承与Vector</li>
</ul>
<hr>
<h2><span id="synchronized-关键字用法">synchronized 关键字用法？</span></h2>
<ul>
<li>
<p>修饰实例方法: 作用于当前<strong>对象实例</strong>加锁，进入同步代码前要获得当前对象实例的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰静态方法: 也就是给<strong>当前类</strong>加锁，会作用于类的所有对象实例</p>
<p>进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰代码块 ：指定加锁对象，对<strong>给定对象/类</strong>加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得当前 class 的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2><span id="构造方法可以使用-synchronized-关键字修饰么">构造方法可以使用 synchronized 关键字修饰么？</span></h2>
<ul>
<li>构造方法不能使用 synchronized 关键字修饰</li>
<li>构造方法本身就属于线程安全的，不存在同步的构造方法一说</li>
</ul>
<hr>
<h2><span id="synchronized使用双重校验锁实现对象单例线程安全">synchronized使用：双重校验锁实现对象单例(线程安全)。</span></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">	<span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 提供getInstance方法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="同步和异步的区别">同步和异步的区别？</span></h2>
<ul>
<li>同步：功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。这时程序是阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。因此，简单来说，同步就是必须一件一件做事，等前一件事做完了才能做完下一件事</li>
<li>异步：与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作，当这个调用完成后，一般通过状态或者回调来通知调用者</li>
</ul>
<hr>
<h2><span id="同步方法和同步块哪个是更好的选择">同步方法和同步块，哪个是更好的选择？</span></h2>
<ul>
<li>同步块，因为同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率（同步的范围越小越好）</li>
</ul>
<hr>
<h2><span id="为什么-wait-notify和-notifyall必须在同步方法或者同步块中被调用">为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</span></h2>
<p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁</p>
<p>接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法</p>
<p>当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁</p>
<p>由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用</p>
<hr>
<h2><span id="什么是线程同步和线程互斥">什么是线程同步和线程互斥？</span></h2>
<p><strong>线程同步</strong></p>
<ul>
<li>指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）</li>
<li>也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！</li>
</ul>
<p><strong>线程互斥</strong></p>
<ul>
<li>指对于共享的进程系统资源，在各单个线程访问时的排它性</li>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）</li>
</ul>
<hr>
<h2><span id="什么是线程池">什么是线程池？</span></h2>
<ul>
<li>提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务</li>
<li>由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能</li>
</ul>
<hr>
<h2><span id="为什么要用线程池">为什么要用线程池？</span></h2>
<ul>
<li>使用继承Thread或者实现Runnable接口的方式来创建及销毁线程会产生耗费资源、线程上下文切换问题</li>
<li>同时创建过多的线程也可能引发资源耗尽的风险</li>
<li>线程池方便线程任务的管理。java中涉及到线程池的相关类均在jdk1.5开始的java.util.concurrent包中，涉及到的几个核心类及接口包括：Executor、Executors、ExecutorService、ThreadPoolExecutor、FutureTask、Callable、Runnable等</li>
</ul>
<hr>
<h2><span id="线程池的优势">线程池的优势？</span></h2>
<ul>
<li>提供了一种限制和管理资源（包括执行一个任务）</li>
<li>每个线程池还维护一些基本统计信息，例如已完成任务的数量</li>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>
<hr>
<h2><span id="线程池的工作原理">线程池的工作原理？</span></h2>
<ul>
<li>线程提交到线程池</li>
<li>判断核心线程池是否已经达到设定的数量，如果没有达到，则直接创建线程执行任务</li>
<li>如果达到了，则放在队列中，等待执行</li>
<li>如果队列已经满了，则判断线程的数量是否已经达到设定的最大值，如果达到了，则直接执行拒绝策略</li>
<li>如果没有达到，则创建线程执行任务</li>
</ul>
<hr>
<h2><span id="线程池都有哪些状态">线程池都有哪些状态？</span></h2>
<ul>
<li>RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）</li>
<li>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态</li>
<li>TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态</li>
<li>TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做</li>
</ul>
<hr>
<h2><span id="什么是executors">什么是Executors？</span></h2>
<ul>
<li>Executor是一个线程池框架</li>
<li>Executor 位于java.util.concurrent.Executors，提供了用于创建工作线程的线程池的工厂方法。它包含一组用于有效管理工作线程的组件</li>
<li>Executor API 通过 Executors 将任务的执行与要执行的实际任务解耦</li>
</ul>
<hr>
<h2><span id="在-java-中-executor-和-executors-的区别">在 Java 中 Executor 和 Executors 的区别？</span></h2>
<p>Executor接口对象能执行我们的线程任务<br>
Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求<br>
ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法，我们能够获得任务执行的状态并且可以获取任务的返回值</p>
<hr>
<h2><span id="executors新建线程池类型">Executors新建线程池类型？</span></h2>
<ul>
<li>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
<li>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行</li>
</ul>
<hr>
<h2><span id="executors新建线程池的弊端">Executors新建线程池的弊端？</span></h2>
<ul>
<li>newFixedThreadPool和newSingleThreadExecutor：堆积的请求处理队列可能会耗费非常大的内存，甚至OOM</li>
<li>newCachedThreadPool和newScheduledThreadPool：线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM</li>
<li>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，规避资源耗尽的风险</li>
</ul>
<hr>
<h2><span id="什么是threadpoolexecutor">什么是ThreadPoolExecutor？</span></h2>
<p>ThreadPoolExecutor是线程池的核心实现类，在JDK1.5引入，位于java.util.concurrent包。</p>
<hr>
<h2><span id="通过threadpoolexecutor如何创建线程池">通过ThreadPoolExecutor如何创建线程池？</span></h2>
<p>通过下面的demo来了解ThreadPoolExecutor创建线程的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolSerialTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//超过 corePoolSize 线程数量的线程最大空闲时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//以秒为时间单位</span></span><br><span class="line">        <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">        <span class="comment">//创建工作队列，用于存放提交的等待执行任务</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建线程池</span></span><br><span class="line">            threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line">                    maximumPoolSize,</span><br><span class="line">                    keepAliveTime,</span><br><span class="line">                    unit,</span><br><span class="line">                    workQueue,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//循环提交任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//提交任务的索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (i + <span class="number">1</span>);</span><br><span class="line">                threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">//线程打印输出</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;大家好，我是线程：&quot;</span> + index);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//模拟线程执行时间，10s</span></span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//每个任务提交后休眠500ms再提交下一个任务，用于保证提交顺序</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个新任务被提交时：</p>
<ul>
<li>当前活跃线程数&lt;corePoolSize，则创建一个新线程执行新任务；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）未满时，则将新任务放入队列中；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）已满，且当前活跃线程数&lt;maximumPoolSize，则继续创建一个新线程执行新任务；</li>
<li>当前活跃线程数&gt;corePoolSize，且队列（workQueue）已满，且当前活跃线程数=maximumPoolSize，则执行拒绝策略（handler）;</li>
</ul>
<p>当任务执行完成后：</p>
<ul>
<li>超出corePoolSize的空闲线程，在等待新任务时，如果超出了keepAliveTime，则线程会被销毁；</li>
<li>如果allowCoreThreadTimeOut被设置为true，那么corePoolSize以内的空闲线程，如果超出了keepAliveTime，则同样会被销毁。</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor线程池中的几种重要的参数">ThreadPoolExecutor线程池中的几种重要的参数？</span></h2>
<ul>
<li>corePoolSize：线程池中的核心线程数量，这几个核心线程在没有用的时候，也不会被回收</li>
<li>maximumPoolSize：线程池中可以容纳的最大线程的数量</li>
<li>keepAliveTime：除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清 除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间</li>
<li>util：计算这个时间的一个单位</li>
<li>workQueue：等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）</li>
<li>threadFactory：创建线程的线程工厂</li>
<li>handler：拒绝策略，我们可以在任务满了之后，拒绝执行某些任务</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor饱和拒绝策略是什么">ThreadPoolExecutor饱和(拒绝)策略是什么？</span></h2>
<ul>
<li>当线程充满了ThreadPool的有界队列时，饱和策略开始起作用</li>
<li>饱和策略可以理解为队列饱和后，处理后续无法入队的任务的策略</li>
<li>ThreadPoolExecutor可以通过调用setRejectedExecutionHandler来修改饱和策略</li>
</ul>
<hr>
<h2><span id="说说线程池的拒绝策略">说说线程池的拒绝策略？</span></h2>
<p>当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务</p>
<p>JDK默认提供的四种拒绝策略（在ThreadPoolExecutor中）</p>
<ul>
<li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li>
<li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</li>
<li>DiscardOleddestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理</li>
</ul>
<p>自定义拒绝策略</p>
<ul>
<li>RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会</li>
</ul>
<hr>
<h2><span id="threadpoolexecutor的execute方法和-submit方法的区别是什么呢">ThreadPoolExecutor的execute()方法和 submit()方法的区别是什么呢？</span></h2>
<ul>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</li>
<li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完</li>
</ul>
<hr>
<h2><span id="什么是线程组为什么在-java-中不推荐使用">什么是线程组，为什么在 Java 中不推荐使用？</span></h2>
<ul>
<li>线程组ThreadGroup对象中的stop，resume，suspend会导致安全问题，主要是死锁问题</li>
<li>线程组ThreadGroup不是线程安全的，在使用过程中不能及时获取安全的信息</li>
</ul>
<hr>
<h2><span id="线程池如何关闭">线程池如何关闭？</span></h2>
<ul>
<li>shutdownNow()：立即关闭线程池(暴力)，正在执行中的及队列中的任务会被中断，同时该方法会返回被中断的队列中的任务列表</li>
<li>shutdown()：平滑关闭线程池，正在执行中的及队列中的任务能执行完成，后续进来的任务会被执行拒绝策略</li>
<li>isTerminated()：当正在执行的任务及对列中的任务全部都执行（清空）完就会返回true</li>
</ul>
<hr>
<h2><span id="线程池的复用原理">线程池的复用原理？</span></h2>
<ul>
<li>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制</li>
<li>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来</li>
</ul>
<hr>
<h2><span id="线程池都有哪几种工作队列">线程池都有哪几种工作队列？</span></h2>
<ul>
<li>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序</li>
<li>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</li>
<li>SynchronousQueue 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool()使用了这个队列</li>
<li>PriorityBlockingQueue 一个具有优先级的无限阻塞队列</li>
</ul>
<hr>
<h2><span id="springboot如何整合线程池">SpringBoot如何整合线程池？</span></h2>
<p>首先是利用好SpringBoot的自动装配功能，配置好线程池的一些基本参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTaskConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 线程池名前缀</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">threadNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;Api-Async-&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean的名称， 默认为首字母小写的方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;taskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，</span></span><br><span class="line"><span class="comment">     * 当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</span></span><br><span class="line"><span class="comment">     * 当队列满了，就继续创建线程，当线程数量大于等于maxPoolSize后，开始使用拒绝策略拒绝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 核心线程数（默认线程数）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">//缓冲队列数</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">//允许线程空闲时间（单位是秒）</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveTime);</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        <span class="comment">//用来设置线程池关闭时候等待所有任务都完成再继续销毁其他的Bean</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//线程池对拒绝任务的处理策略，CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好线程池的基本参数时候，我们就可以使用线程池了， 只要在一个限定域为public的方法头部加上@Async注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行任务&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="线程池的优化">线程池的优化？</span></h2>
<ul>
<li>
<p>分析任务的特性</p>
<p>任务的性质：CPU 密集型任务、IO 密集型任务和混合型任务。<br>
任务的优先级：高、中、低。<br>
任务的执行时间：长、中、短。<br>
任务的依赖性：是否依赖其他系统资源，如数据库连接</p>
</li>
<li>
<p>具体策略</p>
<ul>
<li>CPU 密集型任务配置尽可能小的线程，如配置N（CPU核心数）+1个线程的线程池。</li>
<li>IO 密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*N（CPU核心数）。</li>
<li>混合型任务如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务。只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率；如果这两个任务执行时间相差太大，则没必要进行分解。</li>
<li>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理，它可以让优先级高的任务先得到执行。但是，如果一直有高优先级的任务加入到阻塞队列中，那么低优先级的任务可能永远不能执行。</li>
<li>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</li>
<li>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，线程数应该设置得较大，这样才能更好的利用 CPU。</li>
<li>建议使用有界队列，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。使用无界队列，线程池的队列就会越来越大，有可能会撑满内存，导致整个系统不可用。</li>
</ul>
</li>
</ul>
<hr>
<h2><span id="什么是threadlocal">什么是ThreadLocal？</span></h2>
<p>从字面上理解ThreadLocal就是“线程局部变量”的意思</p>
<p>简单的说就是，一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的（每个线程都只能看到自己线程的值）</p>
<ul>
<li>
<p>set()：赋值操作</p>
</li>
<li>
<p>get()：获取变量中的值</p>
</li>
<li>
<p>remove()：删除当前这个变量的值</p>
<p>需要注意的是initialValue方法会在第一次调用时被触发，用于初始化当前变量值，例如在下列代码中我们需要创建一个ThreadLocal，用于创建一个与线程绑定的Connection对象：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadLocal</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(…);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>每个ThreadLocal实例内部都可以保存一个值（基本数据类型值或者引用类型的引用值），这个值是可以修改的</li>
<li>每一个ThreadLocal实例就类似于一个变量名，不同的ThreadLocal实例就是不同的变量名，它们内部会存有一个值（暂时这么理解）在后面的描述中所说的“ThreadLocal变量或者是线程变量”代表的就是ThreadLocal类的实例</li>
<li>通过重写initialValue方法指定ThreadLocal变量的初始值，默认情况下initialValue返回的是null</li>
</ul>
<hr>
<h2><span id="threadlocal的具体实现">ThreadLocal的具体实现?</span></h2>
<p>一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的（每个线程都只能看到自己线程的值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; num = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 重写这个方法，可以修改“线程变量”的初始值，默认是null</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一号线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 在一号线程中将ThreadLocal变量设置为1</span></span><br><span class="line">                num.set(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;一号线程中ThreadLocal变量中保存的值为：&quot;</span> + num.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建二号线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                num.set(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;二号线程中ThreadLocal变量中保存的值为：&quot;</span> + num.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//为了让一二号线程执行完毕，让主线程睡500ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中ThreadLocal变量中保存的值：&quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码中在类中创建了一个静态的“ThreadLocal变量”，在主线程中创建两个线程，在这两个线程中分别设置ThreadLocal变量为1和2。然后等待一号和二号线程执行完毕后，在主线程中查看ThreadLocal变量的值</li>
<li>程序结果重点看的是主线程输出的是0，如果是一个普通变量，在一号线程和二号线程中将普通变量设置为1和2，那么在一二号线程执行完毕后在打印这个变量，输出的值肯定是1或者2（到底输出哪一个由操作系统的线程调度逻辑有关）</li>
<li>但使用ThreadLocal变量通过两个线程赋值后，在主线程程中输出的却是初始值0。在这也就是为什么“一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的”，每个线程都只能看到自己线程的值，这也就是ThreadLocal的核心作用：实现线程范围的局部变量</li>
</ul>
<hr>
<h2><span id="threadlocal的原理分析">ThreadLocal的原理分析?</span></h2>
<p>每个Thread对象都有一个ThreadLocalMap</p>
<p>当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中</p>
<p>其中键就是ThreadLocal，值可以是任意类型</p>
<p>想要存入的ThreadLocal中的数据实际上并没有存到ThreadLocal对象中去，而是以这个ThreadLocal实例作为key存到了当前线程中的一个Map中去了</p>
<p>获取ThreadLocal的值时同样也是这个道理。这也就是为什么ThreadLocal可以实现线程之间隔离的原因了</p>
<ul>
<li>ThreadLocal的作用：实现线程范围内的局部变量，即ThreadLocal在一个线程中是共享的，在不同线程之间是隔离的。</li>
<li>ThreadLocal的原理：ThreadLocal存入值时使用当前ThreadLocal实例作为key，存入当前线程对象中的Map中去。最开始在看源码之前，我以为是以当前线程对象作为key将对象存入到ThreadLocal中的Map中去</li>
</ul>
<hr>
<h2><span id="threadlocal和synchonized区别">ThreadLocal和Synchonized区别？</span></h2>
<ul>
<li>两者都用于解决多线程并发访问</li>
<li>但是Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离</li>
<li>Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享</li>
<li>而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享</li>
</ul>
<hr>
<h2><span id="threadlocal内存泄漏以及解决方案">ThreadLocal内存泄漏以及解决方案？</span></h2>
<ul>
<li>如果ThreadLocal没有外部强引用，那么在发生垃圾回收的时候，ThreadLocal就必定会被回收</li>
<li>而ThreadLocal又作为Map中的key，ThreadLocal被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li>
<li>解决方案：每次使用完ThreadLocal都调用它的remove()方法清除数据，或者按照JDK建议将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进</li>
</ul>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/post/%E9%AB%98%E5%B9%B6%E5%8F%91/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            高并发
          
        </div>
      </a>
    
    
      <a href="/post/%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">基础</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '3cdc50fed141dacb5545',
    clientSecret: 'efa362468591880b87d44cbe3e1c41428af53b94',
    repo: 'gitalk',
    owner: 'biyixia',
    admin: ['biyixia'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> biyixia
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="biyixia"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>



    
    

  </div>
</body>

</html>