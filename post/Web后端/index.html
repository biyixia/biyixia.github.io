<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Web后端 |  biyixia</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="biyixia" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Web后端"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Web后端
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/post/Web%E5%90%8E%E7%AB%AF/" class="article-date">
  <time datetime="2024-05-08T16:16:15.518Z" itemprop="datePublished">2024-05-09</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">24 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1><span id="web后端面试题">Web后端面试题</span></h1>
<hr>
<h2><span id="servlet的生命周期">Servlet的生命周期？</span></h2>
<ul>
<li>web Client 向servlet服务器发出Http请求</li>
<li>servlet接受web Client的请求</li>
<li>servlet容器创建一个HttpRequest 对象，将Web Client请求的信息封装到这个对象中</li>
<li>servlet容器创建一个HttpResponset对象</li>
<li>servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet对象</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息</li>
<li>HttpServlet调用HttpResponst 对象的有关方法，生成响应数据</li>
<li>Servlet容器把 HttpServlet的响应结果给Web Client</li>
<li>简单的说:init   service  destroy</li>
</ul>
<hr>
<h2><span id="servlet是线程安全的吗">Servlet是线程安全的吗？</span></h2>
<ul>
<li>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题</li>
<li>解决的办法是尽量不要在实现servlet接口的类中定义实例变量，而是要把变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法</li>
<li>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的</li>
</ul>
<hr>
<h2><span id="如何实现servlet的单线程模式">如何实现servlet的单线程模式？</span></h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isThreadSafe=”false”%&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="get和post请求的区别">get和post请求的区别？</span></h2>
<ul>
<li>get请求用来从服务器上获得资源；而post是用来向服务器提交数据；</li>
<li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用&quot;?“连接，而各个变量之间使用”&amp;&quot;连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL</li>
<li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式</li>
<li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post</li>
<li>get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是&quot;%20&quot;</li>
</ul>
<hr>
<h2><span id="转发和重定向的区别">转发和重定向的区别？</span></h2>
<ul>
<li>重定向访问服务器两次，转发只访问服务器一次。</li>
<li>转发页面的URL不会改变，而重定向地址会改变</li>
<li>转发只能转发到自己的web应用内，重定向可以重定义到任意资源路径。</li>
<li>转发相当于服务器跳转，相当于方法调用，在执行当前文件的过程中转向执行目标文件，两个文件(当前文件和目标文件)属于同一次请求，前后页 共用一个request，可以通过此来传递一些数据或者session信息，request.setAttribute()和 request.getAttribute()。而重定向会产生一个新的request，不能共享request域信息与请求参数。</li>
<li>由于转发相当于服务器内部方法调用，所以转发后面的代码仍然会执行(转发之后记得return)；重定向代码执行之后是方法执行完成之后进行重定向操作，也就是访问第二个请求，如果是方法的最后一行进行重定向那就会马上进行重定向(重定向也需要return)。</li>
<li>无论是RequestDispatcher.forward方法，还是HttpServletResponse.sendRedirect方法，在调用它们之前，都不能有内容已经被实际输出到了客户端。如果缓冲区中已经有了一些内容，这些内容将被从缓冲区中移除。<br>
可以这么理解：转发相当于，张三向你借钱，但是你兜里没钱，所以你去找李四借到钱之后借给张三。对于张三而言并不知道你的钱是和李四借的；重定向相当于，张三向你借钱，你兜里没钱，你告诉他李四有钱，所以张三再次去找李四借钱。</li>
</ul>
<hr>
<h2><span id="jsp九大内置对象">jsp九大内置对象?</span></h2>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<hr>
<h2><span id="jsp的四大域对象">jsp的四大域对象？</span></h2>
<ul>
<li>page代表与一个页面相关的对象和属性。</li>
<li>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<hr>
<h2><span id="jsp中的静态包含和动态包含有什么区别">JSP中的静态包含和动态包含有什么区别？</span></h2>
<ul>
<li>静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作<a href="jsp:forward">jsp:forward</a>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的&quot;contentType&quot;属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新</li>
<li>动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。</li>
</ul>
<hr>
<h2><span id="jsp请求是如何被处理的">JSP请求是如何被处理的？</span></h2>
<p>浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。</p>
<hr>
<h2><span id="jsp和servlet的区别">jsp和Servlet的区别？</span></h2>
<ul>
<li>jsp的本质是Servlet ，jvm只能识别java的类，不能识别jsp的代码；</li>
<li>jsp更擅长表现与页面显示，Servlet更擅长与逻辑控制；</li>
<li>servlet中没有内置对象，jsp中有九大内置对象;</li>
</ul>
<hr>
<h2><span id="过滤器filter的作用及配置">过滤器Filter的作用及配置？</span></h2>
<p>过滤器是一个对象，可以传输请求或修改响应。它可以在请求到达Servlet/JSP之前对其进行预处理，而且能够在响应离开Servlet/JSP之后对其进行后处理。所以如果你有几个Servlet/JSP需要执行同样的数据转换或页面处理的话，你就可以写一个过滤器类，然后在部署描述文件（web.xml）中把该过滤器与对应的Servlet/JSP联系起来。你可以一个过滤器以作用于一个或一组servlet，零个或多个过滤器能过滤一个或多个servlet。一个过滤器实现java.servlet.Filter接口并定义它的三个方法：<br>
1.void init(FilterConfig config) throws ServletException:在过滤器执行service前被调用，以设置过滤器的配置对象。<br>
2.void destroy();在过滤器执行service后被调用。<br>
3.void doFilter(ServletRequest req，ServletResponse res，FilterChain chain) throws IOException，ServletException;</p>
<hr>
<h2><span id="五个常用的jstl常用标签">五个常用的JSTL常用标签？</span></h2>
<p>&lt;c:if&gt;、&lt;c:item&gt;、&lt;c:foreach&gt;、&lt;c:out&gt;、&lt;c:set&gt;</p>
<hr>
<h2><span id="xml是什么">XML是什么？</span></h2>
<p>XML 即可扩展标记语言（Extensible Markup language），你可以根据自己的需要扩展 XML。XML 中可以轻松定义<books>, <orders>等自定义标签，而在 HTML 等其他标记语言中必须使用预定义的标签，比如<p>，而不能使用用户定义的标签。使用 DTD 和 XML Schema 标准化XML 结构。XML 主要用于从一个系统到另一系统的数据传输，比如企级应用的客户端与服务端。</p>
<hr>
<h2><span id="xpath是什么">XPath是什么？</span></h2>
<p>XPath 是用于从 XML 文档检索元素的 XML 技术。XML 文档是结构化的，因此 XPath 可以从 XML 文件定位和检索元素、属性或值。从数据检索方面来说，XPath与 SQL 很相似，但是它有自己的语法和规则。了解更多查看怎样使用 XPath 从XML文档中检索数据。</p>
<hr>
<h2><span id="xml命名空间是什么它为什么很重要">XML命名空间是什么？它为什么很重要？</span></h2>
<p>XML 命名空间与 Java 的 package 类似，用来避免不同来源名称相同的标签发生冲突。XML 命名空间在 XML 文档顶部使用 xmlns 属性定义，语法为 xmlns:prefix=’URI’。prefix 与XML 文档中实际标签一起使用。下面例子为 XML 命名空间的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;root xmlns:inst=&quot;http://instruments.com/inst&quot;</span><br><span class="line">    &lt;inst:phone&gt;</span><br><span class="line">    &lt;inst:number&gt;837363223&lt;/inst:number&gt;</span><br><span class="line">    &lt;/inst:phone&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="解析-xml-文档有哪几种方式">解析 XML 文档有哪几种方式？</span></h2>
<ul>
<li>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这种结构占用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML 的随机访问；</li>
<li>SAX:不同于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML 的顺序访问；</li>
<li>STAX:Streaming API for XML (StAX)。</li>
</ul>
<hr>
<h2><span id="项目中的哪些地方用到xml">项目中的哪些地方用到xml?</span></h2>
<ul>
<li>在做数据交换平台时，将不能数据源的数据组装成 XML 文件，然后将 XML 文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同 XML 文件中还原相关信息进行处理。</li>
<li>在做软件配置时，利用 XML 可以很方便的进行，软件的各种配置参数都存贮在 XML 文件中。</li>
</ul>
<hr>
<h2><span id="什么是json">什么是JSON?</span></h2>
<p>JSON是一种取代XML的数据结构，和xml相比，它更小巧但描述能力不差，网络传输数据将减少更多的流量从而加快速度，是一种轻量级的数据交换格式。</p>
<hr>
<h2><span id="json和xml之间的区别">JSON和XML之间的区别？</span></h2>
<ul>
<li>JSON是JavaScript Object Notation；XML是可扩展标记语言。</li>
<li>JSON是基于JavaScript语言；XML源自SGML。</li>
<li>JSON是一种表示对象的方式；XML是一种标记语言，使用标记结构来表示数据项。</li>
<li>JSON不提供对命名空间的任何支持；XML支持名称空间。</li>
<li>JSON支持数组；XML不支持数组。</li>
<li>XML的文件相对难以阅读和解释；与XML相比，JSON的文件非常易于阅读。</li>
<li>JSON不使用结束标记；XML有开始和结束标签。</li>
<li>JSON的安全性较低；XML比JSON更安全。</li>
<li>JSON不支持注释；XML支持注释。</li>
<li>JSON仅支持UTF-8编码；XML支持各种编码。</li>
</ul>
<hr>
<h2><span id="http协议是什么">HTTP协议是什么？</span></h2>
<p><strong>HTTP（超文本传输协议，Hypertext Transfer Protocol）</strong></p>
<ul>
<li>是一种用于从网络传输超文本到本地浏览器的传输协议</li>
<li>它定义了客户端与服务器之间请求和响应的格式</li>
<li>基于TCP/IP通信协议</li>
</ul>
<hr>
<h2><span id="http和https有什么区别">http和https有什么区别？</span></h2>
<ul>
<li>https有ca证书，http一般没有</li>
<li>http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输</li>
<li>http默认80端口，https默认443端口</li>
</ul>
<hr>
<h2><span id="http协议有什么特点">http协议有什么特点？</span></h2>
<ul>
<li>http无连接：限制每次连接只处理一个请求，服务端完成客户端的请求后，即断开连接。(传输速度快，减少不必要的连接，但也意味着每一次访问都要建立一次连接，效率降低);</li>
<li>http无状态：对于事务处理没有记忆能力。每一次请求都是独立的，不记录客户端任何行为；</li>
<li>客户端/服务端模型：客户端支持web浏览器或其他任何客户端；</li>
<li>简单快速\灵活：可以传输任何类型的数据。</li>
</ul>
<hr>
<h2><span id="什么是http协议无状态协议怎么解决http协议无状态协议">什么是http协议无状态协议？怎么解决http协议无状态协议？</span></h2>
<p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。<br>
状态协议解决办法：1、cookie 2、通过session会话保存。</p>
<hr>
<h2><span id="说一下http协议中302状态">说一下http协议中302状态？</span></h2>
<p>http协议中，返回状态码302表示重定向。这种情况下，服务器返回的头部信息中会包含一个Location字段，内容是重定向到的url</p>
<hr>
<h2><span id="http协议什么组成">http协议什么组成？</span></h2>
<p>请求报文</p>
<ul>
<li>请求行：包含请求方法、URI、HTTP版本信息</li>
<li>请求首部字段</li>
<li>请求内容实体</li>
</ul>
<p>响应报文</p>
<ul>
<li>状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>响应首部字段</li>
<li>响应内容实体</li>
</ul>
<hr>
<h2><span id="http协议中有那些请求方式">http协议中有那些请求方式？</span></h2>
<ul>
<li>GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效</li>
<li>OPTIONS：查询相应URI支持的HTTP方法</li>
</ul>
<hr>
<h2><span id="tcp和udp的区别">TCP和UDP的区别？</span></h2>
<p>TCP（Transmission Control Protocol，传输控制协议）</p>
<ul>
<li>是基于连接的协议</li>
<li>在正式收发数据前，必须和对方建立可靠的连接</li>
<li>一个TCP连接必须要经过三次“对话”才能建立起来</li>
</ul>
<p>UDP（User Data Protocol，用户数据报协议）</p>
<ul>
<li>是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去</li>
<li>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境</li>
</ul>
<hr>
<h2><span id="http的长连接和短连接区别">http的长连接和短连接区别？</span></h2>
<p>HTTP协议有HTTP/1.0版本和HTTP/1.1版本</p>
<p>HTTP1.1默认保持长连接（HTTP persistent connection，也翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据</p>
<p>在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</p>
<p>从HTTP/1.1起，默认使用的是长连接，用以保持连接特性。</p>
<hr>
<h2><span id="什么是-csrf-攻击如何避免">什么是 CSRF 攻击，如何避免？</span></h2>
<p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造</p>
<p>攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令</p>
<p>常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为</p>
<hr>
<h2><span id="什么是-xss-攻击如何避免">什么是 XSS 攻击，如何避免？</span></h2>
<p>XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击）</p>
<p>其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的</p>
<p>XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的</p>
<p>而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息</p>
<p>XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式</p>
<p>XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</p>
<hr>
<h2><span id="说一说osi网络模型">说一说OSI网络模型</span></h2>
<p>网络的七层架构从下到上主要包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</p>
<p>物理层</p>
<ul>
<li>主要定义物理设备标准</li>
<li>传输比特流，具体做法是在发送端将1、0转化为电流强弱来进行传输，在到达目的地之后再将电流强弱转化为1、0</li>
<li>也就是模数转换与数模转换，这一层的数据叫做比特</li>
</ul>
<p>数据链路层</p>
<ul>
<li>主要用于对数据包中的MAC地址进行解析和封装</li>
<li>这一层的数据叫做帧，在这一层工作的设备是网卡、网桥、交换机</li>
</ul>
<p>网络层</p>
<ul>
<li>主要用于对数据包中的IP地址进行封装和解析</li>
<li>这一层的数据叫做数据包。在这一层工作的设备有路由器、交换机、防火墙等</li>
</ul>
<p>传输层</p>
<ul>
<li>定义了传输数据的协议和端口号</li>
<li>主要用于数据的分段、传输和重组</li>
<li>在这一层工作的协议有TCP和UDP等</li>
<li>TCP是传输控制协议，传输效率低，可靠性强，用于传输对可靠性要求高，数据量大的数据，比如支付宝转账业务</li>
<li>UDP是用户数据报协议，用于传输可靠性要求不高，数据量小的数据，例如抖音等视频服务</li>
</ul>
<p>会话层</p>
<ul>
<li>传输层的基础上建立连接和管理会话，具体包括登陆验证、断点续传、数据粘包与分包等</li>
<li>在设备之间需要互相识别的可以是IP，也可以是MAC或者主机名</li>
</ul>
<p>表示层</p>
<ul>
<li>表示层主要对接收的数据进行解释、加密、解密、压缩、解压缩等</li>
<li>即把计算机能够识别的内容转换成人能够识别的内容（图片、声音、文字等）</li>
</ul>
<p>应用层</p>
<ul>
<li>基于网络构建具体应用</li>
<li>例如FTP上传文件下载服务、Telnet服务、HTTP服务、DNS服务、SNMP邮件服务等</li>
</ul>
<hr>
<h2><span id="说一说tcpip的网络模型">说一说TCP/IP的网络模型。</span></h2>
<p>TCP/IP不是指TCP和IP这两个协议的合称，而是指因特网的整个TCP/IP协议簇。从协议分层模型方面来讲，TCP/IP由4个层次组成：网络接口层、网络层、传输层和应用层。<br>
①网络接口层：定义了主机间网络连通的协议，具体包括Echernet、FDDI、ATM等通信协议。<br>
②网络层：主要用于数据的传输、路由及地址的解析，以保障主机可以把数据发送给任何网络上的目标。数据经过网络传输，发送的顺序和到达的顺序可能发生变化。在网络层使用IP协议和ARP地址解析协议。<br>
③传输层：使源端和目的端的机器上的对等实体可以基于会话相互通信。在这一层定义了两个端到端的协议TCP和UDP。TCP是面向连接的协议，提供可靠的报文传输和对上层应用的连接服务，除了基本的数据传输，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP是面向无连接的不可靠传输的协议，主要用于不需要TCP的排序和流量控制等功能的应用程序。<br>
④应用层：负责具体应用层协议的定义，包括Telnet虚拟终端协议、FTP文件传输协议、SMTP简单电子邮件传输协议、DNS域名解析服务、NNTP网上新闻传输协议和HTTP超文本传输协议等。</p>
<hr>
<h2><span id="简述tcp的三次握手过程为什么不是两次或四次">简述TCP的三次握手过程，为什么不是两次或四次？</span></h2>
<p>①服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。<br>
②服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。<br>
③客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。<br>
④不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。<br>
⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。</p>
<hr>
<h2><span id="简述tcp的四次握手过程为什么不是三次">简述TCP的四次握手过程，为什么不是三次？</span></h2>
<p>①当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。<br>
②服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。<br>
③当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。<br>
④客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。<br>
⑤不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。</p>
<hr>
<h2><span id="会话是什么">会话是什么？</span></h2>
<p>会话：客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。<br>
http协议是“无状态”协议，不能保存用户信息，需要判断是否是同一个用户，需要会话跟踪。cookies和session都是用来跟踪浏览器用户身份的会话方式，但两者应用场景不一样。</p>
<hr>
<h2><span id="session和cookie的概念">Session和Cookie的概念？</span></h2>
<p>Cookie 是Web 服务器发送给客户端（浏览器）的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。<br>
Session 代表着服务器和客户端一次会话的过程。每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。</p>
<hr>
<h2><span id="cookie的工作原理">Cookie的工作原理？</span></h2>
<p>(1)浏览器端第一次发送请求到服务器端<br>
(2)服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端<br>
(3)浏览器端再次访问服务器端时会携带服务器端创建的Cookie<br>
(4)服务器端通过Cookie中携带的数据区分不同的用户</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20221011/1665470640@00feaa79335586b0530fd04a40ecc872.png" alt="img"></p>
<hr>
<h2><span id="session的工作原理">Session的工作原理？</span></h2>
<p>(1)浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端<br>
(2)浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象<br>
(3)服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。</p>
<p><img src="http://www.bjpowernode.com/Public/Uploads/article/20221011/1665470853@c176e8f01ce5c6c500929a18ba7112a8.png" alt="img"></p>
<hr>
<h2><span id="cookie禁止掉session还能用吗">Cookie禁止掉，Session还能用吗？</span></h2>
<p>第一种，在每次请求中都携带一个 SessionID 的参数放入URL<br>
第二种，Token 机制。Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。随机且无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</p>
<hr>
<h2><span id="cookie的生存周期">Cookie的生存周期？</span></h2>
<p>Cookie在生成时就会被指定一个Expire值，这就是Cookie的生存周期，在这个周期内Cookie有效，超出周期Cookie就会被清除。有些页面将Cookie的生存周期设置为“0”或负值，这样在关闭浏览器时，就马上清除Cookie，不会记录用户信息，更加安全。</p>
<hr>
<h2><span id="cookie和session的区别">Cookie和Session的区别?</span></h2>
<p>①存在的位置：<br>
Cookie存在于客户端，临时文件夹中；  Session存在于服务器的内存中，一个Session域对象为一个用户浏览器服务<br>
②安全性<br>
Cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；  Session存放于服务器的内存中，所以安全性好<br>
③网络传输量<br>
Cookie会传递消息给服务器；  Session本身存放于服务器，不会有传送流量<br>
④生命周期(以20分钟为例)<br>
Cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，Cookie生命周期结束；<br>
session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问Session，那么Session生命周期被销毁。但是，如果在20分钟内（如在第19分钟时）访问过Session，那么，将重新计算Session的生命周期。关机会造成Session生命周期的结束，但是对Cookie没有影响<br>
⑤访问范围<br>
Cookie为多个用户浏览器共享；  Session为一个用户浏览器独享</p>
</orders></books></p> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/post/Web%E5%90%8E%E7%AB%AF/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/post/MySQL/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            MySQL
          
        </div>
      </a>
    
    
      <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">数据库</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '3cdc50fed141dacb5545',
    clientSecret: 'efa362468591880b87d44cbe3e1c41428af53b94',
    repo: 'gitalk',
    owner: 'biyixia',
    admin: ['biyixia'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> biyixia
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="biyixia"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>



    
    

  </div>
</body>

</html>